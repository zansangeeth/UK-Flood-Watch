import { Feature, Polygon, MultiPolygon, BBox, FeatureCollection, Geometry } from 'geojson';
import { BinaryFeatureCollection, BinaryFeature } from '@loaders.gl/schema';
import jsep from 'jsep';

/**
 * Returns current client ID, used to categorize API requests. For internal use only.
 *
 * @internal
 * @privateRemarks Source: @carto/react-core
 */
declare function getClient(): string;
/**
 * Sets current client ID, used to categorize API requests. For internal use only.
 *
 * @internal
 * @privateRemarks Source: @carto/react-core
 */
declare function setClient(c: string): void;

/**
 * Defines a comparator used when matching a column's values against given filter values.
 *
 * Example:
 *
 * ```javascript
 * import { FilterType } from '@carto/api-client';
 * const filters = {
 *   column_name: { [FilterType.IN]: { values: ['a', 'b', 'c'] } }
 * };
 * ```
 *
 * @privateRemarks Source: @carto/react-api, @deck.gl/carto
 */
declare enum FilterType {
    IN = "in",
    /** [a, b] both are included. */
    BETWEEN = "between",
    /** [a, b) a is included, b is not. */
    CLOSED_OPEN = "closed_open",
    TIME = "time",
    STRING_SEARCH = "stringSearch"
}
/** @privateRemarks Source: @carto/constants */
declare enum ApiVersion {
    V1 = "v1",
    V2 = "v2",
    V3 = "v3"
}
/** @privateRemarks Source: @carto/constants, @deck.gl/carto */
declare const DEFAULT_API_BASE_URL = "https://gcp-us-east1.api.carto.com";
declare const AUDIT_TAGS: {
    mapId: string;
};
/** @privateRemarks Source: @carto/react-core */
declare enum TileFormat {
    MVT = "mvt",
    JSON = "json",
    GEOJSON = "geojson",
    BINARY = "binary"
}
/** @privateRemarks Source: @carto/react-core */
declare enum SpatialIndex {
    H3 = "h3",
    QUADBIN = "quadbin"
}
/** @privateRemarks Source: @carto/react-core */
declare enum Provider {
    BIGQUERY = "bigquery",
    REDSHIFT = "redshift",
    POSTGRES = "postgres",
    SNOWFLAKE = "snowflake",
    DATABRICKS = "databricks",
    DATABRICKS_REST = "databricksRest"
}
declare const SpatialIndexColumn: Readonly<{
    h3: string[];
    quadbin: string[];
}>;
/**
 * Enum like container for all types of aggregations available for widgets.
 */
declare const AggregationTypes: {
    readonly Count: "count";
    readonly Avg: "avg";
    readonly Min: "min";
    readonly Max: "max";
    readonly Sum: "sum";
    readonly Custom: "custom";
};

/******************************************************************************
 * MAP INSTANTIATION
 */
/**
 * @privateRemarks Source: @deck.gl/carto
 */
declare enum SchemaFieldType {
    Number = "number",
    Bigint = "bigint",
    String = "string",
    Geometry = "geometry",
    Timestamp = "timestamp",
    Object = "object",
    Boolean = "boolean",
    Variant = "variant",
    Unknown = "unknown"
}
/**
 * @privateRemarks Source: @deck.gl/carto
 */
interface SchemaField {
    name: string;
    type: SchemaFieldType;
}
/******************************************************************************
 * MAPS AND TILES
 */
/** @privateRemarks Source: @deck.gl/carto */
type Format = 'json' | 'geojson' | 'tilejson';
/** @privateRemarks Source: @carto/constants, @deck.gl/carto */
type MapType = 'boundary' | 'query' | 'table' | 'tileset' | 'raster';
/** @privateRemarks Source: cloud-native */
type ProviderType = 'bigquery' | 'postgres' | 'snowflake' | 'redshift' | 'databricks' | 'carto' | 'carto_dw';
/**
 * Alias for GeoJSON 'BBox' type, semantically representing a viewport.
 * Order of values is "west", "south", "east", "north".
 */
type Viewport = [number, number, number, number];
/**
 * Subset of deck.gl's Tile2DHeader type, containing only the properties
 * required for local widget calculations. Deeper dependencies on deck.gl
 * APIs should be minimized within this library: @deck.gl/carto depends
 * on the API client, not the other way around.
 * @privateRemarks Source: @deck.gl/geo-layers
 */
type Tile = {
    index: {
        x: number;
        y: number;
        z: number;
    };
    id: string;
    bbox: {
        west: number;
        east: number;
        north: number;
        south: number;
    };
    isVisible: boolean;
    data?: BinaryFeatureCollection;
};
/** Subset of deck.gl's Tile2DHeader type, for spatial indexes. */
type SpatialIndexTile = Tile & {
    data?: (Feature & {
        id: bigint;
    })[];
};
type RasterTile = Tile & {
    id: string;
    index: {
        q: bigint;
        i: string;
    };
    data?: Raster;
};
/** @privateRemarks Source: @deck.gl/carto */
type Raster = {
    blockSize: number;
    cells: {
        numericProps: BinaryFeature['numericProps'];
        properties: BinaryFeature['properties'];
    };
};
/******************************************************************************
 * AGGREGATION
 */
/**
 * Enum type for the different types of aggregations available for widgets.
 *
 * @privateRemarks Source: @carto/constants
 * @privateRemarks Converted from enum to type union, for improved declarative API.
 */
type AggregationType = 'count' | 'avg' | 'min' | 'max' | 'sum' | 'custom';
/******************************************************************************
 * FILTERS
 */
/** @privateRemarks Source: @carto/react-api */
type SpatialFilter = Polygon | MultiPolygon;
/** @privateRemarks Source: @deck.gl/carto */
interface Filters {
    [column: string]: Filter;
}
/** @privateRemarks Source: @carto/react-api, @deck.gl/carto */
interface Filter {
    [FilterType.IN]?: {
        owner?: string;
        values: number[] | string[];
    };
    /** [a, b] both are included. */
    [FilterType.BETWEEN]?: {
        owner?: string;
        values: number[][];
    };
    /** [a, b) a is included, b is not. */
    [FilterType.CLOSED_OPEN]?: {
        owner?: string;
        values: number[][];
    };
    [FilterType.TIME]?: {
        owner?: string;
        values: number[][];
    };
    [FilterType.STRING_SEARCH]?: {
        owner?: string;
        values: string[];
        params?: StringSearchOptions;
    };
}
/** @privateRemarks Source: @carto/react-core */
type FilterLogicalOperator = 'and' | 'or';
/**
 * Type for minimum or maximum value of an interval. Values 'null' and
 * 'undefined' are intentionally allowed, and represent an unbounded value.
 */
type FilterIntervalExtremum = number | null | undefined;
type FilterInterval = [FilterIntervalExtremum, FilterIntervalExtremum];
type FilterIntervalComplete = [number, number];
type StringSearchOptions = {
    useRegExp?: boolean;
    mustStart?: boolean;
    mustEnd?: boolean;
    caseSensitive?: boolean;
    keepSpecialCharacters?: boolean;
};
/******************************************************************************
 * GROUPING
 */
/**
 * Defines a step size increment for use with {@link TimeSeriesRequestOptions}.
 *
 * @privateRemarks Source: @carto/react-core
 */
type GroupDateType = 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second';
/******************************************************************************
 * SORTING
 */
type SortDirection = 'asc' | 'desc';
type SortColumnType = 'number' | 'string' | 'date';
/******************************************************************************
 * SQL QUERY PARAMETERS
 */
/** @privateRemarks Source: @deck.gl/carto */
type QueryParameterValue = string | number | boolean | Array<QueryParameterValue> | object;
/** @privateRemarks Source: @deck.gl/carto */
type NamedQueryParameter = Record<string, QueryParameterValue>;
/** @privateRemarks Source: @deck.gl/carto */
type PositionalQueryParameter = QueryParameterValue[];
/** @privateRemarks Source: @deck.gl/carto */
type QueryParameters = NamedQueryParameter | PositionalQueryParameter;

/******************************************************************************
 * LOCAL CALCULATIONS
 */
type FeatureData = Record<string, unknown>;

/** @experimental Prefer type definition from deck.gl. */
type _DataFilterExtensionProps = {
    filterRange: number[][];
    updateTriggers: Record<string, string>;
    getFilterValue: (feature: Feature | FeatureData) => number[];
};
/**
 * Creates props for DataFilterExtension, from `@deck.gl/extensions`, given
 * a set of filters. Requires that DataFilterExtension is initialized with
 * filterSize=4, where the CARTO filters will occupy the first two slots.
 *
 * @example To create a deck.gl layer with GPU data filtering:
 * ```typescript
 * import {DataFilterExtension} from '@deck.gl/extensions';
 * import {VectorTileLayer} from '@deck.gl/layers';
 * import {getDataFilterExtensionProps} from '@carto/api-client';
 *
 * const layer = new VectorTileLayer({
 *  data: data,
 *  extensions: [new DataFilterExtension({filterSize: 4})],
 *  ...getDataFilterExtensionProps(filters),
 * });
 * ```
 */
declare function getDataFilterExtensionProps(filters: Filters, filtersLogicalOperator?: FilterLogicalOperator): _DataFilterExtensionProps;

type APIRequestType = 'Map data' | 'Map instantiation' | 'Public map' | 'Tile stats' | 'SQL' | 'Basemap style';
type APIErrorContext = {
    requestType: APIRequestType;
    mapId?: string;
    connection?: string;
    source?: string;
    type?: MapType;
};
/**
 *
 * Custom error for reported errors in CARTO Maps API.
 * Provides useful debugging information in console and context for applications.
 *
 */
declare class CartoAPIError extends Error {
    /** Source error from server */
    error: Error;
    /** Context (API call & parameters) in which error occured */
    errorContext: APIErrorContext;
    /** Response from server */
    response?: Response;
    /** JSON Response from server */
    responseJson?: any;
    constructor(error: Error, errorContext: APIErrorContext, response?: Response, responseJson?: any);
}

/** @internal Required by fetchMap(). */
declare function buildPublicMapUrl({ apiBaseUrl, cartoMapId, }: {
    apiBaseUrl: string;
    cartoMapId: string;
}): string;
/** @internal Required by fetchMap(). */
declare function buildStatsUrl({ attribute, apiBaseUrl, connectionName, source, type, }: {
    attribute: string;
    apiBaseUrl: string;
    connectionName: string;
    source: string;
    type: MapType;
}): string;

declare enum RasterBandColorinterp {
    Gray = "gray",
    Red = "red",
    Green = "green",
    Blue = "blue",
    Alpha = "alpha",
    Palette = "palette"
}

type SourceRequiredOptions = {
    /** Carto platform access token. */
    accessToken: string;
    /** Data warehouse connection name in Carto platform. */
    connectionName: string;
};
type SourceOptionalOptions = {
    /**
     * Base URL of the CARTO Maps API.
     *
     * Example for account located in EU-west region: `https://gcp-eu-west1.api.carto.com`
     *
     * @default https://gcp-us-east1.api.carto.com
     */
    apiBaseUrl: string;
    /**
     * Custom HTTP headers added to map instantiation and data requests.
     */
    headers: Record<string, string>;
    /**
     * Cache buster value returned by map instantiation.
     *
     * Carto source saves `cache` value of map instantiation response in `cache.value`, so it can be used to
     * check if underlying map data has changed between distinct source requests.
     */
    cache?: {
        value?: number;
    };
    clientId: string;
    /**
     * Maximum URL character length. Above this limit, requests use POST.
     * Used to avoid browser and CDN limits.
     * @default {@link DEFAULT_MAX_LENGTH_URL}
     */
    maxLengthURL?: number;
    /**
     * The column name and the type of geospatial support.
     *
     * If not present, defaults to `'geom'` for generic queries, `'quadbin'` for Quadbin sources and `'h3'` for H3 sources.
     */
    spatialDataColumn?: string;
    /**
     * The type of geospatial support. Defaults to `'geo'`.
     */
    spatialDataType?: SpatialDataType;
    /**
     * Relative resolution of a tile. Higher values increase density and data size. At `tileResolution = 1`, tile geometry is
     * quantized to a 1024x1024 grid. Increasing or decreasing the resolution will increase or decrease the dimensions of
     * the quantization grid proportionately.
     *
     * Supported `tileResolution` values, with corresponding grid sizes:
     *
     * - 0.25: 256x256
     * - 0.5: 512x512
     * - 1: 1024x1024
     * - 2: 2048x2048
     * - 4: 4096x4096
     */
    tileResolution?: TileResolution;
    /**
     * By default, local in-memory caching is enabled.
     */
    localCache?: LocalCacheOptions;
    /** Additional tags appended to HTTP requests, available for analytics and audits. */
    tags?: Record<string, string>;
};
type LocalCacheOptions = {
    /**
     * Map that stores requests and their responses.
     */
    cache?: Map<string, Promise<unknown>>;
    /**
     * Cache control
     *  * `no-cache`: If present, the source will always fetch from original source.
     *  * `no-store`: If present, source will not store result in cache (for later reuse).
     *
     * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#directives
     */
    cacheControl?: ('no-cache' | 'no-store')[];
};
type SourceOptions = SourceRequiredOptions & Partial<SourceOptionalOptions>;
type AggregationOptions = {
    /**
     * Defines the aggregation expressions that will be calculated from the resulting columns on each grid cell.
     *
     * Example:
     *
     *     sum(pop) as total_population, avg(rev) as average_revenue
     */
    aggregationExp: string;
    /**
     * Defines the tile aggregation resolution.
     *
     * @default 6 for quadbin and 4 for h3 sources
     */
    aggregationResLevel?: number;
};
type FilterOptions = {
    /**
     * Filters to apply to the data source on the server
     */
    filters?: Filters;
};
type QuerySourceOptions = {
    /** Full SQL query with query paremeter placeholders (if any). */
    sqlQuery: string;
    /**
     * Values for named or positional paramteres in the query.
     *
     * The way query parameters are determined by data warehouse.
     *
     *  * BigQuery has named query parameters, specified with a dictionary, and referenced by key (`@key`)
     *
     *     ```
     *     sqlQuery: "SELECT * FROM carto-demo-data.demo_tables.retail_stores WHERE storetype = ⁣@type AND revenue > ⁣@minRevenue"
     *     queryParameters: { type: 'Supermarket', minRevenue: 1000000 }
     *     ```
     * * Snowflake supports positional parameters, in the form `:1`, `:2`, etc.
     *
     *     ```
     *     sqlQuery: "SELECT * FROM demo_db.public.import_retail_stores WHERE storetype = :2 AND revenue > :1
     *     queryParameters: [100000, "Supermarket"]
     *     ```
     * * Postgres and Redhisft supports positional parameters, but in the form `$1`, `$2`, etc.
     *
     *     ```
     *     sqlQuery: "SELECT * FROM carto_demo_data.demo_tables.retail_stores WHERE storetype = $2 AND revenue > $1
     *     queryParameters: [100000, "Supermarket"]
     *     ```
     */
    queryParameters?: QueryParameters;
    /**
     * Comma-separated aggregation expressions. If assigned on a vector source, source is grouped by geometry and then aggregated.
     *
     * Example:
     *
     *     1 as value, avg(rev) as average_revenue
     */
    aggregationExp?: string;
};
type TableSourceOptions = {
    /**
     * Fully qualified name of table.
     */
    tableName: string;
    /**
     * Comma-separated aggregation expressions. If assigned on a vector source, source is grouped by geometry and then aggregated.
     *
     * Example:
     *
     *     1 as value, avg(rev) as average_revenue
     */
    aggregationExp?: string;
};
type TilesetSourceOptions = {
    /**
     * Fully qualified name of tileset.
     */
    tableName: string;
    /**
     * Whether to use Web Workers for local widget calculations. Workers
     * are used by default if the runtime environment supports ES Module Workers.
     */
    widgetWorker?: boolean;
    /**
     * Script URL used to create Web Workers for local widget calculations. In
     * most cases a custom URL is not needed; bundlers will resolve the worker
     * URL from a `@carto/api-client/worker` import internally. Advanced uses
     * may require deploying the script manually and providing a custom URL.
     */
    widgetWorkerUrl?: string;
};
type ColumnsOption = {
    /**
     * Columns to retrieve from the table.
     *
     * If not present, all columns are returned.
     */
    columns?: string[];
};
type SpatialDataType = 'geo' | 'h3' | 'quadbin' | 'trajectory';
/**
 * Strategy used for covering spatial filter geometry with spatial indexes.
 * See https://docs.carto.com/data-and-analysis/analytics-toolbox-for-bigquery/sql-reference/quadbin#quadbin_polyfill_mode
 * or https://docs.carto.com/data-and-analysis/analytics-toolbox-for-bigquery/sql-reference/h3#h3_polyfill_mode for more information.
 * @privateRemarks Source: cloud-native maps-api
 * */
type SpatialFilterPolyfillMode = 'center' | 'intersects' | 'contains';
type TileResolution = 0.25 | 0.5 | 1 | 2 | 4;
interface Tilejson {
    tilejson: string;
    name: string;
    description: string;
    version: string;
    attribution: string;
    scheme: string;
    tiles: string[];
    minzoom: number;
    maxzoom: number;
    bounds: [left: number, bottom: number, right: number, top: number];
    center: [longitude: number, latitude: number, zoom: number];
    vector_layers: VectorLayer[];
    minresolution: number;
    maxresolution: number;
    properties_tiles: string[];
    tilestats: Tilestats;
    tileResolution?: TileResolution;
    /**
     * Resolution of data in spatial-index dataset (e.g. H3, Quadbin).
     *
     * @internal
     */
    dataresolution?: number;
    /**
     * Array of ratios of dropped features per zoom level.
     *
     * Example: `[0,0,0.5]` - means that 50% of features are dropped at zoom 2 and bigger.
     *
     * @internal
     */
    fraction_dropped_per_zoom?: number[];
    /**
     * Names of bands - rasters only.
     *
     * @internal
     */
    raster_bands?: string[];
    /**
     * Raster metadata - rasters only.
     *
     * @internal
     */
    raster_metadata?: RasterMetadata;
}
interface Tilestats {
    layerCount: number;
    layers: Layer[];
}
interface Layer {
    layer: string;
    /** Number of features in the layer. */
    count: number;
    /** Number of attributes in the layer. */
    attributeCount: number;
    attributes: Attribute[];
    /** Type of geometry as in geojson geometry type (Point, LineString, Polygon, etc.) */
    geometry?: string;
}
interface AttributeCategoryItem {
    category: string;
    frequency: number;
}
/**
 * Quantiles by number of buckets.
 *
 * Example:
 * ```ts
 *   {
 *     // for 3 buckets, first 1/3 of items lies in range [min, 20], second 1/3 is in [20, 40], and last 1/3 is in [40, max]
 *     3: [20, 40],
 *     4: [20, 30, 50], for 4 buckets ...
 *   }
 * ```
 */
interface QuantileStats {
    [bucketCount: number]: number[];
}
interface Attribute {
    /**
     * String, Number, Timestamp, Boolean
     */
    type: string;
    /**
     * Attribute name.
     */
    attribute: string;
    min?: number;
    max?: number;
    sum?: number;
    /** Quantiles by number of buckets */
    quantiles?: {
        global: QuantileStats;
    } | QuantileStats;
    categories?: AttributeCategoryItem[];
}
interface VectorLayer {
    id: string;
    minzoom: number;
    maxzoom: number;
    fields: Record<string, string>;
    geometry_type?: string;
}
type RasterMetadataBandStats = {
    approximated_stats?: boolean;
    min: number;
    max: number;
    mean: number;
    stddev: number;
    sum: number;
    sum_squares: number;
    count: number;
    /**
     * Quantiles by number of buckets.
     */
    quantiles?: QuantileStats;
    /**
     * Top values by number of values.
     *
     * Key of dictionary is value, value is count.
     * Key order is random.
     *
     * Example:
     * ```
     *  {
     *    3: 5, // means there are 5 pixels with value 3
     *    11: 222,
     *    12: 333, // means that 12 is most common value with count 333
     *    ...      // (assuming 333 was largest value in dict)
     *   }
     * ```
     */
    top_values?: Record<number, number>;
    /**
     * Raster loader version.
     */
    version?: string;
};
type RasterBandType = 'uint8' | 'int8' | 'uint16' | 'int16' | 'uint32' | 'int32' | 'uint64' | 'int64' | 'float32' | 'float64';
type RasterMetadataBand = {
    type: RasterBandType;
    name: string;
    stats: RasterMetadataBandStats;
    /**
     * Optional table of mappings from (integer) band values to (string) human
     * readable labels. Values found in tiles are NOT guaranteed to have labels.
     */
    valuelabels?: Record<string, string>;
    /**
     * Known values:
     *  * `palette`: use unique value and `colortable` ad default mapping
     *  * `red`, `green`, `blue`: use the band as color channel
     *  * `gray`: use the band as grayscale
     */
    colorinterp?: string | RasterBandColorinterp;
    /**
     * Default color mapping for unique values (or if coloprinterp is `palette`)
     */
    colortable?: Record<string, [number, number, number, number]>;
    /**
     * No value representation.
     * Observed values:
     *   * `'nan'` for `NaN`
     *   * `number`: both as string as number, so parsing is needed
     */
    nodata: string | number;
};
type RasterMetadata = {
    block_resolution: number;
    minresolution: number;
    maxresolution: number;
    /** @deprecated Use {@link RasterMetadataBand.nodata} from {@link RasterMetadata.bands}. */
    nodata: number | string;
    bands: RasterMetadataBand[];
    bounds: [left: number, bottom: number, right: number, top: number];
    center: [longitude: number, latitude: number, zoom: number];
    width: number;
    height: number;
    block_width: number;
    block_height: number;
    num_blocks: number;
    num_pixels: number;
    pixel_resolution: number;
};
type TilejsonResult = Tilejson & {
    accessToken: string;
    schema: SchemaField[];
};
type QueryResult = {
    meta: {
        cacheHit: boolean;
        location: string;
        totalBytesProcessed: string;
    };
    rows: Record<string, any>[];
    schema: {
        name: string;
        type: string;
    }[];
};

type QueryOptions = SourceOptions & QuerySourceOptions & {
    /**
     * @internal
     * @experimental
     * Used to append additional parameters to the SQL API request for features specific to providers or integrations.
     */
    internalParameters?: Record<string, string | boolean | number>;
    /** Used to abort the request. */
    signal?: AbortSignal;
};
declare const query: (options: QueryOptions) => Promise<QueryResult>;

declare function requestWithParameters<T = any>({ baseUrl, parameters, headers: customHeaders, errorContext, maxLengthURL, localCache, signal, }: {
    baseUrl: string;
    parameters?: Record<string, unknown>;
    headers?: Record<string, string>;
    errorContext: APIErrorContext;
    maxLengthURL?: number;
    localCache?: LocalCacheOptions;
    signal?: AbortSignal;
}): Promise<T>;
/**
 * Clears the HTTP response cache for all requests using the default cache.
 * @internal
 */
declare function clearDefaultRequestCache(): void;

type LayerType = 'clusterTile' | 'h3' | 'heatmapTile' | 'mvt' | 'quadbin' | 'raster' | 'tileset';

type D3Scale = {
    domain: (d?: any) => any[];
    range: (d?: any) => any[];
    unknown?: (d?: string) => any;
} & ((d: any) => any);
type ScaleType = 'linear' | 'ordinal' | 'log' | 'point' | 'quantile' | 'quantize' | 'sqrt' | 'custom' | 'identity';
declare const OPACITY_MAP: Record<string, string>;
/** @privateRemarks Source: Builder */
declare const TEXT_LABEL_INDEX = 0;
/** @privateRemarks Source: Builder */
declare const TEXT_OUTLINE_OPACITY = 64;
declare const TEXT_NUMBER_FORMATTER: Intl.NumberFormat;
declare function getLayerProps(type: LayerType, config: MapLayerConfig, dataset: Dataset): {
    propMap: any;
    defaultProps: any;
};
declare function domainFromValues(values: any, scaleType: ScaleType): any;
declare function opacityToAlpha(opacity?: number): number;
declare function getColorAccessor({ name, colorColumn }: VisualChannelField, scaleType: ScaleType, { aggregation, range }: {
    aggregation?: string;
    range: ColorRange;
}, opacity: number | undefined, data: TilejsonResult): {
    accessor: any;
    domain: number[] | string[];
    scaleDomain: number[] | string[];
    range: string[];
};
declare function calculateLayerScale(name: string, scaleType: ScaleType, range: ColorRange, data: TilejsonResult): {
    scale: D3Scale;
    domain: string[] | number[];
};
declare function createColorScale<T>(scaleType: ScaleType, domain: string[] | number[], range: T[], unknown: T): D3Scale;
declare function getIconUrlAccessor(field: VisualChannelField | null | undefined, range: CustomMarkersRange | null | undefined, { fallbackUrl, maxIconSize, useMaskedIcons, }: {
    fallbackUrl?: string | null;
    maxIconSize: number;
    useMaskedIcons?: boolean;
}, data: any): any;
declare function getMaxMarkerSize(visConfig: VisConfig, visualChannels: VisualChannels): number;
type Accessor = number | ((d: any, i: any) => number);
declare function negateAccessor(accessor: Accessor): Accessor;
declare function getSizeAccessor({ name }: VisualChannelField, scaleType: ScaleType | undefined, aggregation: string | null | undefined, range: number[] | undefined, data: TilejsonResult): {
    accessor: any;
    domain: number[];
    scaleDomain: number[];
    range: number[] | undefined;
};
declare function getTextAccessor({ name, type }: VisualChannelField, data: any): any;

/** @privateRemarks Source: Builder */
declare function calculateClusterRadius(properties: {
    [column: string]: number;
}, stats: Record<string, {
    min: number;
    max: number;
}>, radiusRange: [number, number], column: string): number;
/** @privateRemarks Source: Builder */
declare function getDefaultAggregationExpColumnAliasForLayerType(layerType: LayerType, provider: ProviderType, schema: SchemaField[]): string;
/** @privateRemarks Source: Builder */
declare function calculateClusterTextFontSize(radius: number): number;

type VisualChannelField = {
    name: string;
    type: string;
    colorColumn?: string;
};
type VisualChannels = {
    colorField?: VisualChannelField;
    colorScale?: ScaleType;
    customMarkersField?: VisualChannelField;
    customMarkersScale?: ScaleType;
    radiusField?: VisualChannelField;
    radiusScale?: ScaleType;
    rotationScale?: ScaleType;
    rotationField?: VisualChannelField;
    sizeField?: VisualChannelField;
    sizeScale?: ScaleType;
    strokeColorField?: VisualChannelField;
    strokeColorScale?: ScaleType;
    heightField?: VisualChannelField;
    heightScale?: ScaleType;
    weightField?: VisualChannelField;
    uniqueValuesColorScale?: ScaleType;
};
type ColorRange = {
    category: string;
    colors: string[];
    colorMap: string[][] | undefined;
    name: string;
    type: string;
    uiCustomScaleType?: 'logarithmic';
};
type CustomMarkersRange = {
    markerMap: {
        value: string;
        markerUrl?: string;
    }[];
    othersMarker?: string;
};
type ColorBand = 'red' | 'green' | 'blue' | 'alpha';
type RasterLayerConfigColorBand = {
    band: ColorBand;
    type: 'none' | 'band' | 'expression';
    value: string;
};
type VisConfig = {
    filled?: boolean;
    opacity?: number;
    enable3d?: boolean;
    colorAggregation?: string;
    colorRange: ColorRange;
    customMarkers?: boolean;
    customMarkersRange?: CustomMarkersRange | null;
    customMarkersUrl?: string | null;
    radius: number;
    radiusRange?: number[];
    radiusAggregation?: string;
    sizeAggregation?: string;
    sizeRange?: number[];
    strokeColorAggregation?: string;
    strokeOpacity?: number;
    strokeColorRange?: ColorRange;
    heightRange?: number[];
    heightAggregation?: string;
    weightAggregation?: string;
    clusterLevel?: number;
    isTextVisible?: boolean;
    rasterStyleType?: 'Rgb' | 'ColorRange' | 'UniqueValues';
    colorBands?: RasterLayerConfigColorBand[];
    uniqueValuesColorRange?: ColorRange;
};
type TextLabel = {
    field: VisualChannelField | null | undefined;
    alignment?: 'center' | 'bottom' | 'top';
    anchor?: 'middle' | 'start' | 'end';
    size: number;
    color?: number[];
    offset?: [number, number];
    outlineColor?: number[];
};
type MapLayerConfig = {
    columns?: Record<string, any>;
    color?: number[];
    label?: string;
    dataId: string;
    textLabel: TextLabel[];
    visConfig: VisConfig;
};
type MapConfigLayer = {
    type: LayerType;
    id: string;
    config: MapLayerConfig;
    visualChannels: VisualChannels;
};
interface CustomStyle {
    url?: string;
    style?: any;
    customAttribution?: string;
}
type KeplerMapConfig = {
    filters: any;
    mapState: any;
    mapStyle: {
        styleType: string;
        visibleLayerGroups: Record<string, boolean>;
    };
    legendSettings?: any;
    popupSettings: any;
    visState: {
        layers: MapConfigLayer[];
        layerBlending: any;
        interactionConfig: any;
    };
    customBaseMaps?: {
        customStyle?: CustomStyle;
    };
};
type BasemapType = 'maplibre' | 'google-maps';
type Basemap = MapLibreBasemap | GoogleBasemap;
type BasemapCommon = {
    /**
     * Type of basemap.
     */
    type: BasemapType;
    /**
     * Custom attribution for style data if not provided by style definition.
     */
    attribution?: string;
    /**
     * Properties of the basemap. These properties are specific to the basemap type.
     */
    props: Record<string, any>;
};
type MapLibreBasemap = BasemapCommon & {
    type: 'maplibre';
    /**
     * MapLibre map properties.
     *
     * Meant to be passed to directly to `maplibregl.Map` object.
     */
    props: MapLibreBasemapProps;
    /**
     * Layer groups to be displayed in the basemap.
     */
    visibleLayerGroups?: Record<string, boolean>;
    /**
     * If `style` has been filtered by `visibleLayerGroups` then this property contains original style object, so user
     * can use `applyLayerGroupFilters` again with new settings.
     */
    rawStyle?: string | Record<string, any>;
};
type MapLibreBasemapProps = {
    style: string | Record<string, any>;
    center: [number, number];
    zoom: number;
    pitch?: number;
    bearing?: number;
};
type GoogleBasemap = BasemapCommon & {
    type: 'google-maps';
    /**
     * Google map properties.
     *
     * Meant to be passed to directly to `google.maps.Map` object.
     */
    props: GoogleBasemapProps;
};
type GoogleBasemapProps = {
    mapTypeId: string;
    mapId?: string;
    center?: {
        lat: number;
        lng: number;
    };
    zoom?: number;
    tilt?: number;
    heading?: number;
};
type Dataset = {
    id: string;
    type: MapType;
    source: string;
    cache?: number;
    connectionName: string;
    geoColumn: string;
    data: TilejsonResult;
    columns: string[];
    format: Format;
    aggregationExp: string;
    aggregationResLevel: number;
    queryParameters: QueryParameters;
    connectionId?: string;
    providerId: ProviderType;
    createdAt?: string;
    updatedAt?: string;
    label?: string;
    color?: string;
    uniqueIdProperty?: string;
    queryTemplate?: string | null;
    name?: string | null;
    spatialIndex?: string | null;
    exportToBucketAvailable?: boolean;
};

type StyleLayerGroupSlug = 'label' | 'road' | 'border' | 'building' | 'water' | 'land';
declare function applyLayerGroupFilters(style: any, // this Maplibre/Mapbox style, we don't want to add a dependency on Maplibre
visibleLayerGroups: Record<StyleLayerGroupSlug, boolean>): any;
declare const _default: {
    readonly VOYAGER: string;
    readonly POSITRON: string;
    readonly DARK_MATTER: string;
    readonly VOYAGER_NOLABELS: string;
    readonly POSITRON_NOLABELS: string;
    readonly DARK_MATTER_NOLABELS: string;
};

declare function getRasterTileLayerStyleProps({ layerConfig, visualChannels, rasterMetadata, }: {
    layerConfig: MapLayerConfig;
    visualChannels: VisualChannels;
    rasterMetadata: RasterMetadata;
}): {
    dataTransform: () => any;
    updateTriggers: {
        getFillColor: Record<string, unknown>;
    };
} | {
    dataTransform?: undefined;
    updateTriggers?: undefined;
    domain?: undefined;
    scaleDomain?: undefined;
    range?: undefined;
    type?: undefined;
    field?: undefined;
};

type Scale = {
    type: ScaleType;
    field?: VisualChannelField;
    /** Natural domain of the scale, as defined by the data  */
    domain?: string[] | number[];
    /** Domain of the user to construct d3 scale */
    scaleDomain?: string[] | number[];
    range?: string[] | number[];
};
type ScaleKey = 'fillColor' | 'pointRadius' | 'lineColor' | 'elevation' | 'weight';
type Scales = Partial<Record<ScaleKey, Scale>>;
type LayerDescriptor = {
    type: LayerType;
    props: Record<string, any>;
    filters?: Filters;
    scales: Scales;
};
type ParseMapResult = {
    /** Map id. */
    id: string;
    /** Title of map. */
    title: string;
    /** Description of map. */
    description?: string;
    createdAt: string;
    updatedAt: string;
    initialViewState: any;
    /** @deprecated Use `basemap`. */
    mapStyle: any;
    popupSettings: any;
    token: string;
    layers: LayerDescriptor[];
};
declare function getLayerDescriptor({ mapConfig, layer, dataset, }: {
    mapConfig: KeplerMapConfig;
    layer: MapConfigLayer;
    dataset: Dataset;
}): LayerDescriptor;
declare function parseMap(json: any): {
    id: any;
    title: any;
    description: any;
    createdAt: any;
    updatedAt: any;
    initialViewState: any;
    /** @deprecated Use `basemap`. */
    mapStyle: {
        styleType: string;
        visibleLayerGroups: Record<string, boolean>;
    };
    popupSettings: any;
    legendSettings: any;
    token: any;
    layers: (LayerDescriptor | undefined)[];
};

declare function fillInMapDatasets({ datasets, keplerMapConfig }: {
    datasets: Dataset[];
    keplerMapConfig: any;
}, context: _FetchMapContext): Promise<boolean[]>;
declare function fillInTileStats({ datasets, keplerMapConfig }: {
    datasets: Dataset[];
    keplerMapConfig: any;
}, context: _FetchMapContext): Promise<boolean[]>;
type FetchMapOptions = {
    /**
     * CARTO platform access token. Only required for private maps.
     */
    accessToken?: string;
    /**
     * Base URL of the CARTO Maps API.
     *
     * Example for account located in EU-west region: `https://gcp-eu-west1.api.carto.com`
     *
     * @default https://gcp-us-east1.api.carto.com
     */
    apiBaseUrl?: string;
    /**
     * Identifier of map created in CARTO Builder.
     */
    cartoMapId: string;
    clientId?: string;
    /**
     * Custom HTTP headers added to map instantiation and data requests.
     */
    headers?: Record<string, string>;
    /**
     * Interval in seconds at which to autoRefresh the data. If provided, `onNewData` must also be provided.
     */
    autoRefresh?: number;
    /**
     * Callback function that will be invoked whenever data in layers is changed. If provided, `autoRefresh` must also be provided.
     */
    onNewData?: (map: any) => void;
    /**
     * Maximum URL character length. Above this limit, requests use POST.
     * Used to avoid browser and CDN limits.
     * @default {@link DEFAULT_MAX_LENGTH_URL}
     */
    maxLengthURL?: number;
};
/**
 * Context reused while fetching and updating a map with fetchMap().
 */
type _FetchMapContext = {
    apiBaseUrl: string;
    mapId?: string;
} & Pick<FetchMapOptions, 'accessToken' | 'clientId' | 'headers' | 'maxLengthURL'>;
type FetchMapResult = ParseMapResult & {
    /**
     * Basemap properties.
     */
    basemap: Basemap | null;
    stopAutoRefresh?: () => void;
};
declare function fetchMap({ accessToken, apiBaseUrl, cartoMapId, clientId, headers, autoRefresh, onNewData, maxLengthURL, }: FetchMapOptions): Promise<FetchMapResult>;

/**
 * Get basemap properties for Carto map.
 *
 * For maplibre-based basemaps it returns style or style URL that can be used with  `maplibregl.Map` compatible component.
 *  * style url is returned for non-filtered standard Carto basemaps or if user used style URL directly in configuration
 *  * filtered style object returned for Carto basemaps with layer groups filtered
 *
 * For Google-maps base maps, it returns options that can be used with `google.maps.Map` constructor.
 */
declare function fetchBasemapProps({ config, errorContext, applyLayerFilters, }: {
    config: KeplerMapConfig;
    /** By default `fetchBasemapProps` applies layers filters to style. Set this to `false` to disable it. */
    applyLayerFilters?: boolean;
    errorContext?: APIErrorContext;
}): Promise<Basemap | null>;

/**
 * Create domain for D3 threshold scale with logarithmic steps.
 *
 * If min is 0, it starts with max and goes down to fill color scale.
 * If max is Infinity, it starts with 10 and goes up to fill color scale.
 * Othersise it starts on first power of 10 that is greater than min.
 *
 * Generates `steps-1` entries, as this is what d3 threshold scale expects
 *
 * @see https://d3js.org/d3-scale/threshold
 */
declare function getLog10ScaleSteps({ min, max, steps, }: {
    min: number;
    max: number;
    steps: number;
}): number[];

/**
 * Create vector expresion evaluator.
 *
 * Used to calculate vector expressions, such as `(band_1 * 3) + band_2/2`,
 * where `band_1` and `band_2` are arrays or typed arrays.
 *
 * Note that all vector operations are element-wise, in paricular `band_1 * band_2`
 * is not "mathematical" dot or cross product, but just element-wise multiplication.
 *
 * Based on:
 * - Copyright (c) 2013 Stephen Oney, http://jsep.from.so/, MIT License
 * - Copyright (c) 2023 Don McCurdy, https://github.com/donmccurdy/expression-eval, MIT License
 */
declare function createVecExprEvaluator(expression: string | jsep.Expression): VecExprEvaluator | null;
declare function evaluateVecExpr(expression: string | jsep.Expression, context: Record<string, VecExprResult>): VecExprResult | null | undefined;
declare enum ErrorCode {
    InvalidSyntax = 0,
    UnknownIdentifier = 1
}
type ValidationResult = {
    valid: boolean;
    errorCode?: ErrorCode;
    errorMessage?: string;
};
declare function validateVecExprSyntax(expression: string | jsep.Expression, context: Record<string, unknown>): ValidationResult;
type VecExprVecLike = number[] | Float32Array | Float64Array | Uint8Array | Int8Array | Int32Array | Uint32Array | Uint16Array | Int16Array;
type VecExprResult = number | VecExprVecLike;
type VecExprEvaluator = {
    (context: object): VecExprResult;
    symbols?: string[];
};

type FilterTypeOptions<T extends FilterType> = {
    type: T;
    column: string;
} & Filter[T];
type AddFilterOptions = FilterTypeOptions<FilterType.IN> | FilterTypeOptions<FilterType.BETWEEN> | FilterTypeOptions<FilterType.CLOSED_OPEN> | FilterTypeOptions<FilterType.TIME> | FilterTypeOptions<FilterType.STRING_SEARCH>;
/**
 * Adds a {@link Filter} to the filter set. Any previous filters with the same
 * `column` and `type` will be replaced.
 */
declare function addFilter(filters: Record<string, Filter>, { column, type, values, owner }: AddFilterOptions): Record<string, Filter>;
type RemoveFilterOptions = {
    column: string;
    owner?: string;
};
/**
 * Removes one or more {@link Filter filters} from the filter set. If only
 * `column` is specified, then all filters on that column are removed. If both
 * `column` and `owner` are specified, then only filters for that column
 * associated with the owner are removed.
 */
declare function removeFilter(filters: Record<string, Filter>, { column, owner }: RemoveFilterOptions): Record<string, Filter>;
/**
 * Clears all {@link Filter filters} from the filter set.
 */
declare function clearFilters(filters: Record<string, Filter>): Record<string, Filter>;
type HasFilterOptions = {
    column: string;
    owner?: string;
};
declare function hasFilter(filters: Record<string, Filter>, { column, owner }: HasFilterOptions): boolean;
type GetFilterOptions<T extends FilterType> = {
    column: string;
    type: T;
    owner?: string;
};
declare function getFilter<T extends FilterType>(filters: Record<string, Filter>, { column, type, owner }: GetFilterOptions<T>): Filter[T] | null;
/**
 * Given all filters for a dataset, returns the subset of filters that are not
 * attributable to the given owner. Typically used to allow filterable widgets
 * to affect other widgets *without* filtering themselves.
 *
 * @privateRemarks Source: @carto/react-widgets
 */
declare function getApplicableFilters(owner?: string, filters?: Record<string, Filter>): Record<string, Filter>;

/**
 * Returns a {@link SpatialFilter} for a given viewport, typically obtained
 * from deck.gl's `viewport.getBounds()` method ([west, south, east, north]).
 * If the viewport covers the entire world (to some margin of error in Web
 * Mercator space), `undefined` is returned instead.
 *
 * If the viewport extends beyond longitude range [-180, +180], the polygon
 * may be reformatted for compatibility with CARTO APIs.
 */
declare function createViewportSpatialFilter(viewport: BBox): SpatialFilter | undefined;
/**
 * Returns a {@link SpatialFilter} for a given {@link Polygon} or
 * {@link MultiPolygon}. If the polygon(s) extend outside longitude
 * range [-180, +180], the result may be reformatted for compatibility
 * with CARTO APIs.
 */
declare function createPolygonSpatialFilter(spatialFilter: Polygon | MultiPolygon): SpatialFilter | undefined;

/******************************************************************************
 * WIDGET API REQUESTS
 */
interface ViewState {
    zoom: number;
    latitude: number;
    longitude: number;
}
/** Common options for {@link WidgetRemoteSource} requests. */
interface BaseRequestOptions {
    signal?: AbortSignal;
    spatialFilter?: SpatialFilter;
    spatialFiltersMode?: SpatialFilterPolyfillMode;
    /** Overrides source filters, if any. */
    filters?: Filters;
    filterOwner?: string;
}
type CategoryOrderBy = 'frequency_asc' | 'frequency_desc' | 'alphabetical_asc' | 'alphabetical_desc';
/**
 * Examples:
 *   * population by state
 *      * column: 'state'
 *      * operation: 'sum'
 *      * operationColumn: 'population'
 *   * average salary by department
 *      * column: 'department'
 *      * operation: 'avg'
 *      * operationColumn: 'salary'
 *   * custom aggregation by storetype
 *      * column: 'storetype'
 *      * operation: 'custom'
 *      * operationExp: 'sum(sales)/sum(area)'
 *
 * Options for {@link WidgetRemoteSource#getCategories}.
 */
interface CategoryRequestOptions extends BaseRequestOptions {
    /** The column that to categorize by. */
    column: string;
    /** The type of aggregation to apply on data in scope of each category. */
    operation: AggregationType;
    /** Remote only. Only valid if operation is 'custom' */
    operationExp?: string;
    /** The aggregated column per each category. */
    operationColumn?: string;
    /** Local only. */
    joinOperation?: 'count' | 'avg' | 'min' | 'max' | 'sum';
    /** Calculate `_carto_others` category for all categories after first N (N is threshold). */
    othersThreshold?: number;
    /**
     * Order categories by frequency or alphabetically.
     * @default 'frequency_desc'
     */
    orderBy?: CategoryOrderBy;
    /** Return raw result (CategoryResponseRaw). */
    rawResult?: boolean;
}
/**
 * Options for {@link WidgetRemoteSource#getFeatures}.
 * @experimental
 * @internal
 */
interface FeaturesRequestOptions extends BaseRequestOptions {
    /**
     * Feature IDs, as found in `_carto_feature_id`. Feature IDs are a hash
     * of geometry, and features with identical geometry will have the same
     * feature ID. Order is important; features in the result set will be
     * sorted according to the order of IDs in the request.
     */
    featureIds: string[];
    /**
     * Columns to be returned for each picked object. Note that for datasets
     * containing features with identical geometry, more than one result per
     * requested feature ID may be returned. To match results back to the
     * requested feature ID, include `_carto_feature_id` in the columns list.
     */
    columns: string[];
    /** Topology of objects to be picked. */
    dataType: 'points' | 'lines' | 'polygons';
    /** Zoom level, required if using 'points' data type. */
    z?: number;
    /**
     * Maximum number of objects to return in the result set. For datasets
     * containing features with identical geometry, those features will have
     * the same feature IDs, and so more results may be returned than feature IDs
     * given in the request.
     */
    limit?: number;
    /**
     * Must match `tileResolution` used when obtaining the `_carto_feature_id`
     * column, typically in a layer's tile requests.
     */
    tileResolution?: TileResolution;
}
/**
 * Examples:
 *   * sum of all sales
 *      * column: 'sales'
 *      * operation: 'sum'
 *   * average salary
 *      * column: 'salary'
 *      * operation: 'avg'
 *   * custom aggregation over all rows
 *      * operation: 'custom'
 *      * operationExp: 'sum(sales)/sum(area)'
 *
 * Options for {@link WidgetRemoteSource#getFormula}.
 */
interface FormulaRequestOptions extends BaseRequestOptions {
    /** The column to apply the aggregation operation on. Not needed for 'custom' operation. */
    column?: string;
    /** The type of aggregation to apply on data. */
    operation: AggregationType;
    /** Remote only. Only valid if operation is 'custom' */
    operationExp?: string;
    /** Local only. */
    joinOperation?: 'count' | 'avg' | 'min' | 'max' | 'sum';
}
/** Options for {@link WidgetRemoteSource#getHistogram}. */
interface HistogramRequestOptions extends BaseRequestOptions {
    column: string;
    ticks: number[];
    operation?: 'count' | 'avg' | 'min' | 'max' | 'sum';
    /** Local only. */
    joinOperation?: 'count' | 'avg' | 'min' | 'max' | 'sum';
}
/** Options for {@link WidgetRemoteSource#getRange}. */
interface RangeRequestOptions extends BaseRequestOptions {
    column: string;
}
/** Options for {@link WidgetRemoteSource#getScatter}. */
interface ScatterRequestOptions extends BaseRequestOptions {
    xAxisColumn: string;
    xAxisJoinOperation?: 'count' | 'avg' | 'min' | 'max' | 'sum';
    yAxisColumn: string;
    yAxisJoinOperation?: 'count' | 'avg' | 'min' | 'max' | 'sum';
}
/** Options for {@link WidgetRemoteSource#getTable}. */
interface TableRequestOptions extends BaseRequestOptions {
    columns: string[];
    sortBy?: string;
    sortDirection?: SortDirection;
    sortByColumnType?: SortColumnType;
    offset?: number;
    limit?: number;
    /** @deprecated Supported for tilesets only. Prefer `filters` (for all sources) instead. */
    searchFilterColumn?: string;
    /** @deprecated Supported for tilesets only. Prefer `filters` (for all sources) instead. */
    searchFilterText?: string;
}
/**
 * Examples:
 *   * sum of all sales by month
 *      * column: 'sales'
 *      * stepSize: 'month'
 *      * operation: 'sum'
 *   * average salary by year
 *      * column: 'salary'
 *      * stepSize: 'year'
 *      * operation: 'avg'
 * Options for {@link WidgetRemoteSource#getTimeSeries}.
 */
interface TimeSeriesRequestOptions extends BaseRequestOptions {
    column: string;
    stepSize: GroupDateType;
    stepMultiplier?: number;
    operation: AggregationType;
    /** Remote only. Only valid if operation is 'custom' */
    operationExp?: string;
    operationColumn?: string;
    joinOperation?: 'count' | 'avg' | 'min' | 'max' | 'sum';
    splitByCategory?: string;
    splitByCategoryLimit?: number;
    splitByCategoryValues?: string[];
}
/**
 * Examples:
 *   * aggregations with array syntax
 *      * aggregations: [{column: 'pop_high', operation: 'sum', alias: 'high_pop'}, {column: 'pop_low', operation: 'avg'}]
 *   * aggregations with string syntax
 *      * aggregations: 'sum(pop_high) as high_pop, avg(pop_low) as avg_low'
 *
 * Options for {@link WidgetRemoteSource#getAggregations}.
 */
interface AggregationsRequestOptions extends BaseRequestOptions {
    /** Aggregations to compute. Can be an array of objects or a SQL string expression. */
    aggregations: {
        column: string;
        operation: Exclude<AggregationType, 'custom'>;
        alias: string;
    }[] | string;
}
/** @experimental */
type ExtentRequestOptions = BaseRequestOptions;
/******************************************************************************
 * WIDGET API RESPONSES
 */
/**
 * Response from {@link WidgetRemoteSource#getFeatures}.
 * @experimental
 * @internal
 */
type FeaturesResponse = {
    rows: Record<string, unknown>[];
};
/** Response from {@link WidgetRemoteSource#getFormula}. */
type FormulaResponse = {
    value: number | null;
};
/** Entry in the category widget response, see  {@link WidgetRemoteSource#getCategories}. */
type CategoryResponseEntry = {
    name: string | number | null;
    value: number;
};
/** Response from {@link WidgetRemoteSource#getCategories}. */
type CategoryResponse = CategoryResponseEntry[];
type CategoryResponseRaw = {
    rows: CategoryResponseEntry[] | null;
    metadata?: {
        others?: number;
    };
};
/** Response from {@link WidgetRemoteSource#getRange}. */
type RangeResponse = {
    min: number;
    max: number;
} | {
    min: string;
    max: string;
} | null;
/** Response from {@link WidgetRemoteSource#getTable}. */
type TableResponse = {
    totalCount: number;
    rows: Record<string, number | string>[];
};
/** Response from {@link WidgetRemoteSource#getScatter}. */
type ScatterResponse = [number, number][];
/** Response from {@link WidgetRemoteSource#getTimeSeries}. */
type TimeSeriesResponse = {
    rows: {
        name: string;
        value: number;
    }[];
    categories?: string[];
};
/** Response from {@link WidgetRemoteSource#getHistogram}. */
type HistogramResponse = number[];
/** Response from {@link WidgetRemoteSource#getAggregations}. */
type AggregationsResponse = {
    rows: Record<string, number | string | null>[];
};
/** @experimental */
type ExtentResponse = {
    bbox: BBox;
};

interface WidgetSourceProps extends Omit<SourceOptions, 'filters'> {
    apiVersion?: ApiVersion;
    filters?: Record<string, Filter>;
    filtersLogicalOperator?: FilterLogicalOperator;
}
/**
 * Source for Widget API requests on a data source defined by a SQL query.
 *
 * Abstract class. Use {@link WidgetQuerySource} or {@link WidgetTableSource}.
 */
declare abstract class WidgetSource<Props extends WidgetSourceProps = WidgetSourceProps> {
    readonly props: Props;
    static defaultProps: Partial<WidgetSourceProps>;
    constructor(props: Props);
    /**
     * Destroys the widget source and releases allocated resources.
     *
     * For remote sources (tables, queries) this has no effect, but for local
     * sources (tilesets, rasters) these resources will affect performance
     * and stability if many (10+) sources are created and not released.
     */
    destroy(): void;
    /**
     * Returns a list of labeled datapoints for categorical data. Suitable for
     * charts including grouped bar charts, pie charts, and tree charts.
     */
    abstract getCategories(options: CategoryRequestOptions): Promise<CategoryResponse>;
    /**
     * Given a list of feature IDs (as found in `_carto_feature_id`) returns all
     * matching features. In datasets containing features with duplicate geometries,
     * feature IDs may be duplicated (IDs are a hash of geometry) and so more
     * results may be returned than IDs in the request.
     * @internal
     * @experimental
     */
    abstract getFeatures(options: FeaturesRequestOptions): Promise<FeaturesResponse>;
    /**
     * Returns a scalar numerical statistic over all matching data. Suitable
     * for 'headline' or 'scorecard' figures such as counts and sums.
     */
    abstract getFormula(options: FormulaRequestOptions): Promise<FormulaResponse>;
    /**
     * Returns a list of labeled datapoints for 'bins' of data defined as ticks
     * over a numerical range. Suitable for histogram charts.
     */
    abstract getHistogram(options: HistogramRequestOptions): Promise<HistogramResponse>;
    /**
     * Returns a range (min and max) for a numerical column of matching rows.
     * Suitable for displaying certain 'headline' or 'scorecard' statistics,
     * or rendering a range slider UI for filtering.
     */
    abstract getRange(options: RangeRequestOptions): Promise<RangeResponse>;
    /**
     * Returns a list of bivariate datapoints defined as numerical 'x' and 'y'
     * values. Suitable for rendering scatter plots.
     */
    abstract getScatter(options: ScatterRequestOptions): Promise<ScatterResponse>;
    /**
     * Returns a list of arbitrary data rows, with support for pagination and
     * sorting. Suitable for displaying tables and lists.
     */
    abstract getTable(options: TableRequestOptions): Promise<TableResponse>;
    /**
     * Returns a series of labeled numerical values, grouped into equally-sized
     * time intervals. Suitable for rendering time series charts.
     */
    abstract getTimeSeries(options: TimeSeriesRequestOptions): Promise<TimeSeriesResponse>;
    /**
     * Returns multiple aggregated values computed over matching data. Suitable
     * for aggregated statistics from pivoted tables, such as H3 tables with
     * pre-computed aggregations across multiple columns.
     */
    abstract getAggregations(options: AggregationsRequestOptions): Promise<AggregationsResponse>;
    /** @experimental */
    abstract getExtent(options?: ExtentRequestOptions): Promise<ExtentResponse>;
}

interface ModelSource {
    type: MapType;
    apiVersion: ApiVersion;
    apiBaseUrl: string;
    accessToken: string;
    clientId: string;
    connectionName: string;
    data: string;
    filters?: Record<string, Filter>;
    filtersLogicalOperator?: FilterLogicalOperator;
    spatialFilter?: SpatialFilter;
    queryParameters?: QueryParameters;
    spatialDataColumn?: string;
    spatialDataType?: SpatialDataType;
    spatialFiltersMode?: SpatialFilterPolyfillMode;
    tags?: Record<string, string>;
}

type WidgetRemoteSourceProps = WidgetSourceProps;
/**
 * Source for Widget API requests.
 *
 * Abstract class. Use {@link WidgetQuerySource} or {@link WidgetTableSource}.
 */
declare abstract class WidgetRemoteSource<Props extends WidgetRemoteSourceProps> extends WidgetSource<Props> {
    /**
     * Subclasses of {@link WidgetRemoteSource} must implement this method, calling
     * {@link WidgetRemoteSource.prototype._getModelSource} for common source
     * properties, and adding additional required properties including 'type' and
     * 'data'.
     */
    protected abstract getModelSource(filters: Filters | undefined, filterOwner?: string): ModelSource;
    protected _getModelSource(filters: Filters | undefined, filterOwner?: string): Omit<ModelSource, 'type' | 'data'>;
    getCategories(options: CategoryRequestOptions): Promise<CategoryResponse>;
    getFeatures(options: FeaturesRequestOptions): Promise<FeaturesResponse>;
    getFormula(options: FormulaRequestOptions): Promise<FormulaResponse>;
    getHistogram(options: HistogramRequestOptions): Promise<HistogramResponse>;
    getRange(options: RangeRequestOptions): Promise<RangeResponse>;
    getScatter(options: ScatterRequestOptions): Promise<ScatterResponse>;
    getTable(options: TableRequestOptions): Promise<TableResponse>;
    getTimeSeries(options: TimeSeriesRequestOptions): Promise<TimeSeriesResponse>;
    getAggregations(options: AggregationsRequestOptions): Promise<AggregationsResponse>;
    /** @experimental */
    getExtent(options?: ExtentRequestOptions): Promise<ExtentResponse>;
}

type LayerQuerySourceOptions = Omit<VectorQuerySourceOptions, 'filters'> | Omit<H3QuerySourceOptions, 'filters'> | Omit<QuadbinQuerySourceOptions, 'filters'>;
type WidgetQuerySourceResult = {
    widgetSource: WidgetQuerySource;
};
/**
 * Source for Widget API requests on a data source defined by a SQL query.
 *
 * Generally not intended to be constructed directly. Instead, call
 * {@link vectorQuerySource}, {@link h3QuerySource}, or {@link quadbinQuerySource},
 * which can be shared with map layers. Sources contain a `widgetSource` property,
 * for use by widget implementations.
 *
 * Example:
 *
 * ```javascript
 * import { vectorQuerySource } from '@carto/api-client';
 *
 * const data = vectorQuerySource({
 *   accessToken: '••••',
 *   connectionName: 'carto_dw',
 *   sqlQuery: 'SELECT * FROM carto-demo-data.demo_tables.retail_stores'
 * });
 *
 * const { widgetSource } = await data;
 * ```
 */
declare class WidgetQuerySource extends WidgetRemoteSource<LayerQuerySourceOptions & WidgetRemoteSourceProps> {
    protected getModelSource(filters: Filters | undefined, filterOwner?: string): ModelSource;
}

/**
 * @internal
 * @privateRemarks Exported for use in @deck.gl/carto's getDataFilterExtensionProps.
 */
declare function _buildFeatureFilter({ filters, type, filtersLogicalOperator, }: {
    filters?: Filters;
    type?: 'number' | 'boolean';
    filtersLogicalOperator?: FilterLogicalOperator;
}): (feature: Feature | FeatureData) => number | boolean;
/**
 * Apply certain filters to a collection of features.
 * @internal
 */
declare function applyFilters(features: FeatureData[], filters: Filters, filtersLogicalOperator: FilterLogicalOperator): FeatureData[];
/**
 * Binary.
 * @internal
 */
declare function buildBinaryFeatureFilter({ filters }: {
    filters: Filters;
}): (() => number) | ((featureIdIdx: number, binaryData: BinaryFeature) => boolean);

type FilterFunction = (filterValues: unknown[], featureValue: unknown, params?: Record<string, unknown>) => boolean;
declare const filterFunctions: Record<FilterType, FilterFunction>;

declare function geojsonFeatures({ geojson, spatialFilter, uniqueIdProperty, }: {
    geojson: FeatureCollection;
    spatialFilter: SpatialFilter;
    uniqueIdProperty?: string;
}): FeatureData[];

/** @privateRemarks Source: @carto/react-core */
type TileFeatures = {
    tiles: Tile[];
    tileFormat: TileFormat;
    spatialDataType: SpatialDataType;
    spatialDataColumn?: string;
    spatialFilter?: SpatialFilter;
    uniqueIdProperty?: string;
    rasterMetadata?: RasterMetadata;
    storeGeometry?: boolean;
};
/** @privateRemarks Source: @carto/react-core */
type TileFeatureExtractOptions = {
    storeGeometry?: boolean;
    spatialDataType?: SpatialDataType;
    spatialDataColumn?: string;
    uniqueIdProperty?: string;
};
/** @privateRemarks Source: @carto/react-core */
declare function tileFeatures({ tiles, spatialFilter, uniqueIdProperty, tileFormat, spatialDataColumn, spatialDataType, rasterMetadata, storeGeometry, }: TileFeatures): FeatureData[];

declare const FEATURE_GEOM_PROPERTY = "__geomValue";
type GeometryExtractOptions = {
    storeGeometry?: boolean;
};
declare function tileFeaturesGeometries({ tiles, tileFormat, spatialFilter, uniqueIdProperty, options, }: {
    tiles: Tile[];
    tileFormat?: TileFormat;
    spatialFilter?: SpatialFilter;
    uniqueIdProperty?: string;
    options?: GeometryExtractOptions;
}): FeatureData[];

type TileFeaturesSpatialIndexOptions = {
    tiles: SpatialIndexTile[];
    spatialFilter?: SpatialFilter;
    spatialDataColumn: string;
    spatialDataType: SpatialDataType;
};
declare function tileFeaturesSpatialIndex({ tiles, spatialFilter, spatialDataColumn, spatialDataType, }: TileFeaturesSpatialIndexOptions): FeatureData[];

declare enum Method {
    INIT = "init",
    LOAD_TILES = "loadTiles",
    SET_TILE_FEATURE_EXTRACT_OPTIONS = "setTileFeatureExtractOptions",
    LOAD_GEOJSON = "loadGeoJSON",
    GET_FORMULA = "getFormula",
    GET_HISTOGRAM = "getHistogram",
    GET_CATEGORIES = "getCategories",
    GET_SCATTER = "getScatter",
    GET_TABLE = "getTable",
    GET_TIME_SERIES = "getTimeSeries",
    GET_RANGE = "getRange",
    GET_AGGREGATIONS = "getAggregations"
}

/**
 * Local (in-memory) implementation of tileset widget calculations. This class
 * may be instantiated by {@link WidgetTilesetSource} in a Web Worker when
 * supported, or on the main thread.
 */
declare class WidgetTilesetSourceImpl extends WidgetSource<WidgetTilesetSourceProps> {
    private _tiles;
    private _features;
    private _tileFeatureExtractOptions;
    private _tileFeatureExtractPreviousInputs;
    /**
     * Loads features as a list of tiles (typically provided by deck.gl).
     * After tiles are loaded, {@link extractTileFeatures} must be called
     * before computing statistics on the tiles.
     */
    loadTiles(tiles: unknown[]): void;
    /** Configures options used to extract features from tiles. */
    setTileFeatureExtractOptions(options: TileFeatureExtractOptions): void;
    protected _extractTileFeatures(spatialFilter?: SpatialFilter): void;
    /**
     * Loads features as GeoJSON (used for testing).
     * @experimental
     * @internal Not for public use. Spatial filters in other method calls will be ignored.
     */
    loadGeoJSON({ geojson, spatialFilter, }: {
        geojson: FeatureCollection;
        spatialFilter: SpatialFilter;
    }): void;
    getFeatures(): Promise<FeaturesResponse>;
    getFormula({ column, operation, joinOperation, filters, filterOwner, spatialFilter, }: FormulaRequestOptions): Promise<FormulaResponse>;
    getHistogram({ operation, ticks, column, joinOperation, filters, filterOwner, spatialFilter, }: HistogramRequestOptions): Promise<HistogramResponse>;
    getCategories({ column, operation, operationColumn, joinOperation, filters, filterOwner, spatialFilter, othersThreshold, orderBy, rawResult, }: CategoryRequestOptions): Promise<CategoryResponse>;
    getScatter({ xAxisColumn, yAxisColumn, xAxisJoinOperation, yAxisJoinOperation, filters, filterOwner, spatialFilter, }: ScatterRequestOptions): Promise<ScatterResponse>;
    getTable({ columns, searchFilterColumn, searchFilterText, sortBy, sortDirection, sortByColumnType, offset, limit, filters, filterOwner, spatialFilter, }: TableRequestOptions): Promise<TableResponse>;
    getTimeSeries({ column, stepSize, operation, operationColumn, joinOperation, filters, filterOwner, spatialFilter, }: TimeSeriesRequestOptions): Promise<TimeSeriesResponse>;
    getRange({ column, filters, filterOwner, spatialFilter, }: RangeRequestOptions): Promise<RangeResponse>;
    getAggregations({ aggregations, filters, filterOwner, spatialFilter, }: AggregationsRequestOptions): Promise<AggregationsResponse>;
    /** @experimental */
    getExtent(): Promise<ExtentResponse>;
    /****************************************************************************
     * INTERNAL
     */
    private _getFilteredFeatures;
}

type WidgetTilesetSourceProps = WidgetSourceProps & Omit<TilesetSourceOptions, 'filters'> & {
    tileFormat: TileFormat;
    spatialDataType: SpatialDataType;
    /**
     * Extent of spatial data, typically from TileJSON. Does not include filters.
     */
    spatialDataBounds: BBox;
};
type WidgetTilesetSourceResult = {
    widgetSource: WidgetTilesetSource;
};
/**
 * Source for Widget API requests on a data source defined by a tileset.
 *
 * Generally not intended to be constructed directly. Instead, call
 * {@link vectorTilesetSource}, {@link h3TilesetSource}, or {@link quadbinTilesetSource},
 * which can be shared with map layers. Sources contain a `widgetSource`
 * property, for use by widget implementations.
 *
 * Example:
 *
 * ```javascript
 * import { vectorTilesetSource } from '@carto/api-client';
 *
 * const data = vectorTilesetSource({
 *   accessToken: '••••',
 *   connectionName: 'carto_dw',
 *   tableName: 'carto-demo-data.demo_rasters.my_tileset_source'
 * });
 *
 * const { widgetSource } = await data;
 * ```
 */
declare class WidgetTilesetSource<Props extends WidgetTilesetSourceProps = WidgetTilesetSourceProps> extends WidgetSource<Props> {
    protected _localImpl: WidgetTilesetSourceImpl | null;
    protected _workerImpl: Worker | null;
    protected _workerEnabled: boolean;
    protected _workerNextRequestId: number;
    constructor(props: Props);
    destroy(): void;
    /**
     * Returns an initialized Worker, to be reused for the lifecycle of this
     * source instance.
     */
    protected _getWorker(): Worker;
    /** Executes a given method on the worker. */
    protected _executeWorkerMethod<T>(method: Method, params: unknown[], signal?: AbortSignal): Promise<T>;
    /**
     * Loads features as a list of tiles (typically provided by deck.gl).
     * After tiles are loaded, {@link extractTileFeatures} must be called
     * before computing statistics on the tiles.
     */
    loadTiles(tiles: unknown[]): void;
    /** Configures options used to extract features from tiles. */
    setTileFeatureExtractOptions(options: TileFeatureExtractOptions): void;
    /**
     * Loads features as GeoJSON (used for testing).
     * @experimental
     * @internal Not for public use. Spatial filters in other method calls will be ignored.
     */
    loadGeoJSON({ geojson, spatialFilter, }: {
        geojson: FeatureCollection;
        spatialFilter: SpatialFilter;
    }): void;
    getFeatures(): Promise<FeaturesResponse>;
    getFormula({ signal, ...options }: FormulaRequestOptions): Promise<FormulaResponse>;
    getHistogram({ signal, ...options }: HistogramRequestOptions): Promise<HistogramResponse>;
    getCategories({ signal, ...options }: CategoryRequestOptions): Promise<CategoryResponse>;
    getScatter({ signal, ...options }: ScatterRequestOptions): Promise<ScatterResponse>;
    getTable({ signal, ...options }: TableRequestOptions): Promise<TableResponse>;
    getTimeSeries({ signal, ...options }: TimeSeriesRequestOptions): Promise<TimeSeriesResponse>;
    getRange({ signal, ...options }: RangeRequestOptions): Promise<RangeResponse>;
    getAggregations({ signal, ...options }: AggregationsRequestOptions): Promise<AggregationsResponse>;
    /** @experimental */
    getExtent(): Promise<ExtentResponse>;
}

type WidgetRasterSourceProps = WidgetTilesetSourceProps & {
    rasterMetadata: RasterMetadata;
    spatialDataType: 'quadbin';
};
type WidgetRasterSourceResult = {
    widgetSource: WidgetRasterSource;
};
declare class WidgetRasterSource extends WidgetTilesetSource<WidgetRasterSourceProps> {
}

type LayerTableSourceOptions = Omit<VectorTableSourceOptions, 'filters'> | Omit<H3TableSourceOptions, 'filters'> | Omit<QuadbinTableSourceOptions, 'filters'>;
type WidgetTableSourceResult = {
    widgetSource: WidgetTableSource;
};
/**
 * Source for Widget API requests on a data source defined as a table.
 *
 * Generally not intended to be constructed directly. Instead, call
 * {@link vectorTableSource}, {@link h3TableSource}, or {@link quadbinTableSource},
 * which can be shared with map layers. Sources contain a `widgetSource` property,
 * for use by widget implementations.
 *
 * Example:
 *
 * ```javascript
 * import { vectorTableSource } from '@carto/api-client';
 *
 * const data = vectorTableSource({
 *   accessToken: '••••',
 *   connectionName: 'carto_dw',
 *   tableName: 'carto-demo-data.demo_tables.retail_stores'
 * });
 *
 * const { widgetSource } = await data;
 * ```
 */
declare class WidgetTableSource extends WidgetRemoteSource<LayerTableSourceOptions & WidgetRemoteSourceProps> {
    protected getModelSource(filters: Filters | undefined, filterOwner?: string): ModelSource;
}

/**
 * Name of the category that represents the "Others" category.
 *
 * See `WidgetSource.getCategories` for more information.
 */
declare const OTHERS_CATEGORY_NAME = "_carto_others";

type VectorTilesetSourceOptions = SourceOptions & TilesetSourceOptions;
type VectorTilesetSourceResponse = TilejsonResult & WidgetTilesetSourceResult;
declare const vectorTilesetSource: (options: VectorTilesetSourceOptions) => Promise<VectorTilesetSourceResponse>;

type VectorTableSourceOptions = SourceOptions & TableSourceOptions & FilterOptions & ColumnsOption;
type VectorTableSourceResponse = TilejsonResult & WidgetTableSourceResult;
declare const vectorTableSource: (options: VectorTableSourceOptions) => Promise<VectorTableSourceResponse>;

type VectorQuerySourceOptions = SourceOptions & QuerySourceOptions & FilterOptions & ColumnsOption;
type VectorQuerySourceResponse = TilejsonResult & WidgetQuerySourceResult;
declare const vectorQuerySource: (options: VectorQuerySourceOptions) => Promise<VectorQuerySourceResponse>;

type TrajectoryTableSourceOptions = SourceOptions & TableSourceOptions & ColumnsOption & {
    /** Column name containing the trajectory identifier */
    trajectoryIdColumn: string;
    /** Column name containing the timestamp */
    timestampColumn: string;
};
type TrajectoryTableSourceResponse = TilejsonResult & WidgetTableSourceResult & {
    timestampRange: RangeResponse;
};
declare const trajectoryTableSource: (options: TrajectoryTableSourceOptions) => Promise<TrajectoryTableSourceResponse>;

type TrajectoryQuerySourceOptions = SourceOptions & QuerySourceOptions & ColumnsOption & {
    /** Column name containing the trajectory identifier */
    trajectoryIdColumn: string;
    /** Column name containing the timestamp */
    timestampColumn: string;
};
type TrajectoryQuerySourceResponse = TilejsonResult & WidgetQuerySourceResult & {
    timestampRange: RangeResponse;
};
declare const trajectoryQuerySource: (options: TrajectoryQuerySourceOptions) => Promise<TrajectoryQuerySourceResponse>;

type RasterSourceOptions = SourceOptions & TilesetSourceOptions & FilterOptions;
type RasterSourceResponse = TilejsonResult & WidgetRasterSourceResult;
declare const rasterSource: (options: RasterSourceOptions) => Promise<RasterSourceResponse>;

type QuadbinTilesetSourceOptions = SourceOptions & TilesetSourceOptions;
type QuadbinTilesetSourceResponse = TilejsonResult & WidgetTilesetSourceResult;
declare const quadbinTilesetSource: (options: QuadbinTilesetSourceOptions) => Promise<QuadbinTilesetSourceResponse>;

type QuadbinTableSourceOptions = SourceOptions & TableSourceOptions & AggregationOptions & FilterOptions;
type QuadbinTableSourceResponse = TilejsonResult & WidgetTableSourceResult;
declare const quadbinTableSource: (options: QuadbinTableSourceOptions) => Promise<QuadbinTableSourceResponse>;

type QuadbinQuerySourceOptions = SourceOptions & QuerySourceOptions & AggregationOptions & FilterOptions;
type QuadbinQuerySourceResponse = TilejsonResult & WidgetQuerySourceResult;
declare const quadbinQuerySource: (options: QuadbinQuerySourceOptions) => Promise<QuadbinQuerySourceResponse>;

type H3TilesetSourceOptions = SourceOptions & TilesetSourceOptions;
type H3TilesetSourceResponse = TilejsonResult & WidgetTilesetSourceResult;
declare const h3TilesetSource: (options: H3TilesetSourceOptions) => Promise<H3TilesetSourceResponse>;

type H3TableSourceOptions = SourceOptions & TableSourceOptions & AggregationOptions & FilterOptions;
type H3TableSourceResponse = TilejsonResult & WidgetTableSourceResult;
declare const h3TableSource: (options: H3TableSourceOptions) => Promise<H3TableSourceResponse>;

type H3QuerySourceOptions = SourceOptions & QuerySourceOptions & AggregationOptions & FilterOptions;
type H3QuerySourceResponse = TilejsonResult & WidgetQuerySourceResult;
declare const h3QuerySource: (options: H3QuerySourceOptions) => Promise<H3QuerySourceResponse>;

type BoundaryTableSourceOptions = SourceOptions & FilterOptions & {
    tilesetTableName: string;
    columns?: string[];
    propertiesTableName: string;
};
type BoundaryTableSourceResponse = TilejsonResult;
declare const boundaryTableSource: (options: BoundaryTableSourceOptions) => Promise<BoundaryTableSourceResponse>;

type BoundaryQuerySourceOptions = SourceOptions & FilterOptions & {
    columns?: string[];
    tilesetTableName: string;
    propertiesSqlQuery: string;
    queryParameters?: QueryParameters;
};
type BoundaryQuerySourceResponse = TilejsonResult;
declare const boundaryQuerySource: (options: BoundaryQuerySourceOptions) => Promise<BoundaryQuerySourceResponse>;

declare const SOURCE_DEFAULTS: Omit<SourceOptionalOptions, 'clientId'>;

declare const CARTO_SOURCES: {
    boundaryQuerySource: (options: BoundaryQuerySourceOptions) => Promise<BoundaryQuerySourceResponse>;
    boundaryTableSource: (options: BoundaryTableSourceOptions) => Promise<BoundaryTableSourceResponse>;
    h3QuerySource: (options: H3QuerySourceOptions) => Promise<H3QuerySourceResponse>;
    h3TableSource: (options: H3TableSourceOptions) => Promise<H3TableSourceResponse>;
    h3TilesetSource: (options: H3TilesetSourceOptions) => Promise<H3TilesetSourceResponse>;
    quadbinQuerySource: (options: QuadbinQuerySourceOptions) => Promise<QuadbinQuerySourceResponse>;
    quadbinTableSource: (options: QuadbinTableSourceOptions) => Promise<QuadbinTableSourceResponse>;
    quadbinTilesetSource: (options: QuadbinTilesetSourceOptions) => Promise<QuadbinTilesetSourceResponse>;
    rasterSource: (options: RasterSourceOptions) => Promise<RasterSourceResponse>;
    trajectoryQuerySource: (options: TrajectoryQuerySourceOptions) => Promise<TrajectoryQuerySourceResponse>;
    trajectoryTableSource: (options: TrajectoryTableSourceOptions) => Promise<TrajectoryTableSourceResponse>;
    vectorQuerySource: (options: VectorQuerySourceOptions) => Promise<VectorQuerySourceResponse>;
    vectorTableSource: (options: VectorTableSourceOptions) => Promise<VectorTableSourceResponse>;
    vectorTilesetSource: (options: VectorTilesetSourceOptions) => Promise<VectorTilesetSourceResponse>;
};

/**
 * Resolution conversion function. Takes a WebMercatorViewport and returns
 * a H3 resolution such that the screen space size of the hexagons is
 * "similar" to the given tileSize on screen. Intended for use with deck.gl.
 * @internal
 * @privateRemarks Source: https://github.com/visgl/deck.gl/blob/master/modules/carto/src/layers/h3-tileset-2d.ts
 */
declare function _getHexagonResolution(viewport: {
    zoom: number;
    latitude: number;
}, tileSize: number): number;

/** @privateRemarks Source: @carto/react-core */
type AggregationFunction = (values: unknown[] | FeatureData[], keys?: string[] | string, joinOperation?: AggregationType) => number;
/** @privateRemarks Source: @carto/react-core */
declare const aggregationFunctions: Record<Exclude<AggregationType, 'custom'>, AggregationFunction>;
/** @privateRemarks Source: @carto/react-core */
declare function aggregate(feature: FeatureData, keys?: string[], operation?: AggregationType): unknown;

type SortColumns = string | string[] | object[];
interface SortOptions {
    sortBy?: SortColumns;
    sortByDirection?: SortDirection;
    sortByColumnType?: 'number' | 'string' | 'date';
}
/**
 * Apply sort structure to a collection of features
 * @param features
 * @param [sortOptions]
 * @param [sortOptions.sortBy] - One or more columns to sort by
 * @param [sortOptions.sortByDirection] - Direction by the columns will be sorted
 * @param [sortOptions.sortByColumnType] - Column type
 * @internal
 * @privateRemarks Source: @carto/react-core
 */
declare function applySorting(features: FeatureData[], { sortBy, sortByDirection, sortByColumnType, }?: SortOptions): FeatureData[];

/** @privateRemarks Source: @carto/react-core */
declare function groupValuesByColumn({ data, valuesColumns, joinOperation, keysColumn, operation, othersThreshold, orderBy, }: {
    data: FeatureData[];
    valuesColumns?: string[];
    joinOperation?: AggregationType;
    keysColumn: string;
    operation: AggregationType;
    othersThreshold?: number;
    orderBy?: CategoryOrderBy;
}): CategoryResponseRaw | null;
declare function getSorter(orderBy: CategoryOrderBy): (a: CategoryResponseEntry, b: CategoryResponseEntry) => number;

/** @privateRemarks Source: @carto/react-core */
type GroupByFeature = {
    name: string;
    value: number;
}[];
/** @privateRemarks Source: @carto/react-core */
declare function groupValuesByDateColumn({ data, valuesColumns, joinOperation, keysColumn, groupType, operation, }: {
    data: Record<string, unknown>[];
    valuesColumns?: string[];
    joinOperation?: Exclude<AggregationType, 'custom'>;
    keysColumn: string;
    groupType: GroupDateType;
    operation?: Exclude<AggregationType, 'custom'>;
}): GroupByFeature | null;

/**
 * Histogram computation.
 * @privateRemarks Source: @carto/react-core
 */
declare function histogram({ data, valuesColumns, joinOperation, ticks, operation, }: {
    data: FeatureData[];
    valuesColumns?: string[];
    joinOperation?: Exclude<AggregationType, 'custom'>;
    ticks: number[];
    operation: Exclude<AggregationType, 'custom'>;
}): number[];

type ScatterPlotFeature = [number, number][];
/**
 * Filters invalid features and formats  data.
 * @privateRemarks Source: @carto/react-core
 */
declare function scatterPlot({ data, xAxisColumns, xAxisJoinOperation, yAxisColumns, yAxisJoinOperation, }: {
    data: FeatureData[];
    xAxisColumns: string[];
    xAxisJoinOperation?: AggregationType;
    yAxisColumns: string[];
    yAxisJoinOperation?: AggregationType;
}): ScatterPlotFeature;

declare function makeIntervalComplete(intervals: FilterInterval[]): FilterIntervalComplete[];

/**
 * Transform WGS84 coordinates to tile coords.
 * It's the inverse of deck.gl coordinate-transform (https://github.com/visgl/deck.gl/blob/master/modules/geo-layers/src/mvt-layer/coordinate-transform.js)
 *
 * @param geometry - any valid geojson geometry
 * @param bbox - geojson bbox
 */
declare function transformToTileCoords<T extends Geometry>(geometry: T, bbox: BBox): T;

/**
 * Custom Set-like interface optimized for BigUint64 cell IDs. Unlike Set,
 * limited in most JavaScript runtimes to ~16M entries, this implementation
 * can support up to `n = 2^32 - 1` (4 billion) entries, with lookups in
 * amortized O(1) time.
 */
declare class CellSet {
    /** List of cells stored by the set. Stored by reference, without copying. */
    private cells;
    /** DataView representing a single cell ID. Pre-allocated to reduce memory during queries. */
    private cellView;
    /** Hash table, mapping a hash index (computed) to an index in the 'cells' array. */
    private hashTable;
    constructor(cells: bigint[]);
    has(cell: bigint): boolean;
    private hashLookup;
}

type FetchDatasetOptions = {
    accessToken: string;
    apiBaseUrl: string;
    connection: string;
    headers?: Record<string, string>;
    localCache?: {
        cacheControl: 'no-cache'[];
    };
    maxLengthURL?: number;
    tags?: Record<string, string>;
};
type FetchDataset = {
    dataset: Dataset;
    filters?: Filter;
    options: FetchDatasetOptions;
};
declare function configureSource({ dataset, filters, options, }: FetchDataset): Promise<TilejsonResult>;
/**
 * @internal
 * State of `aggregationResLevel` in the UI and backend config is based on an assumption of
 * 512x512px tiles. Because we may change tile resolution for performance goals, the
 * `aggregationResLevel` passed to the deck.gl layer must be scaled with tile resolution.
 */
declare function scaleAggregationResLevel(aggregationResLevel: number, tileResolution: number): number | undefined;
/**
 * @internal
 */
declare function getColumnNameFromGeoColumn(geoColumn: string | null | undefined): string | null | undefined;
/**
 * @internal
 */
declare function getSpatialIndexFromGeoColumn(geoColumn: string): SpatialIndex | null;

export { type APIErrorContext, type APIRequestType, AUDIT_TAGS, type AddFilterOptions, type AggregationFunction, type AggregationType, AggregationTypes, type AggregationsRequestOptions, type AggregationsResponse, ApiVersion, type Attribute, _default as BASEMAP, type BaseRequestOptions, type Basemap, type BoundaryQuerySourceOptions, type BoundaryQuerySourceResponse, type BoundaryTableSourceOptions, type BoundaryTableSourceResponse, CARTO_SOURCES, CartoAPIError, type CategoryOrderBy, type CategoryRequestOptions, type CategoryResponse, type CategoryResponseEntry, type CategoryResponseRaw, CellSet, type ColumnsOption, type D3Scale, DEFAULT_API_BASE_URL, type ExtentRequestOptions, type ExtentResponse, FEATURE_GEOM_PROPERTY, type FeaturesRequestOptions, type FeaturesResponse, type FetchMapOptions, type FetchMapResult, type Filter, type FilterFunction, type FilterInterval, type FilterIntervalComplete, type FilterIntervalExtremum, type FilterLogicalOperator, type FilterOptions, FilterType, type Filters, type Format, type FormulaRequestOptions, type FormulaResponse, type GetFilterOptions, type GoogleBasemap, type GroupByFeature, type GroupDateType, type H3QuerySourceOptions, type H3QuerySourceResponse, type H3TableSourceOptions, type H3TableSourceResponse, type H3TilesetSourceOptions, type H3TilesetSourceResponse, type HasFilterOptions, type HistogramRequestOptions, type HistogramResponse, type KeplerMapConfig, type Layer, type LayerDescriptor, type LayerType, type MapLibreBasemap, type MapType, type NamedQueryParameter, OPACITY_MAP, OTHERS_CATEGORY_NAME, type ParseMapResult, type PositionalQueryParameter, Provider, type ProviderType, type QuadbinQuerySourceOptions, type QuadbinQuerySourceResponse, type QuadbinTableSourceOptions, type QuadbinTableSourceResponse, type QuadbinTilesetSourceOptions, type QuadbinTilesetSourceResponse, type QueryOptions, type QueryParameterValue, type QueryParameters, type QueryResult, type QuerySourceOptions, type RangeRequestOptions, type RangeResponse, type Raster, RasterBandColorinterp, type RasterBandType, type RasterMetadata, type RasterMetadataBand, type RasterMetadataBandStats, type RasterSourceOptions, type RasterTile, type RemoveFilterOptions, SOURCE_DEFAULTS, type Scale, type ScaleKey, type ScaleType, type Scales, type ScatterPlotFeature, type ScatterRequestOptions, type ScatterResponse, type SchemaField, SchemaFieldType, type SortColumnType, type SortDirection, type SourceOptionalOptions, type SourceOptions, type SourceRequiredOptions, type SpatialDataType, type SpatialFilter, type SpatialFilterPolyfillMode, SpatialIndex, SpatialIndexColumn, type SpatialIndexTile, type StringSearchOptions, TEXT_LABEL_INDEX, TEXT_NUMBER_FORMATTER, TEXT_OUTLINE_OPACITY, type TableRequestOptions, type TableResponse, type TableSourceOptions, type Tile, type TileFeatureExtractOptions, type TileFeatures, type TileFeaturesSpatialIndexOptions, TileFormat, type TileResolution, type Tilejson, type TilejsonResult, type TilesetSourceOptions, type Tilestats, type TimeSeriesRequestOptions, type TimeSeriesResponse, type TrajectoryQuerySourceOptions, type TrajectoryQuerySourceResponse, type TrajectoryTableSourceOptions, type TrajectoryTableSourceResponse, type VectorLayer, type VectorQuerySourceOptions, type VectorQuerySourceResponse, type VectorTableSourceOptions, type VectorTableSourceResponse, type VectorTilesetSourceOptions, type VectorTilesetSourceResponse, type ViewState, type Viewport, WidgetQuerySource, type WidgetQuerySourceResult, WidgetRasterSource, type WidgetRasterSourceProps, type WidgetRasterSourceResult, WidgetRemoteSource, type WidgetRemoteSourceProps, WidgetSource, type WidgetSourceProps, WidgetTableSource, type WidgetTableSourceResult, WidgetTilesetSource, type WidgetTilesetSourceProps, type WidgetTilesetSourceResult, type _DataFilterExtensionProps, ErrorCode as _ErrorCode, type VecExprResult as _VecExprResult, applyLayerGroupFilters as _applyLayerGroupFilters, _buildFeatureFilter, createVecExprEvaluator as _createVecExprEvaluator, domainFromValues as _domainFromValues, evaluateVecExpr as _evaluateVecExpr, fillInMapDatasets as _fillInMapDatasets, fillInTileStats as _fillInTileStats, _getHexagonResolution, getLog10ScaleSteps as _getLog10ScaleSteps, getRasterTileLayerStyleProps as _getRasterTileLayerStyleProps, validateVecExprSyntax as _validateVecExprSyntax, addFilter, aggregate, aggregationFunctions, applyFilters, applySorting, boundaryQuerySource, boundaryTableSource, buildBinaryFeatureFilter, buildPublicMapUrl, buildStatsUrl, calculateClusterRadius, calculateClusterTextFontSize, calculateLayerScale, clearDefaultRequestCache, clearFilters, configureSource, createColorScale, createPolygonSpatialFilter, createViewportSpatialFilter, fetchBasemapProps, fetchMap, filterFunctions, geojsonFeatures, getApplicableFilters, getClient, getColorAccessor, getColumnNameFromGeoColumn, getDataFilterExtensionProps, getDefaultAggregationExpColumnAliasForLayerType, getFilter, getIconUrlAccessor, getLayerDescriptor, getLayerProps, getMaxMarkerSize, getSizeAccessor, getSorter, getSpatialIndexFromGeoColumn, getTextAccessor, groupValuesByColumn, groupValuesByDateColumn, h3QuerySource, h3TableSource, h3TilesetSource, hasFilter, histogram, makeIntervalComplete, negateAccessor, opacityToAlpha, parseMap, quadbinQuerySource, quadbinTableSource, quadbinTilesetSource, query, rasterSource, removeFilter, requestWithParameters, scaleAggregationResLevel, scatterPlot, setClient, tileFeatures, tileFeaturesGeometries, tileFeaturesSpatialIndex, trajectoryQuerySource, trajectoryTableSource, transformToTileCoords, vectorQuerySource, vectorTableSource, vectorTilesetSource };
