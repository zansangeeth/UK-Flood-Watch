import { Deferred } from '@arcgis/toolkit/promise';
import { BaseController, ControllerLifecycleMethods, controllerSymbol } from './types';
import { use, useRef, useRefSync } from './ControllerInternals';
import { PropertyValues } from 'lit';
import { LitElement } from '../LitElement';
/**
 * Base class for Controllers defined using a class rather than a function.
 * Defining controller using makeController() function is more succinct for smaller
 * controllers. For controllers that need to declare several methods, or need
 * more flexibility, this class may be used
 */
export declare abstract class Controller<Exports = never> implements BaseController {
    #private;
    /** @private */
    protected __ready: Deferred<Exports>;
    /** @private */
    __assignedProperty?: string | false;
    connectedCalled: boolean;
    loadedCalled: boolean;
    readonly [controllerSymbol] = true;
    component: LitElement;
    ready: Promise<Exports>;
    constructor(component?: LitElement);
    /**
     * If controller is being added dynamically, after the component
     * construction, then trigger connected and load right away
     */
    catchUpLifecycle(): void;
    get exports(): Exports;
    /**
     * Set controller's exports property (for usage with proxyExports()) and mark
     * controller as ready (for usage in other controllers). Also, triggers
     * re-render of the component
     */
    set exports(exports: Exports);
    /**
     * If controller needs to await a promise before it's exports are fully ready
     * but it wishes to make some limited exports available before then,
     * this method can be used.
     *
     * This is useful for permitting a limited usage of the controller in default
     * values of properties or in component constructor.
     *
     * In order to help detect bugs, trying to access a prop on the exports value
     * that does not exist will throw an error (in development only). This is
     * useful to detect usages of controller that forgot to await it's exports.
     * (the "value in this.myController" check won't cause an exception though)
     *
     * @param proxy [true] - whether to throw an error if unknown property is
     *   accessed before the controller is loaded.
     */
    setProvisionalExports(exports: Exports, proxy?: boolean): void;
    setProvisionalExports(exports: Exports extends object ? Partial<Exports> : Exports, proxy?: boolean): void;
    setProvisionalExports<Props extends keyof Exports>(exports: Pick<Exports, Props>, proxy?: boolean): void;
    watchExports(callback: (exports: Exports) => void): () => void;
    /**
     * A flexible utility for making sure a controller is loaded before it's used,
     * regardless of how or where a controller was defined:
     *
     * @example
     * makeGenericController(async (component, controller) => {
     *   // Await some controller from the component:
     *   await controller.use(component.someController);
     *   // Initialize new controllers
     *   await controller.use(load(importCoreReactiveUtils));
     *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));
     *   await controller.use(someController(component));
     * });
     *
     * @remarks
     * If your controller is not async, and you are not creating it async, then
     * you are not required to use controller.use - you can use it directly.
     * Similarly, accessing controllers after componentWillLoad callback does not
     * require awaiting them as they are guaranteed to be loaded by then.
     */
    get use(): typeof use;
    /**
     * Just like controller.use, but returns the controller itself, rather than it's
     * exports
     *
     * Use cases:
     * - You have a controller and you want to make sure it's loaded before you
     *   try to use it
     * - Your controller is not using exports, so you wish to access some props on
     *   it directly
     * - You have a controller exports only, and you want to retrieve the
     *   controller itself. This is useful if you wish to call .watchExports() or
     *   some other method on the controller
     */
    get useRef(): typeof useRef;
    /**
     * Like useRef, but doesn't wait for the controller to get ready
     *
     * @private
     */
    get useRefSync(): typeof useRefSync;
    controllerRemoved(): void;
    onConnected(callback: NonNullable<ControllerLifecycleMethods["hostConnected"]>): void;
    onDisconnected(callback: NonNullable<ControllerLifecycleMethods["hostDisconnected"]>): void;
    onLoad(callback: NonNullable<ControllerLifecycleMethods["hostLoad"]>): void;
    onLoaded(callback: NonNullable<ControllerLifecycleMethods["hostLoaded"]>): void;
    onUpdate(callback: NonNullable<ControllerLifecycleMethods["hostUpdate"]>): void;
    onUpdated(callback: NonNullable<ControllerLifecycleMethods["hostUpdated"]>): void;
    onDestroy(callback: NonNullable<ControllerLifecycleMethods["hostDestroy"]>): void;
    onLifecycle(callback: NonNullable<ControllerLifecycleMethods["hostLifecycle"]>): void;
    /** @private */
    triggerConnected(): void;
    /** @private */
    triggerDisconnected(): void;
    /** @private */
    triggerLoad(): Promise<void>;
    /** @private */
    triggerLoaded(): void;
    /** @private */
    triggerUpdate(changes: PropertyValues): void;
    /** @private */
    triggerUpdated(changes: PropertyValues): void;
    /** @private */
    triggerDestroy(): void;
    /** @private */
    triggerLifecycle(): void;
}
export declare abstract class GenericControllerType<Exports, Requires = LitElement> extends Controller<Exports> {
    component: LitElement & Requires;
    constructor(component: LitElement & Requires);
}
/**
 * If your controller requires some specific properties to be present on the
 * component, besides what's included in LitElement, use
 * GenericController over the usual Controller. Use the 2nd generic argument
 * on this class for specifying what properties your controller expects on the
 * component
 *
 * When using a controller created using GenericController, consumer must
 * pass in "this" explicitly to the constructor. If controller was
 * created using Controller, that is not necessary
 *
 * @remarks
 * GenericController class is identical to Controller class in all but typing.
 * That is why, at runtime GenericController is actually equal to Controller
 * class.
 * You can use GenericControllerType type if you wish to reference generic
 * controller instance type.
 */
export declare const GenericController: typeof GenericControllerType;
