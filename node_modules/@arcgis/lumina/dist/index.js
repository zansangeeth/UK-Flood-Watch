import { G as GenericController, p as propertyTrackResolve } from "./Controller-ftAEcdmI.js";
import { c } from "./Controller-ftAEcdmI.js";
import { state } from "lit/decorators/state.js";
import { property as property$1 } from "lit/decorators/property.js";
import { e as emptyFunction, n as noShadowRoot, a as attachToAncestor } from "./lazyLoad-BlK67lvm.js";
import { d, m } from "./lazyLoad-BlK67lvm.js";
import { isEsriInternalEnv, safeCall, safeAsyncCall } from "@arcgis/toolkit/error";
import { camelToKebab } from "@arcgis/toolkit/string";
import { devToolsAwareTimeout, Deferred } from "@arcgis/toolkit/promise";
import { nothing as nothing$1, LitElement as LitElement$1, isServer, notEqual, noChange as noChange$1, render } from "lit";
import { s as setAmbientComponent, c as controllerSymbol, a as shouldBypassReadOnly } from "./ControllerInternals-CWQrfEA8.js";
import { propertyFlagAttribute, propertyFlagNoAccessor, propertyFlagReadOnly, propertyFlagState, propertyFlagBoolean, propertyFlagNumber, propertyFlagReflect } from "./config.js";
import { classMap } from "lit/directives/class-map.js";
import { styleMap } from "lit/directives/style-map.js";
import { directive as directive$1, Directive } from "lit/directive.js";
import { live as live$1 } from "lit/directives/live.js";
import { ref } from "lit/directives/ref.js";
const property = property$1;
const method = void 0;
class ControllerManager extends GenericController {
  constructor(component) {
    super(component);
    this.destroyed = false;
    this.R = false;
    this.V = nothing$1;
    this.T = [];
    this.#exportsStore = /* @__PURE__ */ new WeakMap();
    this.#component = component;
    this.exports = void 0;
    this.hasDestroy = autoDestroyDisabledPropName in component && typeof component.destroy === "function";
    LitElement$1.prototype.addController.call(component, {
      // Lit will call these callbacks
      // We do not directly implement hostConnected and etc on ControllerManager
      // because ControllerManager is also included in the list of controllers
      // we manage - and for each controller we manage we call hostConnected
      // (from inside of .triggerConnected). So there would be an infinite
      // loop if Lit calls hostConnected which in turn calls
      // triggerConnected which calls hostConnected again.
      hostConnected: () => {
        if (this.destroyed) {
          const tagName = component.el.localName;
          component.el.remove();
          throw new Error(
            `The ${tagName} component has already been destroyed. It cannot be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the ${autoDestroyDisabledPropName} prop.`
          );
        }
        if (this.#autoDestroyTimeout !== void 0) {
          clearTimeout(this.#autoDestroyTimeout);
        }
        propertyTrackResolve();
        for (const controller of component.M) {
          if ("triggerConnected" in controller) {
            controller.triggerConnected();
          } else {
            safeCall(controller.hostConnected, controller);
          }
        }
      },
      hostDisconnected: () => {
        for (const controller of component.M) {
          if ("triggerDisconnected" in controller) {
            controller.triggerDisconnected();
          } else {
            safeCall(controller.hostDisconnected, controller);
          }
        }
        if (this.hasDestroy && !this.destroyed) {
          this.U();
        }
      },
      hostUpdate: () => {
        for (const controller of component.M) {
          if ("triggerUpdate" in controller) {
            controller.triggerUpdate(this.Q);
          } else {
            safeCall(controller.hostUpdate, controller, this.Q);
          }
        }
      },
      hostUpdated: () => {
        for (const controller of component.M) {
          if ("triggerUpdated" in controller) {
            controller.triggerUpdated(this.Q);
          } else {
            safeCall(controller.hostUpdated, controller, this.Q);
          }
        }
        this.Q = void 0;
      }
    });
    queueMicrotask(() => this.R = true);
    setAmbientComponent(component);
  }
  #autoDestroyTimeout;
  #component;
  // Keep this method async needlessly for now to avoid a breaking change if we
  // would need to make it async in the future
  // eslint-disable-next-line @typescript-eslint/require-await
  async destroy() {
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      this.devOnly$ensureHasDestroy?.();
    }
    if (this.destroyed) {
      return;
    }
    if (this.#component.el.isConnected) {
      this.hasDestroy = false;
      this.#component.el.remove();
    }
    this.#autoDestroyTimeout = void 0;
    this.destroyed = true;
    for (const controller of this.#component.M) {
      if ("triggerDestroy" in controller) {
        controller.triggerDestroy();
      } else {
        safeCall(controller.hostDestroy, controller);
      }
    }
    this.#component.M.splice(0);
  }
  /** @private */
  U() {
    if (this.#autoDestroyTimeout !== void 0) {
      clearTimeout(this.#autoDestroyTimeout);
    }
    if (!this.#component.el.isConnected && !this.#component.autoDestroyDisabled) {
      const destroy = () => void this.#component.destroy();
      if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && autoDestroyOnDisconnectTimeout === 0) ;
      else {
        this.#autoDestroyTimeout = devToolsAwareTimeout(destroy, autoDestroyOnDisconnectTimeout);
      }
    }
  }
  /** @private */
  S(key, value) {
    const trackers = this.T;
    this.V = nothing$1;
    this.T = [];
    trackers.forEach((tracker) => tracker(key, value));
  }
  #exportsStore;
  /**
   * Associate an exports object with a controller for reverse lookup in
   * controller.use
   *
   * @private
   */
  W(controller, exports) {
    if (typeof exports === "object" && exports !== null || typeof exports === "function") {
      this.#exportsStore.set(exports, controller);
    }
  }
  /** @private */
  X(exports) {
    if (typeof exports === "object" && exports !== null || typeof exports === "function") {
      return this.#exportsStore.get(exports);
    } else {
      return void 0;
    }
  }
}
if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
  ControllerManager.prototype.devOnly$ensureHasDestroy = function ensureHasDestroy() {
    if (!this.hasDestroy) {
      throw new Error(
        `
          If the component uses a controller that uses destroy() method, then the
          component must have the following properties:
          /**
           * If true, the component will not be destroyed automatically when it is
           * disconnected from the document. This is useful when you want to move the
           * component to a different place on the page, or temporarily hide it. If this
           * is set, make sure to call the \`destroy\` method when you are done to prevent
           * memory leaks.
           */
          @property() ${autoDestroyDisabledPropName} = false;

          /** Permanently destroy the component */
          @method()
          async destroy(): Promise<void> {
            await this.manager.destroy();
          }
          `.trim().split("\n").map((line) => line.trim()).join("\n")
      );
    }
  };
}
let autoDestroyOnDisconnectTimeout = 1e3;
const autoDestroyDisabledPropName = "autoDestroyDisabled";
process.env.NODE_ENV !== "production" && isEsriInternalEnv() ? {} : void 0;
class LitElement extends LitElement$1 {
  constructor() {
    super();
    this.M = [];
    this.manager = new ControllerManager(this);
    const that = this;
    const constructor = that.constructor;
    const lazy = constructor.N;
    const createObservable = constructor.K.o;
    const ourShouldUpdate = LitElement.prototype.shouldUpdate;
    that.#postLoadedDeferred = lazy?.H ?? new Deferred();
    that.I = lazy?.I ?? new Deferred();
    that.J = lazy?.J ?? [];
    that["_offspring"] = that.J;
    that["_postLoad"] = that.I;
    that.el = lazy ?? that;
    that.#enableUpdating = that.enableUpdating;
    that.enableUpdating = emptyFunction;
    if (that.shouldUpdate !== ourShouldUpdate) {
      that.#originalShouldUpdate = that.shouldUpdate;
      that.shouldUpdate = ourShouldUpdate;
    }
    if (process.env.NODE_ENV !== "production") {
      const isOwnComponent = globalThis.devOnly$ownTagNames?.has(that.el.localName);
      const constructor2 = this.constructor;
      const warningsWereCustomized = constructor2.enabledWarnings !== LitElement$1.enabledWarnings;
      if (!isOwnComponent && !warningsWereCustomized) {
        constructor2.disableWarning?.("change-in-update");
      }
      if (isEsriInternalEnv()) {
        globalThis.devOnly$luminaComponentRefCallback?.(this);
        const stencilToLitMapping = {
          componentDidLoad: "loaded",
          componentDidRender: "updated",
          componentDidUpdate: "updated",
          componentShouldUpdate: "shouldUpdate",
          componentWillLoad: "load",
          componentWillRender: "willUpdate",
          componentWillUpdate: "willUpdate"
        };
        Object.entries(stencilToLitMapping).forEach(([stencilMethod, litMethod]) => {
          if (stencilMethod in this) {
            throw new Error(
              `Unexpected ${stencilMethod}() in a Lit component ${this.el.localName}. In Lit, you should use ${litMethod}() instead`
            );
          }
        });
      }
    }
    if (createObservable) {
      that.#observables = /* @__PURE__ */ new Map();
      constructor.elementProperties.forEach((_, name) => that.#observables.set(name, createObservable()));
    }
    if (isServer) {
      that.el.setAttribute(constructor.K.hydratedAttribute, "");
    }
  }
  /**
   * Customize Lit's default style handling to support non-shadow-root styles
   */
  static finalizeStyles(styles) {
    if (process.env.NODE_ENV === "test" && Array.isArray(styles)) {
      styles = styles.filter(Boolean);
    }
    const finalizedStyles = super.finalizeStyles(styles);
    const useLightDom = this.shadowRootOptions === noShadowRoot;
    return this.K?.commonStyles === void 0 || useLightDom ? finalizedStyles : [this.K.commonStyles, ...finalizedStyles];
  }
  static createProperty(name, options) {
    const flags = typeof options === "number" ? options : Array.isArray(options) ? options[0] : 0;
    const rest = Array.isArray(options) ? options[1] : void 0;
    const hasChanged = rest?.hasChanged ?? notEqual;
    const normalizedOptions = {
      /**
       * By default to infer attribute name from property name, Lit just
       * converts property name to lowercase. That is consistent with
       * native DOM attributes.
       *
       * However, that is not consistent with Stencil and would be a
       * breaking change for us. Also, kebab-case is more common among the
       * web components. But the most important reason is that we have
       * some pretty long attribute names, which would be utterly
       * unreadable in lowercase.
       *
       * Also, if browsers add new attributes, that may cause a conflict
       * with our attributes.
       *
       * Thus, overwriting Lit's default behavior to use kebab-case:
       */
      attribute: !!(flags & propertyFlagAttribute) && typeof name === "string" ? camelToKebab(name) : false,
      reflect: !!(flags & propertyFlagReflect),
      type: flags & propertyFlagBoolean ? Boolean : flags & propertyFlagNumber ? Number : void 0,
      /**
       * At the moment in Lit, state:true just means attribute:false, so this
       * line is technically redundant, but let's keep it here just in case Lit
       * will add more meaning to state:true in the future.
       */
      state: !!(flags & propertyFlagState),
      // Controllers add this option to Lit
      readOnly: !!(flags & propertyFlagReadOnly),
      noAccessor: !!(flags & propertyFlagNoAccessor),
      c: false,
      ...rest,
      hasChanged(newValue, oldValue) {
        const changed = hasChanged(newValue, oldValue);
        normalizedOptions.c = changed;
        return changed;
      }
    };
    super.createProperty(name, normalizedOptions);
  }
  static getPropertyDescriptor(name, key, options) {
    const runtime = this.K;
    const accessor = super.getPropertyDescriptor(name, key, options);
    options.d = accessor;
    return {
      ...accessor,
      get() {
        runtime.t?.(this.#observables.get(name));
        return accessor.get?.call(this);
      },
      set(rawNewValue) {
        const manager = this.manager;
        if (options.readOnly && !shouldBypassReadOnly && (manager.R || manager.connectedCalled)) {
          throw Error(
            `Cannot assign to read-only property "${name}" of ${this.el.localName}. Trying to assign "${rawNewValue}"`
          );
        }
        accessor.set.call(this, rawNewValue ?? void 0);
        if (options.c) {
          this.#observables?.get(name)?.notify();
        }
        if (manager.T.length > 0) {
          propertyTrackResolve();
          manager?.S(name, rawNewValue);
        }
      }
    };
  }
  static {
    this.lumina = true;
  }
  /**
   * The JS API's Accessor observables. This is used to integrate with the JS
   * API's reactivity system.
   *
   * @private
   */
  #observables;
  #originalShouldUpdate;
  #enableUpdating;
  #postLoadedDeferred;
  #trackingTarget;
  connectedCallback() {
    if (this.el.hasAttribute("defer-hydration")) {
      return;
    }
    const trackingTarget = this.constructor.K.c?.(() => this.requestUpdate());
    this.#trackingTarget = trackingTarget;
    const isFirstCall = !this.manager.connectedCalled;
    super.connectedCallback();
    if (isFirstCall) {
      queueMicrotask(
        // eslint-disable-next-line @typescript-eslint/promise-function-async, @typescript-eslint/no-misused-promises
        () => this.#load().catch((error) => {
          this.#postLoadedDeferred.reject(error);
          setTimeout(() => {
            throw error;
          });
        })
      );
    } else if (trackingTarget) {
      this.requestUpdate();
    }
  }
  #doTrackedUpdate(changedProperties) {
    try {
      this.#trackingTarget.clear();
      this.constructor.K.r(
        this.#trackingTarget,
        () => super.update(changedProperties)
      );
    } catch (error) {
      this.#trackingTarget.clear();
      throw error;
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.#trackingTarget?.destroy();
    this.#trackingTarget = void 0;
  }
  /**
   * Overwrite Lit's default behavior of attaching shadow root to the lit
   * element, and instead use this.el to support lazy builds.
   *
   * Also, support the case when component asked to not use shadow root
   */
  createRenderRoot() {
    const existingShadowRoot = this.el.shadowRoot;
    const Class = this.constructor;
    const options = Class.shadowRootOptions;
    const useLightDom = options === noShadowRoot;
    const renderRoot = existingShadowRoot ?? (useLightDom ? this.el : this.el.attachShadow(options));
    if (existingShadowRoot && // The shadow root may already exist if we are doing HMR - such case is not
    // SSR so ignore it
    process.env.NODE_ENV !== "production" && (this.el.constructor.devOnly$hmrIndex ?? 0) === 0) {
      LitElement$1.prototype.createRenderRoot.call(this);
      return existingShadowRoot;
    }
    if (this.isConnected) {
      const domRoot = renderRoot.getRootNode();
      if (process.env.NODE_ENV === "test") {
        domRoot.adoptedStyleSheets ??= [];
      }
      domRoot.adoptedStyleSheets = [
        ...domRoot.adoptedStyleSheets,
        ...Class.elementStyles.map((stylesheet) => "styleSheet" in stylesheet ? stylesheet.styleSheet : stylesheet)
      ];
    }
    return renderRoot;
  }
  /** Do asynchronous component load */
  async #load() {
    const parentLoadPromise = this.el.G ?? attachToAncestor(this.el);
    if (parentLoadPromise) {
      await parentLoadPromise;
    }
    const promises = [];
    for (const controller of this.M) {
      if ("triggerLoad" in controller) {
        promises.push(controller.triggerLoad());
      } else {
        promises.push(safeAsyncCall(controller.hostLoad, controller));
      }
    }
    await Promise.all(promises);
    await this.load?.();
    if (this.manager.hasDestroy) {
      this.manager.onUpdate(
        (changes) => changes.has(autoDestroyDisabledPropName) && this.manager.U()
      );
    }
    this.#enableUpdating(true);
    this.performUpdate();
    this.I.resolve();
    await Promise.resolve();
    const pendingChildren = this.J.filter((loaded) => !loaded.manager?.loadedCalled);
    if (pendingChildren.length) {
      await Promise.allSettled(pendingChildren.map(async (child) => await child.componentOnReady()));
    }
    this.J.length = 0;
    this.el.setAttribute(this.constructor.K.hydratedAttribute, "");
    for (const controller of this.M) {
      if ("triggerLoaded" in controller) {
        controller.triggerLoaded();
      } else {
        safeCall(controller.hostLoaded, controller);
      }
    }
    this.loaded?.();
    this.#postLoadedDeferred.resolve();
  }
  /**
   * Overwriting default shouldUpdate simply to get access to
   * "changedProperties" so that we can later provide it to ControllerManager
   */
  shouldUpdate(_changedProperties) {
    this.manager.Q = _changedProperties;
    return this.#originalShouldUpdate?.(_changedProperties) ?? true;
  }
  update(changedProperties) {
    if (this.#trackingTarget) {
      this.#doTrackedUpdate(changedProperties);
    } else {
      super.update(changedProperties);
    }
  }
  listen(name, listener, options) {
    const boundListener = listener?.bind(this) ?? listener;
    this.manager.onLifecycle(() => {
      this.el.addEventListener(name, boundListener, options);
      return () => this.el.removeEventListener(name, boundListener, options);
    });
  }
  listenOn(target, name, listener, options) {
    const boundListener = listener?.bind(this) ?? listener;
    this.manager.onLifecycle(() => {
      target.addEventListener(name, boundListener, options);
      return () => target.removeEventListener(name, boundListener, options);
    });
  }
  /**
   * Create a promise that resolves once component is fully loaded.
   *
   * @example
   * const map = document.createElement('arcgis-map');
   * document.body.append(map);
   * map.componentOnReady().then(() => {
   *   console.log('Map is ready to go!');
   * });
   */
  async componentOnReady() {
    await this.#postLoadedDeferred.promise;
    return this;
  }
  /**
   * Adds a controller to the host, which connects the controller's lifecycle
   * methods to the host's lifecycle.
   *
   * @remarks
   * Even though Lit's LitElement already has addController,
   * we overwrite it with a compatible version to have more control over
   * timing, and to add support for load/loaded lifecycle hooks.
   */
  addController(controller) {
    this.M.push(controller);
    if (!(controllerSymbol in controller) && this.renderRoot && this.el.isConnected) {
      controller.hostConnected?.();
    }
  }
  /**
   * Removes a controller from the host.
   */
  removeController(controller) {
    this.M.splice(this.M.indexOf(controller), 1);
    controller.controllerRemoved?.();
  }
}
function disableReactiveUtilsIntegration(componentClass) {
  componentClass.prototype["update"] = LitElement$1.prototype["update"];
}
const makeRuntime = (options) => {
  let assetPath;
  const setAssetPath = (path) => {
    assetPath = new URL(
      path,
      /**
       * setAssetPath() is called in global scope whenever Lumina runtime is
       * imported. Thus we need to carefully handle different environments.
       *
       * Need `|| undefined` because Stencil's unit tests mock-dock defines
       * `location.href` as empty string, which crashes `new URL()`. Stencil's
       * test environment does not define `NODE_ENV` by default, so we have to
       * add a few bytes to production.
       *
       * For happy-dom and jsdom, we are assuming that `NODE_ENV` is set.
       * Depending on configuration, `location?.href` is either undefined (not
       * an exception) or `about:blank` (an exception - thus handling that case
       * explicitly).
       *
       * For Node.js without a DOM environment, `location?.href` is undefined so
       * all is good.
       */
      process.env.NODE_ENV === "test" ? globalThis.location?.href === "about:blank" ? void 0 : globalThis.location?.href || void 0 : globalThis.location?.href || void 0
    ).href;
  };
  const runtime = {
    ...options,
    // FEATURE: research https://vitejs.dev/guide/build.html#advanced-base-options
    getAssetPath(suffix) {
      const assetUrl = new URL(suffix, assetPath);
      return assetUrl.origin !== globalThis.location?.origin ? assetUrl.href : assetUrl.pathname;
    },
    setAssetPath,
    customElement(tagName, component) {
      component.K = runtime;
      component.L = tagName;
      if (!customElements.get(tagName)) {
        customElements.define(tagName, component);
      }
    }
  };
  setAssetPath(options.defaultAssetPath);
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
    globalThis.devOnly$luminaRuntime = runtime;
  }
  return runtime;
};
const Fragment = void 0;
const bindAttribute = void 0;
const bindBooleanAttribute = void 0;
const bindProperty = void 0;
const bindEvent = void 0;
const safeClassMap = (parameters) => typeof parameters === "object" && parameters != null ? classMap(parameters) : parameters;
const safeStyleMap = (parameters) => typeof parameters === "object" && parameters != null ? styleMap(parameters) : parameters;
class DeferLoad extends Directive {
  update(part) {
    const tagName = part.element.localName;
    if (!customElements.get(tagName)) {
      void deferredLoaders.get(tagName)?.();
    }
  }
  render() {
    return noChange$1;
  }
}
const deferLoad = /* @__PURE__ */ directive$1(DeferLoad)();
const deferredLoaders = /* @__PURE__ */ new Map();
class StabilizedRef extends Directive {
  #refValue;
  #callback;
  constructor(partInfo) {
    super(partInfo);
    const that = this;
    this.#callback = function ref2(element) {
      return that.#refValue.call(this, element);
    };
  }
  render(refValue) {
    if (typeof refValue === "function") {
      this.#refValue = refValue;
      return ref(this.#callback);
    }
    return ref(refValue);
  }
}
const stabilizedRef = directive$1(StabilizedRef);
const directive = directive$1;
const live = live$1;
const nothing = nothing$1;
const noChange = noChange$1;
function setAttribute(element, attributeName, value) {
  if (value == null) {
    element.removeAttribute(attributeName);
  } else {
    element.setAttribute(attributeName, value);
  }
}
const stringOrBoolean = {
  toAttribute: (value) => value === true ? "" : value === false ? null : value
};
const emptyObject = {};
const makeReactWrapperFactory = (react, createComponent) => (options) => {
  const tagName = options.tagName;
  let customElementPrototype = emptyObject;
  const elementClass = {
    name: tagName,
    /**
     * Lit's createComponent tries to access the elementClass.prototype in
     * global scope (in development mode). The elementClass may not be defined
     * yet (because we are in a lazy loading build, or because current app
     * doesn't import a given custom element as it doesn't use it).
     *
     * Thus, we return an empty object as a fake prototype.
     *
     * Right after the call to `createComponent`, we set to
     * customElementPrototype undefined so that the next access of
     * `.prototype` tries to get the real prototype.
     * `createPrototypeProxy()` is called, this small proxy delays retrieving the custom
     * element prototype until it is actually needed, and caches the result for future calls.
     */
    get prototype() {
      if (customElementPrototype === void 0) {
        const customElement = customElements.get(tagName);
        if (!customElement) {
          throw new Error(`Custom element "${tagName}" not found`);
        }
        customElement.F?.();
        customElement.F = emptyFunction;
        customElementPrototype = customElement.prototype;
        Object.defineProperty(elementClass, "prototype", { value: customElementPrototype });
      }
      return customElementPrototype;
    }
  };
  const result = createComponent({
    ...options,
    react,
    elementClass
  });
  customElementPrototype = void 0;
  return result;
};
const getReactWrapperOptions = (tagNameAndElement, events) => ({ tagName: tagNameAndElement, events });
const renderElement = (element) => {
  const container = document.createElement("div");
  render(element, container);
  return container.firstElementChild;
};
export {
  Fragment,
  LitElement,
  bindAttribute,
  bindBooleanAttribute,
  bindEvent,
  bindProperty,
  c as createEvent,
  deferLoad,
  deferredLoaders,
  d as devOnly$getLitElementTagNameAndRuntime,
  directive,
  disableReactiveUtilsIntegration,
  getReactWrapperOptions,
  live,
  m as makeDefineCustomElements,
  makeReactWrapperFactory,
  makeRuntime,
  method,
  noChange,
  noShadowRoot,
  nothing,
  property,
  renderElement,
  safeClassMap,
  safeStyleMap,
  setAttribute,
  stabilizedRef,
  state,
  stringOrBoolean
};
