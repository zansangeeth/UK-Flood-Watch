import { isEsriInternalEnv } from "@arcgis/toolkit/error";
import { camelToKebab } from "@arcgis/toolkit/string";
import { Deferred } from "@arcgis/toolkit/promise";
import { lazyMetaGroupJoiner, lazyMetaItemJoiner, lazyMetaSubItemJoiner } from "./config.js";
function devOnlyDetectIncorrectLazyUsages(LitClass) {
  const genericPrototype = LitClass.prototype;
  const descriptor = Object.getOwnPropertyDescriptor(genericPrototype, "innerText");
  if (descriptor !== void 0 && descriptor.set?.name === "setWrapper") {
    return;
  }
  const allowList = /* @__PURE__ */ new Set([
    // We shouldn't be overwriting this property
    "constructor",
    // Called by Lit - we proxy it to this.el in ProxyComponent
    "setAttribute",
    // Called by Lit SSR - we proxy it to this.el in ProxyComponent
    "removeAttribute",
    // Called by Lit - we proxy it to this.el in ProxyComponent
    "isConnected",
    // Called by Lit, but only in dev mode for warnings, so we don't have to proxy.
    "localName"
  ]);
  const customErrorMessages = {
    addEventListener: "use this.listen() or this.el.addEventListener()"
  };
  Object.entries({
    ...Object.getOwnPropertyDescriptors(HTMLElement.prototype),
    ...Object.getOwnPropertyDescriptors(Element.prototype),
    ...Object.getOwnPropertyDescriptors(Node.prototype),
    ...Object.getOwnPropertyDescriptors(EventTarget.prototype)
  }).forEach(([key, value]) => {
    if (allowList.has(key)) {
      return;
    }
    function validateUsage(...args) {
      const isDynamicallyCreatedComponentInTest = this === this.el;
      if (isDynamicallyCreatedComponentInTest) {
        return;
      }
      if (key === "hasAttribute" && args[0] === "defer-hydration") {
        return false;
      }
      throw new Error(
        `You should not be trying to access this.${key} directly as it won't work correctly in lazy-builds. Instead, ${customErrorMessages[key] ?? `use this.el.${key}`}`
      );
    }
    if (typeof value.value === "function") {
      genericPrototype[key] = function functionWrapper(...args) {
        return validateUsage.call(this, ...args) ?? value.value.call(this, ...args);
      };
    } else if (typeof value.get === "function") {
      Object.defineProperty(genericPrototype, key, {
        get() {
          validateUsage.call(this);
          return value.get.call(this);
        },
        set: typeof value.set === "function" ? function setWrapper(setValue) {
          validateUsage.call(this);
          value.set.call(this, setValue);
        } : void 0
      });
    } else if (key === key.toUpperCase() && typeof value.value === "number") {
      return;
    } else {
      throw new Error(`Unexpected value type for ${key}: ${value}`);
    }
  });
}
const attachToAncestor = (child) => {
  let ancestor = child;
  while (ancestor = ancestor.parentNode ?? ancestor.host) {
    if (ancestor?.constructor?.lumina) {
      const litParent = ancestor;
      if (!litParent.manager?.loadedCalled) {
        (litParent.J ?? litParent["_offspring"]).push(child);
      }
      return (litParent.I ?? litParent["_postLoad"]).promise;
    }
  }
  return false;
};
if (process.env.NODE_ENV !== "production") {
  const litGlobalThis = globalThis;
  litGlobalThis.litIssuedWarnings ??= /* @__PURE__ */ new Set();
  litGlobalThis.litIssuedWarnings.add("dev-mode");
  litGlobalThis.litIssuedWarnings.add(
    "Overriding ReactiveElement.createProperty() is deprecated. The override will not be called with standard decorators See https://lit.dev/msg/no-override-create-property for more information."
  );
  litGlobalThis.litIssuedWarnings.add(
    "Overriding ReactiveElement.getPropertyDescriptor() is deprecated. The override will not be called with standard decorators See https://lit.dev/msg/no-override-get-property-descriptor for more information."
  );
  if (isEsriInternalEnv()) {
    globalThis.calciteConfig ??= { version: " " };
  }
}
const noShadowRoot = {};
function emptyFunction() {
}
const devOnly$getLitElementTagNameAndRuntime = process.env.NODE_ENV !== "production" && isEsriInternalEnv() ? (componentClass) => ({
  tagName: componentClass.L,
  runtime: componentClass.K
}) : void 0;
const makeDefineCustomElements = (runtime, structure) => function defineCustomElements(windowOrOptions, options) {
  if (!globalThis.customElements) {
    return;
  }
  const resolvedOptions = options ?? windowOrOptions ?? {};
  const resourcesUrl = resolvedOptions.resourcesUrl;
  if (resourcesUrl) {
    runtime.setAssetPath(resourcesUrl);
  }
  for (const [tagName, [load, compactMeta = ""]] of Object.entries(structure)) {
    if (customElements.get(tagName)) {
      continue;
    }
    const [compactObservedProps, compactAsyncMethods, compactSyncMethods] = compactMeta.split(lazyMetaGroupJoiner);
    const observedProps = compactObservedProps ? compactObservedProps?.split(lazyMetaItemJoiner).map(parseCondensedProp) : void 0;
    const observedProperties = observedProps?.map(([property]) => property);
    const ProxyClass = class extends ProxyComponent {
      static {
        this.observedAttributes = observedProps?.map(([, attribute]) => attribute).filter((attribute) => attribute !== "");
      }
      static {
        this.C = observedProperties;
      }
      static {
        this.E = compactAsyncMethods ? compactAsyncMethods?.split(lazyMetaItemJoiner) : void 0;
      }
      static {
        this.D = compactSyncMethods?.split(lazyMetaItemJoiner);
      }
      static {
        this.L = tagName;
      }
      static {
        this.K = runtime;
      }
      constructor() {
        const isFirstInstanceOfType = !ProxyClass.B;
        if (isFirstInstanceOfType) {
          ProxyClass.B = load();
          ProxyClass.F();
        }
        super();
      }
    };
    customElements.define(tagName, ProxyClass);
    if (process.env.NODE_ENV !== "production") {
      globalThis.devOnly$ownTagNames?.add(tagName);
    }
  }
};
const defineProperty = Object.defineProperty;
const parseCondensedProp = (propAndAttribute) => {
  const name = propAndAttribute.split(lazyMetaSubItemJoiner);
  return name.length === 1 ? [name[0], camelToKebab(name[0])] : name;
};
const HtmlElement = globalThis.HTMLElement ?? emptyFunction;
class ProxyComponent extends HtmlElement {
  constructor() {
    super();
    this.#store = {};
    this.#pendingAttributes = [];
    this.I = new Deferred();
    this.H = new Deferred();
    this.J = [];
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      this.devOnly$hmrSetProps = /* @__PURE__ */ new Set();
      this.devOnly$hmrSetAttributes = /* @__PURE__ */ new Set();
      globalThis.devOnly$createdElements ??= [];
      globalThis.devOnly$createdElements.push(new WeakRef(this));
      this.devOnly$InitializeComponent = this.#initializeComponent.bind(this);
      this.devOnly$hmrResetStore = (newStore) => {
        this.#store = newStore;
      };
    }
    const that = this;
    const ProxyClass = that.constructor;
    that["_offspring"] = that.J;
    that["_postLoad"] = that.I;
    ProxyClass.C?.forEach((propName) => {
      if (Object.hasOwn(that, propName)) {
        that.#store[propName] = that[propName];
        delete that[propName];
      }
    });
    if (ProxyClass.A) {
      that.#initializeComponent({ a: ProxyClass.A });
    } else {
      void ProxyClass.B.then(async (module) => {
        await ProxyClass.K.p;
        that.#initializeComponent(
          /**
           * "$$" is our top-level await polyfill due to broken top-level await
           * support in Safari. Only applies in CDN build.
           * See https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/3933
           * and https://bugs.webkit.org/show_bug.cgi?id=242740
           */
          await (module.default?.then(
            (module2) => typeof module2 === "function" ? { a: module2 } : module2
          ) ?? module)
        );
      }).catch((error) => {
        that.H.reject(error);
        setTimeout(() => {
          throw error;
        });
      });
    }
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      ProxyClass.devOnly$hmrInstances ??= [];
      ProxyClass.devOnly$hmrInstances.push(new WeakRef(this));
    }
  }
  static {
    this.lumina = true;
  }
  static F() {
    for (const propName of this.C ?? []) {
      defineProperty(this.prototype, propName, {
        configurable: true,
        enumerable: true,
        get() {
          return this.#store[propName];
        },
        set(value) {
          this.#store[propName] = value;
          if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
            this.devOnly$hmrSetProps.add(propName);
          }
        }
      });
    }
    for (const methodName of this.E ?? []) {
      defineProperty(this.prototype, methodName, {
        async value(...args) {
          if (!this.#litElement) {
            await this.H.promise;
          }
          const genericLitElement = this.#litElement;
          return await genericLitElement[methodName](...args);
        },
        configurable: true
      });
    }
    for (const methodName of this.D ?? []) {
      defineProperty(this.prototype, methodName, {
        value(...args) {
          if (process.env.NODE_ENV !== "production" && !this.#litElement) {
            const ProxyClass = this.constructor;
            throw new Error(
              `Tried to call method ${methodName}() on <${ProxyClass.L}> component before it's fully loaded. Please do 'await component.componentOnReady();' before calling this method.`
            );
          }
          const genericLitElement = this.#litElement;
          return genericLitElement[methodName](...args);
        },
        configurable: true
      });
    }
  }
  #litElement;
  #store;
  #pendingAttributes;
  get manager() {
    return this.#litElement?.manager;
  }
  /*
   * This method must be statically present rather than added later, or else,
   * browsers won't call it. Same for connected and disconnected callbacks.
   */
  attributeChangedCallback(name, oldValue, newValue) {
    this.#litElement?.attributeChangedCallback(name, oldValue, newValue);
    if (!this.#litElement) {
      this.#pendingAttributes.push(name);
    }
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      const isReflecting = this.#litElement?.["__reflectingProperty"] === name;
      if (!isReflecting) {
        this.devOnly$hmrSetAttributes.add(name);
      }
    }
  }
  connectedCallback() {
    if (this.#litElement) {
      this.#litElement.connectedCallback?.();
    } else {
      queueMicrotask(() => this.G = attachToAncestor(this));
    }
  }
  disconnectedCallback() {
    this.#litElement?.disconnectedCallback?.();
  }
  /**
   * Create a promise that resolves once component is fully loaded
   */
  async componentOnReady() {
    await this.H.promise;
    return this;
  }
  #initializeComponent(module) {
    const ProxyClass = this.constructor;
    const tagName = ProxyClass.L;
    const store = this.#store;
    const LitConstructor = Object.values(module).find(
      (LitConstructor2) => LitConstructor2.L === tagName
    );
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && !LitConstructor) {
      throw new Error(
        `Unable to find the LitElement class for the "${tagName}" custom element in the lazy-loaded module`
      );
    }
    const lazyTagName = process.env.NODE_ENV !== "production" && isEsriInternalEnv() ? (ProxyClass.devOnly$hmrIndex ?? 0) === 0 ? `${tagName}--lazy` : `${tagName}--lazy-${ProxyClass.devOnly$hmrIndex}` : `${tagName}--lazy`;
    let parentClass = LitConstructor;
    while (parentClass && !Object.hasOwn(parentClass, "lumina")) {
      parentClass = Object.getPrototypeOf(parentClass);
    }
    patchLitElement(parentClass);
    const isFirstInitialization = !ProxyClass.A;
    if (isFirstInitialization) {
      ProxyClass.A = LitConstructor;
      customElements.define(lazyTagName, LitConstructor);
    }
    LitConstructor.N = this;
    const litElement = document.createElement(lazyTagName);
    LitConstructor.N = void 0;
    this.#litElement = litElement;
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      Object.defineProperty(this, "$component", { value: litElement, configurable: true, enumerable: false });
    }
    this.#store = litElement;
    this.#pendingAttributes.forEach(
      (name) => litElement.attributeChangedCallback(
        name,
        // Lit doesn't look at this value, thus even if attribute already exists, that's ok
        null,
        this.getAttribute(name)
      )
    );
    Object.entries(store).forEach(syncLitElement, litElement);
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      const litObserved = LitConstructor.observedAttributes ?? [];
      const lazyObserved = ProxyClass.observedAttributes ?? [];
      const missingFromLazy = litObserved.filter((attribute) => !lazyObserved.includes(attribute));
      const missingFromLit = lazyObserved.filter((attribute) => !litObserved.includes(attribute));
      if (missingFromLazy.length > 0) {
        console.warn(
          `The following attributes on <${ProxyClass.L}> are present on the Lit element, but are missing from the lazy proxy component: ${missingFromLazy.join(", ")}. This either indicates a bug in Lumina, or you are creating the attribute dynamically in a way that compiler cannot infer statically. For these attributes, lazy-loading version of your component won't work correctly, thus this must be resolved`
        );
      }
      if (missingFromLit.length > 0) {
        console.warn(
          `The following attributes on <${ProxyClass.L}> are defined on the lazy proxy component, but not on the actual Lit element: ${missingFromLit.join(", ")}. This either indicates a bug in Lumina, or you are creating the attribute dynamically in a way that compiler cannot infer statically. This is a non-critical issue, but does indicate that something is going wrong and should be fixed`
        );
      }
    }
    const isStillConnected = this.isConnected;
    if (isStillConnected || this.G) {
      litElement.connectedCallback?.();
      if (!isStillConnected) {
        litElement.disconnectedCallback();
      }
    }
  }
  /**
   * Implemented on the proxy for compatibility with Lit Context.
   */
  addController() {
  }
  /**
   * Implemented on the proxy for compatibility with Lit Context.
   */
  requestUpdate() {
    this.#litElement?.requestUpdate();
  }
}
function syncLitElement([key, value]) {
  this[key] = value;
}
const patchLitElement = (parentClass) => {
  const litElementPrototype = parentClass.prototype;
  const elementPrototype = Element.prototype;
  const alreadyPatched = Object.hasOwn(litElementPrototype, "isConnected");
  if (!alreadyPatched) {
    litElementPrototype.setAttribute = function(qualifiedName, value) {
      elementPrototype.setAttribute.call(this.el, qualifiedName, value);
    };
    litElementPrototype.removeAttribute = function(qualifiedName) {
      elementPrototype.removeAttribute.call(this.el, qualifiedName);
    };
    defineProperty(litElementPrototype, "isConnected", {
      get() {
        return Reflect.get(elementPrototype, "isConnected", this.el);
      }
    });
  }
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
    devOnlyDetectIncorrectLazyUsages(parentClass);
  }
};
export {
  ProxyComponent as P,
  attachToAncestor as a,
  devOnly$getLitElementTagNameAndRuntime as d,
  emptyFunction as e,
  makeDefineCustomElements as m,
  noShadowRoot as n
};
