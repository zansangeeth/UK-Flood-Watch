import { n as noShadowRoot, P as ProxyComponent } from "./lazyLoad-BlK67lvm.js";
import { camelToKebab } from "@arcgis/toolkit/string";
function handleHmrUpdate(newModules) {
  newModules.forEach((newModule) => {
    if (newModule === void 0) {
      return;
    }
    Object.values(newModule).forEach((exported) => {
      if (typeof exported !== "function" || typeof exported.L !== "string") {
        return;
      }
      const LitConstructor = exported;
      const ProxyClass = customElements.get(LitConstructor.L);
      if (ProxyClass === void 0) {
        throw new Error(`Failed to find custom element proxy for tag name: ${LitConstructor.L}`);
      }
      ProxyClass.A = void 0;
      ProxyClass.B = void 0;
      ProxyClass.devOnly$hmrIndex ??= 0;
      ProxyClass.devOnly$hmrIndex += 1;
      ProxyClass.F();
      ProxyClass.devOnly$hmrInstances?.forEach((instanceWeakRef) => {
        const instance = instanceWeakRef.deref();
        if (instance === void 0) {
          return;
        }
        if (instance.$component === void 0) {
          void ProxyClass.B.then(() => reInitialize(instance, newModule));
        } else {
          reInitialize(instance, newModule);
        }
      });
      return;
    });
  });
}
function reInitialize(instance, newModule) {
  const PreviousLitConstructor = instance.$component.constructor;
  const isShadowRoot = PreviousLitConstructor.shadowRootOptions !== noShadowRoot;
  if (!isShadowRoot) {
    const root = instance.getRootNode() ?? document;
    if ("adoptedStyleSheets" in root) {
      const rootStyles = Array.from(root.adoptedStyleSheets);
      PreviousLitConstructor.elementStyles.forEach((style) => {
        const styleSheet = "styleSheet" in style ? style.styleSheet : style;
        const index = rootStyles.lastIndexOf(styleSheet);
        if (index > -1) {
          rootStyles.splice(index, 1);
        }
      });
      root.adoptedStyleSheets = rootStyles;
    }
  }
  const properties = PreviousLitConstructor.elementProperties;
  const preservedProperties = Array.from(properties.entries()).filter(
    ([propertyName, descriptor]) => typeof propertyName === "string" && (instance.devOnly$hmrSetProps.has(propertyName) || typeof descriptor.attribute === "string" && instance.devOnly$hmrSetAttributes.has(descriptor.attribute))
  ).map(([key]) => [key, instance[key]]);
  instance.devOnly$hmrResetStore(Object.fromEntries(preservedProperties));
  if (instance.isConnected) {
    instance.$component.disconnectedCallback();
  }
  const renderRoot = instance.$component?.renderRoot;
  if (renderRoot) {
    renderRoot["_$litPart$"] = void 0;
    while (renderRoot.firstChild) {
      renderRoot.removeChild(renderRoot.firstChild);
    }
  }
  instance.devOnly$InitializeComponent(newModule);
}
function handleComponentMetaUpdate(meta) {
  const ProxyClass = customElements.get(meta.tagName);
  if (ProxyClass === void 0) {
    return;
  }
  const attributes = meta.properties.map(([property, attribute]) => attribute ?? camelToKebab(property)).filter(Boolean);
  const observedAttributes = initializeAttributeObserver();
  observedAttributes[meta.tagName] ??= {};
  observedAttributes[meta.tagName].original ??= new Set(ProxyClass.observedAttributes);
  const originallyObserved = observedAttributes[meta.tagName].original;
  observedAttributes[meta.tagName].manuallyObserved = new Set(
    /**
     * Never manually observe attributes that were in the original
     * observedAttributes as those would be observed by the browser
     */
    attributes.filter((attribute) => !originallyObserved.has(attribute))
  );
  ProxyClass.E = meta.asyncMethods;
  ProxyClass.D = meta.syncMethods;
  ProxyClass.C = meta.properties.map(([name]) => name);
  ProxyClass.observedAttributes = attributes;
}
function initializeAttributeObserver() {
  const observedAttributesSymbol = Symbol.for("@arcgis/lumina:observedAttributes");
  const globalThisWithObservedAttributes = globalThis;
  const alreadyHadObservers = observedAttributesSymbol in globalThisWithObservedAttributes;
  globalThisWithObservedAttributes[observedAttributesSymbol] ??= {};
  const observedAttributes = globalThisWithObservedAttributes[observedAttributesSymbol];
  if (!alreadyHadObservers) {
    const makeObserver = (original) => function observeAttributes(qualifiedName, ...rest) {
      const observed = observedAttributes[this.tagName.toLowerCase()]?.manuallyObserved;
      if (observed?.has(qualifiedName)) {
        const oldValue = this.getAttribute(qualifiedName);
        const returns = original.call(this, qualifiedName, ...rest);
        const newValue = this.getAttribute(qualifiedName);
        this.attributeChangedCallback(qualifiedName, oldValue, newValue);
        return returns;
      } else {
        return original.call(this, qualifiedName, ...rest);
      }
    };
    ProxyComponent.prototype.setAttribute = makeObserver(ProxyComponent.prototype.setAttribute);
    ProxyComponent.prototype.toggleAttribute = makeObserver(ProxyComponent.prototype.toggleAttribute);
    ProxyComponent.prototype.removeAttribute = makeObserver(ProxyComponent.prototype.removeAttribute);
  }
  return observedAttributes;
}
export {
  handleComponentMetaUpdate,
  handleHmrUpdate
};
