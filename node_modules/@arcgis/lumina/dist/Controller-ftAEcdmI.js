import { safeCall, isEsriInternalEnv, safeAsyncCall } from "@arcgis/toolkit/error";
import { r as retrieveComponent, d as retrieveParentControllers, b as setParentController, s as setAmbientComponent, u as use, k as useRef, l as useRefSync, c as controllerSymbol } from "./ControllerInternals-CWQrfEA8.js";
import { nothing } from "lit";
import { Deferred } from "@arcgis/toolkit/promise";
const trackPropertyKey = (object, onResolved, defaultValue) => {
  const keys = Object.keys(object);
  const keyCount = keys.length;
  if (keyTrackMap === void 0) {
    queueMicrotask(propertyTrackResolve);
  }
  keyTrackMap ??= /* @__PURE__ */ new Map();
  let pendingTrackers = keyTrackMap.get(object);
  if (pendingTrackers === void 0) {
    pendingTrackers = { callbacks: [], keyCount };
    keyTrackMap.set(object, pendingTrackers);
  }
  if (pendingTrackers.keyCount !== keyCount) {
    pendingTrackers.callbacks.forEach((resolve) => resolve(keys));
    pendingTrackers.callbacks = [];
    pendingTrackers.keyCount = keyCount;
  }
  pendingTrackers.callbacks.push((keys2) => {
    const callback = (key2) => safeCall(onResolved, null, key2);
    const key = keys2[keyCount];
    if (key === void 0) {
      callback(void 0);
    } else if (object[key] === defaultValue) {
      callback(key);
    } else {
      callback(void 0);
    }
  });
  return defaultValue;
};
let keyTrackMap = void 0;
const propertyTrackResolve = () => {
  keyTrackMap?.forEach(({ callbacks }, object) => {
    const keys = Object.keys(object);
    callbacks.forEach((commit) => commit(keys));
  });
  keyTrackMap = void 0;
};
const trackPropKey = (component, onResolved, defaultValue) => {
  const manager = component.manager;
  if (manager.V !== nothing && manager.V !== defaultValue) {
    manager.S(void 0, void 0);
  }
  if (manager.T.length === 0) {
    queueMicrotask(() => manager.S(void 0, void 0));
  }
  manager.V = defaultValue;
  manager.T.push((key, value) => safeCall(onResolved, void 0, defaultValue === value ? key : void 0));
  return defaultValue;
};
const trackKey = (hostsCandidates = [
  retrieveComponent(),
  ...retrieveParentControllers()
], onResolved, defaultValue) => {
  const candidateHosts = Array.isArray(hostsCandidates) ? hostsCandidates : [hostsCandidates];
  let leftToResolve = candidateHosts.length + 1;
  const resolved = (resolution) => {
    leftToResolve -= 1;
    if (resolution !== void 0) {
      leftToResolve = Math.min(leftToResolve, 0);
    }
    if (leftToResolve === 0) {
      onResolved(resolution);
    }
  };
  candidateHosts.forEach(
    (host) => trackPropertyKey(
      host,
      (key) => resolved(key === void 0 ? void 0 : { key, host, isReactive: false }),
      defaultValue
    )
  );
  for (const host of candidateHosts) {
    if ("manager" in host && host.manager.component === host) {
      trackPropKey(
        host,
        (key) => resolved(key === void 0 ? void 0 : { key, host, isReactive: true }),
        defaultValue
      );
      break;
    }
  }
  return defaultValue;
};
const createEventFactory = (eventName = "", options = {}, component = retrieveComponent()) => {
  const emitter = {
    emit: (payload) => {
      if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && !component.el.isConnected) {
        console.warn(`Trying to emit an ${eventName} event on a disconnected element ${component.el.localName}`);
      }
      if (eventName === "") {
        propertyTrackResolve();
        if (process.env.NODE_ENV !== "production" && isEsriInternalEnv() && eventName === "") {
          throw new Error("Unable to resolve event name from property name");
        }
      }
      const event = new CustomEvent(eventName, {
        detail: payload,
        cancelable: true,
        bubbles: true,
        composed: true,
        ...options
      });
      component.el.dispatchEvent(event);
      return event;
    }
  };
  if (eventName === "") {
    trackKey(
      void 0,
      process.env.NODE_ENV !== "production" && isEsriInternalEnv() ? (resolution) => {
        if (resolution === void 0) {
          throw new Error(`createEvent must be called in property default value only`);
        }
        eventName = resolution.key;
      } : (resolution) => eventName = resolution.key,
      emitter
    );
  }
  return emitter;
};
const createEvent = createEventFactory.bind(null, "");
var _a;
_a = controllerSymbol;
class Controller {
  constructor(component) {
    this.#hostConnected = [];
    this.#hostDisconnected = [];
    this.#hostLoad = [];
    this.#hostLoaded = [];
    this.#hostUpdate = [];
    this.#hostUpdated = [];
    this.#hostDestroy = [];
    this.#hostLifecycle = [];
    this.#lifecycleCleanups = [];
    this.#loadCalled = false;
    this.P = new Deferred();
    this.connectedCalled = false;
    this.loadedCalled = false;
    this[_a] = true;
    this.#exportWatchers = [];
    const that = this;
    const resolvedComponent = component ?? retrieveComponent(new.target.name);
    that.#component = resolvedComponent;
    that.ready = that.P.promise;
    that.#exports = makeProvisionalValue(that);
    if (process.env.NODE_ENV !== "production") {
      Object.defineProperty(this, "component", {
        writable: false,
        enumerable: false,
        configurable: true,
        value: resolvedComponent
      });
      if ("hostDestroy" in this) {
        that.#component.manager.devOnly$ensureHasDestroy?.();
      }
    } else {
      that.component = resolvedComponent;
    }
    that.#component.addController(that);
    const manager = that.#component.manager;
    const isInControllerManager = manager === void 0;
    if (!isInControllerManager) {
      setParentController(that);
      queueMicrotask(() => that.catchUpLifecycle());
    }
  }
  #hostConnected;
  #hostDisconnected;
  #hostLoad;
  #hostLoaded;
  #hostUpdate;
  #hostUpdated;
  #hostDestroy;
  #hostLifecycle;
  #lifecycleCleanups;
  #loadCalled;
  #component;
  /**
   * If controller is being added dynamically, after the component
   * construction, then trigger connected and load right away
   */
  catchUpLifecycle() {
    const { manager } = this.#component;
    const connectedWillStillHappen = !manager.connectedCalled;
    if (!connectedWillStillHappen && !this.connectedCalled) {
      this.triggerConnected();
    }
    const loadWillStillHappen = !manager.#loadCalled;
    if (loadWillStillHappen) {
      return;
    }
    this.triggerLoad().then(
      () => (
        // Call loaded ourself, unless manager is going to do it
        manager.loadedCalled && this.triggerLoaded()
      )
    ).catch(console.error);
  }
  #exports;
  get exports() {
    return this.#exports;
  }
  /**
   * Set controller's exports property (for usage with proxyExports()) and mark
   * controller as ready (for usage in other controllers). Also, triggers
   * re-render of the component
   */
  set exports(exports) {
    const oldExports = this.#exports;
    if (oldExports !== exports) {
      this.#exports = exports;
      this.#exportWatchers.forEach(safeCall);
      if (this.connectedCalled && this.O !== false) {
        this.#component.requestUpdate(this.O, oldExports);
      }
    }
    this.P.resolve(exports);
  }
  setProvisionalExports(exports, proxy = true) {
    this.#exports = proxy ? makeProvisionalValue(exports) : exports;
    this.#exportWatchers.forEach(safeCall);
  }
  #exportWatchers;
  watchExports(callback) {
    const safeCallback = () => callback(this.#exports);
    this.#exportWatchers.push(safeCallback);
    return () => void this.#exportWatchers.splice(this.#exportWatchers.indexOf(safeCallback), 1);
  }
  /**
   * A flexible utility for making sure a controller is loaded before it's used,
   * regardless of how or where a controller was defined:
   *
   * @example
   * makeGenericController(async (component, controller) => {
   *   // Await some controller from the component:
   *   await controller.use(component.someController);
   *   // Initialize new controllers
   *   await controller.use(load(importCoreReactiveUtils));
   *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));
   *   await controller.use(someController(component));
   * });
   *
   * @remarks
   * If your controller is not async, and you are not creating it async, then
   * you are not required to use controller.use - you can use it directly.
   * Similarly, accessing controllers after componentWillLoad callback does not
   * require awaiting them as they are guaranteed to be loaded by then.
   */
  get use() {
    setAmbientComponent(this.#component);
    return use;
  }
  /**
   * Just like controller.use, but returns the controller itself, rather than it's
   * exports
   *
   * Use cases:
   * - You have a controller and you want to make sure it's loaded before you
   *   try to use it
   * - Your controller is not using exports, so you wish to access some props on
   *   it directly
   * - You have a controller exports only, and you want to retrieve the
   *   controller itself. This is useful if you wish to call .watchExports() or
   *   some other method on the controller
   */
  get useRef() {
    setAmbientComponent(this.#component);
    return useRef;
  }
  /**
   * Like useRef, but doesn't wait for the controller to get ready
   *
   * @private
   */
  get useRefSync() {
    setAmbientComponent(this.#component);
    return useRefSync;
  }
  controllerRemoved() {
    if (this.#component.el.isConnected) {
      this.triggerDisconnected();
    }
    this.triggerDestroy();
  }
  // Register a lifecycle callback
  onConnected(callback) {
    this.#hostConnected.push(callback);
  }
  onDisconnected(callback) {
    this.#hostDisconnected.push(callback);
  }
  onLoad(callback) {
    this.#hostLoad.push(callback);
  }
  onLoaded(callback) {
    this.#hostLoaded.push(callback);
  }
  onUpdate(callback) {
    this.#hostUpdate.push(callback);
  }
  onUpdated(callback) {
    this.#hostUpdated.push(callback);
  }
  onDestroy(callback) {
    if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
      this.#component.manager.devOnly$ensureHasDestroy?.();
    }
    this.#hostDestroy.push(callback);
  }
  onLifecycle(callback) {
    this.#hostLifecycle.push(callback);
    if (this.connectedCalled && this.#component.el.isConnected) {
      this.#callLifecycle(callback);
    }
  }
  // Call each lifecycle hook
  /** @private */
  triggerConnected() {
    const that = this;
    if (that.hostConnected) {
      safeCall(that.hostConnected, that);
    }
    that.#hostConnected.forEach(safeCall);
    that.triggerLifecycle();
    that.connectedCalled = true;
  }
  /** @private */
  triggerDisconnected() {
    const that = this;
    if (that.hostDisconnected) {
      safeCall(that.hostDisconnected, that);
    }
    that.#hostDisconnected.forEach(safeCall);
    that.#lifecycleCleanups.forEach(safeCall);
    that.#lifecycleCleanups = [];
  }
  /** @private */
  async triggerLoad() {
    if (this.#loadCalled) {
      return;
    }
    this.#loadCalled = true;
    const genericController = this;
    if (genericController.hostLoad) {
      await safeAsyncCall(genericController.hostLoad, genericController);
    }
    if (this.#hostLoad.length > 0) {
      await Promise.allSettled(this.#hostLoad.map(safeAsyncCall));
    }
    this.P.resolve(this.#exports);
  }
  /** @private */
  triggerLoaded() {
    if (this.loadedCalled) {
      return;
    }
    if (this.hostLoaded) {
      safeCall(this.hostLoaded, this);
    }
    this.#hostLoaded.forEach(safeCall);
    this.loadedCalled = true;
  }
  /** @private */
  triggerUpdate(changes) {
    if (this.hostUpdate) {
      safeCall(this.hostUpdate, this, changes);
    }
    this.#hostUpdate.forEach(callUpdate, changes);
  }
  /** @private */
  triggerUpdated(changes) {
    if (this.hostUpdated) {
      safeCall(this.hostUpdated, this, changes);
    }
    this.#hostUpdated.forEach(callUpdate, changes);
  }
  /** @private */
  triggerDestroy() {
    if (this.hostDestroy) {
      safeCall(this.hostDestroy, this);
    }
    this.#hostDestroy.forEach(safeCall);
  }
  /** @private */
  triggerLifecycle() {
    if (this.hostLifecycle) {
      this.#callLifecycle(() => this.hostLifecycle());
    }
    this.#hostLifecycle.forEach(this.#callLifecycle, this);
  }
  #callLifecycle(callback) {
    setAmbientComponent(this.#component);
    const cleanupRaw = safeCall(callback);
    const cleanup = Array.isArray(cleanupRaw) ? cleanupRaw : [cleanupRaw];
    cleanup.forEach((cleanup2) => {
      if (typeof cleanup2 === "function") {
        this.#lifecycleCleanups.push(cleanup2);
      } else if (typeof cleanup2 === "object" && typeof cleanup2.remove === "function") {
        this.#lifecycleCleanups.push(cleanup2.remove);
      }
    });
  }
}
function callUpdate(callback) {
  safeCall(callback, void 0, this);
}
const GenericController = Controller;
const makeProvisionalValue = (base) => {
  if (typeof base !== "object" && typeof base !== "function" || base === null) {
    return base;
  }
  const proxyDefinition = {
    get(target, prop, receiver) {
      if ((prop === "exports" || prop === "_exports") && prop in target && target[prop] === proxy) {
        return void 0;
      }
      if (prop in target || prop in Promise.prototype || typeof prop === "symbol") {
        return typeof target === "function" ? target[prop] : Reflect.get(target, prop, receiver);
      }
      if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
        if (process.env.NODE_ENV === "test" && (prop.startsWith("$$") || prop.startsWith("@@") || prop === "nodeType" || prop === "tagName" || prop === "toJSON" || prop === "hasAttribute")) {
          return;
        }
        console.error(
          `Trying to access "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`
        );
      }
      return void 0;
    }
  };
  if (process.env.NODE_ENV !== "production" && isEsriInternalEnv()) {
    proxyDefinition.set = (target, prop, newValue, receiver) => {
      console.error(`Trying to set "${prop.toString()}" on the controller before it's loaded. ${accessBeforeLoad}`);
      return Reflect.set(target, prop, newValue, receiver);
    };
  }
  const proxy = new Proxy(base, proxyDefinition);
  return proxy;
};
const accessBeforeLoad = process.env.NODE_ENV !== "production" && isEsriInternalEnv() ? [
  "This might be the case if you are trying to access an async controller in ",
  "connectedCallback(). Or, if you are using it inside of ",
  "componentWillLoad()/another controller without controller.use. Example correct ",
  "usage:\n",
  "makeController(async (component, controller)=>{ await controller.use(someOtherController); });"
].join("") : void 0;
export {
  Controller as C,
  GenericController as G,
  createEventFactory as a,
  trackPropertyKey as b,
  createEvent as c,
  trackPropKey as d,
  propertyTrackResolve as p,
  trackKey as t
};
