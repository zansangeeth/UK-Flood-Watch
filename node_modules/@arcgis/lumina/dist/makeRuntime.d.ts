import { CSSResult } from 'lit';
import { LitElement } from './LitElement';
import { AccessorObservableLike, ReactiveTrackingTarget } from './controllers/types';
/**
 * `@arcgis/lumina` package may be bundled once but used by multiple packages with
 * different configuration options. For that reason, the configuration options
 * cannot be a global object, but has to be an object that you pass around.
 */
export type Runtime = RuntimeOptions & {
    /**
     * Get the base path to where the package assets can be found.
     * By default, the package asset path is set to `https://js.arcgis.com/<simplified-package-name>/<released-verion>/`.
     * We are hosting our assets on a CDN (Content Delivery Network) to ensure fast and reliable access.
     * It is CORS-enabled, so you can load the assets from any domain.
     * Use "setAssetPath(path)" if the path needs to be customized.
     */
    readonly getAssetPath: (suffix: string) => string;
    /**
     * Used to manually set the base path where package assets (like localization
     * and icons) can be found.
     *
     * By default, the package asset path is set to `https://js.arcgis.com/<simplified-package-name>/<released-verion>/`.
     * For example, `https://js.arcgis.com/map-components/4.30/`.
     * We are hosting our assets on a CDN (Content Delivery Network) to ensure fast and reliable access.
     * It is CORS-enabled, so you can load the assets from any domain.
     * This is the recommended way to load the assets and avoid bundling them with your application.
     * It means that by default, you don't need to use "setAssetPath" since the path is already set.
     *
     * However, if you need to host the assets locally, you can use "setAssetPath" to set the base path.
     * If the script is used as "module", it's recommended to use "import.meta.url",
     * such as "setAssetPath(import.meta.url)". Other options include
     * "setAssetPath(document.currentScript.src)", or using a bundler's replace plugin to
     * dynamically set the path at build time, such as "setAssetPath(process.env.ASSET_PATH)".
     * But do note that this configuration depends on how your script is bundled, or lack of
     * bundling, and where your assets can be loaded from. Additionally custom bundling
     * will have to ensure the static assets are copied to its build directory.
     */
    readonly setAssetPath: (path: URL | string) => void;
    /**
     * The customElement decorator. Unlike default Lit's decorator this one
     * provides runtime instance to the LitElement class
     *
     * @remarks
     * You do not need to call this decorator in your component.
     * It will be added automatically at build time.
     *
     * Instead, make sure your component file has the following:
     * ```ts
     * declare global {
     *  interface DeclareElements {
     *      "arcgis-your-component": ArcgisYourComponent;
     *   }
     * }
     * ```
     */
    readonly customElement: (tagName: string, component: typeof LitElement) => void;
    /**
     * Short for trackAccess. A reference to JS API's accessor's trackAccess
     * function to mark an observable as accessed.
     * Used in the getter for each property in component packages that use @arcgis/core.
     *
     * @private
     */
    t?: (observable: AccessorObservableLike) => void;
    /**
     * Short for createObservable. A callback to create a JS API Accessor's
     * SimpleObservable. Such observable will be created for each property in
     * component packages that use @arcgis/core to bring reactiveUtils integration.
     * @private
     */
    o?: () => AccessorObservableLike;
    /**
     * In CDN build, we can only import @arcgis/core async, so the lazy loader will need
     * to await this promise before beginning hydration so that the reactiveUtils
     * integration modules had time to load.
     *
     * @private
     */
    p?: Promise<void>;
    /**
     * A possible reference to JS API's createTrackingTarget() function to create
     * an observer that will keep track of what properties were accessed during
     * render().
     *
     * @private
     */
    c?: (callback: () => void) => ReactiveTrackingTarget;
    /**
     * A possible reference to JS API's runTracked() function to run update() with
     * property accesses tracking enabled.
     *
     * @private
     */
    r?: (target: ReactiveTrackingTarget, callback: () => void) => void;
};
export type RuntimeOptions = {
    /**
     * The default asset path to use in NPM and CDN builds.
     *
     * This option will be set by Lumina compiler based on the value of the
     * `assets.defaultPath` option in the `useLumina()` plugin.
     */
    readonly defaultAssetPath: string;
    /**
     * The attribute that indicates a component has rendered its content.
     * Usually this attribute is added after your component's `loaded()` lifecycle
     * happened. However, during SSR, "hydrated" is added right away on the
     * server.
     *
     * Until element has this attribute, it will have `visibility:hidden` style
     * applied.
     *
     * This option will be set by the Lumina compiler based on the value of
     * the `css.hydratedAttribute` option in the `useLumina()` plugin.
     */
    readonly hydratedAttribute: string;
    /**
     * Styles that you wish to make available in each component's shadow root, but
     * to not apply outside the shadow root
     *
     * This option will be set by Lumina compiler based on the value of the
     * `css.commonStylesPath` option in the `useLumina()` plugin.
     */
    readonly commonStyles?: CSSResult;
};
/**
 * The options object will be provided by Lumina compiler at build-time.
 * It should not be specified in the source code.
 */
export declare const makeRuntime: (options?: RuntimeOptions) => Runtime;
/**
 * Exposing the reference to the runtime globally when in tests or development.
 * This is primarily for usage by dynamically created components in tests
 *
 * @private
 */
export type DevOnlyGlobalRuntime = typeof globalThis & {
    devOnly$luminaRuntime?: Runtime;
};
/**
 * Called from the component constructor when in development or test mode.
 * Used primarily by mount to get a reference to the rendered component.
 *
 * @private
 */
export type DevOnlyGlobalComponentRefCallback = typeof globalThis & {
    devOnly$luminaComponentRefCallback?: (component: LitElement) => void;
};
