/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{fromJSON as e}from"../../geometry/support/jsonUtils.js";function t(e,t){let r;return{loaded:!1,load:()=>r??=t().then(t=>{o[e]={loaded:!0,execute:t}})}}function r(e){return null==e?null:e.toJSON()}const o={disjoint:t("disjoint",()=>import("../../geometry/operators/json/disjointOperator.js").then(e=>e.execute)),intersects:t("intersects",()=>import("../../geometry/operators/json/intersectsOperator.js").then(e=>e.execute)),touches:t("touches",()=>import("../../geometry/operators/json/touchesOperator.js").then(e=>e.execute)),crosses:t("crosses",()=>import("../../geometry/operators/json/crossesOperator.js").then(e=>e.execute)),within:t("within",()=>import("../../geometry/operators/json/withinOperator.js").then(e=>e.execute)),contains:t("contains",()=>import("../../geometry/operators/json/containsOperator.js").then(e=>e.execute)),overlaps:t("overlaps",()=>import("../../geometry/operators/json/overlapsOperator.js").then(e=>e.execute)),equals:t("equals",async()=>{const t=await import("../../geometry/operators/equalsOperator.js");return(r,o)=>t.execute(e(r),e(o))}),relate:t("relate",async()=>{const t=await import("../../geometry/operators/relateOperator.js");return(r,o,n)=>t.execute(e(r),e(o),n)}),intersection:t("intersection",()=>import("../../geometry/operators/json/intersectionOperator.js").then(e=>e.execute)),union:t("union",()=>import("../../geometry/operators/json/unionOperator.js").then(e=>e.executeMany)),difference:t("difference",async()=>{const t=await import("../../geometry/operators/differenceOperator.js");return(o,n)=>r(t.execute(e(o),e(n)))}),symmetricDifference:t("symmetricDifference",async()=>{const t=await import("../../geometry/operators/symmetricDifferenceOperator.js");return(o,n)=>r(t.execute(e(o),e(n)))}),clip:t("clip",async()=>{const t=await import("../../geometry/operators/clipOperator.js");return(o,n)=>r(t.execute(e(o),e(n)))}),cut:t("cut",async()=>{const t=await import("../../geometry/operators/cutOperator.js");return(o,n)=>t.execute(e(o),e(n)).map(e=>r(e))}),area:t("area",async()=>{const t=await import("../../geometry/operators/areaOperator.js"),{convertFromSpatialReferenceUnit:r,toAreaUnit:o}=await import("./unitConversion.js");return(n,a)=>{const s=t.execute(e(n));return r(n.spatialReference,o(a),s)}}),geodeticArea:t("geodeticArea",async()=>{const t=await import("../../geometry/operators/geodeticAreaOperator.js"),{convert:r,squareMeters:o,toAreaUnit:n}=await import("./unitConversion.js");return await t.load(),(a,s,i)=>{const c=t.execute(e(a),{curveType:i});return r(o,n(s),c)}}),length:t("length",async()=>{const e=await import("../../geometry/operators/json/lengthOperator.js"),{convertFromSpatialReferenceUnit:t,toLengthUnit:r}=await import("./unitConversion.js");return(o,n)=>{const a=e.execute(o);return t(o.spatialReference,r(n),a)}}),geodeticLength:t("geodeticLength",async()=>{const t=await import("../../geometry/operators/geodeticLengthOperator.js"),{convert:r,meters:o,toLengthUnit:n}=await import("./unitConversion.js");return await t.load(),(a,s,i)=>{const c=t.execute(e(a),{curveType:i});return r(o,n(s),c)}}),distance:t("distance",async()=>{const t=await import("../../geometry/operators/distanceOperator.js"),{convertFromSpatialReferenceUnit:r,toLengthUnit:o}=await import("./unitConversion.js");return(n,a,s)=>{const i=t.execute(e(n),e(a));return r(n.spatialReference,o(s),i)}}),densify:t("densify",async()=>{const t=await import("../../geometry/operators/densifyOperator.js"),{convertToSpatialReferenceUnit:o,toLengthUnit:n}=await import("./unitConversion.js");return(a,s,i)=>(s=o(n(i),a.spatialReference,s),r(t.execute(e(a),s)))}),geodeticDensify:t("geodeticDensify",async()=>{const t=await import("../../geometry/operators/geodeticDensifyOperator.js"),{convert:o,meters:n,toLengthUnit:a}=await import("./unitConversion.js");return await t.load(),(s,i,c,p)=>(i=o(a(c),n,i),r(t.execute(e(s),i,{curveType:p})))}),generalize:t("generalize",async()=>{const t=await import("../../geometry/operators/generalizeOperator.js"),{convertToSpatialReferenceUnit:o,toLengthUnit:n}=await import("./unitConversion.js");return(a,s,i,c)=>(s=o(n(i),a.spatialReference,s),r(t.execute(e(a),s,c)))}),buffer:t("buffer",async()=>{const e=await import("../../geometry/operators/json/bufferOperator.js"),{convertToSpatialReferenceUnit:t,toLengthUnit:r}=await import("./unitConversion.js");return(o,n,a)=>(n=t(r(a),o.spatialReference,n),e.execute(o,n))}),geodesicBuffer:t("geodesicBuffer",async()=>{const e=await import("../../geometry/operators/json/geodesicBufferOperator.js"),{convert:t,meters:r,toLengthUnit:o}=await import("./unitConversion.js");return await e.load(),(n,a,s,i)=>(a=t(o(s),r,a),e.execute(n,a,{curveType:i}))}),offset:t("offset",async()=>{const{executeOffsetJson:e}=await import("./offset.js");return e}),rotate:t("rotate",async()=>{const t=await import("../../geometry/operators/affineTransformOperator.js"),{default:o}=await import("../../geometry/operators/support/Transformation.js");return(n,a,s,i)=>{const c=(new o).rotate(a,s,i);return r(t.execute(e(n),c))}}),centroid:t("centroid",async()=>{const t=await import("../../geometry/operators/centroidOperator.js");return o=>r(t.execute(e(o)))}),labelPoint:t("labelPoint",async()=>{const t=await import("../../geometry/operators/labelPointOperator.js");return o=>r(t.execute(e(o)))}),simplify:t("simplify",()=>import("../../geometry/operators/json/simplifyOperator.js").then(e=>e.execute)),isSelfIntersecting:t("isSelfIntersecting",async()=>{const{NonSimpleResult:t}=await import("../../chunks/OperatorDefinitions.js"),r=await import("../../geometry/operators/simplifyOGCOperator.js"),o=new Set([5,6,7,10,11,12]);return n=>{const a=new t;return!r.isSimple(e(n),a)&&o.has(a.m_reason)}}),isSimple:t("isSimple",()=>import("../../geometry/operators/json/simplifyOperator.js").then(e=>e.isSimple)),convexHull:t("convexHull",()=>import("../../geometry/operators/json/convexHullOperator.js").then(e=>e.execute)),getNearestCoordinate:t("getNearestCoordinate",async()=>{const t=await import("../../geometry/operators/proximityOperator.js");return(o,n,a)=>{const s=t.getNearestCoordinate(e(o),e(n),a);return{...s,coordinate:r(s.coordinate)}}}),getNearestVertex:t("getNearestVertex",async()=>{const t=await import("../../geometry/operators/proximityOperator.js");return(o,n)=>{const a=t.getNearestVertex(e(o),e(n));return{...a,coordinate:r(a.coordinate)}}})};function n(e,t){const r=o[e];return r.loaded?r.execute.apply(void 0,t):r.load().then(()=>n(e,t))}export{n as invokeGeometryOp};
