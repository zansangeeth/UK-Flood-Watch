/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{parse as t}from"../../layers/support/arcgisLayerUrl.js";import{fetchFeatureService as r}from"../../layers/support/fetchService.js";import{LayerLoadContext as a}from"../../layers/support/LayerLoadContext.js";import{applyPreferredHostToPortalItem as o,getPreferredHost as n,isPreferredUrlApplicable as s}from"../../layers/support/layerUtils.js";import l from"../Portal.js";import{createForItemRead as i}from"./jsonContext.js";import{instanceTypeToLayerTypes as p,getSublayersByLayerType as u,getFirstLayerOrTable as c,preprocessFSItemData as y,populateSceneServiceItemData as d,getNumLayersAndTables as f,layerTypeToLayerModuleType as m,createSublayerData as w}from"./loadUtils.js";import{hasTypeKeyword as h}from"./portalItemUtils.js";import{loadStyleRenderer as g}from"../../renderers/support/styleUtils.js";import{fetchArcGISServiceJSON as I}from"../../support/requestPresets.js";async function b(e,t){const r=e.instance.portalItem;if(r?.id)return await r.load(t),v(e),e.validateItem&&e.validateItem(r),L(e,t)}function v(t){const r=t.instance.portalItem;if(!r?.type||!t.supportedTypes.includes(r.type))throw new e("portal:invalid-layer-item-type","Invalid layer item type '${type}', expected '${expectedType}'",{type:r?.type,expectedType:t.supportedTypes.join(", ")})}async function L(e,t){const r=e.instance,o=r.portalItem;if(!o)return;let{url:n}=o;const{title:s}=o,l=i(o,"portal-item");if("group"===r.type)return S(r,l,e);n&&"media"!==r.type&&r.read({url:n},l);const p=new a,{data:u,preferredHost:c}=await x(e,p,t);return n=o.url,"isUrlHostModified"in r&&(c?r.applyPreferredHost({preferredHost:c}):r.applyHostFromPortalItem()),u&&r.read(u,l),r.resourceReferences={portalItem:o,paths:l.readResourcePaths??[]},"subtype-group"!==r.type&&r.read({title:s},l),g(r,l)}async function S(t,r,a){const o=t.portalItem;if(!t.sourceIsPortalItem)return;const{title:n,type:s}=o;if("Group Layer"===s){if(!h(o,"Map"))throw new e("portal:invalid-layer-item-typekeyword","'Group Layer' item without 'Map' type keyword is not supported");return T(t,a)}return t.read({title:n},r),j(t,a)}async function T(t,r){const a=t.portalItem,o=await a.fetchData("json");if(!o)return;if(!r.populateGroupLayer)throw new e("portal:missing-populate-group-layer","Missing populate group layer");const n=i(a,"web-map");t.read(o,n),await r.populateGroupLayer(t,o,{context:n}),t.resourceReferences={portalItem:a,paths:n.readResourcePaths??[]}}async function j(t,r){let n;const{portalItem:s}=t;if(!s)return;const l=s.type,i=r.layerModuleTypeMap;if(!i)throw new e("portal:missing-layer-module-type-map","Layer module type map is required to construct sub layers");switch(l){case"Feature Service":case"Feature Collection":n=i.FeatureLayer;break;case"Stream Service":n=i.StreamLayer;break;case"Scene Service":n=i.SceneLayer;break;case"Video Service":n=i.VideoLayer;break;default:throw new e("portal:unsupported-item-type-as-group",`The item type '${l}' is not supported as a 'GroupLayer'`)}const p="Video Service"===l,u=new a;let[m,{data:w}]=await Promise.all([n(),p?{data:null}:x(r,u)]),h=()=>m;if(p)return F(t,h,i);if("Feature Service"===l){const e=c(w)?.customParameters;w=s.url?(await y(w,s.url,u)).data:{},h=await E(w,i)||h;const{provider:r,preferredHost:a}=await U(s.url,{customParameters:e,loadContext:u});return o(s,a),await H(t,h,h,w,i,r)}return"Scene Service"===l&&s.url&&(w=await d(s,w,u)),f(w)>0?await H(t,h,null,w,i):await P(t,h,i)}async function P(e,t,r){const{portalItem:a}=e;if(!a?.url)return;const o=await I(a.url);o&&H(e,t,null,{layers:o.layers?.map(w),tables:o.tables?.map(w)},r)}async function F(e,t,r){const{portalItem:a}=e;if(!a?.url)return;const o=await I(a.url);o&&H(e,t,null,{layers:o.layers?.map(({id:e,name:t})=>({id:e,name:t}))},r)}async function H(e,t,r,a,o,n){let s=a.layers||[];const l=a.tables||[];if("Feature Collection"===e.portalItem?.type?(s.forEach((e,t)=>{e.id=t,"Table"===e?.layerDefinition?.type&&l.push(e)}),s=s.filter(e=>"Table"!==e?.layerDefinition?.type)):(s.reverse(),l.reverse()),s.forEach(r=>{const o=n?.(r);if(o||!n){const n=M(e,t(r),a,r,o);e.add(n)}}),l.length){const t=r?null:await o.FeatureLayer();l.forEach(o=>{const s=n?.(o);if(s||!n){const n=M(e,r?r(o):t,a,o,s);e.tables.add(n)}})}}function M(e,t,r,a,o){const n=e.portalItem,s={portalItem:n.clone(),layerId:a.id};null!=a.url&&(s.url=a.url);const i=new t(s);if("sourceJSON"in i&&(i.sourceJSON=o),"subtype-group"!==i.type&&"catalog"!==i.type&&(i.sublayerTitleMode="service-name"),"Feature Collection"===n.type){const e={origin:"portal-item",portal:n.portal||l.getDefault()};i.read(a,e);const t=r.showLegend;null!=t&&i.read({showLegend:t},e)}return i}async function x(e,t,r){if(!1===e.supportsData)return{data:void 0};const a=e.instance,n=a.portalItem;if(!n)return{data:void 0};let s=null;try{s=await n.fetchData("json",r)}catch(l){}if(C(a)){let e=null;const{count:r,preferredHost:l}=await G(n,s,t);if(o(n,l),(s?.layers||s?.tables)&&r>0){if(null==a.layerId){const e=p(a.type),t=e?.length?u(s,e)[0]:c(s);t&&(a.layerId=t.id)}e=k(s,a),"OrientedImageryLayer"===e?.layerType&&"oriented-imagery"===a.type&&a.supportedSourceTypes.add("Feature Layer"),e&&null!=s.showLegend&&(e.showLegend=s.showLegend)}return r>1&&"sublayerTitleMode"in a&&"service-name"!==a.sublayerTitleMode&&(a.sublayerTitleMode="item-title-and-service-name"),{data:e,preferredHost:l}}return{data:s}}async function G(e,r,a){if(r?.layers&&r?.tables)return{count:f(r)};const o=t(e.url);if(!o)return{count:1};const l=o.url.path,i=await a.fetchServiceMetadata(l,{customParameters:c(r)?.customParameters}).catch(()=>null);return{count:(r?.layers?.length??i?.layers?.length??0)+(r?.tables?.length??i?.tables?.length??0),preferredHost:s(e)?n():null}}function k(e,t){const{layerId:r}=t,a=e.layers?.find(e=>e.id===r)||e.tables?.find(e=>e.id===r);return a&&D(a,t)?a:null}function C(e){return"stream"!==e.type&&"layerId"in e}function D(e,t){const r="layerType"in e&&e.layerType,{type:a}=t;return!("feature"===a&&r&&"ArcGISFeatureLayer"!==e.layerType||"catalog"===a&&!r||"oriented-imagery"===a&&!r||"subtype-group"===a&&!r)}async function U(e,t){const{layersJSON:a,preferredHost:o}=await r(e,t);if(!a)return{provider:null,preferredHost:o};const n=[...a.layers,...a.tables];return{provider:e=>n.find(t=>t.id===e.id),preferredHost:o}}async function E(e,t){const{layers:r,tables:a}=e,o=[...r??[],...a??[]];if(!o.length)return;const n=new Set,s=[];for(const{layerType:p}of o){const e=p??"ArcGISFeatureLayer";if(n.has(e))continue;n.add(e);const r=t[m(e)];s.push(r())}const l=await Promise.all(s),i=new Map;return Array.from(n).forEach((e,t)=>{i.set(e,l[t])}),({layerType:e})=>{const t=e??"ArcGISFeatureLayer";return i.get(t)}}export{b as load};
