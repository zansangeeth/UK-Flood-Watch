/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../../../core/Accessor.js";import{isSome as o}from"../../../../../core/arrayUtils.js";import{abortMaybe as i}from"../../../../../core/maybe.js";import{debounce as n}from"../../../../../core/promiseUtils.js";import{property as a}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/Logger.js";import{subclass as r}from"../../../../../core/accessorSupport/decorators/subclass.js";import{UpdatingHandles as s}from"../../../../../core/support/UpdatingHandles.js";import{WorkerHandle as d}from"../../../../../core/workers/WorkerHandle.js";import{featureGeometryTypeKebabDictionary as l}from"../../../../../geometry/support/typeUtils.js";import{makeDehydratedPoint as p}from"../../../../../layers/graphics/dehydratedPoint.js";let u=class extends t{get updating(){return this._updatingHandles.updating||this._workerHandleUpdating}constructor(e){super(e),this._updatingHandles=new s,this._suspendController=null,this.schedule=null,this.hasZ=!1,this.elevationAlignPointsInFeatures=async e=>{const t=[];for(const{points:o}of e.pointsInFeatures)for(const{z:e}of o)t.push(e);return{elevations:t,drapedObjectIds:new Set,failedObjectIds:new Set}},this.queryForSymbologySnapping=async()=>({candidates:[],sourceCandidateIndices:[]}),this.availability=0,this._workerHandleUpdating=!0,this.updateOutFields=n(async(e,t)=>{await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateOutFields",[...e],t)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))})}destroy(){this._suspendController=i(this._suspendController),this._workerHandle.destroy(),this._updatingHandles.destroy()}initialize(){this._workerHandle=new g(this.schedule,{alignElevation:async(e,{signal:t})=>({result:await this.elevationAlignPointsInFeatures(e.query,t)}),getSymbologyCandidates:async(e,{signal:t})=>({result:await this.queryForSymbologySnapping(e,t)})}),this.addHandles([this._workerHandle.on("notify-updating",({updating:e})=>this._workerHandleUpdating=e),this._workerHandle.on("notify-availability",({availability:e})=>this._set("availability",e))])}async setup(e,t){const o=c(e.layer);if(null==o)return;const i={configuration:h(e.configuration),serviceInfo:o,spatialReference:e.spatialReference.toJSON(),hasZ:this.hasZ,elevationInfo:e.layer.elevationInfo?.toJSON()};await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setup",i,t)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async configure(e,t){const o=h(e);await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("configure",o,t)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async refresh(e){await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("refresh",{},e)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},e))}async fetchCandidates(e,t){const{point:o,filter:i,coordinateHelper:n}=e,a={...e,point:p(o[0],o[1],o[2],n.spatialReference.toJSON()),filter:i?.toJSON()};return this._workerHandle.invoke(a,t)}async updateTiles(e,t){const o={tiles:e.tiles.map(e=>e.toJSON()),tileInfo:null!=e.tileInfo?e.tileInfo.toJSON():null,tileSize:e.tileSize};await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("updateTiles",o,t)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},t))}async handleEdits({historicMoment:e,addedFeatures:t,deletedFeatures:i,updatedFeatures:n},a){const r={historicMoment:e,addedFeatures:t?.map(({objectId:e})=>e).filter(o)??[],deletedFeatures:i?.map(({objectId:e,globalId:t})=>({objectId:e,globalId:t}))??[],updatedFeatures:n?.map(({objectId:e})=>e).filter(o)??[]};await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("handleEdits",r,a)),this._updatingHandles.addPromise(this._workerHandle.invokeMethod("whenNotUpdating",{},a))}async setHistoricMoment(e,t){await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setHistoricMoment",{moment:e},t))}getDebugInfo(e){return this._workerHandle.invokeMethod("getDebugInfo",{},e)}async notifyElevationSourceChange(){await this._workerHandle.invokeMethod("notifyElevationSourceChange",{})}async notifySymbologyChange(){await this._workerHandle.invokeMethod("notifySymbologyChange",{})}async setSymbologySnappingSupported(e){await this._workerHandle.invokeMethod("setSymbologySnappingSupported",e)}async setSuspended(e){this._suspendController?.abort(),this._suspendController=new AbortController,await this._updatingHandles.addPromise(this._workerHandle.invokeMethod("setSuspended",e,this._suspendController.signal))}};function h(e){return{filter:null!=e.filter?e.filter.toJSON():null,customParameters:e.customParameters,viewType:e.viewType}}function c(e){return"multipatch"===e.geometryType||"mesh"===e.geometryType?null:{url:e.parsedUrl?.path??"",fieldsIndex:e.fieldsIndex.toJSON(),geometryType:l.toJSON(e.geometryType),capabilities:e.capabilities,objectIdField:e.objectIdField,globalIdField:e.globalIdField,spatialReference:e.spatialReference.toJSON(),timeInfo:e.timeInfo?.toJSON()}}e([a({constructOnly:!0})],u.prototype,"schedule",void 0),e([a({constructOnly:!0})],u.prototype,"hasZ",void 0),e([a({constructOnly:!0})],u.prototype,"elevationAlignPointsInFeatures",void 0),e([a({constructOnly:!0})],u.prototype,"queryForSymbologySnapping",void 0),e([a({readOnly:!0})],u.prototype,"updating",null),e([a({readOnly:!0})],u.prototype,"availability",void 0),e([a()],u.prototype,"_workerHandleUpdating",void 0),u=e([r("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")],u);class g extends d{constructor(e,t){super("FeatureServiceSnappingSourceWorker","fetchCandidates",{},e,{strategy:"dedicated",client:t})}}export{u as FeatureServiceSnappingSourceWorkerHandle};
