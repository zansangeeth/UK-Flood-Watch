/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{create as a}from"../../../../../../core/libs/gl-matrix-2/factories/vec3f64.js";import{Float4BindUniform as e}from"../../shaderModules/Float4BindUniform.js";import{glsl as o}from"../../shaderModules/glsl.js";import{IntegerBindUniform as s}from"../../shaderModules/IntegerBindUniform.js";import{Matrix4sDrawUniform as i}from"../../shaderModules/Matrix4sDrawUniform.js";import{Matrix4sPassUniform as t}from"../../shaderModules/Matrix4sPassUniform.js";import{NoParameters as r}from"../../../../../webgl/NoParameters.js";class d extends r{constructor(){super(...arguments),this.origin=a()}}function c(a){a.fragment.uniforms.add(new t("shadowMapMatrix",(a,e)=>e.shadowMap.getShadowMapMatrices(a.origin),4)),l(a)}function n(a){a.fragment.uniforms.add(new i("shadowMapMatrix",(a,e)=>e.shadowMap.getShadowMapMatrices(a.origin),4)),l(a)}function l(a){const{fragment:i}=a;i.uniforms.add(new e("cascadeDistances",a=>a.shadowMap.cascadeDistances),new s("numCascades",a=>a.shadowMap.numCascades)),i.code.add(o`const vec3 invalidShadowmapUVZ = vec3(0.0, 0.0, -1.0);
vec3 lightSpacePosition(vec3 _vpos, mat4 mat) {
vec4 lv = mat * vec4(_vpos, 1.0);
lv.xy /= lv.w;
return 0.5 * lv.xyz + vec3(0.5);
}
vec2 cascadeCoordinates(int i, ivec2 textureSize, vec3 lvpos) {
float xScale = float(textureSize.y) / float(textureSize.x);
return vec2((float(i) + lvpos.x) * xScale, lvpos.y);
}
vec3 calculateUVZShadow(in vec3 _worldPos, in float _linearDepth, in ivec2 shadowMapSize) {
int i = _linearDepth < cascadeDistances[1] ? 0 : _linearDepth < cascadeDistances[2] ? 1 : _linearDepth < cascadeDistances[3] ? 2 : 3;
if (i >= numCascades) {
return invalidShadowmapUVZ;
}
mat4 shadowMatrix = i == 0 ? shadowMapMatrix[0] : i == 1 ? shadowMapMatrix[1] : i == 2 ? shadowMapMatrix[2] : shadowMapMatrix[3];
vec3 lvpos = lightSpacePosition(_worldPos, shadowMatrix);
if (lvpos.z >= 1.0 || lvpos.x < 0.0 || lvpos.x > 1.0 || lvpos.y < 0.0 || lvpos.y > 1.0) {
return invalidShadowmapUVZ;
}
vec2 uvShadow = cascadeCoordinates(i, shadowMapSize, lvpos);
return vec3(uvShadow, lvpos.z);
}`)}export{d as ReadShadowMapOrigin,n as calculateUVZShadowDraw,c as calculateUVZShadowPass};
