/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import e from"../../../../../core/Accessor.js";import{deg2rad as o,rad2deg as i}from"../../../../../core/mathUtils.js";import{when as n,sync as r}from"../../../../../core/reactiveUtils.js";import{property as s}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/Logger.js";import"../../../../../core/RandomLCG.js";import{subclass as a}from"../../../../../core/accessorSupport/decorators/subclass.js";import{axis as l,angle as c}from"../../../../../geometry/support/axisAngleDegrees.js";import{manipulatedObjectGeometry as p}from"../manipulatedObjectUtils.js";let g=class extends e{constructor(t){super(t),this._interactionState=null}initialize(){this.addHandles([n(()=>{const t=this._interactionState;return t&&t.angle!==t.previousAngle?{interactionState:t,angle:t.state.angle}:null},({interactionState:t})=>{this._updateMeshRotation(t)},r),n(()=>{const t=this._interactionState;return t&&t.scale!==t.previousScale?{interactionState:t,scale:t.state.scale}:null},({interactionState:t})=>{this._updateMeshSize(t)},r)])}get geometry(){const t=p(this.object);return"mesh"===t?.type?t:null}get initialAngle(){return this._interactionState?.initialAngle??0}get angle(){const t=this.geometry?.transform;if(null==t)return this._interactionState?.angle??0;const e=l(t.rotation)[2];return Math.abs(e)>.999999?o(c(t.rotation))*Math.sign(e):0}get angleClockwise(){return-this.angle}get relativeAngle(){return this.angle-this.initialAngle}get relativeAngleClockwise(){return-this.relativeAngle}get scale(){return this._interactionState?.scale??1}startInteraction(){const t=new u({angle:this.angle});this._interactionState=t;const e=()=>{this._interactionState=null};return{state:t,done:e,cancel:()=>{t.cancel(),e()}}}createUndoRecord(){return this.object.createUndoRecord()}_updateMeshRotation(t){const{geometry:e}=this;if(null==e)return;const{angle:o,previousAngle:n}=t;t.previousAngle=o;const r=i(o-n);e.rotate(0,0,r)}_updateMeshSize(t){const{geometry:e}=this;if(null==e)return;const{scale:o,previousScale:i}=t;t.previousScale=o;const n=o/i;e.scale(n)}};t([s({constructOnly:!0})],g.prototype,"object",void 0),t([s()],g.prototype,"geometry",null),t([s({constructOnly:!0})],g.prototype,"viewingMode",void 0),t([s()],g.prototype,"initialAngle",null),t([s()],g.prototype,"angle",null),t([s()],g.prototype,"angleClockwise",null),t([s()],g.prototype,"relativeAngle",null),t([s()],g.prototype,"relativeAngleClockwise",null),t([s()],g.prototype,"scale",null),t([s()],g.prototype,"_interactionState",void 0),g=t([a("esri.views.3d.interactive.editingTools.transform.ScaleRotateMeshAdapter")],g);let u=class extends e{get state(){const{angle:t,scale:e}=this;return{angle:t,scale:e}}constructor(t){super(t),this.angle=0,this.initialAngle=0,this.previousAngle=0,this.previousScale=1,this.scale=1,this.initialAngle=t.angle,this.previousAngle=t.angle}cancel(){this.angle=this.initialAngle,this.scale=1}};t([s()],u.prototype,"angle",void 0),t([s()],u.prototype,"initialAngle",void 0),t([s()],u.prototype,"previousAngle",void 0),t([s()],u.prototype,"previousScale",void 0),t([s()],u.prototype,"scale",void 0),t([s()],u.prototype,"state",null),u=t([a("esri.views.3d.interactive.editingTools.transform.ScaleRotateMeshAdapter.InteractionState")],u);export{g as ScaleRotateMeshAdapter};
