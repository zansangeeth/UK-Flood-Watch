/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__addDisposableResource as t,__disposeResources as e,__decorate as s}from"tslib";import o from"../../../../../core/Accessor.js";import{isSome as a}from"../../../../../core/arrayUtils.js";import{createTask as i}from"../../../../../core/asyncUtils.js";import has from"../../../../../core/has.js";import{throwIfAborted as r,throwIfNotAbortError as n}from"../../../../../core/promiseUtils.js";import l from"../../../../../core/ReactiveMap.js";import{whenOnce as c}from"../../../../../core/reactiveUtils.js";import{waitTick as d}from"../../../../../core/scheduling.js";import{property as u}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/Logger.js";import{subclass as h}from"../../../../../core/accessorSupport/decorators/subclass.js";import{fromExtent as f,intersects as p}from"../../../../../geometry/support/aaBoundingRect.js";import{joinCommands as m}from"./PipelineCommand.js";import{FeatureData as y}from"./featureData/FeatureData.js";let _=class extends o{constructor(t){super(t),this.extent=null,this._tileHandles=new l,this._wanted=new l,this._updateRequested=!1,this._synchronizationTask=null,this._requestedTiles=new Array}destroy(){this._tileHandles.clear(),this._wanted.clear()}get updating(){return this._updateRequested||!(this._synchronizationTask?.finished??1)}get _boundingRect(){const{extent:t}=this;return null==t?null:f(t)}get _missingTiles(){const t=new Array,e=this._wanted,s=this._tileHandles;for(const o of e.values())null==s.get(o.id)?.featureData&&t.push(o);return t}onTileTreeChange({tiles:t}){this._requestedTiles=t,this._scheduleTilesSync()}_scheduleTilesSync(){if(this._updateRequested)return;this._updateRequested=!0;const t=this._synchronizationTask,e=i(async()=>{try{await c(()=>t?.finished??!0),await d(),this._updateRequested=!1,await this._synchronizeTiles()}finally{this._synchronizationTask===e&&(this._synchronizationTask=null)}});this._synchronizationTask=e}async _synchronizeTiles(){const t=this._requestedTiles,e=this._tileHandles,s=new Array;for(const u of t)e.has(u.id)||s.push(u);const o=new Array;for(const u of e.values()){const{id:e}=u;t.every(t=>t.id!==e)&&o.push(u.descriptor)}const a=this._tileHandles,{_boundingRect:i}=this,r=null!=i?s.filter(t=>!t.extent||p(i,t.extent)):s,n=this._wanted,l=new Array;for(const{id:u}of o)n.delete(u);for(const u of r)n.set(u.id,u);const c=this._missingTiles;for(const u of o){const{id:t}=u;if(c.some(t=>w(t,u)||w(u,t)))continue;const e=a.get(t);null!=e&&l.push(this._removeTile(e))}for(const u of r)l.push(this._addTile(u));const d=await Promise.allSettled(l);for(const u of d)"rejected"===u.status&&console.error(u.reason)}forEachTile(t){for(const e of this._tileHandles.values()){const s=e.featureData;null!=s&&t(s)}}*loadedTiles(){for(const t of this._tileHandles.values()){const e=t.featureData;null!=e&&(yield e)}}async _removeTile(s){s.loadTask.abort(),this._tileHandles.delete(s.id),this._validate();const{featureData:o}=s;if(null!=o){const s={stack:[],error:void 0,hasError:!1};try{t(s,await this.tileLocks.lock([o.tileId]),!1);const e=await this.createRemoveCommand(o.id);await(e?.execute())}catch(a){s.error=a,s.hasError=!0}finally{e(s)}}}async _addTile(t){const{_tileHandles:e}=this,s=e.get(t.id);if(null!=s){if(!T(s)||s.featureData.isFullyEnabled)return;return s.featureData.enableAll(),void await this._onTileLoad(s)}const o=new v(t,i(async e=>{const s=await this.loadTile(t,e);return r(e),new y(s)}));this._tileHandles.set(o.id,o);try{await o.loadTask.promise}catch(a){return void n(a)}g(o),await this._onTileLoad(o)}async _onTileLoad(s){const o={stack:[],error:void 0,hasError:!1};try{const{_wanted:e,_tileHandles:i,_missingTiles:r}=this,n=s.descriptor,l=new Array,c=new Array,d=new Array,u=new Set;for(const t of i.values()){if(t===s)continue;const{descriptor:o,id:a}=t;if(!(e.has(a)||r.some(t=>w(t,o)||w(o,t)))){i.delete(a),t.loadTask.abort();const{featureData:e}=t;null!=e&&l.push(e);continue}if(T(t)){if(w(n,o)){const e=t.featureData;for(const t of e.objectIds())u.add(t)}if(w(o,n)){const{featureData:e}=t;c.push(e)}}}u.size>0&&(s.featureData.disableObjectIds(u),this._validateRemoval(s.featureData,u)),this._validate(),d.push(s.featureData);const h=[...d,...l,...c].map(t=>t.tileId);t(o,await this.tileLocks.lock(h),!1);if(0!==c.length){const t=s.featureData,e=new Set(t.objectIds());for(const s of c)s.disableObjectIds(e),this._validateRemoval(s,e)}const f=l.map(t=>this.createRemoveCommand(t.id)),p=d.map(t=>this.createAddCommand(t)),y=c.map(t=>this.createUpdateCommand(t)),_=await Promise.all([...f,...p,...y]),v=m(_.filter(a));await(v?.execute())}catch(i){o.error=i,o.hasError=!0}finally{e(o)}}_validate(){if(!has("feature-pipeline-3d-test-validation"))return;const t=new Array;for(const e of this._tileHandles.values()){if(!T(e))continue;const{featureData:s}=e;t.push({featureData:s,objectIds:new Set(s.enabledObjectIds())})}for(let e=0;e<t.length;++e){const{featureData:s,objectIds:o}=t[e];for(let a=e+1;a<t.length;++a){const{featureData:e,objectIds:i}=t[a];for(const t of i)if(o.has(t))throw new Error(`${s.id} and ${e.id} both contain ${t}.`)}}}_validateRemoval(t,e){if(has("feature-pipeline-3d-test-validation"))for(const s of t.enabledObjectIds())if(e.has(s))throw new Error(`Failed to remove ${s} from ${t.id}!`)}};function w({lij:[t,e,s]},{lij:[o,a,i]}){const r=o-t;return r>=0&&e===a>>r&&s===i>>r}s([u()],_.prototype,"updating",null),s([u({constructOnly:!0})],_.prototype,"loadTile",void 0),s([u({constructOnly:!0})],_.prototype,"createAddCommand",void 0),s([u({constructOnly:!0})],_.prototype,"createRemoveCommand",void 0),s([u({constructOnly:!0})],_.prototype,"createUpdateCommand",void 0),s([u({constructOnly:!0})],_.prototype,"tileLocks",void 0),s([u()],_.prototype,"extent",void 0),s([u()],_.prototype,"_boundingRect",null),s([u()],_.prototype,"_missingTiles",null),s([u()],_.prototype,"_updateRequested",void 0),s([u()],_.prototype,"_synchronizationTask",void 0),_=s([h("esri.views.3d.layers.graphics.pipeline.Tile3DManager")],_);class v{constructor(t,e){this.descriptor=t,this.loadTask=e}get id(){return this.descriptor.id}get featureData(){return this.loadTask.value}}function T(t){return null!=t.featureData}function g(t){if(!T(t))throw new Error}export{_ as Tile3DManager};
