/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{EventEmitter as t}from"../../../../../../core/Evented.js";import{baseObjectMemory as e,estimateNumberMemory as i}from"../../../../../../core/memoryEstimations.js";import{PooledRBush as r,BBox as s}from"../../../../../../core/libs/rbush/PooledRBush.js";import{getCentroidOptimizedGeometry as n}from"../../../../../../layers/graphics/centroid.js";import o from"../../../../../../layers/graphics/OptimizedGeometry.js";class u{constructor(t,e){this._index=t,this._view=e}get usedMemory(){return e+i}getObjectId(){return this._view.getObjectId(this._index)}getAttribute(t){return this._view.getAttribute(this._index,t)}getAttributeAsTimestamp(t){return this._view.getAttributeAsTimestamp(this._index,t)}getAttributes(){return this._view.getAttributes(this._index)}getOptimizedGeometry(){return this._view.getOptimizedGeometry(this._index)}getCentroid(t){return this._view.getCentroid(this._index,t)}getBounds(){return this._view.getBounds(this._index)}getBoundingBox(){return this._view.getBoundingBox(this._index)}cloneWithGeometry(t){return new d(this._index,this._view,t)}}class d extends u{constructor(t,e,i){super(t,e),this._geometryOverride=i}getOptimizedGeometry(){return this._geometryOverride}getCentroid(t){return n(new o,this._geometryOverride,t.hasZ,t.hasM)}}class a{constructor(t,e){this.featureData=t,this.bounds=e}}class h{constructor(){this._tileBounds=new Map,this.events=new t,this.featureAdapter=m.shared}get usedMemory(){return e+e*this._tileBounds.size}addTile(t){const{featureCount:e}=t;if(0===e)return;const i=new r(9,e=>t.getBounds(e)),s=new Array;for(let r=0;r<e;++r)s[r]=r;i.load(s),this._tileBounds.set(t.id,new a(t,i)),this.events.emit("changed")}removeTile(t){this._tileBounds.delete(t),this.events.emit("changed")}clear(){this._tileBounds.clear(),this.events.emit("changed")}forEach(t){for(const{featureData:e,bounds:i}of this._tileBounds.values())i.all(i=>{e.getEnabled(i)&&t(new u(i,e))})}forEachInBounds(t,e){g.minX=t[0],g.minY=t[1],g.maxX=t[2],g.maxY=t[3];for(const{featureData:i,bounds:r}of this._tileBounds.values())r.search(g,t=>{i.getEnabled(t)&&e(new u(t,i))})}forEachBounds(t,e){for(const i of t)e(i.getBoundingBox())}getFullExtent(t){let e=1/0,i=1/0,r=-1/0,s=-1/0;for(const{bounds:n}of this._tileBounds.values()){const{minX:t,minY:o,maxX:u,maxY:d}=n.toJSON();e=Math.min(e,t),i=Math.min(i,o),r=Math.min(r,u),s=Math.min(s,d)}return{xmin:e,ymin:i,xmax:r,ymax:s,spatialReference:t}}}class m{static{this.shared=new m}getObjectId(t){return t.getObjectId()}getAttribute(t,e){return t.getAttribute(e)}getAttributeAsTimestamp(t,e){return t.getAttributeAsTimestamp(e)}getAttributes(t){return t.getAttributes()}getGeometry(t){return t.getOptimizedGeometry()}getCentroid(t,e){return t.getCentroid(e)}cloneWithGeometry(t,e){return t.cloneWithGeometry(e)}}const g=new s;export{u as FeatureHandle,h as TiledFeatureStore};
