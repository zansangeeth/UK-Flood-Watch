/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{baseObjectMemory as t}from"../../../../../core/memoryEstimations.js";import{isBadArcadeResult as e}from"../../../arcade/callExpressionWithCursor.js";const s=Math.PI/180;class i{static create(t){return new i(t.map(t=>n(t)))}constructor(t){this._statistics=t}static get estimatedMemory(){return t+4*t}values(){return this._statistics.values()}insert(t,e){for(const s of this._statistics)s.insert(t,e)}merge(t){for(let e=0;e<this._statistics.length;e++){const s=this._statistics[e],i=t._statistics[e];if(s.field.name!==i.field.name)throw new Error("InternalError: Tried to merge incompatible statistics");s.merge(i)}}clone(){return new i(this._statistics.map(t=>t.clone()))}}function n(t){switch(t.statisticType){case"min":return new u(t);case"max":return new a(t);case"avg":return new o(t);case"avg_angle":return new h(t);case"sum":case"count":return new c(t);case"mode":return new l(t)}}class r{constructor(t){this.field=t}insert(t,s){if(!this.field.computed)return;const i=this.field.computed.read(t,s);e(i)||this._insertValue(i)}}class u extends r{constructor(){super(...arguments),this.type="min",this.value=Number.MAX_VALUE}_insertValue(t){this.value=Math.min(this.value,t)}merge(t){this.value=Math.min(this.value,t.value)}clone(){const t=new u(this.field);return t.value=this.value,t}}class a extends r{constructor(){super(...arguments),this.type="max",this.value=Number.MIN_VALUE}_insertValue(t){this.value=Math.max(this.value,t)}merge(t){this.value=Math.max(this.value,t.value)}clone(){const t=new a(this.field);return t.value=this.value,t}}class c extends r{constructor(){super(...arguments),this.type="sum",this.value=0}_insertValue(t){this.value+=t}merge(t){this.value+=t.value}clone(){const t=new c(this.field);return t.value=this.value,t}}class o extends r{constructor(){super(...arguments),this.type="avg",this._total=0,this._count=0}get value(){return this._total/this._count}_insertValue(t){this._total+=t,this._count+=1}merge(t){this._total+=t._total,this._count+=t._count}clone(){const t=new o(this.field);return t._total=this._total,t._count=this._count,t}}class h extends r{constructor(){super(...arguments),this.type="avg_angle",this._x=0,this._y=0,this._count=0}get value(){const t=this._x/this._count,e=this._y/this._count,s=180/Math.PI;return Math.atan2(e,t)*s}_insertValue(t){this._x=this._x+Math.cos(t*s),this._y=this._y+Math.sin(t*s),this._count+=1}merge(t){this._x+=t._x,this._y+=t._y,this._count+=t._count}clone(){const t=new h(this.field);return t._x=this._x,t._y=this._y,t._count=this._count,t}}class l extends r{constructor(){super(...arguments),this._frequencies=new Map}get value(){let t,e=0;for(const[s,i]of this._frequencies.entries())i>e&&(e=i,t=s);return t}_insertValue(t){const e=this._frequencies.get(t);null!=e?this._frequencies.set(t,e+1):this._frequencies.set(t,1)}merge(t){for(const[e,s]of t._frequencies.entries()){const t=this._frequencies.get(e);null!=t?this._frequencies.set(e,t+s):this._frequencies.set(e,s)}}clone(){const t=new l(this.field);return t._frequencies=new Map(this._frequencies),t}}export{i as AccumulatedStatistics};
