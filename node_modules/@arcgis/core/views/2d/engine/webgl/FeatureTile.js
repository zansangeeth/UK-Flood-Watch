/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import has from"../../../../core/has.js";import e from"../../../../core/Logger.js";import{create as t}from"../../../../core/libs/gl-matrix-2/factories/mat2df32.js";import{create as s}from"../../../../core/libs/gl-matrix-2/factories/mat3f32.js";import{AFeatureTile as i}from"./AFeatureTile.js";import{RESHUFFLING_EXEMPT_MEMORY_BYTES as r,RESHUFFLING_TARGET_MEMORY_EFFICIENCY as o,RESHUFFLING_EXEMPT_DRAW_CALLS as n,RESHUFFLING_TARGET_DRAW_EFFICIENCY as d,tileSize as h}from"./definitions.js";import a from"./DisplayEntity.js";import{DisplayList as l}from"./FeatureDisplayList.js";import{ReshufflePlan as c}from"./ReshufflePlan.js";import{LabelMetric as f}from"./collisions/LabelMetric.js";import{MappedMesh as _}from"./cpuMapped/MappedMesh.js";import{debugMeshDataInfo as u}from"./mesh/meshDebugUtils.js";import m from"./util/Reader.js";import{deserializeList as y}from"./util/serializationUtils.js";const p=()=>e.getLogger("esri.views.2d.engine.webgl.FeatureTile");let g=0;class b extends i{constructor(e,i,r,o,n,d,h=!1){super(e,i,r,o),this._fader=n,this._labelInstanceId=d,this._meshes=new Map,this._entities=[],this._entityIndex=new Map,this._invalidated=!1,this._nextUploadAllowed=!1,this.tileAge=g++,this._metrics=[],this._metricsVisibility=new Set,this._entityIds=new Set,this._entityIdsFromBuffer=new Set,this._attributeEpoch=0,this._encounteredEnd=!1,this._decluttered=!1,this._objectIdMap=null,this.isCoverage=!1,this.rendering=!1,this.visible=!0,this.transforms.labelMat2d=t(),this.transforms.tileUnitsToPixels=s(),this.enableDeferredUploads=h}destroy(){super.destroy(),this.clear()}clear(){for(const e of this._meshes.values())e.destroy();this._meshes.clear(),this._entities=[],this._fader?.removeFeatureTileMetrics(this,this._metrics),this._metrics=[],this._displayList=null,this._invalidated=!0,this._entityIds.clear(),this._nextUploadAllowed=!0}beforeRender(e){super.beforeRender(e),this._needsReshuffle&&e.reshuffleManager.schedule(this)}tryReady(e){const t=this._invalidated&&!this._uploadAllowed;return!(this.isReady||t||!this._encounteredEnd||!(e>=this._attributeEpoch))&&(has("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.ready [epoch=${e}]`),this.ready(),this.requestRender(),this.decluttered=!1,!0)}get symbols(){const e=new Map;for(const t of this._metrics)e.get(t.labelClassId)||e.set(t.labelClassId,[]),e.get(t.labelClassId).push(t);return e}get decluttered(){return this._decluttered}set decluttered(e){this._decluttered=e,this.requestRender()}get id(){return this.key.id}get hasData(){return!!this._meshes.size}get hasAnimations(){return!!this._objectIdMap}get needsUpload(){return this._invalidated}get usedMemory(){let e=0;for(const t of this._meshes.values())e+=t.usedMemory;if(this._entities.length){let t=0;const s=Math.min(this._entities.length,10);for(let e=0;e<s;e++)t+=this._entities[0].records.length;const i=t/s;e+=a.estimateMemory(i)*this._entities.length,e+=4*this._entities.length}return e+=25*this._entityIndex.size,e+=18*this._entityIds.size,e+=25*this._entityIdsFromBuffer.size,this._displayList&&(e+=this._displayList.usedMemory),this._objectIdMap&&(e+=25*this._entities.length),e}get _uploadAllowed(){return!this.enableDeferredUploads||this._nextUploadAllowed}get _hasMetrics(){return this._metrics.length>0}upload(){this._nextUploadAllowed=!0}getDisplayList(e,t){if(this._uploadAllowed&&this._invalidated){this._entities.sort((e,t)=>{const s=t.sortKey,i=e.sortKey;return i===s?e.id-t.id:i-s}),0===t&&this.reshuffle(!0),this._displayList=l.fromDisplayEntities(this._entities,this,e,t);for(const e of this._meshes.values())e.upload();this.debugInfo.display.length=this._displayList.length,this.debugInfo.display.minOrderedLength=this._displayList.minOrderedLength,this.debugInfo.display.minUnorderedLength=this._displayList.minUnorderedLength,this.requestRender(),this._invalidated=!1,this._nextUploadAllowed=!1}return this._displayList}getMesh(e){if(!this._meshes.has(e))throw new Error(`InternalError: Unable to find VAO for instance: ${e}`);return this._meshes.get(e)}getSortKeys(e){const t=new Map;for(const{id:s,sortKey:i}of this._entities)if(e.has(s)&&t.set(s,i),t.size===e.size)break;return t}onMessage(e){if(e.objectIdMap)for(const t in e.objectIdMap)this._objectIdMap||(this._objectIdMap={}),this._objectIdMap[t]=e.objectIdMap[t];switch(e.type){case"append":this._onAppendMessage(e);break;case"update":this._onUpdateMessage(e)}if(this._aggregateMemoryStats(),this.requestRender(),e.end){if(has("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.end [epoch=${e.attributeEpoch}]`),!e.attributeEpoch)throw new Error("InternalError: Attribute epoch not defined.");this._attributeEpoch=e.attributeEpoch,this._encounteredEnd=!0}this._writeLabelVisibilityToMesh()}_onAppendMessage(e){if(has("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.append`,{append:u(e?.append)}),e.clear&&this.clear(),!e.append)return;const t=y(new m(e.append.entities),a);this._insert(t,e.append.data,!1)}_onUpdateMessage(e){has("esri-2d-update-debug")&&console.debug(`Tile[${this.key.id}] FeatureTile.update`,{isPixelBuffer:e.isPixelBuffer,modify:u(e.modify),remove:e.remove});const t=y(new m(e.modify.entities),a),s=t.map(e=>e.id),i=e.isPixelBuffer??!1,r=[...e.remove,...s];i?this._removeByIdsFromBuffer(r):this._removeByIds(r),this._insert(t,e.modify.data,i)}reshuffle(e=!1){if(this.destroyed)return;const t=new Map;for(const s of this._entities)for(const i of s.records){const s=this._meshes.get(i.instanceId);let r=t.get(s);r||(r=new c(e),t.set(s,r)),r.copyRecord(i)}for(const[s,i]of t)s.reshuffle(i);this._invalidated=!0,this._aggregateMemoryStats(),has("esri-2d-update-debug")&&p().info(`Tile ${this.key.id} was reshuffled.`)}copyPixelBufferedEntitesFrom(e,t,s,i){const r=s*h,o=i*h;for(const n of e._entities){let s=null;for(const i of n.records)if(i.overlaps&t){const t=e.getMesh(i.instanceId),d=this._ensureMesh(i.instanceId,t.layout,t.useVisibility).copyRecordFrom(t,i,r,o);s||(s=new a(n.id,n.sortKey),this._entityIdsFromBuffer.add(n.id),this._entityIndex.set(s.id,s),this._entities.push(s)),s.records.push(d)}}this._invalidated=!0}get metricsVisibility(){return this._metricsVisibility}copyMetricsVisibility(e){for(const t of e)this._metricsVisibility.add(t);this._writeLabelVisibilityToMesh()}updateLabelVisibility(){this._metricsVisibility.clear();for(const e of this._metrics){e.uniqueSymbol.show&&e.selectedForRendering&&this._metricsVisibility.add(e.hash)}this._writeLabelVisibilityToMesh()}_writeLabelVisibilityToMesh(){const e=this._meshes.get(this._labelInstanceId);if(e&&this._hasMetrics){for(const t of this._metrics){const s=this._entityIndex.get(t.id);if(!s)continue;const i=this._metricsVisibility.has(t.hash);e.setEntityRecordRangeVisibility(s.records,t.recordStart,t.recordCount,i?0:255)}this._invalidated=!0}}_ensureMesh(e,t,s){return this._meshes.has(e)||this._meshes.set(e,new _(this._stage.bufferPool,t,s)),this._meshes.get(e)}_insert(e,t,s){if(!e.length)return;this._removeDuplicatedBufferedEntites(e);const i=this._insertVertexData(t);for(const r of e){for(const e of r.records)e.updateBaseOffsets(i.get(e.instanceId));s?this._tryInsertBufferedEntity(r):this._insertEntity(r)}this._invalidated=!0}_insertMetrics(e){for(const t of e)t.tile=this;this._metrics.push(...e),this._fader?.insertFeatureTileMetrics(this,e)}_insertVertexData(e){const t=new Map;for(const s of e){const{instanceId:e,layout:i}=s,r=i.attributes.some(e=>"visibility"===e.name),o=this._ensureMesh(e,i,r).append(s);if(s.metrics){const e=y(new m(s.metrics),f)??[];this._insertMetrics(e)}t.set(e,o)}return t}_insertEntity(e){has("esri-2d-update-debug")&&this._entityIds.has(e.id)&&console.error(`Tile ${this.key.id} insertEntity: Already have entityId ${e.id}`),this._entityIds.add(e.id),this._entityIndex.set(e.id,e),this._entities.push(e)}_tryInsertBufferedEntity(e){this._entityIds.has(e.id)?this._removeRecordsFromMesh(e.records):(this._entityIdsFromBuffer.add(e.id),this._entityIndex.set(e.id,e),this._entities.push(e))}_removeDuplicatedBufferedEntites(e){if(!this._entityIdsFromBuffer.size)return;const t=[];for(const s of e)this._entityIdsFromBuffer.has(s.id)&&t.push(s.id);this._removeByIds(t)}_removeByIdsFromBuffer(e){this._removeByIds(e.filter(e=>this._entityIdsFromBuffer.has(e)))}_removeByIds(e){if(0===e.length)return;const t=new Set(e),s=[];for(const r of this._entities)t.has(r.id)?(this._remove(r),this._entityIndex.delete(r.id)):s.push(r);this._entities=s;const i=this._metrics.filter(e=>t.has(e.displayId));this._metrics=this._metrics.filter(e=>!t.has(e.displayId)),this._fader?.removeFeatureTileMetrics(this,i),this._invalidated=!0}_remove(e){this._removeRecordsFromMesh(e.records),this._entityIds.delete(e.id),this._entityIdsFromBuffer.delete(e.id)}_removeRecordsFromMesh(e){for(const t of e){const{instanceId:e,indexStart:s,indexCount:i,vertexStart:r,vertexCount:o}=t;this._meshes.get(e)?.remove(s,i,r,o)}}_aggregateMemoryStats(){this.debugInfo.memory.bytesUsed=0,this.debugInfo.memory.bytesReserved=0;for(const e of this._meshes.values())this.debugInfo.memory.bytesUsed+=e.memoryStats.bytesUsed,this.debugInfo.memory.bytesReserved+=e.memoryStats.bytesReserved}get _needsReshuffle(){if(this.destroyed)return!1;const{bytesUsed:e,bytesReserved:t}=this.debugInfo.memory,s=e/t,{minOrderedLength:i,length:h}=this.debugInfo.display;return t>r&&s<o||h>n&&i/h<d}get entityIds(){return this._objectIdMap?this._entities.map(({id:e})=>({objectId:this._objectIdMap[e],displayId:e})):[]}}export{b as FeatureTile};
