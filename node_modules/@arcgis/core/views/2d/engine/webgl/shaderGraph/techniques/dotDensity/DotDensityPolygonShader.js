/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t,__param as e}from"tslib";import{tileSize as o}from"../../../definitions.js";import{FragmentOutput as s,location as i,uniform as r,define as l,input as d,UniformGroup as n}from"../../GraphShaderModule.js";import{Mat3 as a,Vec3 as p,Vec4 as h,texture2D as c,Mat4 as u,step as m,Float as y,dot as v,max as w,FixedArray as x,Sampler2D as f}from"../../graph/glsl.js";import{AFeatureShader as g,FeatureFragmentInput as A,FeatureVertexInput as D}from"../shaders/AFeatureShader.js";import{failHittest as T}from"../shaders/hittestUtils.js";import{max4 as b}from"../shaders/utils.js";class j extends D{}t([i(3,y)],j.prototype,"inverseArea",void 0);class C extends A{}class V extends n{}t([r(x.ofType(h,2))],V.prototype,"isActive",void 0),t([r(x.ofType(h,8))],V.prototype,"colors",void 0),t([r(y)],V.prototype,"dotValue",void 0);class F extends n{}t([r(f)],F.prototype,"dotTexture0",void 0),t([r(f)],F.prototype,"dotTexture1",void 0),t([r(y)],F.prototype,"tileZoomFactor",void 0),t([r(y)],F.prototype,"pixelRatio",void 0),t([r(y)],F.prototype,"tileDotsOverArea",void 0);class O extends g{constructor(){super(...arguments),this.type="DotDensityPolygonShader"}_dotThreshold(t,e,o){return t.divide(e).divide(o)}vertex(t){const e=new a(2/o,0,0,0,-2/o,0,-1,1,1).multiply(new p(t.pos,1)),s=this.clip(t.id),i=new h(e.xy,s,1),r=this.storage.getVVData(t.id).multiply(this.instance.isActive.get(0)).multiply(t.inverseArea),l=this.storage.getDataDrivenData0(t.id).multiply(this.instance.isActive.get(1)).multiply(t.inverseArea),d=this.draw.tileZoomFactor.multiply(o).divide(this.draw.pixelRatio),n=this._dotThreshold(r,this.instance.dotValue,this.draw.tileDotsOverArea),c=this._dotThreshold(l,this.instance.dotValue,this.draw.tileDotsOverArea),u=t.pos.add(.5).divide(d);return{glPosition:i,color:new h(0,0,0,0),textureCoords:u,thresholds0:n,thresholds1:c}}fragment(t){const e=new s,o=c(this.draw.dotTexture0,t.textureCoords),i=c(this.draw.dotTexture1,t.textureCoords),r=t.thresholds0.subtract(o),l=t.thresholds1.subtract(i);let d;const n=u.fromColumns(this.instance.colors[0],this.instance.colors[1],this.instance.colors[2],this.instance.colors[3]),a=u.fromColumns(this.instance.colors[4],this.instance.colors[5],this.instance.colors[6],this.instance.colors[7]);if(this.blending){const t=m(new y(0),r),e=m(new y(0),l),o=v(t,r).add(v(e,l)),s=m(o,new y(0)),i=new y(1).subtract(s),p=o.add(s),h=r.multiply(t).divide(p),c=l.multiply(e).divide(p),u=n.multiply(h).add(a.multiply(c));d=i.multiply(u)}else{const t=w(b(r),b(l)),e=m(t,new y(0)),o=new y(1).subtract(e),s=m(t,r),i=m(t,l),p=n.multiply(s).add(a.multiply(i));d=o.multiply(p)}return e.fragColor=d,e}hittest(t){return T(this.hittestRequest)}}t([l],O.prototype,"blending",void 0),t([r(V)],O.prototype,"instance",void 0),t([r(F)],O.prototype,"draw",void 0),t([e(0,d(j))],O.prototype,"vertex",null),t([e(0,d(A))],O.prototype,"fragment",null);export{F as DotDensityPolygonDrawUniforms,C as DotDensityPolygonFragmentInput,V as DotDensityPolygonInstanceUniforms,O as DotDensityPolygonShader,j as DotDensityPolygonVertexInput};
