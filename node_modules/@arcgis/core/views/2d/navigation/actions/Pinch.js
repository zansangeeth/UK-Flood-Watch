/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import o from"../../../../Viewpoint.js";import i from"../../../../core/Accessor.js";import{when as s}from"../../../../core/reactiveUtils.js";import{Seconds as e,secondsFromMilliseconds as m}from"../../../../core/time.js";import{property as n}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as a}from"../../../../core/accessorSupport/decorators/subclass.js";import{set as r,add as h}from"../../../../core/libs/gl-matrix-2/math/vec2.js";import{create as u}from"../../../../core/libs/gl-matrix-2/factories/vec2f64.js";import l from"../../../../geometry/Point.js";import{getPaddingScreenTranslation as p,scaleAndRotateBy as c}from"../../viewpointUtils.js";import{RotationMomentumEstimator as _}from"../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as d}from"../../../navigation/ZoomMomentumEstimator.js";let M=class extends i{constructor(t){super(t),this._animationTime=e(0),this._momentumFinished=!1,this._previousAngle=0,this._previousRadius=0,this._previousCenter=null,this._rotationMomentumEstimator=new _(.6,.15,.95),this._rotationDirection=1,this._startAngle=0,this._startRadius=0,this._updateTimestamp=null,this._zoomDirection=1,this._zoomMomentumEstimator=new d,this._zoomOnly=null,this.viewpoint=new o({targetGeometry:new l,scale:0,rotation:0}),this.zoomMomentum=null,this.rotateMomentum=null,this.addHandles(s(()=>this._momentumFinished,()=>this.navigation.stop()))}begin(t,o){this.navigation.begin(),this._rotationMomentumEstimator.reset(),this._zoomMomentumEstimator.reset(),this._zoomOnly=null,this._previousAngle=this._startAngle=o.angle,this._previousRadius=this._startRadius=o.radius,this._previousCenter=o.center,this._updateTimestamp=null,t.constraints.rotationEnabled&&this.addToRotateEstimator(0,o.timestamp),this.addToZoomEstimator(o,1)}update(t,o){null===this._updateTimestamp&&(this._updateTimestamp=o.timestamp);const i=o.angle,s=o.radius,e=o.center,m=Math.abs(180*(i-this._startAngle)/Math.PI),n=Math.abs(s-this._startRadius),a=this._startRadius/s;if(this._previousRadius&&this._previousCenter){const r=s/this._previousRadius;let h=180*(i-this._previousAngle)/Math.PI;this._rotationDirection=h>=0?1:-1,this._zoomDirection=r>=1?1:-1,t.constraints.rotationEnabled?(null===this._zoomOnly&&o.timestamp-this._updateTimestamp>200&&(this._zoomOnly=n-m>0),null===this._zoomOnly||this._zoomOnly?h=0:this.addToRotateEstimator(i-this._startAngle,o.timestamp)):h=0,this.addToZoomEstimator(o,a),this.navigation.setViewpoint([e.x,e.y],1/r,h,[this._previousCenter.x-e.x,e.y-this._previousCenter.y])}this._previousAngle=i,this._previousRadius=s,this._previousCenter=e}end(t){this.rotateMomentum=this._rotationMomentumEstimator.evaluateMomentum(),this.zoomMomentum=this._zoomMomentumEstimator.evaluateMomentum(),this._animationTime=e(0),(this.rotateMomentum||this.zoomMomentum)&&this.onAnimationUpdate(t),this.navigation.end()}addToRotateEstimator(t,o){this._rotationMomentumEstimator.add(t,.001*o)}addToZoomEstimator(t,o){this._zoomMomentumEstimator.add(o,.001*t.timestamp)}canZoomIn(t){const o=t.scale,i=t.constraints.effectiveMaxScale;return 0===i||o>i}canZoomOut(t){const o=t.scale,i=t.constraints.effectiveMinScale;return 0===i||o<i}onAnimationUpdate(t){this.navigation.animationManager?.animateContinuous(t.viewpoint,(o,i)=>{const s=!this.canZoomIn(t)&&this._zoomDirection>1||!this.canZoomOut(t)&&this._zoomDirection<1,n=!this.rotateMomentum||this.rotateMomentum.isFinished(this._animationTime),a=s||!this.zoomMomentum||this.zoomMomentum.isFinished(this._animationTime),l=m(i);if(this._momentumFinished=n&&a,!this._momentumFinished){const i=this.rotateMomentum?Math.abs(this.rotateMomentum.valueDelta(this._animationTime,l))*this._rotationDirection*180/Math.PI:0;let s=this.zoomMomentum?Math.abs(this.zoomMomentum.valueDelta(this._animationTime,l)):1;const e=u(),m=u();if(this._previousCenter){r(e,this._previousCenter.x,this._previousCenter.y),p(m,t.size,t.padding),h(e,e,m);const{constraints:n,scale:a}=t,u=a*s;s<1&&!n.canZoomInTo(u)?(s=a/n.effectiveMaxScale,this.zoomMomentum=null,this.rotateMomentum=null):s>1&&!n.canZoomOutTo(u)&&(s=a/n.effectiveMinScale,this.zoomMomentum=null,this.rotateMomentum=null),c(o,t.viewpoint,s,i,e,t.size),t.constraints.constrainByGeometry(o)}}this._animationTime=e(this._animationTime+l)})}stopMomentumNavigation(){(this.rotateMomentum||this.zoomMomentum)&&(this.rotateMomentum&&(this._rotationMomentumEstimator.reset(),this.rotateMomentum=null),this.zoomMomentum&&(this._zoomMomentumEstimator.reset(),this.zoomMomentum=null),this.navigation.stop())}};t([n()],M.prototype,"_momentumFinished",void 0),t([n()],M.prototype,"viewpoint",void 0),t([n()],M.prototype,"navigation",void 0),M=t([a("esri.views.2d.navigation.actions.Pinch")],M);export{M as default};
