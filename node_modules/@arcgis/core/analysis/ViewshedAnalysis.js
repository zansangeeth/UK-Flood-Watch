/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"./Analysis.js";import r from"./Viewshed.js";import{equals as s}from"../core/arrayUtils.js";import n from"../core/Collection.js";import{referenceSetter as i,castForReferenceSetter as o}from"../core/collectionUtils.js";import{cyclicalDegrees as l}from"../core/Cyclical.js";import{deg2rad as a,clamp as p}from"../core/mathUtils.js";import{watch as u,syncAndInitial as c}from"../core/reactiveUtils.js";import{property as m}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import"../core/Logger.js";import{subclass as h}from"../core/accessorSupport/decorators/subclass.js";import d from"../geometry/Extent.js";import{projectOrLoadMany as f}from"../geometry/projectionUtils.js";const v=n.ofType(r);let y=class extends t{constructor(e){super(e),this.type="viewshed",this._extent=null}initialize(){this.addHandles(u(()=>this._computeExtent(),e=>{null==e.pending&&(this._extent=e.extent)},c))}get viewsheds(){return this._get("viewsheds")||new v}set viewsheds(e){this._set("viewsheds",i(e,this.viewsheds,v))}get spatialReference(){for(const e of this.viewsheds)if(null!=e.observer)return e.observer.spatialReference;return null}get extent(){return this._extent}get valid(){return this.viewsheds.every(e=>e.valid)}async waitComputeExtent(){const e=this._computeExtent();null!=e.pending&&await e.pending}_computeExtent(){const{spatialReference:e}=this;if(null==e)return{pending:null,extent:null};const t=this.viewsheds.filter(e=>null!=e.observer),r=t.map(e=>e.observer).toArray(),s=f(r,e);if(null!=s.pending)return{pending:s.pending,extent:null};return{pending:null,extent:s.geometries.map((e,r)=>{const s=t.at(r);return null!=e&&null!=s?this._computeViewshedExtent(this.viewsheds.at(r),e):null}).filter(e=>null!=e).reduce((e,t)=>x(e,t),null)}}_computeViewshedExtent(e,t){const{farDistance:r,heading:s,tilt:n,horizontalFieldOfView:i,verticalFieldOfView:o}=e,{spatialReference:u}=t,c=i/2,m=o/2,h=r/u.metersPerUnit,f=[l.normalize(s-c),s,l.normalize(s+c)],v=d.fromPoint(t),y=e=>{const t=f.map(t=>l.normalize(t-e));if(t[0]>t[2]||360===i)return h;const r=t.map(e=>Math.abs(e>180?360-e:e)).reduce((e,t)=>e>t?t:e);return r>90?0:h*Math.cos(a(r))};v.xmax+=y(90),v.xmin-=y(-90),v.ymax+=y(0),v.ymin-=y(180);const x=t.z;if(null!=x){let e=x,t=x;const s=n-90,i=p(s+m,-90,90),o=p(s-m,-90,90),l=u?.isGeographic?r:h;e+=l*g(i),t+=l*g(o);const a=w(m)*l,d=g(s)*a*(1-w(c));n<90&&(e-=d),n>90&&(t-=d),v.zmax=Math.max(e,x),v.zmin=Math.min(t,x)}return v}equals(e){return this===e||super.equals(e)&&s(this.viewsheds.toArray(),e.viewsheds.toArray(),(e,t)=>e.equals(t))}clear(){this.viewsheds.removeAll()}};function x(e,t){return null==e?t:null==t?e:e.union(t)}function w(e){return Math.cos(a(e))}function g(e){return Math.sin(a(e))}e([m({type:["viewshed"]})],y.prototype,"type",void 0),e([m({cast:o,type:v,nonNullable:!0})],y.prototype,"viewsheds",null),e([m({readOnly:!0})],y.prototype,"spatialReference",null),e([m()],y.prototype,"_extent",void 0),e([m()],y.prototype,"extent",null),e([m({readOnly:!0})],y.prototype,"valid",null),y=e([h("esri.analysis.ViewshedAnalysis")],y);export{y as default};
