/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import i from"../../renderers/support/AuthoringInfo.js";import a from"../../renderers/support/ClassBreakInfo.js";import s from"../../renderers/visualVariables/support/SizeStop.js";import{getSize as o}from"../../renderers/visualVariables/support/visualVariableUtils.js";import{createVisualVariable as n}from"./color.js";import{createVisualVariables as l,createContinuousRenderer as t,regenerateContinuousRenderer as r}from"./size.js";import{isColorVV as u,updateAuthoringInfoVisualVariable as p,spliceVisualVariables as m,getAuthoringInfoVisualVariable as c,processRegenerateParams as v,getRendererToUpdate as d,getStyleType as f,hasOutlineVV as b,hasScaleDependentSizeVV as y,findSizeVVIndex as w}from"./support/regenerateUtils.js";import{verifyBasicFieldValidity as h,createStopValuesForAboveBelow as z,clampAboveAndBelowStopValues as g,createDefaultStopValues as V}from"./support/utils.js";import{verifyBinningParams as O}from"../support/binningUtils.js";import{isAnyDateField as x,getFieldsList as E}from"../support/utils.js";import{binningCapableLayerTypes as S,featureCapableLayerTypes as I,createLayerAdapter as T,getLayerTypeLabels as j}from"../support/adapters/support/layerUtils.js";import{getAboveAndBelowSymbols as B}from"../symbology/support/aboveAndBelowUtils.js";import{applyCIMSymbolColor as q}from"../../symbols/support/cimSymbolUtils.js";import{Symbol3DMaterial as D}from"../../symbols/support/Symbol3DMaterial.js";const U=2**53-1;async function C(i){if(!i?.layer||!(i.field||i.valueExpression||i.sqlExpression))throw new e("univariate-colorsize-visual-variables:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(i.valueExpression&&!i.sqlExpression&&!i.view)throw new e("univariate-colorsize-visual-variables:missing-parameters","View is required when 'valueExpression' is specified");if("above-and-below"===i.theme&&i.sizeOptions?.sizeOptimizationEnabled)throw new e("univariate-colorsize-visual-variables:invalid-parameters","sizeOptimizationEnabled cannot be true for 'above-and-below' theme");i.forBinning&&O(i,"univariate-colorsize-visual-variables");const a={...i,layer:i.layer},s=i.forBinning?S:I,o=T(a.layer,s,i.forBinning);if(!o)throw new e("univariate-colorsize-visual-variables:invalid-parameters","'layer' must be one of these types: "+j(s).join(", "));a.layer=o,a.theme=a.theme||a.colorOptions?.theme?a.theme:"high-to-low";const n=null!=a.signal?{signal:a.signal}:null;await o.load(n);const l=await E({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),t=h(o,l,"univariate-colorsize-visual-variables:invalid-parameters");if(t)throw t;return a}function F(e,i){const a={...e},{sizeOptions:s,theme:o}=a,n=a.legendOptions||a.sizeOptions?.legendOptions;return delete a.sizeOptions,delete a.colorOptions,{...a,...s,statistics:i||a.statistics,theme:"above-and-below"===o?null:o,legendOptions:n}}function k(e,i){const a={...e},s=a.colorOptions,o=a.theme||s?.theme,n=a.legendOptions||a.colorOptions?.legendOptions;return delete a.sizeOptions,delete a.colorOptions,{...a,...s,statistics:i||a.statistics,theme:o,legendOptions:n}}async function A(i){if(!i?.layer||!(i.field||i.valueExpression||i.sqlExpression))throw new e("univariate-colorsize-continuous-renderer:missing-parameters","'layer' and 'field', 'valueExpression' or 'sqlExpression' parameters are required");if(i.valueExpression&&!i.sqlExpression&&!i.view)throw new e("univariate-colorsize-continuous-renderer:missing-parameters","View is required when 'valueExpression' is specified");i.forBinning&&O(i,"univariate-colorsize-continuous-renderer");const a={...i,layer:i.layer};a.symbolType=a.symbolType||"2d",a.colorOptions||(a.colorOptions={}),a.colorOptions.isContinuous=a.colorOptions.isContinuous??!1;const s=i.forBinning?S:I,o=T(a.layer,s,i.forBinning);if(!o)throw new e("univariate-colorsize-continuous-renderer:invalid-parameters","'layer' must be one of these types: "+j(s).join(", "));const n=null!=a.signal?{signal:a.signal}:null;if(await o.load(n),"above-and-below"===a.theme&&a.symbolOptions){if(a.symbolType.includes("3d-volumetric"))throw new e("univariate-colorsize-continuous-renderer:invalid-parameters","'symbolOptions' is applicable for '2d' and '3d-flat' 'symbolType' only");if("point"!==o.geometryType&&"polygon"!==o.geometryType)throw new e("univariate-colorsize-continuous-renderer:invalid-parameters","'symbolOptions' only apply to layers with 'point' or 'polygon' geometryType")}const l=await E({field:a.field,normalizationField:a.normalizationField,valueExpression:a.valueExpression}),t=h(o,l,"univariate-colorsize-continuous-renderer:invalid-parameters");if(t)throw t;return{...a,layer:o}}function M(e){const i={...e},a={...i.sizeOptions};return delete i.sizeOptions,delete i.colorOptions,delete a.sizeOptimizationEnabled,{...i,...a}}async function P(i){const a="regenerate-univariate-color-size-renderer";await v(i,a);const s=await d(i);if("univariate-color-size"!==f(s))throw new e(`${a}:invalid-parameters`,"Renderer is invalid");const{layer:o,forBinning:n,filter:l,view:t,signal:r}=i,{field:u,normalizationField:p,valueExpression:m,valueExpressionTitle:c}=s,w=b(s),h=y(s),z=s.authoringInfo?.univariateTheme,g=await A({layer:o,field:u,normalizationField:p,valueExpression:m,valueExpressionTitle:c,outlineOptimizationEnabled:w,theme:z,colorOptions:{isContinuous:"above-and-below"===z?s.visualVariables?.some(e=>"color"===e.type):void 0},sizeOptions:{sizeOptimizationEnabled:h},forBinning:n,filter:l,view:t,signal:r});return{...i,creatorParameters:g,renderer:s}}function R(e,i){if("type"in e&&"cim"===e.type)q(e,i);else if("type"in e&&e.type.includes("3d")){e.symbolLayers.forEach(e=>{"material"in e&&null!=e.material&&"color"in e.material&&(e.material?e.material.color=i:e.material=new D({color:i}))})}else"color"in e&&(e.color=i)}function L(e,i,a){if((i?.symbolStyle||i?.symbols)&&("point"===a||"polygon"===a))return i.symbols||B(i.symbolStyle);const s=e.classBreakInfos[0].symbol;return{above:s.clone(),below:s.clone()}}function $(e,i,s){const o=s.symbolOptions,n=s.layer,l=o?.symbols?"custom":o?.symbolStyle,t=s.colorOptions?.isContinuous;if(G(e,i,t),l||!t){const s=i.size.visualVariables[0].stops,{above:r,below:u}=L(e,o,n.geometryType);if(!t){const e=i.color.colorScheme.colors,a=e[0];R(r,e[e.length-1]),R(u,a)}e.classBreakInfos=[new a({minValue:-U,maxValue:s[2].value,symbol:u}),new a({minValue:s[2].value,maxValue:U,symbol:r})],l&&e.authoringInfo&&(e.authoringInfo.univariateSymbolStyle=l)}}function G(e,i,a=!0){const s=i?.authoringInfo?.clone(),o=s?.visualVariables?.some(e=>"reference-size"===e.theme),n=o?[]:i.size.visualVariables.map(e=>e.clone());a?n.push(i.color.visualVariable.clone()):s.visualVariables=s.visualVariables?.filter(e=>"size"===e.type),e.visualVariables&&n.push(...e.visualVariables.filter(e=>"target"in e&&"outline"===e.target).map(e=>e.clone())),e.authoringInfo=s,e.visualVariables=n}function H(e){const i={...e},a=i.symbolType,s=!!a?.includes("3d-volumetric");delete i.symbolType,delete i.defaultSymbolEnabled;const o=i;return o.worldScale=s,s&&(o.sizeOptions={...o.sizeOptions},o.sizeOptions.axis="3d-volumetric-uniform"===a?"all":"height"),o}async function J(e,i,a,n){const l=i[0],t=i[1],r=Math.round((t-l)/2)+l,u=e.clone();u.stops=[new s({value:a[0],size:t}),new s({value:a[1],size:r}),new s({value:a[2],size:l}),new s({value:a[3],size:r}),new s({value:a[4],size:t})],e.stops=[new s({value:n[0],size:o(u,n[0])}),new s({value:n[1],size:o(u,n[1])}),new s({value:n[2],size:o(u,n[2])}),new s({value:n[3],size:o(u,n[3])}),new s({value:n[4],size:o(u,n[4])})]}async function K(e,i,a,s,o){const n=e.find(e=>"width-and-depth"!==e.axis&&!e.target),l="number"==typeof n?.minSize?n?.minSize:null,t="number"==typeof n?.maxSize?n?.maxSize:null;if(null!=n?.minDataValue&&null!=l&&null!=t)if(s)if("above-and-below"===s){n.minDataValue=null,n.maxDataValue=null,n.minSize=null,n.maxSize=null;const e=z(a,o),s=g(e,a);await J(n,[l,t],e,s),i.stops.forEach((e,i)=>e.value=s[i])}else{const{minDataValue:e,maxDataValue:a}=n,s=V(e,a,5);i.stops.forEach((e,i)=>e.value=s[i]),n.minDataValue=s[0],n.maxDataValue=s[s.length-1]}else n.minDataValue=i.stops[0].value,n.maxDataValue=i.stops[i.stops.length-1].value}function N(e,a,s){const{theme:o,minValue:n,maxValue:l}=e,t=a.authoringInfo.visualVariables[0].clone(),r=s.authoringInfo.visualVariables[0].clone(),{stops:u}=a.visualVariable;return"above-and-below"===o?(t.minSliderValue=r.minSliderValue=n??u[0].value,t.maxSliderValue=r.maxSliderValue=l??u.at(-1)?.value,r.theme="above-and-below"):o&&"high-to-low"!==o||"reference-size"!==r.theme||2!==r.sizeStops?.length||(r.sizeStops[0].value=u[0].value,r.sizeStops[1].value=u.at(-1)?.value),new i({type:"univariate-color-size",univariateTheme:o,visualVariables:[t,r]})}async function Q(e){const i=await C(e),a=await n(k(i)),{visualVariable:s,statistics:o}=a,t=await l(F(i,o)),r=t.visualVariables,u=e.layer,p=e.field?u.getField(e.field):null;return await K(r,s,o,i.theme,x(p)),{basemapId:t.basemapId,basemapTheme:t.basemapTheme,statistics:o,defaultValuesUsed:a.defaultValuesUsed,color:{visualVariable:s,colorScheme:a.colorScheme},size:{visualVariables:r,sizeScheme:t.sizeScheme},authoringInfo:N(i,a,t)}}async function W(e){return X(e)}async function X(e){const i=await A(e),{renderer:a,statistics:s,defaultValuesUsed:o}=await t(M(i)),n=H(i);n.statistics=s;const l=await Q(n);return"above-and-below"===i.theme?$(a,l,i):G(a,l),{renderer:a,statistics:s,defaultValuesUsed:o,color:i.colorOptions?.isContinuous||"above-and-below"!==i.theme?l.color:null,size:l.size,basemapId:l.basemapId,basemapTheme:l.basemapTheme}}async function Y(e){const{creatorParameters:i}=await P(e),{layer:a,field:s,theme:o,colorOptions:t}=i,{renderer:v,statistics:d}=await r(e),f=await C({...H(i),statistics:d}),b=await n(k(f)),y=b.visualVariable,h=(await l(F(f))).visualVariables,z=s?a.getField(s):null;await K(h,y,d,o,x(z));const g=t?.isContinuous||"above-and-below"!==o,V=v.visualVariables?.find(u);g&&V?.stops&&(V.stops.forEach((e,i)=>e.value=y.stops[i].value),p(v,b.authoringInfo,"color")),m(v,h,w);const O=c(v,"size");if((!o||"high-to-low"===o)&&O&&"reference-size"===O.theme&&2===O.sizeStops?.length){const{stops:e}=y;O.sizeStops[0].value=e[0].value,O.sizeStops[1].value=e.at(-1)?.value}if("above-and-below"===o&&h[0]?.stops){const e=h[0].stops;v.classBreakInfos[0].maxValue=e[2].value,v.classBreakInfos[1].minValue=e[2].value}return{renderer:v}}export{W as createContinuousRenderer,X as createRenderer,Q as createVisualVariables,Y as regenerateRenderer};
