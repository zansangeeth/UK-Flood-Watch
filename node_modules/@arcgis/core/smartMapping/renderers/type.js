/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{createUniqueColors as e}from"../../core/colorUtils.js";import i from"../../core/Error.js";import{clone as l}from"../../core/lang.js";import{fetchMessageBundle as n}from"../../intl/messages.js";import{isTimeOnlyField as r}from"../../layers/support/fieldUtils.js";import o from"../../renderers/PointCloudUniqueValueRenderer.js";import t from"../../renderers/UniqueValueRenderer.js";import s from"../../renderers/support/RendererLegendOptions.js";import{createUniqueValueLabel as a,calculateDateFormatInterval as u,dateFormatIntervalOptions as p}from"../../renderers/support/utils.js";import m from"../../renderers/support/pointCloud/ColorUniqueValueInfo.js";import d from"../heuristics/outline.js";import c from"../heuristics/sizeRange.js";import{spliceVisualVariables as f,processRegenerateParams as y,getRendererToUpdate as v,getStyleType as b,hasOutlineVV as w,hasScaleDependentSizeVV as g,findOutlineVVIndex as h,findScaleDependentSizeVVIndex as T}from"./support/regenerateUtils.js";import{getBasemapInfo as z,errorCallback as E,getPointSizeAlgorithm as x,verifyBasicFieldValidity as I,getSymbolSizeFromScheme as V,getSymbolOutlineFromScheme as M,createSymbol as j,isValidPointSize as S}from"./support/utils.js";import O from"../statistics/uniqueValues.js";import{verifyBinningParams as q}from"../support/binningUtils.js";import{getFieldsList as U,fieldDelimiter as C,isAnyDateField as B}from"../support/utils.js";import{binningCapableLayerTypes as R,featureCapableLayerTypes as P,createLayerAdapter as Z,getLayerTypeLabels as F}from"../support/adapters/support/layerUtils.js";import{cloneScheme as D,getSchemes as k}from"../symbology/type.js";async function A(e){if(!e?.layer||!e.field&&!e.valueExpression)throw new i("type-renderer:missing-parameters","'layer' and 'field' or 'valueExpression' parameters are required");if(e.valueExpression&&!e.view)throw new i("type-renderer:missing-parameters","View is required when 'valueExpression' is specified");e.forBinning&&q(e,"type-renderer");const n={...e,layer:e.layer};n.symbolType=n.symbolType||"2d",n.defaultSymbolEnabled??=!0,n.sortBy??="count",n.sortEnabled??=!0,n.statistics=l(n.statistics);const r=null==n.numTypes?10:n.numTypes,o=e.forBinning?R:P,t=Z(n.layer,o,e.forBinning);if(!t)throw new i("type-renderer:invalid-parameters","'layer' must be one of these types: "+F(o).join(", "));const s=null!=n.signal?{signal:n.signal}:null;await t.load(s);const a=t.geometryType;n.outlineOptimizationEnabled="polygon"===a&&n.outlineOptimizationEnabled;const u="featureReduction"in e.layer&&"cluster"===e.layer.featureReduction?.type;if(n.sizeOptimizationEnabled=!("point"!==a&&"multipoint"!==a&&"polyline"!==a||u)&&n.sizeOptimizationEnabled,"mesh"===a)n.symbolType="3d-volumetric",n.colorMixMode=n.colorMixMode||"replace",n.edgesType=n.edgesType||"none";else{if("3d-volumetric-uniform"===n.symbolType&&"point"!==a)throw new i("type-renderer:not-supported","3d-volumetric-uniform symbols are supported for point layers only");if(n.symbolType.includes("3d-volumetric")&&(!n.view||"3d"!==n.view.type))throw new i("type-renderer:invalid-parameters","'view' parameter should be an instance of SceneView when 'symbolType' parameter is '3d-volumetric' or '3d-volumetric-uniform'")}const p=await U({field:n.field,field2:n.field2,field3:n.field3,valueExpression:n.valueExpression}),m=I(t,p,"type-renderer:invalid-parameters");if(m)throw m;return{...n,layer:t,numTypes:r}}async function L(e){const l="regenerate-type-renderer";await y(e,l);const n=await v(e),r=b(n);if(!r||!["type","type-size"].includes(r))throw new i(`${l}:invalid-parameters`,"Renderer is invalid");const{field:o,field2:t,field3:s,valueExpression:a,valueExpressionTitle:u}=n,p=n.uniqueValueInfos.length,{layer:m,forBinning:d,filter:c,view:f,signal:h}=e,T=w(n),z=g(n),E=await A({layer:m,field:o,field2:t,field3:s,valueExpression:a,valueExpressionTitle:u,numTypes:p,outlineOptimizationEnabled:T,sizeOptimizationEnabled:z,forBinning:d,filter:c,view:f,signal:h});return{...e,creatorParameters:E,renderer:n}}async function $(e){if(!e?.layer||!e.field)throw new i("type-point-cloud-class-renderer:missing-parameters","'layer' and 'field' parameters are required");const n={...e,layer:e.layer};n.statistics=l(n.statistics);const r=[10],o=Z(n.layer,r);if(!o)throw new i("type-point-cloud-class-renderer:invalid-parameters","'layer' must be one of these types: "+F(r).join(", "));if(n.layer=o,n.density=n.density||25,n.size=n.size||"100%",!S(n.size))throw new i("type-point-cloud-class-renderer:invalid-parameters","Invalid 'size' parameter. It should be a string of the form '100%'");const t=null!=n.signal?{signal:n.signal}:null;await o.load(t);const s=await U({field:n.field}),a=I(o,s,"type-point-cloud-class-renderer:invalid-parameters");if(a)throw a;return n}async function G(e){let i=e.typeScheme,l=null,n=null;const r=await z(e.basemap,e.view);if(l=null!=r.basemapId?r.basemapId:null,n=null!=r.basemapTheme?r.basemapTheme:null,i)return{scheme:D(i),basemapId:l,basemapTheme:n};const o=k({numColors:e.numColors,basemapTheme:n,geometryType:e.geometryType,theme:e.theme,worldScale:e.worldScale,view:e.view});return o&&(i=o.primaryScheme,l=o.basemapId,n=o.basemapTheme),{scheme:i,basemapId:l,basemapTheme:n}}function H(e,i){let l;return l=e.label<i.label?-1:e.label>i.label?1:0,l}function J(e,i){let l;return l=e.value<i.value?-1:e.value>i.value?1:0,l}function K(e,i){let l=i.count-e.count;return 0===l&&(l=H(e,i)),l}function N(e,i){let l=i.count-e.count;return 0===l&&(l=J(e,i)),l}function Q(e,i,l){let n;"count"===i?(n=N,l&&"codedValues"in l&&l.codedValues&&(n=K)):"value"===i&&(n=J,l&&"codedValues"in l&&l.codedValues&&(n=H)),n&&e.sort(n)}async function W(e,i,l,r){const o=await n("esri/smartMapping/t9n/smartMapping"),{field:u,field2:p,field3:m}=i,d=e.uniqueValueInfos,c=i.layer,f=u?c.getField(u):null,y=f?c.getFieldDomain(f.name):null,v=-1===i.numTypes?d.length:i.numTypes,b=c.geometryType,w=new t({field:u,field2:p,field3:m,fieldDelimiter:u&&p?C:null}),g=[],h=[],T={value:null,domain:y,fieldInfo:f};d.forEach((e,i)=>{T.value=e.value,e.label=a(T);const l=e.value;(null===l||"string"==typeof l&&l.toLowerCase().includes("<null>"))&&g.unshift(i)});for(const n of g)h.unshift(d.splice(n,1)[0]);!1!==i.sortEnabled&&Q(d,i.sortBy,y),X(T,i,d);const z=l?.opacity,E=await G({numColors:d.length,basemap:i.basemap,geometryType:b,typeScheme:i.typeScheme,worldScale:!!i.symbolType?.includes("3d-volumetric"),view:i.view}),x=E.scheme,I=x.colors.map(e=>e.clone()),S=V(x,b),O=M(x,b,z);d.forEach((e,l)=>{T.value=e.value,e.label=a(T),e.symbol=j(b,{type:i.symbolType,color:I[l],size:S,outline:O,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})}),i.valueExpression&&(w.valueExpression=i.valueExpression,w.valueExpressionTitle=i.valueExpressionTitle),i.legendOptions&&(w.legendOptions=new s(i.legendOptions));for(let n=0;n<v;n++){const e=d[n];e&&w.addUniqueValueInfo({value:e.value,label:e.label,symbol:j(b,{type:i.symbolType,color:I[n].clone(),size:S,outline:O,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}})})}i.defaultSymbolEnabled&&(w.defaultSymbol=j(b,{type:i.symbolType,color:x.noDataColor,size:S,outline:O,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),w.defaultLabel=o.other);for(const n of h)n.symbol=j(b,{type:i.symbolType,color:x.noDataColor,size:S,outline:O,meshInfo:{colorMixMode:i.colorMixMode,edgesType:i.edgesType}}),d.push(n);const q=[],U=w.uniqueValueInfos?.length??0,B=U===d.length?-1:U;if(B>-1)for(let n=B;n<d.length;n++)q.push({...d[n]});return l?.visualVariables?.length&&(w.visualVariables=l.visualVariables.map(e=>e.clone())),r?.minSize&&(w.visualVariables?w.visualVariables.push(r.minSize):w.visualVariables=[r.minSize]),{renderer:w,uniqueValueInfos:d,excludedUniqueValueInfos:q,typeScheme:D(x),basemapId:E.basemapId,basemapTheme:E.basemapTheme}}function X(e,i,l){const{field:n,numTypes:o,layer:t,view:s}=i,a=n?t.getField(n):null;if(a&&(B(a)||r(a))){const i=l.filter((e,i)=>i<o).map(e=>e.value),n=r(a)?null:u(i),m=n?p[n]:void 0;if(e.dateFormatOptions={fieldType:a.type,format:m},s){const i=t.layer;e.dateFormatOptions.timeZoneOptions={layerTimeZone:"preferredTimeZone"in i?i.preferredTimeZone:null,viewTimeZone:s.timeZone,datesInUnknownTimezone:"datesInUnknownTimezone"in i&&i.datesInUnknownTimezone}}}}async function Y(i,l){const n=i.uniqueValueInfos,r=await G({numColors:n.length,basemap:"gray",theme:"point-cloud-class",geometryType:"point",typeScheme:l}),o=r?.scheme,t="point-cloud-class"===o?.theme,s=t?o.colors:e(o?.colors??[],n.length);return Q(n,"value"),n.map((e,i)=>{const l=e.value;let n=null;return t?(n=s[l],n||(n=s[s.length-1])):n=s[i],new m({values:[l],color:n,label:e.label})})}async function _(e){const i=await A(e),{layer:l,view:n,signal:r,filter:o}=i,t={layer:l,field:i.field,field2:i.field2,field3:i.field3,valueExpression:i.valueExpression,returnAllCodedValues:i.returnAllCodedValues,view:n,filter:o,signal:r},[s,a,u]=await Promise.all([null!=i.statistics?i.statistics:O(t),i.outlineOptimizationEnabled?d({layer:l,view:n,signal:r,filter:o}).catch(E):null,i.sizeOptimizationEnabled?c({layer:l,view:n,signal:r,filter:o}).catch(E):null]);return W(s,i,a,u)}async function ee(e){const{creatorParameters:i,view:l,signal:n,filter:r,renderer:o}=await L(e),{layer:t,outlineOptimizationEnabled:s,sizeOptimizationEnabled:a}=i,[u,p]=await Promise.all([s?d({layer:t,view:l,signal:n,filter:r}).catch(E):null,a?c({layer:t,view:l,signal:n,filter:r}).catch(E):null]);return f(o,u?.visualVariables,h),f(o,p?.minSize,T),{renderer:o}}async function ie(e){const i=await $(e),l=null!=i.statistics?i.statistics:await O({layer:i.layer,field:i.field,signal:i.signal});return{renderer:new o({field:i.field,pointsPerInch:i.density??void 0,pointSizeAlgorithm:x(i.size),colorUniqueValueInfos:await Y(l,i.typeScheme)})}}export{ie as createPCClassRenderer,_ as createRenderer,G as getTypeSchemeData,ee as regenerateRenderer};
