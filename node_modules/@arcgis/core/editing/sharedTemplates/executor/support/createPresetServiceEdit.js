/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{isLoadedSharedTemplate as t,isSharedFeatureTemplate as o,isSharedPresetTemplate as s}from"../../../templateUtils.js";import{createFeatureServiceEdit as r}from"./createFeatureServiceEdit.js";import{maxDigitizingDisplayEdits as i}from"./executorUtils.js";import n from"../../../../geometry/Multipoint.js";import a from"../../../../geometry/Point.js";import l from"../../../../geometry/Polygon.js";import p from"../../../../geometry/Polyline.js";import{execute as h}from"../../../../geometry/operators/affineTransformOperator.js";import f from"../../../../geometry/operators/support/Transformation.js";function m({edits:n,geometry:a,mode:l,relationships:p,rotation:c,tag:u="",template:y}){const{definition:d}=y,Z=a.x-d.origin.x,M=a.y-d.origin.y,j=d.origin.hasZ&&a.hasZ?a.z-d.origin.z:0,R=g(d.origin.clone(),Z,M,j),w=(new f).rotate(c,R.x,R.y);for(const f of d.parts){if(n.length>i&&"digitizing"===l)break;const c=f.template;if(!t(c))throw new e("shared-template:template-not-loaded","A template part's template must be loaded before use");if(o(c)){let e=g(f.geometry,Z,M,j);w.isIdentity()||(e=h(e,w)),r({edits:n,geometry:e,relationships:p,tag:u,template:c})}else if(s(c)){const e=[];if(m({edits:w.isIdentity()?e:n,geometry:a,mode:l,relationships:p,rotation:0,tag:u,template:c}),!w.isIdentity())for(const t of e){const{geometry:e}=t.graphic;e&&"mesh"!==e.type&&(t.graphic.geometry=h(e,w),n.push(t))}}}return R}function g(e,t,o,s=0){if(!e)return null;if("point"===e.type)return new a({spatialReference:e.spatialReference,x:e.x+t,y:e.y+o,...e.hasZ?{z:e.z+s}:{},...e.hasM?{m:e.m}:{}});if("multipoint"===e.type){const r=[];if(e.hasZ&&e.hasM)for(let i=0;i<e.points.length;i++){const n=e.points[i];r.push([n[0]+t,n[1]+o,n[2]+s,n[3]])}else if(e.hasZ)for(let i=0;i<e.points.length;i++){const n=e.points[i];r.push([n[0]+t,n[1]+o,n[2]+s])}else if(e.hasM)for(let s=0;s<e.points.length;s++){const i=e.points[s];r.push([i[0]+t,i[1]+o,i[2]])}else for(let s=0;s<e.points.length;s++){const i=e.points[s];r.push([i[0]+t,i[1]+o])}return new n({spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM,points:r})}if("polygon"===e.type){const r=new l({spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM});for(let i=0;i<e.rings.length;i++){const n=e.rings[i],a=[];if(e.hasZ&&e.hasM)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+o,n[e][2]+s,n[e][3]]);else if(e.hasM)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+o,n[e][2]]);else if(e.hasZ)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+o,n[e][2]+s]);else for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+o]);r.addRing(a)}return r}if("polyline"===e.type){const r=new p({spatialReference:e.spatialReference,hasZ:e.hasZ,hasM:e.hasM});for(let i=0;i<e.paths.length;i++){const n=e.paths[i],a=[];if(e.hasZ&&e.hasM)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+o,n[e][2]+s,n[e][3]]);else if(e.hasZ)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+o,n[e][2]+s]);else if(e.hasM)for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+o,n[e][2]]);else for(let e=0;e<n.length;e++)a.push([n[e][0]+t,n[e][1]+o]);r.addPath(a)}return r}return e.clone()}export{m as createPresetServiceEdit,g as translate};
