/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import{createArcadeProfile as e,createArcadeExecutor as r}from"../../../../arcade.js";import o from"../../../../core/Accessor.js";import{debounce as s}from"../../../../core/promiseUtils.js";import{property as i}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as l}from"../../../../core/accessorSupport/decorators/subclass.js";import{UpdatingHandles as a}from"../../../../core/support/UpdatingHandles.js";import{fixFields as n}from"../../../../layers/support/fieldUtils.js";var u;const c=Symbol("FormExpressionArcadeExecutor");let p=class extends o{static{u=c}constructor(t){super(t),this[u]=!0,this._lastEvaluatedValue=null,this._abortController=new AbortController,this._initialExecutionComplete=!1,this._stale=!1,this._updatingTracking=new a,this._executeAsyncDebounced=s(async(t,e,r)=>{const o=await this.executor.executeAsync(t,{...e,abortSignal:r});return r.aborted?this._lastEvaluatedValue:(this._lastEvaluatedValue=o,this._initialExecutionComplete=!0,this._stale=!1,o)})}get initialExecutionComplete(){return this._initialExecutionComplete}get isAsync(){return this.executor.isAsync}get fieldsUsed(){return this.executor.fieldsUsed}get syntaxTree(){return this.executor.syntaxTree}get updating(){return this._updatingTracking.updating}get stale(){return this._stale}get geometryUsed(){return this.executor.geometryUsed}get variablesUsed(){return this.executor.variablesUsed}get lastEvaluatedValue(){return this._lastEvaluatedValue}abort(){this._abortController.abort()}execute(t,e){this._abortController=new AbortController;const r=this.executor.execute(t,{...e,abortSignal:this._abortController.signal});return this._lastEvaluatedValue=r,this._initialExecutionComplete=!0,r}async executeAsync(t,e){return this._abortController=new AbortController,this._updatingTracking.addPromise(this._executeAsyncDebounced(t,e??{},this._abortController.signal))}markStale(){this._stale=!0}reset(){this.abort(),this._lastEvaluatedValue=null,this._stale=!1}};t([i()],p.prototype,"_lastEvaluatedValue",void 0),t([i()],p.prototype,"_initialExecutionComplete",void 0),t([i()],p.prototype,"_stale",void 0),t([i()],p.prototype,"_updatingTracking",void 0),t([i({constructOnly:!0})],p.prototype,"executor",void 0),t([i()],p.prototype,"initialExecutionComplete",null),t([i()],p.prototype,"isAsync",null),t([i()],p.prototype,"fieldsUsed",null),t([i()],p.prototype,"syntaxTree",null),t([i()],p.prototype,"updating",null),t([i()],p.prototype,"stale",null),t([i()],p.prototype,"geometryUsed",null),t([i()],p.prototype,"variablesUsed",null),t([i()],p.prototype,"lastEvaluatedValue",null),p=t([l("esri.widgets.support.forms.expressions.FormExpressionArcadeExecutor")],p);const d=async(t,o)=>{const s=e("form-calculation"),i=await r(t,s,{});return o?.fieldsIndex&&(i.fieldsUsed=n(o.fieldsIndex,i.fieldsUsed)),new p({executor:i})};export{p as FormExpressionArcadeExecutor,d as createFormExpressionArcadeExecutor};
