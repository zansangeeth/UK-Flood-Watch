/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../core/Accessor.js";import"../../core/has.js";import s from"../../core/Logger.js";import{getOrCreateMapValue as r}from"../../core/MapUtils.js";import{isAbortError as o,createResolver as a}from"../../core/promiseUtils.js";import{property as i}from"../../core/accessorSupport/decorators/property.js";import"../../core/RandomLCG.js";import{subclass as n}from"../../core/accessorSupport/decorators/subclass.js";const l="#JSAPI_FORM_EXPRESSIONS_MANAGER_GEOMETRY";let c=class extends t{constructor(e){super(e),this._fieldReferencesLookup=new Map,this._fieldsAffectedLookup=new Map,this.preserveFieldValuesWhenHidden=!0,this._latestFieldValues={...e.feature.attributes}}initialize(){this._dependencyGraph=this._buildDependencyGraph()}destroy(){this.resetExecutors()}get _asyncExecutors(){return this.executors.filter(e=>e.isAsync)}get _baseContext(){const{editType:e,layer:t,map:s,originalFeature:r,spatialReference:o,timeZone:a}=this.arcadeContextInfo,i="scene"===t?.type&&null!=t.associatedLayer?t.associatedLayer:t;return[{$originalfeature:r,$editcontext:{editType:e},$layer:i,$featureset:i,$datastore:t?.url,$map:s},{rawOutput:!0,spatialReference:o??void 0,timeZone:a}]}set feature(e){this._latestFieldValues={...e?.attributes},this._set("feature",e)}evaluateAll(){return this._evaluate(this.executors)}evaluateAsyncExpressions(){return this._evaluate(this._asyncExecutors)}evaluateExpressions(e){return this._evaluate(e)}evaluateInvalidated(e){const{_fieldReferencesLookup:t,_latestFieldValues:s,feature:r}=this,o=new Set;for(const a of e)if(s[a]=r.getAttribute(a),t.has(a))for(const e of t.get(a))o.add(e);return this._evaluate([...o])}async evaluateInvalidatedByGeometry(){if(this._fieldReferencesLookup.has(l))return this._evaluate([...this._fieldReferencesLookup.get(l)])}resetExecutors(){for(const e of this.executors)e.reset()}_buildDependencyGraph(){const{_fieldReferencesLookup:e,_fieldsAffectedLookup:t,executors:s,preserveFieldValuesWhenHidden:o}=this,a=new Map(this.fieldInputs.map(e=>[e.name,e])),i=!1===o,n=new Map(s.map(e=>[e,new Array]));for(const c of s){for(const s of c.fieldsUsed){r(e,s,()=>new Set).add(c);const o=a.get(s);[o?.valueExpressionExecutor,o?.editableExpressionExecutor,i?o?.group?.visibilityExpressionExecutor:null,i?o?.visibilityExpressionExecutor:null].filter(e=>null!=e&&e!==c).forEach(e=>{n.get(e).push(c);r(t,e,()=>new Set).add(o)})}if(c.geometryUsed){r(e,l,()=>new Set).add(c)}}return n}async _evaluate(e){const t=new Map,{_dependencyGraph:r,_fieldsAffectedLookup:a,_latestFieldValues:i}=this;for(const s of e)u(s,t,r);for(const[s,{resolver:l,dependencyPromises:c}]of t){Promise.all(c).then(async()=>{const[e,t]=this._makeContext(i);return s.executeAsync(e,t)}).then(()=>{if(a.has(s))for(const e of a.get(s))this._latestFieldValues[e.name]=e.value;l.resolve()},e=>{!e||o(e)||p(e)||s.markStale(),l.reject(e)})}const n=(await Promise.allSettled(Array.from(t.values(),({resolver:e})=>e.promise))).filter(e=>"rejected"===e.status&&!(o(e.reason)||p(e.reason)));if(n.length>0){const e=new AggregateError(n,`One or more expression executions failed. First error message: ${n[0].reason}`);throw s.getLogger(this).error(e),e}}_makeContext(e){const[t,s]=this._baseContext,r=this.feature.clone();return r.attributes=e,[{...t,$feature:r},s]}get test(){}};e([i()],c.prototype,"_asyncExecutors",null),e([i()],c.prototype,"_baseContext",null),e([i()],c.prototype,"feature",null),e([i({constructOnly:!0})],c.prototype,"preserveFieldValuesWhenHidden",void 0),e([i()],c.prototype,"executors",void 0),e([i()],c.prototype,"fieldInputs",void 0),e([i()],c.prototype,"arcadeContextInfo",void 0),c=e([n("esri.widgets.FeatureForm.FormExpressionsManager")],c);const u=(e,t,s)=>{if(t.has(e))return;const r=a();t.set(e,{resolver:r,dependencyPromises:[]}),e.abort();const o=s.get(e);for(const a of o)u(a,t,s),t.get(a).dependencyPromises.push(r.promise)},p=e=>e&&"object"==typeof e&&"message"in e&&"Cancelled"===e.message;export{c as FormExpressionsManager};
