/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../Graphic.js";import{isSome as t}from"../../../../core/arrayUtils.js";import i from"../../../../core/Logger.js";import{waitTick as o,throwIfAborted as r,isAbortError as a}from"../../../../core/promiseUtils.js";import s from"../../../../geometry/Polygon.js";import{projectWithZConversion as n}from"../../../../geometry/projectionUtils.js";import{convertOrientationToPixelLocation as l}from"../../../../layers/orientedImagery/transformations/utils.js";import{fixedImageSize as c}from"../../constants.js";import{activePolygonSymbol as p,polygonSymbol as u}from"../../symbols.js";class m{constructor(m){this.viewModel=m,this.createFootprints=async t=>{await o(t);const{coveragePolygons:i,currentBestFeature:r,isAdditionalCoverageVisible:a}=this.viewModel;for(const o of i)o?.imageID===r.attributes.objectId?this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:o?.imageID},geometry:o,symbol:p,visible:!1}):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:o?.imageID},geometry:o,symbol:u.clone(),visible:a}))},this.updateFootprint=async(o,l,u)=>{const{activeViewer:m,mode:d,currentBestFeature:g,currentCoverageVisible:v,footprintExtent:f}=this.viewModel,w="video"===d?c:m?.imageSize,h=l??g;if(g&&w&&f&&h)try{const i=await this.viewModel.getMapPoint(o,{feature:h,mode:"default",imageSize:w});r(u);const a=i.filter(t);if(!a.length)return;const l=[a.map(({x:e,y:t})=>[e,t,1])];l[0].push(l[0][0]);const c=new s({rings:l,spatialReference:a[0].spatialReference}),m=this.viewModel.view?.spatialReference.equals(c.spatialReference)?c:await n(c,this.viewModel.view.spatialReference,u);this.viewModel.updateCurrentCoveragePolygon(new e({geometry:m,attributes:{imageID:h.attributes.objectId},symbol:p,visible:v}))}catch(y){a(y)||i.getLogger(this.viewModel).error("update-footprint",y)}else this.viewModel.updateCurrentCoveragePolygon(null)},this.updateFootprintPanorama=async(t,i)=>{const{horizontalFieldOfView:o,pitch:a,verticalFieldOfView:u,yaw:m,feature:d}=t,{activeViewer:g,currentBestFeature:v,currentCoverageVisible:f,footprintExtent:w,mode:h}=this.viewModel,y="video"===h||"panoramic-video"===h?c:g?.imageSize,b=d??v;if(!b||!y||!w)return void this.viewModel.updateCurrentCoveragePolygon(null);const{cameraPitch:M,objectId:C}=b.attributes;if(a+M-u/2>180)return void this.viewModel.updateCurrentCoveragePolygon(null);const j=[],P=u/2,F=o/2,I=a-P,R=M+I,D=M+(a+P);if(R>180)return void this.viewModel.updateCurrentCoveragePolygon(null);const V=I<0,x=[-F,P],z=[F,P],S=[F,-P],B=[-F,-P];if(R<180&&D>180){j.push(V?S:B);const e=Math.floor(o/5),t=o/e;for(let i=0;i<=e;i++)j.push([i*t-F,90-a]);j.push(V?B:S)}D<180&&(j.push(x,z),V?j.push(B,S):j.push(S,B));const U=j.map(([e,t])=>l(m+e,a+t,y[0],y[1])),q=await this.viewModel.getMapPoint(U,{feature:b,mode:"panorama",imageSize:y});r(i);const E=[q.map(({x:e,y:t})=>[e,t,1])];E[0].push(E[0][0]);const L=new s({rings:E,spatialReference:q[0].spatialReference}),O=this.viewModel.view?.spatialReference.equals(L.spatialReference)?L:await n(L,this.viewModel.view.spatialReference,i);this.viewModel.updateCurrentCoveragePolygon(new e({geometry:O,attributes:{imageID:C},symbol:p.clone(),visible:f}))}}}export{m as default};
