/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../../Graphic.js";import{isSome as t}from"../../../../core/arrayUtils.js";import{throwIfAborted as i,waitTick as o}from"../../../../core/promiseUtils.js";import a from"../../../../geometry/Mesh.js";import r from"../../../../geometry/Point.js";import{projectWithZConversion as s}from"../../../../geometry/projectionUtils.js";import{MeshVertexAttributes as n}from"../../../../geometry/support/MeshVertexAttributes.js";import{projectVertices as l,updateFrustum as c,createCoveragePolygon as p}from"../../../../layers/orientedImagery/core/coverageUtils.js";import{getMetersPerUnitOfSR as m}from"../../../../layers/orientedImagery/core/utils.js";import{fixedImageSize as u}from"../../constants.js";import{activeFrustumSymbol as f,additionalFrustumSymbol as d}from"../../symbols.js";class v{constructor(r){this.viewModel=r,this._updateBestFeatureFootprintElevation=!1,this._updatedElevationSampler=null,this.createFootprints=async o=>{const{coverageFrustums:r,currentBestFeature:c,isAdditionalCoverageVisible:p,view:m}=this.viewModel,u=r.filter(t);for(const t of u){let r=t.clone();if(!m.spatialReference.equals(r.spatialReference)){const{components:e,spatialReference:t,origin:c,vertexAttributes:p,vertexSpace:u}=r;if("local"===u.type){const e=await s(c,m.spatialReference,o);i(o),r.centerAt(e)}else{const s=p.position,c=Float64Array.from(await l([...s],t.clone(),m.spatialReference.clone(),o));i(o),r=new a({vertexAttributes:new n({position:c}),components:e,spatialReference:m.spatialReference.clone()})}}t.imageID===c.attributes.objectId?(this._updateBestFeatureFootprintElevation=!0,this.viewModel.bestFeatureFootprint=new e({attributes:{imageID:t.imageID},geometry:r,symbol:f.clone(),visible:!1})):this.viewModel.additionalFootprints.push(new e({attributes:{imageID:t.imageID},geometry:r,symbol:d.clone(),visible:p}))}},this.updateFootprint=async(o,a,r)=>{const{bestFeatureFootprint:n,currentBestFeature:l,activeViewer:p,footprintExtent:m,view:d,mode:v}=this.viewModel,y="video"===v?u:p?.imageSize,b=a??l;if(!(l&&n?.geometry&&y&&m&&b&&d?.spatialReference))return void this.viewModel.updateCurrentCoveragePolygon(null);const{attributes:{cameraHeight:F,location:R,cameraPitch:M,horizontalFieldOfView:A,verticalFieldOfView:x,cameraRoll:E},elevationSample:S}=b;let j=null;if(a&&(this._updatedElevationSampler=l.elevationSample,j=await h(a,d.spatialReference),this._updatedElevationSampler)){const e=this._updatedElevationSampler?.extent,t=a.attributes.geometry;if(e&&!e.contains(t)){const e=this.viewModel.selectedPoint;if(!e)return;e.x=a.geometry.x,e.y=a.geometry.y;const t=await this.viewModel.processFeatureElevation([a],e);t&&(this._updatedElevationSampler=t)}const[i]=g([j],this._updatedElevationSampler,a);i&&(j=i)}S&&this._updateBestFeatureFootprintElevation&&(this.updateGroundElevation([n]),this._updateBestFeatureFootprintElevation=!1);const I=R.toArray(),V=a&&j?j:n,{vertexAttributes:{position:P},spatialReference:z}=V.geometry,C=await w(P,z,R.spatialReference),_=await this.viewModel.getMapPoint(o,{feature:b,mode:"default",imageSize:y});i(r);let D=_.filter(t);if(!D.length)return;D[0].spatialReference.equals(R.spatialReference)||(D=await Promise.all(D.map(async e=>{const t=await s(e,R.spatialReference,r);return i(r),t})));const B=await c(o.map(({x:e,y:t})=>[e,t]),D.map(e=>e.toArray()),{cameraHeight:F,cameraLocation:I,cameraPitch:M,frustumVertices:C,horizontalFieldOfView:A,imageHeight:y[1],imageWidth:y[0],inSRS:{wkid:R.spatialReference.wkid},outSRS:{wkid:d.spatialReference.wkid},verticalFieldOfView:x,cameraRoll:E??0,options:r});this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:b.attributes.objectId},geometry:B,symbol:f.clone(),visible:this.viewModel.currentCoverageVisible}))},this.updateFootprintPanorama=async(t,i)=>{await o(i);const{horizontalFieldOfView:a,pitch:r,verticalFieldOfView:n,yaw:l,feature:c}=t,m=c?.clone()??this.viewModel.currentBestFeature?.clone();if(!m)return;const{attributes:u}=m;u.orientedImageryType=null,u.cameraHeading=(l+u.cameraHeading)%360,u.cameraPitch=r,u.horizontalFieldOfView=a,u.verticalFieldOfView=n,u.cameraRoll=0;const{frustum:d}=p(u);if(!d)return void this.viewModel.updateCurrentCoveragePolygon(null);const v=this.viewModel.view?.spatialReference.equals(d.spatialReference)?d.clone():await s(d.clone(),this.viewModel.view?.spatialReference,i);this.viewModel.updateCurrentCoveragePolygon(new e({attributes:{imageID:u.objectId},geometry:v,symbol:f.clone(),visible:this.viewModel.currentCoverageVisible}))}}updateGroundElevation(e){const{geometry:t,attributes:{elevation:i}}=this.viewModel.currentBestFeature,o=(i??0)*m(t.spatialReference);e.forEach(e=>{const{geometry:t}=e;switch(t?.type){case"mesh":{const{vertexAttributes:{position:e}}=t,i=Math.floor(e.length/3);for(let a=0;a<i;a+=1)e[3*a+2]+=o/m(t.spatialReference);break}case"point":t.z=(t.z??0)+o/m(t.spatialReference)}})}}async function w(e,t,i,o){return Float64Array.from((await Promise.all(e.reduce((e,t,i)=>{const o=Math.floor(i/3);return e[o]=e[o]??[],e[o].push(t),e},new Array).map(async e=>(await s(new r(e,t),i,o)).toArray()))).flat())}const h=async(t,o,r)=>{const{frustum:c}=p(t.attributes);let m=c.clone();if(!o.equals(m.spatialReference)){const{components:e,spatialReference:t,origin:o,vertexAttributes:c,vertexSpace:p}=m;if("local"===p.type){const e=await s(o,t,r);i(r),m.centerAt(e)}else{const o=c.position,s=Float64Array.from(await l([...o],t.clone(),t.clone(),r));i(r),m=new a({vertexAttributes:new n({position:s}),components:e,spatialReference:t.clone()})}}return new e({attributes:{imageID:c.imageID},geometry:m,symbol:f.clone(),visible:!1})},g=(e,t,i)=>{const{geometry:o}=i,a=t.queryElevation(o);for(const r of e){const{geometry:e}=r;switch(e?.type){case"mesh":{const{vertexAttributes:{position:t}}=e,i=Math.floor(t.length/3);for(let e=0;e<i;e++)t[3*e+2]+=a?.z??0;break}case"point":e.z=(e.z??0)+(a?.z??0)}}return e};export{v as default};
