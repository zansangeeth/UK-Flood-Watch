/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../../Graphic.js";import{createTask as a}from"../../../../core/asyncUtils.js";import{EsriPromise as i}from"../../../../core/Promise.js";import{throwIfAborted as s}from"../../../../core/promiseUtils.js";import{property as r}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/Logger.js";import"../../../../core/RandomLCG.js";import{subclass as o}from"../../../../core/accessorSupport/decorators/subclass.js";import n from"../../../../geometry/Polygon.js";import c from"../../../../geometry/Polyline.js";import{load as l}from"../../../../geometry/projectionUtils.js";import m from"../../../../geometry/SpatialReference.js";import{convertSphereVertexToPixelLocation as u,convertPixelToHeadingPitch as h,convertHeadingPitchToSphereVertex as d}from"../../../../layers/orientedImagery/transformations/utils.js";import{getPixelLocationFromSphereVertices as p,formatPixels as y}from"../../imageMeasurementUtils.js";import{SketchHandlerMixin as M}from"../../mixins/SketchHandlerMixin.js";let w=[],g=[],v=0,f=class extends(M(i)){constructor(e){super(e),this.type="measurement",this.measurementArray=[],this.pixelMeasurement=0,this.pixelAreaMeasurement=0,this.polygonVertices=[],this._calculationTask=null,this._distanceCalculation=0,this._areaCalculation=null}initialize(){this.addResolvingPromise(l())}async handleCreate(e){const t=e.toolEventInfo;switch(e.tool){case"polyline":await this.handlePolylineEvents(e,t);break;case"polygon":await this.handlePolygonEvents(e,t)}}handleDelete(e){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}handleDestroy(){this.resetDistanceMeasurements(),this.resetAreaMeasurements()}cursorUpdatePolylineHandler(e){const{mode:t,activeViewer:a}=this.viewModel;if("none"===t||!a?.imageSize)return;if("default"===t)this.measurementArray.push(e.coordinates);else{const t={x:e.coordinates[0],y:e.coordinates[1],z:e.coordinates[2]},i=u(t,a.imageSize[0],a.imageSize[1]);this.measurementArray.push([i.x,i.y])}const i=g.reduce((e,t)=>e+t,0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=i}async cursorUpdatePolygonHandler(e){const{mode:t,activeViewer:a}=this.viewModel;if("none"===t||!a?.imageSize)return;const i=e.coordinates;if(w=[...this.polygonVertices],"default"===t)w.push(i);else{const e={x:i[0],y:i[1],z:i[2]},t=u(e,a?.imageSize[0],a?.imageSize[1]);w.push([t.x,t.y])}if(w.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;const s=w[0];w=w.filter((e,t)=>0===t||t===w.length-1||JSON.stringify(e)!==JSON.stringify(s));const r=await this._getAreaFromTask(w);r?.area&&r?.perimeter&&(v=r.area)}async handlePolylineEvents(e,t){const a=!this.viewModel.accuracyParametersMissing;if("cancel"===e.state)return this.resetDistanceMeasurements(),this.viewModel.distanceMeasurementResult=0,this.viewModel.distanceAccuracyArray=[],void(this.viewModel.displayNewMeasurementButton=!0);if("complete"===e.state&&e.graphic){if(this.viewModel.activeViewer?.addGraphic(e.graphic),this.viewModel.triangularMeasurementActive){const t=e.graphic.geometry;await this.viewModel.processMeasurementVectors(t.paths[0]),await this._overlayFirstMeasurement(e.graphic,e.tool)}return this.viewModel.measurementGraphic=e.graphic,void this.resetDistanceMeasurements()}switch(t?.type){case"cursor-update":this.cursorUpdatePolylineHandler(t);break;case"vertex-add":if(this.measurementArray.length&&a){const e=await this._getAccuracyFromTask();e&&this.viewModel.distanceAccuracyArray.push(e)}this.vertexUpdatePolylineHandler()}const i=await this._getDistanceFromTask();this.pixelMeasurement=i??this.pixelMeasurement}async handlePolygonEvents(e,t){const a=!this.viewModel.accuracyParametersMissing;if("cancel"===e.state)return this.resetAreaMeasurements(),this.viewModel.areaMeasurementResult=0,this.viewModel.areaMeasurementAccuracy=0,void(this.viewModel.displayNewMeasurementButton=!0);if("complete"===e.state&&e.graphic){if(this.viewModel.activeViewer?.addGraphic(e.graphic),a){const e=await this._getAreaAccuracyFromTask(this.polygonVertices);this.viewModel.areaMeasurementAccuracy=e&&e>this.viewModel.areaMeasurementAccuracy?e:this.viewModel.areaMeasurementAccuracy}if(this.viewModel.triangularMeasurementActive){const t=e.graphic.geometry;await this.viewModel.processMeasurementVectors(t.rings[0]),await this._overlayFirstMeasurement(e.graphic,e.tool)}return this.viewModel.measurementGraphic=e.graphic,void this.resetAreaMeasurements()}switch(t?.type){case"vertex-add":await this.vertexAddPolygonHandler(t);break;case"cursor-update":await this.cursorUpdatePolygonHandler(t)}this.viewModel.areaMeasurementResult=v>0?v:this.pixelAreaMeasurement}async vertexAddPolygonHandler(e){const{mode:t,activeViewer:a}=this.viewModel,i=e.added,s=i[i.length-1];if(!Array.isArray(s)||"none"===t||!a?.imageSize)return;if("default"===t)this.polygonVertices.push(s);else{const e={x:s[0],y:s[1],z:s[2]},t=u(e,a?.imageSize[0],a?.imageSize[1]);this.polygonVertices.push([t.x,t.y])}if(this.polygonVertices.length<3||!this.viewModel.currentBestFeature||!this.viewModel.activeViewer?.imageSize)return;const r=this.polygonVertices[0];this.polygonVertices=this.polygonVertices.filter((e,t)=>0===t||t===this.polygonVertices.length-1||JSON.stringify(e)!==JSON.stringify(r));const o=await this._getAreaFromTask(this.polygonVertices);if(!o?.area||!o?.perimeter)return;const{area:n}=o;this.pixelAreaMeasurement=n}vertexUpdatePolylineHandler(){this.measurementArray=this.measurementArray.slice(-1);const e=g.reduce((e,t)=>e+t,0)+this.pixelMeasurement;this.viewModel.distanceMeasurementResult=e,this.pixelMeasurement>0&&g.push(this.pixelMeasurement)}resetDistanceMeasurements(){this.measurementArray=[],this.pixelMeasurement=0,g=[]}resetAreaMeasurements(){this.polygonVertices=[],this.pixelAreaMeasurement=0,v=0}async _overlayFirstMeasurement(e,t){switch(t){case"polyline":await this._overlayFirstDistanceMeasurement(e);break;case"polygon":await this._overlayFirstAreaGeometry(e)}}async _overlayFirstDistanceMeasurement(e){const{mode:a,activeTriangulatedViewer:i}=this.viewModel,s=e.geometry?.clone(),r=e.symbol?.clone(),o=i?.imageSize,n=[...s.paths[0]],l="default"===a;if("none"===a||"video"===a||!o)return;const u=l?n:p(n,o),h=l?y(u,!0):u,d=l?await this.viewModel.getMeasurementProperties():await this.viewModel.getMeasurementPropertiesPanoramic(),M=l?await this.viewModel.getMeasurementProperties(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.imageMeasurementViewer):await this.viewModel.getMeasurementPropertiesPanoramic(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.activeTriangulatedViewer);if(h?.length&&d&&M){const e=l?await this.viewModel.imageToImageTransform(h,d,M):await this.viewModel.imageToImageTransformPanoramic(h,d,M),a=e.map(e=>[e.x-.5,-.5-e.y]),i=e.slice(0,2).map(e=>_(e,o)),s=new c({paths:l?[a]:[i],spatialReference:m.WebMercator}),n=new t({geometry:s,symbol:r});await this.viewModel.editOverlayedGraphics(n)}}async _overlayFirstAreaGeometry(e){const{mode:a,activeTriangulatedViewer:i}=this.viewModel,s=e.geometry?.clone(),r=e.symbol?.clone(),o=i?.imageSize,c=[...s.rings[0]],l="default"===a;if("none"===a||"video"===a||!o)return;const u=l?c:p(c,o),h=l?y(u,!0):u,d=l?await this.viewModel.getMeasurementProperties():await this.viewModel.getMeasurementPropertiesPanoramic(),M=l?await this.viewModel.getMeasurementProperties(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.imageMeasurementViewer):await this.viewModel.getMeasurementPropertiesPanoramic(this.viewModel.currentBestFeatureMeasurementImage,this.viewModel.activeTriangulatedViewer);if(h?.length&&d&&M){const e=l?await this.viewModel.imageToImageTransform(h,d,M):await this.viewModel.imageToImageTransformPanoramic(h,d,M),a=e.map(e=>[e.x-.5,-.5-e.y]),i=e.slice(0,l?2:e.length).map(e=>_(e,o)),s=new n({rings:l?[a]:[i],spatialReference:m.WebMercator}),c=new t({geometry:s,symbol:r});await this.viewModel.editOverlayedGraphics(c)}}async _getAreaFromTask(e){const{mode:t}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=a(async a=>{this._areaCalculation=null;const i=await this.viewModel.calculateAreaMeasurement(e,t,a);s(a),this._areaCalculation=i}),await this._calculationTask.promise,this._areaCalculation}async _getDistanceFromTask(){const{mode:e}=this.viewModel;return this._calculationTask?.abort(),this._calculationTask=a(async t=>{this._distanceCalculation=0;const a=await this.viewModel.calculateDistanceMeasurement(this.measurementArray,e,t);s(t),this._distanceCalculation=a}),await this._calculationTask.promise,this._distanceCalculation}async _getAccuracyFromTask(){const{mode:e}=this.viewModel;return"none"===e?null:(this._calculationTask?.abort(),this._calculationTask=a(async t=>{this._distanceCalculation=0;const a="default"===e?await this.viewModel.calculateAccuracy(this.measurementArray,"distance",t):await this.viewModel.calculateAccuracyPanoramic(this.measurementArray,"distance",void 0,t);s(t),this._distanceCalculation=a}),await this._calculationTask.promise,this._distanceCalculation)}async _getAreaAccuracyFromTask(e){const{mode:t}=this.viewModel;return"none"===t?null:(this._calculationTask?.abort(),this._calculationTask=a(async a=>{this._distanceCalculation=0;const i="default"===t?await this.viewModel.calculateAccuracy(e,"area",a):await this.viewModel.calculateAccuracyPanoramic(e,"area",void 0,a);s(a),this._distanceCalculation=i}),await this._calculationTask.promise,this._distanceCalculation)}};e([r()],f.prototype,"type",void 0),e([r()],f.prototype,"measurementArray",void 0),e([r()],f.prototype,"pixelMeasurement",void 0),e([r()],f.prototype,"pixelAreaMeasurement",void 0),e([r()],f.prototype,"polygonVertices",void 0),f=e([o("esri.widgets.OrientedImageryViewer.adapters.sketch.MeasurementAdapter")],f);const A=f,_=(e,t)=>{const{heading:a,pitch:i}=h(e,t[0],t[1]);return d(a,i)};export{A as default};
