/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../Color.js";import{isRGB as r}from"../../core/colorUtils.js";import{clone as i}from"../../core/lang.js";import s from"../../layers/support/FieldsIndex.js";import{createRendererExpression as t}from"../../support/ArcadeExpression.js";import{normalizeDashEffectTemplate as o,toLowerCaseProps as a,normalizePrimitiveOverrideProps as c,attributesToFields as l,analyzeTextParts as n,assignTextValuesFromFeature as p,uncapitalize as f}from"./utils.js";import m from"../../views/2d/arcade/callExpressionWithFeature.js";const y=e=>{if(!e)return[0,0,0,0];const{r,g:i,b:s,a:t}=e;return[r,i,s,255*t]};class v{static findApplicableOverrides(e,r,i){if(e&&r){if(e.primitiveName){let s=!1;for(const r of i)if(r.primitiveName===e.primitiveName){s=!0;break}if(!s)for(const t of r)t.primitiveName===e.primitiveName&&i.push(t)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)v.findApplicableOverrides(s,r,i);if(e.symbolLayers)for(const s of e.symbolLayers)v.findApplicableOverrides(s,r,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const s of e.effects)v.findApplicableOverrides(s,r,i);if(e.markerPlacement&&v.findApplicableOverrides(e.markerPlacement,r,i),"CIMVectorMarker"===e.type){if(e.markerGraphics)for(const s of e.markerGraphics)v.findApplicableOverrides(s,r,i),v.findApplicableOverrides(s.symbol,r,i)}else"CIMCharacterMarker"===e.type?v.findApplicableOverrides(e.symbol,r,i):"CIMHatchFill"===e.type?v.findApplicableOverrides(e.lineSymbol,r,i):"CIMPictureMarker"===e.type&&v.findApplicableOverrides(e.animatedSymbolProperties,r,i)}}}static findEffectOverrides(e,r){if(!e)return null;if("CIMGeometricEffectDashes"===e.type&&o(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const i=a(e),s=e.primitiveName,t=[];for(const o of r)o.primitiveName===s&&t.push(a(o));return{type:"cim-effect-param",effect:i,overrides:c(t)}}static async resolveSymbolOverrides(e,r,t,o,a,c,n){if(!e?.symbol)return null;let{symbol:p,primitiveOverrides:f}=e;const m=!!f;if(!m&&!o)return p;p=i(p),f=i(f);let y=!0;if(r||(r={attributes:{}},y=!1),m){if(y||(f=f.filter(e=>!e.valueExpressionInfo?.expression.includes("$feature"))),n||(f=f.filter(e=>!e.valueExpressionInfo?.expression.includes("$view"))),f.length>0){const e=l(r.attributes),i={spatialReference:t,fields:e,geometryType:a};await v.createRenderExpressions(f,i),v.evaluateOverrides(f,r,a??"esriGeometryPoint",c,n,new s(e))}v.applyOverrides(p,f)}return o&&v.applyDictionaryTextOverrides(p,r,o,null),p}static{this._expressionToRenderExpression=new Map}static async createRenderExpressions(e,r){const i=[];for(const s of e){const e=s.valueExpressionInfo;if(!e||v._expressionToRenderExpression.has(e.expression))continue;const o=t(e.expression,r.spatialReference);i.push(o),o.then(r=>v._expressionToRenderExpression.set(e.expression,r))}i.length>0&&await Promise.all(i)}static evaluateOverrides(e,i,s,t,o,a){const c={$view:{scale:o?.scale}};for(const l of e){l.value&&"object"==typeof l.value&&r(l.value)&&("Color"===l.propertyName||"StrokeColor"===l.propertyName)&&(l.value=y(l.value));const e=l.valueExpressionInfo;if(!e)continue;const o=v._expressionToRenderExpression.get(e.expression);o&&(l.value=m(o,i,c,s,a,t))}}static applyDictionaryTextOverrides(e,r,i,s,t="Normal"){if(e?.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const o=e.symbolLayers;if(!o)return;for(const a of o)a&&"CIMVectorMarker"===a.type&&v.applyDictionaryTextOverrides(a,r,i,s,"CIMTextSymbol"===e.type?e.textCase:t)}break;case"CIMVectorMarker":{const t=e.markerGraphics;if(!t)return;for(const e of t)e&&v.applyDictionaryTextOverrides(e,r,i,s)}break;case"CIMMarkerGraphic":{const o=e.textString;if(o&&o.includes("[")){const a=n(o,i);e.textString=p(r,a,s,t)}}}}static applyOverrides(e,r,i,s){if(e.primitiveName)for(const t of r)if(t.primitiveName===e.primitiveName){const r=f(t.propertyName);if(s&&s.push({cim:e,nocapPropertyName:r,value:e[r]}),i){let r=!1;for(const s of i)s.primitiveName===e.primitiveName&&(r=!0);r||i.push(t)}null!=t.value&&(e[r]=t.value)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const t of e.effects)v.applyOverrides(t,r,i,s);if(e.symbolLayers)for(const t of e.symbolLayers)v.applyOverrides(t,r,i,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const t of e.effects)v.applyOverrides(t,r,i,s);if("CIMVectorMarker"===e.type&&e.markerGraphics)for(const t of e.markerGraphics)v.applyOverrides(t,r,i,s),v.applyOverrides(t.symbol,r,i,s)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const i of e)void 0!==i.value&&(r+=`${i.primitiveName}${i.propertyName}${JSON.stringify(i.value)}`);return r}static toValue(r,i){if("DashTemplate"===r)return i.split(" ").map(e=>Number(e));if("Color"===r){const r=new e(i).toRgba();return r[3]*=255,r}return i}}export{v as OverrideHelper};
