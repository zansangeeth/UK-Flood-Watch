/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{isArrayLike as e}from"../../../core/arrayUtils.js";import{deg2rad as t}from"../../../core/mathUtils.js";import{clone as a,zeros as r}from"../../../core/libs/gl-matrix-2/factories/vec3f64.js";import i from"../../../geometry/Point.js";import{isElevationSource as n}from"../core/ElevationSourceDefinitions.js";import{rectifyMapPointPanoramic as o,rectifyMapPoint as c}from"./rectifyMapPoint.js";import{getWebMercatorScalingFactor as s,hasAngles as f,convertPixelToHeadingPitch as l,isElevationSampler as m,reducerFn as p,validatePixelsToTransform as h,validateRotationMatrix as u,computeFarplaneVertices as y,computeHFOVAndVFOV as d,vecToPoint as w,or as g,isUpdateElevationWithElevationSource as v,scaleAndAddWithFactor as x,computeNewReferenceCoordinates as M,projectiveTransform as R}from"./utils.js";import{worldToImage as A}from"./worldToImage.js";import{viewingLimit as P}from"../../../widgets/OrientedImageryViewer/constants.js";async function V(e,t,a){const{verticalFieldOfView:r,imageBoundaries:i,scalingFactor:n,farPlaneVertices:o,cameraLocation:c,pixelsToTransform:s,vecToPoint:f,pixelDepths:l}=S(e,t),m=new Array;return await j(s,o,i,f,t,m,c,n,r,a,l),Array.isArray(e)?m:m[0]}async function j(e,t,a,r,n,o,s,f,l,m,p){let h=n.averageElevation;const u=e.length;for(let y=0;y<u;y+=1){const u=e.at(y),d=L(t,a,u,r,n),w=p?.at(y);if("number"==typeof w){const e=F(d,s,f),t=w*f,a=[s[0]+e[0]*t,s[1]+e[1]*t,s[2]+e[2]*w];o.push(new i(a,n.cameraLocation.spatialReference));continue}if(m&&g("elevationSample"in m,v(m))){h=(await c(r(d),{x:u[0],y:u[1]},{...n,...m,farPlaneVertices:t.map(r)}))[2]}o.push(r(b(d,s,f,h,n.cameraPitch,l)))}}function F(e,t,a){const i=e[0]-t[0],n=e[1]-t[1],o=e[2]-t[2],c=Math.hypot(i,n)/a,s=Math.hypot(o,c)*a,f=r();return f[0]=i/s,f[1]=n/s,f[2]=o/s,f[2]=f[2]*a,f}function b(e,t,r,i,n,o){let c=a(e);const s=F(e,t,r);if(T(e[2],i,n,o)){const e=Math.abs((t[2]-i)/-s[2])*r;c=x(t,s,e,r)}else c[2]=i;return c}function T(e,t,a,r){return e<t||a+r/2<P}function L(e,t,a,r,i){let n=null;const o=9;let c,s=0,f=e,l=t;for(;s<=o;){const e=D(a,l,f,i);if(c=e.error,n=e.transformedPoint,g(c<=1,s===o))break;f=M(f,c,a,t),l=O(f,r,i),s++}return n}function O(e,t,a){return A(e.map(t),a).map(({x:e,y:t})=>[e,t,1])}function D(e,t,a,r){const{cameraLocation:n}=r,o=R(e,t,a),{x:c,y:s}=A(new i(o,n.spatialReference),r);return{transformedPoint:o,error:E(e,[c,s,1])}}function E(e,t){return Math.abs(e[0]-t[0])+Math.abs(e[1]-t[1])}function S(t,a){const r=e(t)||"items"in t?t:[t],{cameraLocation:n,rotationMatrix:o}=a;if(h(r,n),u(o),9!==o?.length)throw new Error("Rotation matrix is not provided or is not a valid 3x3 matrix");const c=s(n.y,n.spatialReference),f=y({...a,scalingFactor:c}),l=A(f.map(e=>new i(e,n.spatialReference)),a),{vfov:m}=d(a.horizontalFieldOfView,a.verticalFieldOfView,a.cameraRoll);return{cameraLocation:n.toArray(),imageBoundaries:l.map(({x:e,y:t})=>[e,t,1]),verticalFieldOfView:m,farPlaneVertices:f,scalingFactor:c,pixelsToTransform:r.map(e=>[e.x,e.y,1]),vecToPoint:w(n.spatialReference),pixelDepths:r.map(e=>B(e)?e.depth:void 0)}}function B(e){return"depth"in e&&"number"==typeof e.depth}async function H(e,a,r){const{cameraHeading:c,cameraLocation:h,farDistance:u,imageHeight:y,imageWidth:d,verticalFieldOfView:w}=a,g=s(h.y,h.spatialReference),v=u*g,x=new Array,[M,R,A]=h.toArray(),P=Array.isArray(e)?e:[e];for(const s of P){let e,P;const V=B(s),j=V?s.depth*g:v;if(f(s))e=s.heading,P=s.pitch;else{const t=l({x:s.x,y:s.y},d,y);e=t.heading,P=t.pitch}e=(e+c)%360;const F=[M+Math.sin(t(e))*Math.sin(t(P))*j,R+Math.cos(t(e))*Math.sin(t(P))*j,A+-Math.cos(t(P))*(V?s.depth:u)];if(V){x.push(new i(F,h.spatialReference));continue}let T=a.averageElevation;if(r&&(n(r)||m(r.elevationSample))){T=(await o(new i(F,h.spatialReference),{heading:e,pitch:P},{...a,...r,farPlaneVertices:p(u,u).map(([e,t])=>new i([h.x+e,h.y+t],h.spatialReference))}))[2]}x.push(new i(b(F,h.toArray(),g,T,P,w),h.spatialReference))}return Array.isArray(e)?x:x[0]}export{V as imageToWorld,H as imageToWorldPanoramic};
