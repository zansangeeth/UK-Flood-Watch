/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import e from"../../../core/Error.js";import{property as r}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/has.js";import"../../../core/Logger.js";import"../../../core/RandomLCG.js";import{subclass as s}from"../../../core/accessorSupport/decorators/subclass.js";import i from"../../../geometry/Polygon.js";import o from"./BaseRaster.js";import{clip as a}from"../rasterFunctions/clipUtils.js";import{approximateTransform as n}from"../rasterFunctions/pixelUtils.js";import{projectPolygon as l}from"../rasterFunctions/rasterProjectionHelper.js";import c from"../../../rest/support/FeatureSet.js";const p=40;let m=class extends o{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,e,r,s={}){const{rasters:i,rasterIds:o}=this.primaryRasters;let l=!1;const{interpolation:c}=s,p=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!s.requestRawData&&p&&(l=1===i.length&&!s.skipRasterFunction,s={...s,interpolation:"bilinear",requestRawData:l}),s.requestRawData&&i.length>1&&!this.hasUniqueSourceStorageInfo&&(l=!1,s={...s,requestRawData:!1});const m=i.map(i=>i.fetchPixels(t,e,r,s)),u=await Promise.all(m),h=u.map(t=>t.pixelBlock),d=l||s.requestRawData?u.map(t=>t.srcTilePixelSize):null;if(s.skipRasterFunction||h.every(t=>null==t))return u[0];const f=u.find(t=>null!=t.pixelBlock)?.extent??t;let y=this.rasterJobHandler?await this.rasterJobHandler.process({extent:f,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:o}):this.rasterFunction.process({extent:f,primaryPixelBlocks:h,primaryPixelSizes:d,primaryRasterIds:o});const{transformGrid:g}=u[0];if(!l||null==y||null==g){const t=s.noClip?null:this.getClippingGeometry(f.spatialReference);return!s.noClip&&null!=y&&t&&(y=await a(y,f,t)),{...u[0],pixelBlock:y}}const x={rows:g.spacing[0],cols:g.spacing[1]};let R;if(this.rasterJobHandler){R=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[y],srcMosaicSize:{width:y.width,height:y.height},destDimension:{width:e,height:r},coefs:g.coefficients,sampleSpacing:x,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:c,alignmentInfo:void 0,blockWidths:null},s)).pixelBlock}else R=n(y,{width:e,height:r},g.coefficients,x,c);const w=s.noClip?null:this.getClippingGeometry(t.spatialReference);return s.noClip||null==R||null==w||(R=await a(R,t,w)),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:R}}getClippingGeometry(t){const e=this._clippingGeometry.get("0");if(!t||!e)return e;const r=h(t);let s=this._clippingGeometry.get(r);return null!=s||(s=t.equals(e.spatialReference)?e:l(e,t),this._clippingGeometry.set(r,s)),s}async _open(t){const{rasterFunction:r}=this;r.isRoot=!0,this.primaryRasters?.rasters?.length?r.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=r.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach(t=>t.rasterJobHandler=this.rasterJobHandler));const{rasters:s,rasterIds:i}=this.primaryRasters,o=s.map(e=>e.rasterInfo?void 0:e.open(t));await Promise.all(o);const a=s.map(({rasterInfo:t})=>t),n=r.bind({rasterInfos:a,rasterIds:i});if(r.rawSourceRasterInfos=a,!n.success||0===a.length)throw new e("raster-function:open",`cannot bind the function: ${n.error??""}`);const l="Table"===r.functionName?r:r.functionArguments?.raster;"Table"===l?.functionName&&(r.rasterInfo.attributeTable=c.fromJSON(l.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const p=a[0];this.hasUniqueSourceStorageInfo=1===a.length||a.slice(1).every(t=>u(t,p)),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",r.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let e=t?.clippingGeometry;if(e&&"inside"===t.clippingType){const{extent:t}=this.rasterInfo,r=await import("../../../geometry/operators/densifyOperator.js"),s=await import("../../../geometry/operators/differenceOperator.js");let o=r.execute(i.fromExtent(t),2*(t.width+t.height)/p);o=l(o,e.spatialReference),e=s.execute(o,e)}this._clippingGeometry.clear(),e&&this._clippingGeometry.set("0",e)}};function u(t,e){const{storageInfo:r,pixelSize:s,spatialReference:i,extent:o}=t,{storageInfo:a,pixelSize:n,spatialReference:l,extent:c}=e;return s.x===n.x&&s.y===n.y&&i.equals(l)&&o.equals(c)&&r.blockHeight===a.blockHeight&&r.blockWidth===a.blockWidth&&r.maximumPyramidLevel===a.maximumPyramidLevel&&r.firstPyramidLevel===a.firstPyramidLevel&&r.pyramidBlockWidth===a.pyramidBlockWidth&&r.pyramidBlockHeight===a.pyramidBlockHeight&&r.pyramidScalingFactor===a.pyramidScalingFactor}function h(t){return String(t.wkid??t.wkt??t.wkt2)}t([r({type:String,json:{write:!0}})],m.prototype,"datasetFormat",void 0),t([r()],m.prototype,"tileType",void 0),t([r()],m.prototype,"rasterFunction",void 0),t([r()],m.prototype,"primaryRasters",void 0),m=t([s("esri.layers.support.rasterDatasets.FunctionRaster")],m);export{m as default};
