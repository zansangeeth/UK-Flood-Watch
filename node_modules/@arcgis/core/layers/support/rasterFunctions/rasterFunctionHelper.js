/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{toRGB as t}from"../../../core/colorUtils.js";import e from"../../../core/Error.js";import{clone as r}from"../../../core/lang.js";import n from"./ArithmeticFunction.js";import o from"./AspectFunction.js";import s from"./BandArithmeticFunction.js";import a from"./ClipFunction.js";import i from"./ColormapFunction.js";import c from"./ColormapToRGBFunction.js";import u from"./CompositeBandFunction.js";import m from"./ComputeChangeFunction.js";import l from"./ContrastBrightnessFunction.js";import p from"./ConvolutionFunction.js";import f from"./CurvatureFunction.js";import d from"./ExtractBandFunction.js";import g from"./GrayscaleFunction.js";import F from"./HillshadeFunction.js";import h from"./LocalFunction.js";import A from"./MaskFunction.js";import y from"./NDVIFunction.js";import b from"./RemapFunction.js";import j from"./ShadedReliefFunction.js";import C from"./SlopeFunction.js";import _ from"./StatisticsFunction.js";import R from"./StatisticsHistogramFunction.js";import N from"./StretchFunction.js";import S from"./TableFunction.js";const v=new Map;function w(t,e){const{rasterFunctionArguments:r}=t;if(!r)return;(r.rasters||[r.raster,r.raster2]).forEach(t=>{t&&"number"!=typeof t&&("string"==typeof t?t.startsWith("http")&&(e.includes(t)||e.push(t)):"rasterFunctionArguments"in t&&w(t,e))})}function T(t,n){n=n??{};try{if("function"in(t=r(t))&&"arguments"in t&&t.arguments){const r=$(t,new Map,n);if(L(r),!r.renderingRule)throw new e("raster-function-helper","Unsupported raster function json.");t=r.renderingRule}if("rasterFunction"in t){const e=k(t=B(t),n);return e.isRoot=!0,e}}catch{}throw new e("raster-function-helper","unsupported raster function json.")}function D(t,e){return"rasters"===e[0]&&Array.isArray(t.rasters)?t.rasters:e.map(e=>t[e])}function V(t){return!!(t&&"object"==typeof t&&t.rasterFunction&&t.rasterFunctionArguments)}function B(t){const{rasterFunction:e,rasterFunctionArguments:r}=t,n={};for(const o in r){let t=r[o];const e=o.toLowerCase();if("rasters"===e&&Array.isArray(t))n.rasters=t.map(t=>V(t)?B(t):t);else switch(V(t)&&(t=B(t)),e){case"dra":n.dra=t;break;case"pspower":n.psPower=t;break;case"pszfactor":n.psZFactor=t;break;case"bandids":n.bandIds=t;break;default:n[o[0].toLowerCase()+o.slice(1)]=t}}return"Local"!==e||n.rasters?.length||(n.rasters=["$$"]),{...t,rasterFunctionArguments:n}}function k(t,r){const{rasterFunction:n,rasterFunctionArguments:o}=t,s=t.outputPixelType?.toLowerCase();if(null==n||!v.has(n))throw new e("raster-function-helper",`unsupported raster function: ${n}`);const a=v.get(n),i=("function"==typeof a.ctor?a.ctor:a.ctor.default).fromJSON({...t,outputPixelType:s}),{rasterArgumentNames:c}=i,u=[],m=D(o,c),l="rasters"===c[0]||c.length>1,p=[];for(let e=0;e<m.length;e++){const t=m[e];let n;null==t||"string"==typeof t&&t.startsWith("$")?u.push(r?.raster):"string"==typeof t?r[t]&&u.push(r[t]):"number"!=typeof t&&"rasterFunction"in t&&(n=k(t,r),l||(i.functionArguments[c[e]]=n),u.push(n)),l&&p.push(n??t)}if(l&&("rasters"===c[0]?i.functionArguments.rasters=p:c.forEach((t,e)=>{i.functionArguments[t]=p[e]})),r){i.sourceRasters=u;const t=r.raster?.url;t&&(i.mainPrimaryRasterId=t)}return i}function x(t,e){if(t&&e)for(const r in t){const n=t[r];n&&"object"==typeof n&&"type"in n&&("RasterFunctionTemplate"===n.type?x(n.arguments,e):"RasterFunctionVariable"===n.type&&null!=e[n.name]&&(n.value=e[n.name]))}}function E(t,r){if(!t||"object"!=typeof t)return t;const{value:n}=t;if(!n||"object"!=typeof n)return t.isDataset?"$$":n;if(Array.isArray(n))return 0===n.length?[]:n.map(t=>t&&"object"==typeof t&&"RasterFunctionVariable"===t.type?E(t,r):t);if("value"in n&&["number","string","boolean"].includes(typeof n.value))return n.value;if(t.isDataset&&"Scalar"!==n.type)return"$$";if(!("type"in n))return n;let o=n;switch(n.type){case"Scalar":o=n.value;break;case"AlgorithmicColorRamp":o=M(n);break;case"MultiPartColorRamp":o={type:"multipart",colorRamps:n.ArrayOfColorRamp.map(M)};break;case"ArgumentArray":if(n.elements?.length&&"RasterStatistics"!==n.elements[0].type){const t=[];for(let o=0;o<n.elements.length;o++){const s=n.elements[o],{type:a}=s;if(a)if("RasterFunctionTemplate"===a){const{renderingRule:e}=$(s,r);t.push(e),null!=s._object_id&&r.set(s._object_id,e)}else{if("RasterFunctionVariable"!==a)throw new e("raster-function-helper","unsupported raster function json.");{const e=E(s,r);t.push(e),null!=s._object_id&&r.set(s._object_id,e)}}else t.push(s)}o=t}else o=n.elements}return null!=n._object_id&&r.set(n._object_id,o),o}function M(e){const r=e.algorithm??"esriHSVAlgorithm";let{FromColor:n,ToColor:o}=e;if(!Array.isArray(n)){const{r:e,g:r,b:o}=t({h:n.Hue,s:n.Saturation,v:n.Value});n=[e,r,o,n.AlphaValue]}if(!Array.isArray(o)){const{r:e,g:r,b:n}=t({h:o.Hue,s:o.Saturation,v:o.Value});o=[e,r,n,o.AlphaValue]}return{type:"algorithmic",algorithm:r,fromColor:n,toColor:o}}function $(t,e,r){r&&x(t,r);const n={renderingRule:{},templates:e};return H(t,n),n}function H(t,e){if(!t||!e.renderingRule)return;const{renderingRule:r,templates:n}=e,{function:o,arguments:s,_object_id:a}=t;if(!o||!s)return;null!=a&&n.set(a,r),r.rasterFunction=o.type.replace("Function",""),r.outputPixelType=o.pixelType;const i={};r.rasterFunctionArguments=i;for(const c in s){if("type"===c||"object_id"===c||"_object_ref_id"===c)continue;const t=s[c];t&&"object"==typeof t&&"type"in t&&("RasterFunctionTemplate"===t.type||"RasterFunctionVariable"===t.type)?("RasterFunctionVariable"===t.type?i[c]=E(t,n):(r.rasterFunctionArguments[c]={},H(t,{renderingRule:r.rasterFunctionArguments[c],templates:n})),null!=t._object_id&&n.set(t._object_id,i[c])):i[c]=t}switch(i.DEM&&!i.Raster&&(i.Raster=i.DEM,delete i.DEM),r.rasterFunction){case"Stretch":O(i);break;case"Colormap":G(i);break;case"Convolution":P(i);break;case"Mask":I(i)}}function L(t){const{renderingRule:r,templates:n}=t;if("object"!=typeof r||!r?.rasterFunctionArguments||!n.size)return;const{rasterFunctionArguments:o}=r;for(const s in o){const t=o[s],r="_object_ref_id"===s?t:t&&"object"==typeof t&&"_object_ref_id"in t?t._object_ref_id:null;if(null!=r){if(!n.has(r))throw new e("raster-function-helper",`unsupported raster function json. _object_ref_id: ${r} does not exist`);const t=n.get(r);"_object_ref_id"!==s?o[s]=t:t&&"object"==typeof t&&Object.assign(o,t);continue}t&&"object"==typeof t&&(t.rasterFunctionArguments&&L({renderingRule:t,templates:n}),Array.isArray(t)&&t.forEach((o,s)=>{if(o&&"object"==typeof o)if(null!=o._object_ref_id){if(!n.has(o._object_ref_id))throw new e("raster-function-helper",`unsupported raster function json. _object_ref_id: ${t} does not exist`);const a=n.get(r);a&&"object"==typeof a?Object.assign(o,a):t[s]=a}else L({renderingRule:o,templates:n})}))}}function O(t){t.Statistics?.length&&"object"==typeof t.Statistics&&(t.Statistics=t.Statistics.map(t=>[t.min,t.max,t.mean,t.standardDeviation])),null!=t.NumberOfStandardDeviation&&(t.NumberOfStandardDeviations=t.NumberOfStandardDeviation,delete t.NumberOfStandardDeviation)}function G(t){"randomcolorramp"===t.ColorRamp?.type?.toLowerCase()&&(delete t.ColorRamp,t.ColormapName="Random"),0===t.ColorSchemeType&&delete t.ColorRamp}function P(t){null!=t.ConvolutionType&&(t.Type=t.ConvolutionType,delete t.ConvolutionType)}function I(t){t.NoDataValues?.length&&"string"==typeof t.NoDataValues[0]&&(t.NoDataValues=t.NoDataValues.filter(t=>""!==t).map(t=>Number(t)))}v.set("Arithmetic",{desc:"Arithmetic Function",ctor:n,rasterArgumentNames:["rasters"]}),v.set("Aspect",{desc:"Aspect Function",ctor:o,rasterArgumentNames:["raster"]}),v.set("BandArithmetic",{desc:"Band Arithmetic Function",ctor:s,rasterArgumentNames:["raster"]}),v.set("Colormap",{desc:"Colormap Function",ctor:i,rasterArgumentNames:["raster"]}),v.set("ColormapToRGB",{desc:"ColormapToRGB Function",ctor:c,rasterArgumentNames:["raster"]}),v.set("CompositeBand",{desc:"CompositeBand Function",ctor:u,rasterArgumentNames:["rasters"]}),v.set("ComputeChange",{desc:"ComputeChange Function",ctor:m,rasterArgumentNames:["rasters"]}),v.set("Convolution",{desc:"Convolution Function",ctor:p,rasterArgumentNames:["raster"]}),v.set("ContrastBrightness",{desc:"Contrast Brightness Function",ctor:l,rasterArgumentNames:["raster"]}),v.set("ExtractBand",{desc:"ExtractBand Function",ctor:d,rasterArgumentNames:["raster"]}),v.set("Curvature",{desc:"Curvature Function",ctor:f,rasterArgumentNames:["raster"]}),v.set("Hillshade",{desc:"Hillshade Function",ctor:F,rasterArgumentNames:["raster"]}),v.set("ShadedRelief",{desc:"ShadedRelief Function",ctor:j,rasterArgumentNames:["raster"]}),v.set("Grayscale",{desc:"Grayscale Function",ctor:g,rasterArgumentNames:["raster"]}),v.set("Clip",{desc:"Clip Function",ctor:a,rasterArgumentNames:["raster"]}),v.set("Local",{desc:"Local Function",ctor:h,rasterArgumentNames:["rasters"]}),v.set("Mask",{desc:"Mask Function",ctor:A,rasterArgumentNames:["raster"]}),v.set("NDVI",{desc:"NDVI Function",ctor:y,rasterArgumentNames:["raster"]}),v.set("Remap",{desc:"Remap Function",ctor:b,rasterArgumentNames:["raster"]}),v.set("Slope",{desc:"Slope Function",ctor:C,rasterArgumentNames:["raster"]}),v.set("Statistics",{desc:"Focal Statistics Function",ctor:_,rasterArgumentNames:["raster"]}),v.set("StatisticsHistogram",{desc:"Statistics Histogram Function",ctor:R,rasterArgumentNames:["raster"]}),v.set("Stretch",{desc:"Stretch Function",ctor:N,rasterArgumentNames:["raster"]}),v.set("Table",{desc:"Attribute Table Function",ctor:S,rasterArgumentNames:["raster"]});export{T as create,w as getPrimaryRasterUrls,D as getRasterValues};
