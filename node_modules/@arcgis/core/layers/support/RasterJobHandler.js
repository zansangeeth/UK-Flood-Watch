/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../core/Error.js";import{open as r}from"../../core/workers/workers.js";import o from"./PixelBlock.js";class t{constructor(){this._workerThread=null,this._destroyed=!1}async initialize(){const e=await r("RasterWorker");this._destroyed?e.close():this._workerThread=e}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}async convertVectorFieldData(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const n=r.pixelBlock.getTransferableObject().pixelBlock,a=await this._workerThread.invoke("convertVectorFieldData",{pixelBlock:n,type:r.dataType},t);return a?new o(a):null}async convertPixelBlockToFeatures(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=await this._workerThread.invoke("convertPixelBlockToFeatures",{pixelBlock:r.pixelBlock.toJSON(),extent:r.extent.toJSON(),fieldNames:r.fieldNames,skipFactor:r.skipFactor,pixelIdOffset:r.pixelIdOffset,imageRowSize:r.imageRowSize},o),n=r.extent.spatialReference?.toJSON();return t.forEach(e=>e.geometry.spatialReference=n),t}computeStatisticsHistograms(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const{transferList:t,pixelBlock:n}=r.pixelBlock.getTransferableObject();return o?.transferPixelsToWorker&&(o={...o,transferList:t}),this._workerThread.invoke("computeStatisticsHistograms",{...r,pixelBlock:n},o)}async decode(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("decode",r,{...t,transferList:[r.data]});return n?new o(n):null}async symbolize(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const n=r.pixelBlock?.getTransferableObject().pixelBlock,a={extent:r.extent?.toJSON(),pixelBlock:n,simpleStretchParams:r.simpleStretchParams,bandIds:r.bandIds},i=await this._workerThread.invoke("symbolize",a,t);return i?new o(i):null}async highlightPixels(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t={pixelBlock:r.pixelBlock?.toJSON(),renderedPixelBlock:r.renderedPixelBlock?.toJSON(),highlightOptions:r.highlightOptions},n=await this._workerThread.invoke("highlightPixels",t,o);r.renderedPixelBlock.pixels=n.pixels,r.renderedPixelBlock.mask=n.mask,r.renderedPixelBlock.maskIsAlpha=n.maskIsAlpha}async updateSymbolizer(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=r?.rendererJSON?.histograms;await Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:r.toJSON(),histograms:t},o))}async updateRasterFunction(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");await Promise.all(this._workerThread.broadcast("updateRasterFunction",{rasterFunctionJSON:r.toJSON()},o))}async process(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("process",{extent:r.extent?.toJSON(),primaryPixelSizes:r.primaryPixelSizes?.map(e=>null!=e?e.toJSON():null),primaryPixelBlocks:r.primaryPixelBlocks.map(e=>e?.getTransferableObject().pixelBlock),primaryRasterIds:r.primaryRasterIds},t);return n?new o(n):null}async stretch(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const n={srcPixelBlock:r.pixelBlock.getTransferableObject().pixelBlock,stretchParams:r.stretchParams},a=await this._workerThread.invoke("stretch",n,t);return a?new o(a):null}async split(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const n={srcPixelBlock:r.pixelBlock.getTransferableObject().pixelBlock,tileSize:r.tileSize,maximumPyramidLevel:r.maximumPyramidLevel,useBilinear:r.useBilinear},a=await this._workerThread.invoke("split",n,t);return a&&a.forEach((e,r)=>{a.set(r,e?o.fromJSON(e):null)}),a}async clipTile(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const n=r.pixelBlock.getTransferableObject().pixelBlock,a={...r,pixelBlock:n},i=await this._workerThread.invoke("clipTile",a,t);return i?o.fromJSON(i):null}async estimateStatisticsHistograms(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.pixelBlock)return null;const t={srcPixelBlock:r.pixelBlock.getTransferableObject().pixelBlock};return await this._workerThread.invoke("estimateStatisticsHistograms",t,o)}async mosaicAndTransform(r,t){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");if(!r?.srcPixelBlocks?.length)return{pixelBlock:null};const n=r.srcPixelBlocks.map(e=>e?.getTransferableObject()),a={...r,srcPixelBlocks:n.map(e=>e?.pixelBlock)};if(t?.transferPixelsToWorker){const e=n.flatMap(e=>e?.transferList).filter(e=>null!=e);t={...t,transferList:e}}const i=await this._workerThread.invoke("mosaicAndTransform",a,t);return{pixelBlock:i.pixelBlock?new o(i.pixelBlock):null,localNorthDirections:i.localNorthDirections}}async createFlowMesh(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t={buffer:r.flowData.data.buffer,maskBuffer:r.flowData.mask.buffer,width:r.flowData.width,height:r.flowData.height},{meshType:n,simulationSettings:a}=r,i=await this._workerThread.invoke("createFlowMesh",{meshType:n,flowData:t,simulationSettings:a},{...o,transferList:[t.buffer,t.maskBuffer]});return{vertexData:new Float32Array(i.vertexBuffer),indexData:new Uint32Array(i.indexBuffer)}}getProjectionOffsetGrid(r,o){if(!this._workerThread)throw new e("raster-jobhandler:no-connection","no available worker connection");const t=null!=r.datumTransformation?r.datumTransformation.steps.map(e=>({wkid:e.wkid,wkt:e.wkt,isInverse:e.isInverse})):null,n=null!=r.rasterTransform?r.rasterTransform.toJSON():null,a={projectedExtent:r.projectedExtent.toJSON(),srcBufferExtent:r.srcBufferExtent.toJSON(),pixelSize:r.pixelSize,hasWrapAround:r.hasWrapAround,spacing:r.spacing,datumTransformationSteps:t,rasterTransform:n,isAdaptive:r.isAdaptive,includeGCSGrid:r.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",a,o)}}export{t as default};
