/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{clone as e}from"../../../core/lang.js";import{polygonCentroid as t,extentCentroid as i}from"../../../geometry/support/centroid.js";import{getPolygonExtent as s,getGeometryExtent as a}from"../../../geometry/support/extentUtils.js";import{toQuantizationTransform as r}from"../../../geometry/support/quantizationUtils.js";import{isValid as n,equals as o}from"../../../geometry/support/spatialReferenceUtils.js";import l from"./AttributesBuilder.js";import{cleanFromGeometryEngine as u,getGeometry as c,transformCentroid as m}from"./geometryUtils.js";import{project as d}from"./projectionSupport.js";import{getDateInNumber as h}from"./queryUtils.js";import{makeEdgeCandidate as f,makeVertexCandidate as p}from"./SnappingCandidate.js";import{isDateField as y,isDateOnlyField as g,isTimestampOffsetField as x,isStringField as T,isTimeOnlyField as F}from"../../support/fieldUtils.js";import I from"../../../rest/support/AutoIntervalBinParameters.js";import _ from"../../../rest/support/DateBinParameters.js";import{unitsDict as S}from"../../../rest/support/DateBinUtils.js";import V from"../../../rest/support/FixedBoundariesBinParameters.js";import b from"../../../rest/support/FixedIntervalBinParameters.js";import{calculateStringStatistics as v,calculateStatistics as R,processSummaryStatisticsResult as B,calculateUniqueValuesCount as z,createUVResult as M,calculateClassBreaks as A,resolveCBResult as N,calculateHistogram as D,getAttributeComparator as w,calculatePercentile as P,binIndex as q,getBinParams as Z,isNullCountSupported as j}from"../../../statistics/utils.js";import{utc as G}from"../../../time/constants.js";import{DateTime as C}from"luxon";const O="bin";class E{constructor(e,t,i){this.items=e,this.query=t,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.fieldsIndex=i.fieldsIndex,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.featureAdapter=i.featureAdapter}get size(){return this.items.length}createQueryResponseForCount(){const e=new l(this.query,this.featureAdapter,this.fieldsIndex);if(!this.query.outStatistics)return e.countDistinctValues(this.items);const{groupByFieldsForStatistics:t,having:i,outStatistics:s}=this.query,a=t?.length;if(!!!a)return 1;const r=new Map,n=new Map,o=new Set;for(const l of s){const{statisticType:s}=l,a="exceedslimit"!==s?l.onStatisticField:void 0;if(!n.has(a)){const i=[];for(const s of t){const t=this._getAttributeValues(e,s,this.items,r);i.push(t)}n.set(a,this._calculateUniqueValues(i,this.items,e.returnDistinctValues))}const u=n.get(a);for(const t in u){const{data:s,items:a}=u[t],r=s.join(",");i&&!e.validateItems(a,i)||o.add(r)}}return o.size}async createQueryResponse(){let e;if(this.query.outStatistics){e=this.query.outStatistics.some(e=>"exceedslimit"===e.statisticType)?this._createExceedsLimitQueryResponse():await this._createStatisticsQueryResponse(this.query,this.items)}else e=this._createFeatureQueryResponse(this.query);if(this.query.returnQueryGeometry){const t=this.query.geometry;n(this.query.outSR)&&!o(t.spatialReference,this.query.outSR)?e.queryGeometry=u({spatialReference:this.query.outSR,...d(t,t.spatialReference,this.query.outSR)}):e.queryGeometry=u({spatialReference:this.query.outSR,...t})}return e}createSnappingResponse(e,t,i){const s=this.featureAdapter,a=Q(this.hasZ,this.hasM),{point:r,mode:n}=e,o="number"==typeof e.distance?e.distance:e.distance.x,l="number"==typeof e.distance?e.distance:e.distance.y,u={candidates:[]},c="esriGeometryPolygon"===this.geometryType,m="esriGeometryPolyline"===this.geometryType||"esriGeometryPoint"===this.geometryType,d=this._getPointCreator(n,t,this.spatialReference,i),h=new U(null,0),y=new U(null,0),g={x:0,y:0,z:0};for(const x of this.items){const t=s.getGeometry(x);if(null==t)continue;const{coords:i}=t,n=t.isPoint?J:t.lengths;if(h.coords=i,y.coords=i,e.returnEdge){let e=0;for(let t=0;t<n.length;t++){const i=n[t],m=e;for(let t=0;t<i;t++,e+=a){if(!c&&t===i-1)continue;const n=h;n.coordsIndex=e;const p=y;p.coordsIndex=t===i-1?m:e+a;const T=g;if(!H(g,r,n,p))continue;const F=(r.x-T.x)/o,I=(r.y-T.y)/l,_=F*F+I*I;_<=1&&u.candidates.push(f(s.getObjectId(x),d(T),Math.sqrt(_),d(n),d(p)))}}}if("all"===e.vertexMode){let e=0;for(let t=0;t<n.length;t++){const i=n[t],m=e,f=y;f.coordsIndex=m;for(let t=0;t<i;t++,e+=a){const a=h;if(a.coordsIndex=e,c&&t===i-1&&a.x===f.x&&a.y===f.y)continue;const n=(r.x-a.x)/o,m=(r.y-a.y)/l,y=n*n+m*m;y<=1&&u.candidates.push(p(s.getObjectId(x),d(a),Math.sqrt(y)))}}}else if(m&&"ends"===e.vertexMode){let e=0;const t=[];for(let i=0;i<n.length;i++){t.push(e);const s=n[i];e+=s*a,!c&&s>1&&t.push(e-a)}for(const i of t){const e=h;e.coordsIndex=i;const t=(r.x-e.x)/o,a=(r.y-e.y)/l,n=t*t+a*a;n<=1&&u.candidates.push(p(s.getObjectId(x),d(e),Math.sqrt(n)))}}}return u.candidates.sort((e,t)=>e.distance-t.distance),u}_getPointCreator(e,t,i,s){const a=null==s||o(i,s)?e=>e:e=>d(e,i,s),{hasZ:r}=this,n=0;return"3d"===e?r&&t?({x:e,y:t,z:i})=>a({x:e,y:t,z:i}):({x:e,y:t})=>a({x:e,y:t,z:n}):({x:e,y:t})=>a({x:e,y:t})}async createSummaryStatisticsResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,minValue:n,maxValue:o,scale:l,timeZone:u,outStatisticTypes:c}=e,m=this.fieldsIndex.get(t),d=y(m)||g(m)||x(m),h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:l,timeZone:u},this.items),f=j({normalizationType:a,normalizationField:s,minValue:n,maxValue:o}),p={value:.5,fieldType:m?.type},F=T(m)?v({values:h,supportsNullCount:f,percentileParams:p,outStatisticTypes:c}):R({values:h,minValue:n,maxValue:o,useSampleStdDev:!a,supportsNullCount:f,percentileParams:p,outStatisticTypes:c});return B(F,c,d)}async createUniqueValuesResponse(e){const{field:t,valueExpression:i,domains:s,returnAllCodedValues:a,scale:r,timeZone:n}=e,o=await this._getDataValues({field:t,field2:e.field2,field3:e.field3,fieldDelimiter:e.fieldDelimiter,valueExpression:i,scale:r,timeZone:n},this.items,!1),l=z(o);return M(l,s,a,e.fieldDelimiter)}async createClassBreaksResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c,scale:m,timeZone:d}=e,h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:m,timeZone:d},this.items),f=A(h,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numClasses:c});return N(f,n)}async createHistogramResponse(e){const{field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c,scale:m,timeZone:d}=e,h=await this._getDataValues({field:t,valueExpression:i,normalizationField:s,normalizationType:a,normalizationTotal:r,scale:m,timeZone:d},this.items);return D(h,{field:t,normalizationField:s,normalizationType:a,normalizationTotal:r,classificationMethod:n,standardDeviationInterval:o,minValue:l,maxValue:u,numBins:c})}_sortFeatures(e,t,i){if(e.length>1&&t?.length)for(const s of t.slice().reverse()){const t=s.split(" "),a=t[0],r=this.fieldsIndex.get(a),n=!!t[1]&&"desc"===t[1].toLowerCase(),o=w(r?.type,n);e.sort((e,t)=>{const s=i(e,a,r),n=i(t,a,r);return o(s,n)})}}_createFeatureQueryResponse(e){const{items:t,geometryType:i,hasM:s,hasZ:a,objectIdField:n,spatialReference:o}=this,{outFields:l,outSR:c,quantizationParameters:m,resultRecordCount:d,resultOffset:h,returnZ:f,returnM:p}=e,y=null!=d&&t.length>(h||0)+d,g=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map(e=>this.fieldsIndex.get(e)));return{exceededTransferLimit:y,features:this._createFeatures(e,t),fields:g,geometryType:i,hasM:s&&p,hasZ:a&&f,objectIdFieldName:n,spatialReference:u(c||o),transform:m&&r(m)||null}}_createFeatures(e,t){const i=new l(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:n,quantizationParameters:o,returnGeometry:u,returnCentroid:d,maxAllowableOffset:h,resultOffset:f,resultRecordCount:p,returnZ:y=!1,returnM:g=!1}=e,x=a&&y,T=s&&g;let F=[],I=0;const _=[...t];if(this._sortFeatures(_,n,(e,t,s)=>i.getFieldValue(e,t,s)),this.geometryType&&(u||d)){const e=r(o)??void 0,t="esriGeometryPolygon"===this.geometryType||"esriGeometryPolyline"===this.geometryType;if(u&&!d)for(const s of _){const a=this.featureAdapter.getGeometry(s),r=this._addFeatureJSONMetadata(s,{attributes:i.getAttributes(s),geometry:c(this.geometryType,this.hasZ,this.hasM,a,h,e,x,T)});t&&a&&!r.geometry&&(r.centroid=m(this,this.featureAdapter.getCentroid(s,this),e)),F[I++]=r}else if(!u&&d)for(const s of _)F[I++]=this._addFeatureJSONMetadata(s,{attributes:i.getAttributes(s),centroid:m(this,this.featureAdapter.getCentroid(s,this),e)});else for(const s of _)F[I++]=this._addFeatureJSONMetadata(s,{attributes:i.getAttributes(s),centroid:m(this,this.featureAdapter.getCentroid(s,this),e),geometry:c(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(s),h,e,x,T)})}else for(const r of _){const e=i.getAttributes(r);e&&(F[I++]=this._addFeatureJSONMetadata(r,{attributes:e}))}const S=f||0;if(null!=p){const e=S+p;F=F.slice(S,Math.min(F.length,e))}return F}_addFeatureJSONMetadata(e,t){const i=this.featureAdapter.getMetadata?.(e);return void 0!==i&&(t.metadata=i),t}_createExceedsLimitQueryResponse(){let e=!1,t=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,s=Number.POSITIVE_INFINITY;for(const a of this.query.outStatistics??[])if("exceedslimit"===a.statisticType){t=null!=a.maxPointCount?a.maxPointCount:Number.POSITIVE_INFINITY,i=null!=a.maxRecordCount?a.maxRecordCount:Number.POSITIVE_INFINITY,s=null!=a.maxVertexCount?a.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)e=this.items.length>t;else if(this.items.length>i)e=!0;else{const t=Q(this.hasZ,this.hasM),i=this.featureAdapter;e=this.items.reduce((e,t)=>{const s=i.getGeometry(t);return e+(null!=s&&s.coords.length||0)},0)/t>s}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(e)}}]}}async _createStatisticsQueryResponse(e,t,i={attributes:{}}){const s=[],a=new Map,r=new Map,n=new Map,o=new Map,u=new l(e,this.featureAdapter,this.fieldsIndex),c=e.outStatistics,{groupByFieldsForStatistics:m,having:d,orderByFields:h,resultRecordCount:f}=e,p=m?.length,y=!!p,g=y?m[0]:null,x=y&&!this.fieldsIndex.get(g);for(const l of c??[]){const{outStatisticFieldName:e,statisticType:c}=l,h=l,f="exceedslimit"!==c?l.onStatisticField:void 0,F="percentile_disc"===c||"percentile_cont"===c,I="EnvelopeAggregate"===c||"CentroidAggregate"===c||"ConvexHullAggregate"===c,_=y&&1===p&&(f===g||x)&&"count"===c;if(y){if(!n.has(f)){const e=[];for(const i of m){const s=this._getAttributeValues(u,i,t,a);e.push(s)}n.set(f,this._calculateUniqueValues(e,t,!I&&u.returnDistinctValues))}const i=n.get(f);if(!i)continue;const s=Object.keys(i);for(const r of s){const{count:s,data:n,items:l,itemPositions:c}=i[r],p=n.join(",");if(!d||u.validateItems(l,d)){const i=o.get(p)||{attributes:{}};if(I){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:t}=await this._getAggregateGeometry(h,l);i.aggregateGeometries[t]=e}else{let r=null;if(_)r=s;else{const e=this._getAttributeValues(u,f,t,a),i=c.map(t=>e[t]);r=F&&"statisticParameters"in h?this._getPercentileValue(h,i):this._getStatisticValue(h,i,null,u.returnDistinctValues)}i.attributes[e]=r}let r=0;m.forEach((e,t)=>i.attributes[this.fieldsIndex.get(e)?e:"EXPR_"+ ++r]=n[t]),o.set(p,i)}}}else if(I){i.aggregateGeometries||(i.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:s}=await this._getAggregateGeometry(h,t);i.aggregateGeometries[s]=e}else{const s=this._getAttributeValues(u,f,t,a);i.attributes[e]=F&&"statisticParameters"in h?this._getPercentileValue(h,s):this._getStatisticValue(h,s,r,u.returnDistinctValues)}const S="min"!==c&&"max"!==c||!T(this.fieldsIndex.get(f))&&!this._isAnyDateField(f)?null:this.fieldsIndex.get(f)?.type;s.push({name:e,alias:e,type:S||"esriFieldTypeDouble"})}const F=y?Array.from(o.values()):[i];return this._sortFeatures(F,h,(e,t)=>e.attributes[t]),f&&(F.length=Math.min(f,F.length)),{fields:s,features:F}}_isAnyDateField(e){const t=this.fieldsIndex.get(e);return y(t)||g(t)||x(t)||F(t)}async _getAggregateGeometry(e,r){const{convexHull:n,union:o}=await import("../../../geometry/geometryEngineJSON.js"),{statisticType:l,outStatisticFieldName:u}=e,{featureAdapter:m,spatialReference:d,geometryType:h,hasZ:f,hasM:p}=this,y=r.map(e=>c(h,f,p,m.getGeometry(e))),g=n(d,y,!0)[0],x={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===l){const e=g?s(g):a(o(d,y));x.aggregateGeometries={...e,spatialReference:d},x.outStatisticFieldName=u||"extent"}else if("CentroidAggregate"===l){const e=g?t(g):i(a(o(d,y)));x.aggregateGeometries={x:e[0],y:e[1],spatialReference:d},x.outStatisticFieldName=u||"centroid"}else"ConvexHullAggregate"===l&&(x.aggregateGeometries=g,x.outStatisticFieldName=u||"convexHull");return x}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let n=null;n=i?.has(a)?i.get(a):T(this.fieldsIndex.get(a))||this._isAnyDateField(a)?v({values:t,returnDistinct:s}):R({values:s?[...new Set(t)]:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n);return n["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,o=this.fieldsIndex.get(i);return P(t,{value:r,orderBy:n,fieldType:o?.type,isDiscrete:"percentile_disc"===a})}_getAttributeValues(e,t,i,s){if(s.has(t))return s.get(t);const a=this.fieldsIndex.get(t),r=i.map(i=>e.getFieldValue(i,t,a));return s.set(t,r),r}_calculateUniqueValues(e,t,i){const s={},a=t.length;for(let r=0;r<a;r++){const a=t[r],n=[];for(const t of e)n.push(t[r]);const o=n.join(",");null==s[o]?s[o]={count:1,data:n,items:[a],itemPositions:[r]}:(i||s[o].count++,s[o].items.push(a),s[o].itemPositions.push(r))}return s}async _getDataValues(t,i,s=!0){const a=new l(this.query,this.featureAdapter,this.fieldsIndex),{valueExpression:r,scale:n,timeZone:o}=t;return r?a.getExpressionValues(i,r,{viewingMode:"map",scale:n,spatialReference:this.query.outSR||this.spatialReference},{geometryType:this.geometryType,hasZ:this.hasZ,hasM:this.hasM},o):a.getDataValues(i,e(t),s)}_calculateHistogramBins(e,t,i){if(null==t.min&&null==t.max)return[];const s=t.intervals,a=t.min??0,r=t.max??0,n=s.map(([e,t])=>({minValue:e,maxValue:t,count:0,items:[]}));for(let o=0;o<e.length;o++){const t=e[o],l=i[o];if(null!=t&&t>=a&&t<=r){const e=q(s,t);e>-1&&(n[e].count++,n[e].items.push(l))}}return n}async createQueryBinsResponse(e){const t=e.bin?.splitBy;if(!t)return this._createBinsResponse(e);const{value:i,outAlias:s,valueType:a}=t,r=[],n=[{name:s??i,alias:s??i,type:a??"esriFieldTypeString"},{name:O,alias:O,type:"esriFieldTypeInteger"}],o=new l(e,this.featureAdapter,this.fieldsIndex),u=new Map,c=[...this.items];this._sortFeatures(c,[i],(e,t,i)=>o.getFieldValue(e,t,i));const m=this._getAttributeValues(o,i,c,u),d=this._calculateUniqueValues([m],c,o.returnDistinctValues);for(const l in d){const{items:t}=d[l],a=await this._createBinsResponse(e,t);if(r.push(...a.features.map(e=>({...e,attributes:{...e.attributes,[s??i]:l}}))),a.fields)for(const e of a.fields)n.some(t=>t.name===e.name)||n.push(e)}return{fields:n,features:r}}async _createBinsResponse(e,t){const i=e.bin;switch(t=t??this.items,i.type){case"autoIntervalBin":return this._createAutoIntervalBinsResponse(I.fromJSON(i),e,t);case"dateBin":return this._createDateBinsResponse(_.fromJSON(i),e,t);case"fixedBoundariesBin":return this._createFixedBoundariesBinsResponse(V.fromJSON(i),e,t);case"fixedIntervalBin":return this._createFixedIntervalBinsResponse(b.fromJSON(i),e,t)}}async _createAutoIntervalBinsResponse(e,t,i){const{field:s,normalizationField:a,numBins:r,normalizationType:n,normalizationTotal:o,start:l,end:u}=e,c=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),m=Z(c,{field:s,normalizationField:a,normalizationType:n,normalizationTotal:o,numBins:r,minValue:h(l,!1),maxValue:h(u,!1)}),d=this._calculateHistogramBins(c,m,i);return this._createFeaturesFromHistogramBins(d,t)}async _createDateBinsResponse(e,t,i){const{field:s,interval:a,start:r,end:n,snapToData:o,returnFullIntervalBin:l}=e,u=a.unit,c=await this._getDataValues({field:e.field,timeZone:t.outTimeReference?.ianaTimeZone},i),m=F(this.fieldsIndex.get(s)),d=S.toJSON(u),f=c.filter(Boolean).sort((e,t)=>e-t),p=null!=r?h(r,m):f[0],y=null!=n?h(n,m):f[f.length-1],g=[];if(null!=p&&null!=y){const e={zone:t.outTimeReference?.ianaTimeZone??G},i=C.fromMillis(p,e),s=C.fromMillis(y,e);if("last"===o){let e=s;for(;e>i;){const t=e.minus({[d]:a.value});if(t<i){g.unshift([l?t.toMillis():i.toMillis(),e.toMillis()]);break}g.unshift([t.toMillis(),e.toMillis()]),e=t}}else{let e="first"===o?i:i.startOf(d);for(;e<=s;){const t=e.plus({[d]:a.value});if(t>s){g.push([e.toMillis(),l?t.toMillis():s.toMillis()]);break}g.push([e.toMillis(),t.toMillis()]),e=t}}}const x=this._calculateHistogramBins(c,{intervals:g,min:p,max:y},i);return this._createFeaturesFromHistogramBins(x,t)}async _createFixedBoundariesBinsResponse(e,t,i){const{field:s}=e,a=await this._getDataValues({field:s,timeZone:t.outTimeReference?.ianaTimeZone},i),r=F(this.fieldsIndex.get(s)),n=e.boundaries.map(e=>h(e,r)).sort((e,t)=>e-t),o=[];for(let c=0;c<n.length-1;c++)o.push([n[c],n[c+1]]);const l={intervals:o,min:n.at(0),max:n.at(-1)},u=this._calculateHistogramBins(a,l,i);return this._createFeaturesFromHistogramBins(u,t)}async _createFixedIntervalBinsResponse(e,t,i){const{field:s,interval:a,start:r,end:n}=e,o=await this._getDataValues({field:e.field,normalizationField:e.normalizationField,normalizationType:e.normalizationType,normalizationTotal:e.normalizationTotal,timeZone:t.outTimeReference?.ianaTimeZone},i),l=F(this.fieldsIndex.get(s)),u=Z(o,{field:s,classificationMethod:"defined-interval",definedInterval:a,minValue:h(r,l),maxValue:h(n,l)},!0),c=this._calculateHistogramBins(o,u,i);return this._createFeaturesFromHistogramBins(c,t)}async _createFeaturesFromHistogramBins(e,t){const{upperBoundaryAlias:i,lowerBoundaryAlias:s}=t,a=s||"lowerBoundary",r=i||"upperBoundary",n=[],o=[{name:a,alias:a,type:"esriFieldTypeDouble"},{name:r,alias:r,type:"esriFieldTypeDouble"}],l=t.bin?.stackBy?.value,u=t.bin?.stackBy?.outAlias;l&&o.push({name:O,alias:O,type:"esriFieldTypeInteger"},{name:u??l,alias:u??l,type:"esriFieldTypeString"});let c=0;const m="dateBin"===t.bin.type,d=t.outTimeReference?.ianaTimeZone;for(const h of e){const{minValue:e,maxValue:i,items:s}=h,f={attributes:{}};let p;if(f.attributes[a]=m&&d&&null!=e?C.fromMillis(e,{zone:d}).toISO():e,f.attributes[r]=m&&d&&null!=i?C.fromMillis(i,{zone:d}).toISO():i,l?(p=await this._createStatisticsQueryResponse({...t,groupByFieldsForStatistics:[l],orderByFields:[l]},s),f.attributes[O]=++c,"flat"===t.bin.jsonStyle?n.push(...p.features.map(({attributes:{EXPR_1:e,...t},...i})=>({...i,attributes:u??e?{...t,[u??e]:e,...f.attributes}:{...t,...f.attributes}}))):(f.stackedAttributes=p.features.map(({attributes:{EXPR_1:e,...t}})=>u??e?{...t,[u??e]:e}:t),n.push(f))):(t.bin?.splitBy&&(f.attributes[O]=++c),p=await this._createStatisticsQueryResponse(t,s,f),n.push(f)),p.fields)for(const t of p.fields)o.some(e=>e.name===t.name)||o.push(t)}return"desc"===t.binOrder&&n.reverse(),{fields:o,features:n}}}function H(e,t,i,s){const a=s.x-i.x,r=s.y-i.y,n=t.x-i.x,o=t.y-i.y,l=a*a+r*r;if(0===l)return!1;const u=n*a+o*r,c=Math.min(1,Math.max(0,u/l));return e.x=i.x+a*c,e.y=i.y+r*c,!0}function Q(e,t){return e?t?4:3:t?3:2}class U{constructor(e,t){this.coords=e,this.coordsIndex=t}get x(){return this.coords[this.coordsIndex]}get y(){return this.coords[this.coordsIndex+1]}get z(){return this.coords[this.coordsIndex+2]}}const J=[1];export{E as QueryEngineResult};
