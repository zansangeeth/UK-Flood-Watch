/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import e from"../../../core/Error.js";import{validateFields as t,validateWhere as i,validateHaving as s,numericFieldTypes as r,allDateAndTimeFieldTypes as o}from"./attributeSupport.js";import{checkProjectionSupport as n}from"./projectionSupport.js";import{checkSpatialQuerySupport as a}from"./spatialQuerySupport.js";import{loadArcade as l}from"../../../support/loadArcade.js";const u="unsupported-query";async function p(t,i){const s=t.bin;if(!s.onField&&!s.onExpression?.value||"autoIntervalBin"===s.type&&null==s.parameters.numberOfBins||"dateBin"===s.type&&(null==s.parameters.number||null==s.parameters.unit)||"fixedBoundariesBin"===s.type&&null==s.parameters.boundaries||"fixedIntervalBin"===s.type&&null==s.parameters.interval)throw new e(u,"Unsupported query options",{query:t});return d(t,i)}async function d(t,{fieldsIndex:i,geometryType:s,spatialReference:r,availableFields:o}){if(null!=t.geometryPrecision||t.multipatchOption&&"xyFootprint"!==t.multipatchOption||t.pixelSize||t.relationParam||t.text)throw new e(u,"Unsupported query options",{query:t});return c(i,o,t),m(i,o,t),Promise.all([a(t,s,r),n(r,t.outSR)]).then(()=>t)}function c(s,r,o){const{returnDistinctValues:n,outStatistics:a}=o,l=a?a.map(e=>e.outStatisticFieldName&&e.outStatisticFieldName.toLowerCase()).filter(Boolean):[];if("orderByFields"in o&&o.orderByFields&&o.orderByFields.length>0){const e=" asc",i=" desc",n=o.orderByFields.map(t=>{const s=t.toLowerCase();return s.includes(e)?s.split(e)[0]:s.includes(i)?s.split(i)[0]:t}).filter(e=>!l.includes(e));t(s,r,n,{expressionName:"orderByFields",query:o})}if("outFields"in o)if(o.outFields?.length)t(s,r,o.outFields,{expressionName:"outFields",query:o,allowedFieldTypes:"all"});else if(n)throw new e(u,"outFields should be specified for returnDistinctValues",{query:o});i(s,r,o.where,o)}const f=new Set([...r,...o]);function m(i,r,o){const{outStatistics:n,groupByFieldsForStatistics:a,having:l}=o,p=a?.length,d=n?.length;if(l){if(!p||!d)throw new e(u,"outStatistics and groupByFieldsForStatistics should be specified with having",{query:o});s(i,r,l,n,o)}if(d){if(!h(n))return;const s=n.map(e=>e.onStatisticField).filter(Boolean);t(i,r,s,{expressionName:"onStatisticFields",query:o}),p&&t(i,r,a,{expressionName:"groupByFieldsForStatistics",query:o});for(const a of n){const{onStatisticField:s,statisticType:n}=a;if(("percentile_disc"===n||"percentile_cont"===n)&&"statisticParameters"in a){const{statisticParameters:t}=a;if(!t)throw new e(u,"statisticParameters should be set for percentile type",{definition:a,query:o})}else i.get(s)&&"count"!==n&&"min"!==n&&"max"!==n&&t(i,r,[s],{expressionName:`outStatistics with '${n}' statistic type`,allowedFieldTypes:f,query:o})}}}async function y(t,i,{fieldsIndex:s,geometryType:r,spatialReference:o,availableFields:l}){if(null!=t.geometryPrecision||t.multipatchOption||t.pixelSize||t.relationParam||t.text||t.outStatistics||t.groupByFieldsForStatistics||t.having||t.orderByFields)throw new e(u,"Unsupported query options",{query:t});return c(s,l,t),Promise.all([F(s,l,i,t),a(t,r,o),n(o,t.outSR)]).then(()=>t)}async function F(i,s,r,o){let n=[];if(r.valueExpression){const{arcadeUtils:e}=await l();n=e.extractFieldNames(r.valueExpression)}if(r.field&&n.push(r.field),r.field2&&n.push(r.field2),r.field3&&n.push(r.field3),r.normalizationField&&n.push(r.normalizationField),!n.length&&!r.valueExpression)throw new e(u,"field or valueExpression is required",{params:r});t(i,s,n,{expressionName:"statistics",query:o})}function h(e){return null!=e&&e.every(e=>"exceedslimit"!==e.statisticType)}export{p as validateAttributeBinsQuery,d as validateQuery,y as validateStatisticsQuery};
