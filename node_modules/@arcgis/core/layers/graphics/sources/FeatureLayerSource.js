/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../config.js";import r from"../../../request.js";import{isSome as s,remove as a}from"../../../core/arrayUtils.js";import i from"../../../core/Error.js";import has from"../../../core/has.js";import{JSONMap as n}from"../../../core/jsonMap.js";import{Loadable as o}from"../../../core/Loadable.js";import u from"../../../core/Logger.js";import{setDeepValue as l}from"../../../core/object.js";import{debounce as c,after as d,throwIfAbortError as p}from"../../../core/promiseUtils.js";import{watch as y}from"../../../core/reactiveUtils.js";import{join as h}from"../../../core/urlUtils.js";import{generateBracedUUID as m}from"../../../core/uuid.js";import{property as f}from"../../../core/accessorSupport/decorators/property.js";import{subclass as g}from"../../../core/accessorSupport/decorators/subclass.js";import q from"../../../geometry/Extent.js";import w from"../../../geometry/SpatialReference.js";import S from"../../../geometry/support/MeshGeoreferencedVertexSpace.js";import{isRelativeVertexSpace as E}from"../../../geometry/support/meshVertexSpaceUtils.js";import{isOriginalExternal as O}from"../../../geometry/support/meshUtils/External.js";import{createFeatureEditResult as _,getFeatureJSON as b,getFeatureIds as R,getAttachmentEditsJSON as A,isProtectedOrPrivateVersionError as F,unpackEditResultData as I,createEditedFeatures as x}from"../applyEditsUtils.js";import{createDrawingInfo as v}from"./support/clientSideDefaults.js";import j from"./support/QueryTask.js";import{isHostedAgolService as T}from"../../support/arcgisLayerUrl.js";import{ensureLayerCredential as M}from"../../support/featureLayerUtils.js";import{getAssetMapTable as N}from"../../support/infoFor3D.js";import{executeQueryJSON as U}from"../../../rest/query/executeQueryJSON.js";import{unapplyEditsZUnitScaling as J}from"../../../rest/query/operations/editsZScale.js";import D from"../../../rest/support/Query.js";import k from"../../../time/TimeExtent.js";import{isSafeToEditVersion as C,isVersionInEditSession as L,isHistoricVersion as Q,currentSessionId as P}from"../../../versionManagement/support/versionManagementUtils.js";const V=new n({originalAndCurrentFeatures:"original-and-current-features",none:"none"}),$=new n({Started:"published",Publishing:"publishing",Stopped:"unavailable"});let G=class extends o{constructor(e){super(e),this.type="feature-layer",this.supportedSourceTypes=new Set(["Feature Layer","Oriented Imagery Layer","Table","Catalog Layer"]),this.refresh=c(async()=>{await this.load();const e=this.sourceJSON.editingInfo?.lastEditDate;if(null==e)return{dataChanged:!0,updates:{}};try{await this._fetchService(null)}catch{return{dataChanged:!0,updates:{}}}const t=e!==this.sourceJSON.editingInfo?.lastEditDate;return{dataChanged:t,updates:t?{editingInfo:this.sourceJSON.editingInfo,extent:this.sourceJSON.extent}:null}}),this._ongoingAssetUploads=new Map}load(e){const t=this.layer.sourceJSON,r=this._fetchService(t,{...e}).then(()=>this.layer.setUserPrivileges(this.sourceJSON.serviceItemId,e)).then(()=>this._ensureLatestMetadata(e));return this.addResolvingPromise(r),Promise.resolve(this)}initialize(){this.addHandles([y(()=>{const e=this.layer;return e&&"lastEditsEventDate"in e?e.lastEditsEventDate:null},e=>this._handleLastEditsEventChange(e))])}destroy(){this._removeEditInterceptor()}get queryTask(){const{capabilities:e,parsedUrl:t,gdbVersion:r,spatialReference:s,fieldsIndex:a,uniqueIdFields:i}=this.layer,n="infoFor3D"in this.layer?this.layer.infoFor3D:null,o="dynamicDataSource"in this.layer?this.layer.dynamicDataSource:null,u=has("featurelayer-pbf")&&e?.query.supportsFormatPBF&&null==n;return new j({dynamicDataSource:o,fieldsIndex:a,gdbVersion:r,infoFor3D:n,pbfSupported:u,queryAttachmentsSupported:e?.operations?.supportsQueryAttachments??!1,sourceSpatialReference:s,uniqueIdFields:i,url:t.path})}async addAttachment(e,t){await this.load();const{layer:s}=this;await M(s,"editing");const a=e.attributes[s.objectIdField],i=s.parsedUrl.path+"/"+a+"/addAttachment",n=this._getLayerRequestOptions(),o=this._getFormDataForAttachment(t,n.query);try{const e=await r(i,{body:o});return _(e.data.addAttachmentResult)}catch(u){throw this._createAttachmentErrorResult(a,u)}}async updateAttachment(e,t,s){await this.load();const{layer:a}=this;await M(a,"editing");const i=e.attributes[a.objectIdField],n=a.parsedUrl.path+"/"+i+"/updateAttachment",o=this._getLayerRequestOptions({query:{attachmentId:t}}),u=this._getFormDataForAttachment(s,o.query);try{const e=await r(n,{body:u});return _(e.data.updateAttachmentResult)}catch(l){throw this._createAttachmentErrorResult(i,l)}}async applyEdits(e,t){await this.load();const{layer:a}=this;await M(a,"editing");const n="infoFor3D"in a?a.infoFor3D:null,o=null!=n,u=o||(t?.globalIdUsed??!1),l=o?await this._uploadMeshesAndGetAssetMapEditsJSON(e):null,c=e.addFeatures?.map(e=>b(this.layer,e,n))??[],d=(await Promise.all(c)).filter(s),p=e.updateFeatures?.map(e=>b(this.layer,e,n))??[],y=(await Promise.all(p)).filter(s),h=R(this.layer,e.deleteFeatures,u);J(d,y,a.spatialReference);const m=await A(this.layer,e),f=a.capabilities.editing.supportsAsyncApplyEdits&&o,g=t?.gdbVersion||a.gdbVersion,q={gdbVersion:g,rollbackOnFailure:t?.rollbackOnFailureEnabled,useGlobalIds:u,returnEditMoment:t?.returnEditMoment,usePreviousEditMoment:t?.usePreviousEditMoment,async:f};await C(this.layer.url,g,!0);const w=L(this.layer.url,g||null);if(await Q(a.url,g,a.historicMoment))throw new i("feature-layer-source:historic-version","Editing a historic version is not allowed");t?.returnServiceEditsOption?(q.edits=JSON.stringify([{id:a.layerId,adds:d.length?d:null,updates:y.length?y:null,deletes:h.length?h:null,attachments:m,assetMaps:l}]),q.returnServiceEditsOption=V.toJSON(t?.returnServiceEditsOption),q.returnServiceEditsInSourceSR=t?.returnServiceEditsInSourceSR):(q.adds=d.length?JSON.stringify(d):null,q.updates=y.length?JSON.stringify(y):null,q.deletes=h.length?u?JSON.stringify(h):h.join(","):null,q.attachments=m&&JSON.stringify(m),q.assetMaps=null!=l?JSON.stringify(l):void 0);const S=this._getLayerRequestOptions({method:"post",query:q});w&&(S.authMode="immediate",S.query.returnEditMoment=!0,S.query.sessionId=P);const E=t?.returnServiceEditsOption?a.url:a.parsedUrl.path;let O;try{O=f?await this._asyncApplyEdits(E+"/applyEdits",S):await r(E+"/applyEdits",S)}catch(_){if(!F(_))throw _;S.authMode="immediate",O=f?await this._asyncApplyEdits(E+"/applyEdits",S):await r(E+"/applyEdits",S)}return this._createEditsResult(O)}async deleteAttachments(e,t){await this.load();const{layer:s}=this;await M(s,"editing");const a=e.attributes[s.objectIdField],i=s.parsedUrl.path+"/"+a+"/deleteAttachments";try{return(await r(i,this._getLayerRequestOptions({query:{attachmentIds:t.join(",")},method:"post"}))).data.deleteAttachmentResults.map(_)}catch(n){throw this._createAttachmentErrorResult(a,n)}}fetchRecomputedExtents(e={}){const t=e.signal;return this.load({signal:t}).then(async()=>{const t=this._getLayerRequestOptions({...e,query:{returnUpdates:!0}}),{layerId:s,url:a}=this.layer,{data:i}=await r(`${a}/${s}`,t),{id:n,extent:o,fullExtent:u,timeExtent:l}=i,c=o||u;return{id:n,fullExtent:c&&q.fromJSON(c),timeExtent:l&&k.fromJSON({start:l[0],end:l[1]})}})}async queryAttachments(e,t={}){await this.load();const r=this._getLayerRequestOptions(t);return this.queryTask.executeAttachmentQuery(e,r)}async queryFeatures(e,t){await this.load();const r=await this.queryTask.execute(e,{...t,query:this._createRequestQueryOptions(t)});if(e.outStatistics?.length&&r.features.length){const t=new Map;if(r.features.forEach(r=>{const s=r.attributes;e.outStatistics?.forEach(({outStatisticFieldName:e})=>{if(e){const r=e.toLowerCase();r&&r in s&&e!==r&&(s[e]=s[r],delete s[r],t.set(r,e))}})}),null!=r.fields)for(const e of r.fields){const r=t.get(e.name.toLowerCase());null!=r&&(e.name=r)}}return r}async queryFeaturesJSON(e,t){return await this.load(),this.queryTask.executeJSON(e,{...t,query:this._createRequestQueryOptions(t)})}async queryObjectIds(e,t){return await this.load(),this.queryTask.executeForIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryFeatureCount(e,t){return await this.load(),this.queryTask.executeForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryExtent(e,t){return await this.load(),this.queryTask.executeForExtent(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeatures(e,t){return await this.load(),this.queryTask.executeRelationshipQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryRelatedFeaturesCount(e,t){return await this.load(),this.queryTask.executeRelationshipQueryForCount(e,{...t,query:this._createRequestQueryOptions(t)})}async queryPivot(e,t){return await this.load(),this.queryTask.executePivotQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopFeatures(e,t){return await this.load(),this.queryTask.executeTopFeaturesQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryAttributeBins(e,t){return await this.load(),this.queryTask.executeAttributeBinsQuery(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopObjectIds(e,t){return await this.load(),this.queryTask.executeForTopIds(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopExtents(e,t){return await this.load(),this.queryTask.executeForTopExtents(e,{...t,query:this._createRequestQueryOptions(t)})}async queryTopCount(e,t){return await this.load(),this.queryTask.executeForTopCount(e,{...t,query:this._createRequestQueryOptions(t)})}async fetchPublishingStatus(){if(!T(this.layer.url))return"unavailable";const e=h(this.layer.url,"status"),t=await r(e,{query:{f:"json"}});return $.fromJSON(t.data.status)}async uploadAssets(e,t){const{uploadAssets:r}=await import("./support/uploadAssets.js");return r(e,{layer:this.layer,ongoingUploads:this._ongoingAssetUploads},t)}_handleLastEditsEventChange(e){const t=this.layer;if(null==e||!("capabilities"in t)||!("effectiveCapabilities"in t))return;if(!(!t.capabilities?.operations?.supportsEditing&&t.effectiveCapabilities?.operations?.supportsEditing))return;const r=t.url;if(null==r)return;"layerId"in t&&h(r,t.layerId.toString());this._getOrCreateEditInterceptor(r).before=t=>{const r=t.requestOptions.method??"auto";if("auto"===r||"head"===r){const r=t.requestOptions.query??{};r._ts=e.getTime(),t.requestOptions.query=r}}}_getOrCreateEditInterceptor(e){return null==this._editInterceptor&&(this._editInterceptor={urls:e},t.request.internalInterceptors.push(this._editInterceptor)),this._editInterceptor}_removeEditInterceptor(){null!=this._editInterceptor&&(a(t.request.internalInterceptors,this._editInterceptor),this._editInterceptor=null)}async _asyncApplyEdits(e,t){const s=(await r(e,t)).data.statusUrl;for(;;){const e=(await r(s,{query:{f:"json"},responseType:"json"})).data;switch(e.status){case"Completed":return r(e.resultUrl,{query:{f:"json"},responseType:"json"});case"CompletedWithErrors":throw new i("async-applyEdits-failed","asynchronous applyEdits call failed.");case"Failed ImportChanges":case"InProgress":case"Pending":case"ExportAttachments":case"ExportChanges":case"ExportingData":case"ExportingSnapshot":case"ImportAttachments":case"ProvisioningReplica":case"UnRegisteringReplica":break;default:throw new i("async-applyEdits-failed","asynchronous applyEdits call failed (undefined response status)")}await d(H)}}_createRequestQueryOptions(e){const t={...this.layer.customParameters,token:this.layer.apiKey,...e?.query};return this.layer.datesInUnknownTimezone&&(t.timeReferenceUnknownClient=!0),t}async _fetchService(e,t){if(!e){const s={};has("featurelayer-advanced-symbols")&&(s.returnAdvancedSymbols=!0),t?.cacheBust&&(s._ts=Date.now());const{data:a}=await r(this.layer.parsedUrl.path,this._getLayerRequestOptions({query:s,signal:t?.signal}));e=a}this.layer.applyPreferredHost(e),this.sourceJSON=await this._patchServiceJSON(e,t?.signal);const s=e.type;if(!this.supportedSourceTypes.has(s))throw new i("feature-layer-source:unsupported-type",`Source type "${s}" is not supported`)}async _patchServiceJSON(e,t){if("Table"!==e.type&&e.geometryType&&!e?.drawingInfo?.renderer&&!e.defaultSymbol){const t=v(e.geometryType).renderer;l("drawingInfo.renderer",t,e)}if("esriGeometryMultiPatch"===e.geometryType&&e.infoFor3D&&(e.geometryType="mesh"),null==e.extent)try{const{data:s}=await r(this.layer.url,this._getLayerRequestOptions({signal:t}));s.spatialReference&&(e.extent={xmin:0,ymin:0,xmax:0,ymax:0,spatialReference:s.spatialReference})}catch(s){p(s)}return e}async _ensureLatestMetadata(e){if(this.layer.userHasUpdateItemPrivileges&&this.sourceJSON.cacheMaxAge>0)return this._fetchService(null,{...e,cacheBust:!0})}async _uploadMeshesAndGetAssetMapEditsJSON(e){const{addAssetFeatures:t}=e;if(!t?.length)return null;if(await this._areAllAssetsAlreadyMapped(t))return null;const r=e.addFeatures.filter(e=>e.geometry);if(t.length!==r.length+e.updateFeatures.length)throw new i("feature-layer-source:unsupported-mesh-edits","Mixing attribute only edits with mesh geometry edits is not currently supported");const s=new Array,a=new Map;for(const i of t){const{geometry:e}=i,{vertexSpace:t}=e;if(E(t))s.push(e);else{const t=e.origin,{convertMeshVertexSpace:r}=await import("../../../geometry/support/meshUtils/convertMeshVertexSpace.js"),n=await r(e,new S({origin:[t.x,t.y,t.z??0]}));a.set(n,e),i.geometry=n,s.push(n)}}await this.uploadAssets(s);for(const[i,n]of a)n.addExternalSources(i.metadata.externalSources.items);return{adds:this._getAssetMapEditsJSON(t),updates:[],deletes:[]}}_getAssetMapEditsJSON(e){const t=new Array,r=this.layer.globalIdField,s=this.layer.parsedUrl;for(const a of e){const e=a.geometry,{metadata:i}=e,n=i.getExternalSourcesOnService(s),o=a.getAttribute(r);if(0===n.length){u.getLogger(this).error(`Skipping feature ${o}. The mesh it is associated with has not been uploaded to the service and cannot be mapped to it.`);continue}const{source:l}=n.find(O)??n[0];for(const r of l.assets)1===r.parts.length?t.push({globalId:m(),parentGlobalId:o,assetName:r.assetName,assetHash:r.parts[0].partHash,flags:[]}):u.getLogger(this).error(`Skipping asset ${r.assetName}. It does not have exactly one part, so we cannot map it to a feature.`)}return t}_createEditsResult(e){const t=e.data,{layerId:r}=this.layer,s=[];let a=null;if(Array.isArray(t))for(const n of t)s.push({id:n.id,editedFeatures:n.editedFeatures}),n.id===r&&(a={addResults:n.addResults??[],updateResults:n.updateResults??[],deleteResults:n.deleteResults??[],attachments:n.attachments,editMoment:n.editMoment});else a=t;const i=I(a);if(s.length>0){i.editedFeatureResults=[];for(const e of s){const{editedFeatures:t}=e,r=t?.spatialReference?new w(t.spatialReference):null;i.editedFeatureResults.push({layerId:e.id,editedFeatures:x(t,r)})}}return i}_createAttachmentErrorResult(e,t){const r=t.details.messages?.[0]||t.message,s=t.details.httpStatus||t.details.messageCode;return{objectId:e,globalId:null,error:new i("feature-layer-source:attachment-failure",r,{code:s})}}_getFormDataForAttachment(e,t){const r=e instanceof FormData?e:e&&e.elements?new FormData(e):null;if(r)for(const s in t){const e=t[s];null!=e&&(r.set?r.set(s,e):r.append(s,e))}return r}_getLayerRequestOptions(e={}){const{layer:t,layer:{parsedUrl:r,gdbVersion:s}}=this;return{...e,query:{gdbVersion:s,layer:"dynamicDataSource"in t&&t.dynamicDataSource?JSON.stringify({source:t.dynamicDataSource}):void 0,...r.query,f:"json",...this._createRequestQueryOptions(e)},responseType:"json"}}async _areAllAssetsAlreadyMapped(e){const{layer:t}=this,{globalIdField:r,parsedUrl:a}=t,i="infoFor3D"in t?t.infoFor3D:null;if(null==i||null==r)return!1;const n=N(i);if(null==n)return!1;const o=h(a.path,`../${n.id}`),u=new Array;for(const s of e){if(!(s.geometry.metadata.getExternalSourcesOnService(a).length>0))return!1;u.push(s)}const l=u.map(e=>e.getAttribute(r)).filter(s);if(0===l.length)return!1;const{assetMapFieldRoles:{parentGlobalId:c,assetHash:d}}=i,p=new D({where:`${c} IN (${l.map(e=>`'${e}'`)})`,outFields:[d,c],returnGeometry:!1}),y=await U(o,p),{features:m}=y;return 0!==m.length&&!u.some(e=>{const t=e.getAttribute(r);if(!t)return!0;const{metadata:s}=e.geometry,i=m.filter(e=>e.getAttribute(c)===t);if(0===i.length)return!0;const n=i.map(e=>e.getAttribute(d));return s.getExternalSourcesOnService(a).flatMap(({source:e})=>e.assets.flatMap(e=>e.parts.map(e=>e.partHash))).some(e=>n.every(t=>e!==t))})}};e([f()],G.prototype,"type",void 0),e([f({constructOnly:!0})],G.prototype,"layer",void 0),e([f({constructOnly:!0})],G.prototype,"supportedSourceTypes",void 0),e([f({readOnly:!0})],G.prototype,"queryTask",null),G=e([g("esri.layers.graphics.sources.FeatureLayerSource")],G);const H=1e3;export{G as default};
