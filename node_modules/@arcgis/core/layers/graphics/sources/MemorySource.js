/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as e}from"tslib";import t from"../../../Graphic.js";import r from"../../../core/Collection.js";import o from"../../../core/Error.js";import has from"../../../core/has.js";import{LoadableMixin as s}from"../../../core/Loadable.js";import i from"../../../core/Logger.js";import{EsriPromiseMixin as n}from"../../../core/Promise.js";import{open as a}from"../../../core/workers/workers.js";import{property as l}from"../../../core/accessorSupport/decorators/property.js";import{ensureType as u}from"../../../core/accessorSupport/ensureType.js";import"../../../core/RandomLCG.js";import{shared as p}from"../../../core/accessorSupport/decorators/shared.js";import{subclass as c}from"../../../core/accessorSupport/decorators/subclass.js";import d from"../../../geometry/Extent.js";import y from"../../../geometry/Polygon.js";import{typeKebabDictionary as h}from"../../../geometry/support/typeUtils.js";import{unapplyEditsZUnitScaling as m}from"../../../rest/query/operations/editsZScale.js";import{applyFeatureSetZUnitScaling as f}from"../../../rest/query/operations/queryZScale.js";import g from"../../../rest/support/FeatureSet.js";let _=0,T=class extends(s(n(r))){constructor(e){super(e),this._idToClientGeometry=null,this.type="memory"}load(e){const t=null!=e?e.signal:null;return this.addResolvingPromise(this._startWorker(t)),Promise.resolve(this)}destroy(){this._connection?.close(),this._connection=null}get _workerGeometryType(){const e=this.layer?.geometryType;return e?this._geometryTypeRequiresClientGraphicMapping(e)?"polygon":e:null}applyEdits(e){return this.load().then(()=>this._applyEdits(e))}openPorts(){return this.load().then(()=>this._connection.openPorts())}async queryFeatures(e,t={}){await this.load(t);const r=await this._connection.invoke("queryFeatures",e?e.toJSON():null,t);f(e,this.layer.spatialReference,r);const o=g.fromJSON(r);if(!this._requiresClientGraphicMapping()||!this._idToClientGeometry)return o;const s=this.layer.objectIdField;for(const i of o.features){const e=i.attributes[s],t=this._idToClientGeometry.get(e);void 0!==t&&(i.geometry=t)}return o.geometryType=this.layer.geometryType,o}async queryFeaturesJSON(e,t={}){if(this._requiresClientGraphicMapping())throw new o("query-features-json:unsupported","Cannot query in JSON format for client only geometry types (mesh and extent)");await this.load(t);const r=await this._connection.invoke("queryFeatures",e?e.toJSON():null,t);return f(e,this.layer.spatialReference,r),r}queryFeatureCount(e,t={}){return this.load(t).then(()=>this._connection.invoke("queryFeatureCount",e?e.toJSON():null,t))}queryObjectIds(e,t={}){return this.load(t).then(()=>this._connection.invoke("queryObjectIds",e?e.toJSON():null,t))}queryExtent(e,t={}){return this.load(t).then(()=>this._connection.invoke("queryExtent",e?e.toJSON():null,t)).then(e=>({count:e.count,extent:d.fromJSON(e.extent)}))}querySnapping(e,t={}){return this.load(t).then(()=>this._connection.invoke("querySnapping",e,t))}async queryAttributeBins(e,t={}){return await this.load(),this._connection.invoke("queryAttributeBins",e?.toJSON(),t)}async _applyEdits(e){if(!this._connection)throw new o("feature-layer-source:edit-failure","Memory source not loaded");const t=this.layer.objectIdField;let r=null;const s=[],i=[];await Promise.all([this._prepareClientMapping(e.addFeatures,null),this._prepareClientMapping(e.updateFeatures,null)]);const n=e=>"objectId"in e&&null!=e.objectId?e.objectId:"attributes"in e&&null!=e.attributes[t]?e.attributes[t]:null;if(e.addFeatures&&(r=this._prepareAddFeatures(e.addFeatures)),e.deleteFeatures)for(const o of e.deleteFeatures){const e=n(o);null!=e&&s.push(e)}const a=e.updateFeatures&&this._idToClientGeometry?new Map:null;if(e.updateFeatures)for(const o of e.updateFeatures)if(i.push(this._serializeFeature(o)),a&&null!=o.geometry){const e=n(o);null!=e&&a.set(e,o)}m(r?r.features:null,i,this.layer.spatialReference);const{fullExtent:l,featureEditResults:u}=await this._connection.invoke("applyEdits",{adds:r?r.features:[],updates:i,deletes:s});return this.fullExtent=l,r&&r.finish(u.uidToObjectId),this._updateIdToClientGeometries(a,u),this._createEditsResult(u)}async _prepareClientMapping(e,t){if("mesh"!==this._layerOrSourceGeometryType||null==e)return;const r=[];for(const{geometry:o}of e)null==o||"mesh"!==o.type||o.hasExtent||o.loaded||r.push(o.load({signal:t}));r.length&&await Promise.all(r)}_updateIdToClientGeometries(e,t){if(this._idToClientGeometry){if(e)for(const r of t.updateResults){if(!r.success)continue;const t=e.get(r.objectId);null!=t&&this._addIdToClientGeometry(t)}for(const e of t.deleteResults)e.success&&this._idToClientGeometry.delete(e.objectId)}}_createEditsResult(e){return{addFeatureResults:e.addResults?e.addResults.map(this._createFeatureEditResult,this):[],updateFeatureResults:e.updateResults?e.updateResults.map(this._createFeatureEditResult,this):[],deleteFeatureResults:e.deleteResults?e.deleteResults.map(this._createFeatureEditResult,this):[],addAttachmentResults:[],updateAttachmentResults:[],deleteAttachmentResults:[]}}_createFeatureEditResult(e){const t=!0===e.success?null:e.error||{code:void 0,description:""};return{objectId:e.objectId,globalId:e.globalId,error:t?new o("feature-layer-source:edit-failure",t.description,{code:t.code}):null}}_prepareAddFeatures(e){const t=new Map,r=new Array(e.length);let o=null;for(let i=0;i<e.length;i++){const s=e[i],n=this._serializeFeature(s);o||null==s.geometry||(o=s.geometry.type),r[i]=n,t.set(`${n.uid}`,s)}const s=this;return{features:r,inferredGeometryType:o,finish(e){const r=s.sourceJSON.objectIdField;for(const o in e){const i=e[o],n=t.get(o);n&&(n.attributes||(n.attributes={}),-1===i?delete n.attributes[r]:n.attributes[r]=i,s._addIdToClientGeometry(n))}}}}_addIdToClientGeometry(e){if(!this._idToClientGeometry)return;const t=this.sourceJSON.objectIdField,r=e.attributes?.[t];null!=r&&this._idToClientGeometry.set(r,e.geometry??null)}get _layerOrSourceGeometryType(){return this.layer?.geometryType??this.sourceJSON?.geometryType}_requiresClientGraphicMapping(){return this._geometryTypeRequiresClientGraphicMapping(this._layerOrSourceGeometryType)}_geometryRequiresClientGraphicMapping(e){return this._geometryTypeRequiresClientGraphicMapping(e.type)}_geometryTypeRequiresClientGraphicMapping(e){return"mesh"===e||"multipatch"===e||"extent"===e}_serializeFeature(e){const{attributes:t}=e,r=this._geometryForSerialization(e),o=(_++).toString();return r?{uid:o,geometry:r.toJSON(),attributes:t}:{uid:o,attributes:t}}_geometryForSerialization(e){const{geometry:t}=e;if(null==t)return null;if(this._geometryRequiresClientGraphicMapping(t)){return t.extent?y.fromExtent(t.extent):null}return t}async _startWorker(e){this._connection=await a("MemorySourceWorker",{strategy:has("feature-layers-workers")?"dedicated":"local",signal:e,registryTarget:this});const{fields:t,spatialReference:r,objectIdField:o,hasM:s,hasZ:n,timeInfo:l,dateFieldsTimeZone:u}=this.layer,p="defaults"===this.layer.originOf("spatialReference");await this._prepareClientMapping(this.items,e);const c=this._prepareAddFeatures(this.items);this.addHandles(this.on("before-changes",e=>{i.getLogger(this).error("Source modifications will not propagate after layer has been loaded. Please use .applyEdits() instead"),e.preventDefault()}));const d={features:c.features,fields:t?.map(e=>e.toJSON()),geometryType:h.toJSON(this._workerGeometryType),hasM:"mesh"!==this._layerOrSourceGeometryType&&s,hasZ:"mesh"===this._layerOrSourceGeometryType||n,objectIdField:o,spatialReference:p?null:r&&r.toJSON(),timeInfo:l?.toJSON()??null,dateFieldsTimeZone:u},y=await this._connection.invoke("load",d,{signal:e});for(const a of y.warnings)i.getLogger(this.layer).warn("#load()",`${a.message} (title: '${this.layer.title||"no title"}', id: '${this.layer.id??"no id"}')`,{warning:a});y.featureErrors.length&&i.getLogger(this.layer).warn("#load()",`Encountered ${y.featureErrors.length} validation errors while loading features. (title: '${this.layer.title||"no title"}', id: '${this.layer.id??"no id"}')`,{errors:y.featureErrors});const m=y.layerDefinition;this._geometryTypeRequiresClientGraphicMapping(c.inferredGeometryType)&&(m.geometryType=h.toJSON(c.inferredGeometryType)),this.sourceJSON=m,this._requiresClientGraphicMapping()&&(this._idToClientGeometry=new Map),c.finish(y.assignedObjectIds)}};e([p({Type:t,ensureType:u(t)})],T.prototype,"itemType",void 0),e([l()],T.prototype,"type",void 0),e([l({constructOnly:!0})],T.prototype,"layer",void 0),e([l({readOnly:!0})],T.prototype,"_workerGeometryType",null),e([l()],T.prototype,"sourceJSON",void 0),T=e([c("esri.layers.graphics.sources.MemorySource")],T);export{T as MemorySource};
