/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__decorate as t}from"tslib";import{equals as e}from"../core/arrayUtils.js";import{deprecatedProperty as r}from"../core/deprecate.js";import{clone as s}from"../core/lang.js";import i from"../core/Logger.js";import{property as n}from"../core/accessorSupport/decorators/property.js";import"../core/has.js";import{subclass as o}from"../core/accessorSupport/decorators/subclass.js";import{writer as a}from"../core/accessorSupport/decorators/writer.js";import l from"./Extent.js";import p from"./Geometry.js";import c from"./Point.js";import h from"./SpatialReference.js";import{polygonCentroidPoint as u}from"./support/centroid.js";import{polygonContainsPoint as m}from"./support/contains.js";import{isClockwise as f}from"./support/coordsUtils.js";import{getPolygonExtent as g}from"./support/extentUtils.js";import{isSelfIntersecting as y}from"./support/intersectsBase.js";import{project as d}from"./support/webMercatorUtils.js";import{updateSupportFromPoint as R}from"./support/zmUtils.js";var w;function v(t){return!Array.isArray(t[0])}function x(t){return"number"==typeof t[0]?.[0]}function j(t){if(!t)return;let{rings:e,hasM:r,hasZ:s,spatialReference:i}=t;switch(e??=[],x(e)&&(e=[e]),e[0]?.[0]?.length){case 4:s??=!0,r??=!0;break;case 3:s??=!0!==r,r??=!s;break;default:s??=!1,r??=!1}return i??=h.WGS84,{...t,hasM:r,hasZ:s,rings:e,spatialReference:i}}let P=w=class extends p{static fromExtent(t){const e=t.clone().normalize(),{spatialReference:r}=t;let s=!1,i=!1;for(const o of e)o.hasZ&&(s=!0),o.hasM&&(i=!0);const n={rings:e.map(t=>{const e=[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]];if(s&&t.hasZ){const r=t.zmin+.5*(t.zmax-t.zmin);for(let t=0;t<e.length;t++)e[t].push(r)}if(i&&t.hasM){const r=t.mmin+.5*(t.mmax-t.mmin);for(let t=0;t<e.length;t++)e[t].push(r)}return e}),spatialReference:r};return s&&(n.hasZ=!0),i&&(n.hasM=!0),new w(n)}constructor(t){super(j(t)),this.curveRings=void 0,this.rings=[],this.type="polygon"}get cache(){return this.commitProperty("curveRings"),this.commitProperty("hasM"),this.commitProperty("hasZ"),this.commitProperty("rings"),this.commitProperty("spatialReference"),{}}get centroid(){r(i.getLogger(this),"centroid",{replacement:"Please use centroidOperator.execute() instead.",version:"4.34",warnOnce:!0});const t=u(this);return t?c.fromJSON(t):null}writeCurveRings(t,e){e.curveRings=s(t)}get extent(){const t=g(this),{spatialReference:e}=this;return t?new l({...t,spatialReference:e}):null}get isSelfIntersecting(){return r(i.getLogger(this),"isSelfIntersecting",{replacement:"Please use simplifyOperator.isSimple() instead.",version:"4.33",warnOnce:!0}),y(this.rings)}writeRings(t,e){e.rings=s(this.rings)}addRing(t){if(!t)return;const e=this.rings,r=e.length;if(v(t)){const s=[];for(let e=0,r=t.length;e<r;e++)s[e]=t[e].toArray();e[r]=s}else e[r]=t.slice();return this.notifyChange("rings"),this}clone(){const t=new w;return t.spatialReference=this.spatialReference,t.rings=s(this.rings),t.curveRings=s(this.curveRings),t.hasZ=this.hasZ,t.hasM=this.hasM,t}equals(t){if(this===t)return!0;if(null==t)return!1;const r=this.spatialReference,s=t.spatialReference;if(null!=r!=(null!=s))return!1;if(null!=r&&null!=s&&!r.equals(s))return!1;if(this.rings.length!==t.rings.length)return!1;const i=([t,e,r,s],[i,n,o,a])=>t===i&&e===n&&(null==r&&null==o||r===o)&&(null==s&&null==a||s===a);for(let n=0;n<this.rings.length;n++){const r=this.rings[n],s=t.rings[n];if(!e(r,s,i))return!1}return!0}contains(t){if(!t)return!1;const e=d(t,this.spatialReference);return m(this,null!=e?e:t)}isClockwise(t){const e=v(t)?t.map(t=>this.hasZ?this.hasM?[t.x,t.y,t.z,t.m]:[t.x,t.y,t.z]:[t.x,t.y]):t;return f(e)}getPoint(t,e){if(!this._validateInputs(t,e))return null;const r=this.rings[t][e],s=this.hasZ,i=this.hasM;return s&&!i?new c(r[0],r[1],r[2],void 0,this.spatialReference):i&&!s?new c(r[0],r[1],void 0,r[2],this.spatialReference):s&&i?new c(r[0],r[1],r[2],r[3],this.spatialReference):new c(r[0],r[1],this.spatialReference)}insertPoint(t,e,r){return this._validateInputs(t,e,!0)?(R(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[t].splice(e,0,r),this.notifyChange("rings"),this):this}removePoint(t,e){if(!this._validateInputs(t,e))return null;const r=new c(this.rings[t].splice(e,1)[0],this.spatialReference);return this.notifyChange("rings"),r}removeRing(t){if(!this._validateInputs(t,null))return null;const e=this.rings.splice(t,1)[0],r=this.spatialReference,s=e.map(t=>new c(t,r));return this.notifyChange("rings"),s}setPoint(t,e,r){return this._validateInputs(t,e)?(R(this,r),Array.isArray(r)||(r=r.toArray()),this.rings[t][e]=r,this.notifyChange("rings"),this):this}_validateInputs(t,e,r=!1){if(null==t||t<0||t>=this.rings.length)return!1;if(null!=e){const s=this.rings[t];if(r&&(e<0||e>s.length))return!1;if(!r&&(e<0||e>=s.length))return!1}return!0}toJSON(t){return this.write({},t)}};t([n({readOnly:!0})],P.prototype,"cache",null),t([n({readOnly:!0})],P.prototype,"centroid",null),t([n({json:{write:!0,origins:{"portal-item":{write:!1},"web-map":{write:!1},"web-scene":{write:!1}}}})],P.prototype,"curveRings",void 0),t([a("curveRings")],P.prototype,"writeCurveRings",null),t([n({readOnly:!0})],P.prototype,"extent",null),t([n({readOnly:!0})],P.prototype,"isSelfIntersecting",null),t([n({type:[[[Number]]],json:{write:{isRequired:!0}}})],P.prototype,"rings",void 0),t([a("rings")],P.prototype,"writeRings",null),P=w=t([o("esri.geometry.Polygon")],P),P.prototype.toJSON.isDefaultToJSON=!0;export{P as default};
