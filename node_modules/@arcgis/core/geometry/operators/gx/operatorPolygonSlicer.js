/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{G as t,S as e}from"../../../chunks/SimpleGeometryCursor.js";import{a as s,g as r}from"../../../chunks/Geometry.js";import{Envelope2D as n}from"../../../chunks/Envelope2D.js";import{T as i}from"../../../chunks/Transformation2D.js";import{p as o,q as a,t as l,u,P as h,v as m,E as c,n as p,a as _,w as g}from"../../../chunks/MultiPathImpl.js";import{K as f,l as y,E as d,m as x,P as T,c as A,q as E}from"../../../chunks/Point2D.js";import{P as v,b as N}from"../../../chunks/Envelope.js";import{O as S}from"../../../chunks/OperatorClip.js";import{O as w}from"../../../chunks/OperatorMultiPartToSinglePart.js";import{O as C}from"../../../chunks/OperatorCut.js";function X(t,e,s,r,n){return new j(n).findSlicesByArea(t,e,s,r)}function k(t,e,s,r,n){return new j(n).sliceIntoStrips(t,e,s,r)}function P(t,e,s,r){return new j(r).recursiveSliceEqualArea(t,e,s)}function H(t){this.currentX=this.calcX(t)}function b(t){if(null===this.curve){const e=(t-this.y0)/(this.y1-this.y0);return E(this.x0,this.x1,e)}return this.curve.intersectionOfYMonotonicWithAxisX(t,this.x0)}function Y(){return{x0:Number.NaN,y0:Number.NaN,x1:Number.NaN,y1:Number.NaN,currentX:Number.NaN,nextAET:null,prevAET:null,startNodeNext:null,nextInChain:null,curve:null,advance:H,calcX:b}}function I(t,e){const s=Y();return s.x0=t.getStartX(),s.y0=t.getStartY(),s.x1=t.getEndX(),s.y1=t.getEndY(),e&&(s.y0=A(s.x0,s.x0=s.y0),s.y1=A(s.x1,s.x1=s.y1)),s.y1<s.y0&&(s.y1=A(s.y0,s.y0=s.y1),s.x1=A(s.x0,s.x0=s.x1)),s.currentX=Number.NaN,s.nextAET=null,s.prevAET=null,s.startNodeNext=null,s.nextInChain=null,s.curve=null,s}function O(t){const e=Y();return e.x0=t.getStartX(),e.y0=t.getStartY(),e.x1=t.getEndX(),e.y1=t.getEndY(),e.curve=t,e.y1<e.y0&&(e.y1=A(e.y0,e.y0=e.y1),e.x1=A(e.x0,e.x0=e.x1)),e.currentX=Number.NaN,e.nextAET=null,e.prevAET=null,e.startNodeNext=null,e.nextInChain=null,e}function q(t){if(this.x===t.x&&this.y===t.y){const e=null!==this.endEdge,s=null!==t.startEdge;return e&&s?-1:1}return this.y!==t.y?this.y-t.y:this.x-t.x}function R(){return{x:Number.NaN,y:Number.NaN,startEdge:null,endEdge:null,compare:q}}function D(t,e){return{y:t,startingEdges:e}}class M{constructor(t,e,s,r,n,i){this.m_parent=t,this.m_y0=e,this.m_y1=s,this.m_t0=r,this.m_area=i}getMaxDerivative(){return 1}getValue(t,e){return 1===t?0:this.getArea(e)-this.m_area}getError(t){return r(0),0}getArea(t){const e=.5*(this.m_parent.m_sumBase-this.m_parent.m_sumA),s=this.m_y1-this.m_y0;let r=(this.m_parent.m_sumBase-e*(t+this.m_t0))*s*(t-this.m_t0),n=!1;for(let i=this.m_parent.m_AETHead;null!==i;i=i.nextAET)if(n=!n,n&&(null!==i.curve||null!==i.nextAET.curve)){const e=this.m_y0+s*this.m_t0,n=this.m_y0+s*t;i.curve&&(r+=V(i.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),i.nextAET.curve&&(r-=V(i.nextAET.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t));r+=(n-e)*(i.nextAET.calcX(e)-i.calcX(e)+(i.nextAET.calcX(n)-i.calcX(n)))*.5}return r}}function B(t,e,s){return{polygon:t,from:e,to:s}}function V(t,e,s){const n=[0,0],i=t.intersectionWithAxis2D(!0,e,null,n);r(1===i);const o=n[0],a=t.intersectionWithAxis2D(!0,s,null,n);r(1===a);const l=n[0],u=x(T,4);g(t,u,!0);const h=u[3],m=u[2],c=u[1],p=t.getCoordX(o)-t.getStartX(),_=t.getCoordY(o)-t.getStartY(),f=t=>{const e=t*t;return e*t*(10*(m.x*c.y-m.y*c.x)-15*t*(h.y*c.x-h.x*c.y)+6*e*(m.y*h.x-h.y*m.x))/60},y=t=>(-t*(c.y+t*(m.y+h.y*t))*p+t*(c.x+t*(m.x+h.x*t))*_)/2;return f(l)-f(o)-(y(l)-y(o))}class z extends t{constructor(t){super(),this.m_geoms=[],this.m_index=-1,this.m_id=-1,this.m_geoms=t}tock(){return!0}getRank(){return 1}next(){return this.m_index++,this.m_index>=this.m_geoms.length?null:(this.m_id=this.m_geoms[this.m_index].second,this.m_geoms[this.m_index].first)}getGeometryID(){return this.m_id}}class j{constructor(t){this.m_edges=[],this.m_curves=[],this.m_sortedNodes=[],this.m_sortHelper=[],this.m_cuts=[],this.m_cutAreas=[],this.m_totalAreaOfTraps=new f(0),this.m_areaTracking=0,this.m_splitArea=0,this.m_sumBase=0,this.m_sumA=0,this.m_numberOfCuts=0,this.m_currentScan=0,this.m_progressCounter=0,this.m_AETHead=null,this.m_bHorizontalSweep=!1,this.m_bPolygonHasCurves=!1,this.m_progressTracker=t}findSlicesByArea(t,e,r,n){n<0&&s("remainingArea");let i=t,a=null;i.hasNonLinearSegments()&&(this.m_bPolygonHasCurves=!0,a=o(t,1e-16,!0),G(a),i=a);const l=Math.abs(i.calculateArea2D());return 0===l||0===r||n>=l||1===r&&0===n?[]:(this.m_splitArea=(l-n)/r,this.m_numberOfCuts=r-1,n>0&&this.m_numberOfCuts++,this.m_edges.length=0,this.m_sortedNodes.length=0,this.m_cuts.length=0,this.m_areaTracking=0,this.m_totalAreaOfTraps.reset(),this.m_curves.length=0,this.buildEdges(i),this.buildScanNodes(),this.trapezoidation(),this.m_cuts)}sliceIntoStrips(t,s,r,i){if(0===i)return new e([t]);const o=new n;t.queryLooseEnvelope(o);const a=o.width()+o.height();return new z(this.splitPolygon(t,s,o.xmin-a-1+1,o.xmax+a+1,r,i))}recursiveSliceEqualArea(t,s,o){if(o<=1||t.isEmpty())return new e([t]);{const e=[],a=[];a.push(y(t.clone(),o));let l=0,u=0;for(;a.length>0;){r(u++<2*o);const t=a.at(-1);if(a.pop(),1===t.second){e.push(y(t.first,l++));continue}const h=new n;t.first.queryEnvelope(h);const m=h.width()+h.height(),c=new i;c.setIdentity(),h.width()>h.height()&&(c.setRotateCcw90(),t.first.applyTransformation(c),c.transformEnvInPlace(h));const p=t.first.calculateArea2D(),_=p/t.second,g=p-Math.trunc(t.second/2)*_,f=new j(this.m_progressTracker).findSlicesByArea(t.first,s,1,g),d=new j(this.m_progressTracker).splitPolygon(t.first,s,h.xmin-m-1+1,h.xmax+m+1,f,1),x=d.length;if(r(x>0&&x<=2),!c.isIdentity()){const t=new i;t.setRotateCw90(),d[0].first.applyTransformation(t),2===x&&d[1].first.applyTransformation(t)}2===x?(a.push(y(d[1].first,t.second-Math.trunc(t.second/2))),a.push(y(d[0].first,Math.trunc(t.second/2)))):a.push(y(d[0].first,t.second))}return new z(e)}}recursiveSliceEqualAreaImpl(t,e,s,n){return r(0),{}}processTraps(t,e,s){s?this.processTrapsCurves(t,e):this.processTrapsLinear(t,e)}processTrapsLinear(t,e){let s=0,r=1;const n=.5*(this.m_sumBase-this.m_sumA),i=e-t,o=(this.m_sumBase-n*(r+s))*i*(r-s);if(o+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(o),void(this.m_areaTracking+=o);const l=new f(o),u=new d(0,1);let h=!1;for(;s<1;){const e=this.m_splitArea-this.m_areaTracking,m=[Number.NaN,Number.NaN];if(!(a(-n*i,this.m_sumBase*i,(n*s-this.m_sumBase)*i*s-e,u,!1,m)>0)){h?this.m_areaTracking=l.getResult():this.m_areaTracking+=o;break}{h=!0,r=m[0],this.m_areaTracking=0,s=r,l.me(e);const n=r*i+t;if(this.m_cuts.push(n),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+o-l.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(o-l.getResult())}}this.m_totalAreaOfTraps.pe(o)}processTrapsCurves(t,e){let s=0,r=1;const n=new M(this,t,e,0,1,0).getArea(1);if(n+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(n),void(this.m_areaTracking+=n);const i=e-t,o=new f(n);let a=!1;for(;s<1;){const u=this.m_splitArea-this.m_areaTracking,h=new M(this,t,e,s,1,u),m=[0],c=new d(s,1);if(!(l(h,c,1,m)>0)){a?this.m_areaTracking=o.getResult():this.m_areaTracking+=n;break}{a=!0,r=m[0],this.m_areaTracking=0,s=r,o.me(u);const e=r*i+t;if(this.m_cuts.push(e),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+n-o.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(n-o.getResult())}}this.m_totalAreaOfTraps.pe(n)}advanceAET(){const t=this.m_sortedNodes[this.m_currentScan-1].y,e=this.m_sortedNodes[this.m_currentScan];let s=!1,r=!1;const n=new f(0);for(let a=this.m_AETHead;null!==a;a=a.nextAET){const t=a.prevAET;s=!s,null!==a.nextAET&&s&&(this.m_bPolygonHasCurves&&(a.curve||a.nextAET.curve)||n.pe(a.nextAET.currentX-a.currentX)),a.advance(e.y),null!==t&&a.currentX<t.currentX&&(r=!0)}this.m_sumBase=n.getResult(),r&&this.sortAET();const i=new f(0);s=!1;let o=!1;for(let a=this.m_AETHead;null!==a;a=a.nextAET){o=o||null!==a.curve;s=!s,null!==a.prevAET&&(s||this.m_bPolygonHasCurves&&(a.curve||a.prevAET.curve)||i.pe(a.currentX-a.prevAET.currentX))}this.m_sumA=i.getResult(),this.processTraps(t,e.y,o);for(let a=this.m_AETHead;null!=a;){const t=a.prevAET,s=a.nextAET;if(e.y===a.y1)if(a.prevAET=null,a.nextAET=null,null!==a.nextInChain){const e=a.currentX;a=a.nextInChain,a.currentX=e,a.prevAET=t,t?t.nextAET=a:this.m_AETHead=a,a.nextAET=s,s&&(s.prevAET=a)}else t?t.nextAET=s:this.m_AETHead=s,s&&(s.prevAET=t);a=s}}mergeNewEdgesToAET(){for(let r=this.m_sortedNodes[this.m_currentScan].startingEdges;null!==r;r=r.startNodeNext)Number.isNaN(r.currentX)&&(this.m_sortHelper.push(r),r.currentX=r.x0);if(!this.m_sortHelper.length)return;this.sortHelper();let t=this.m_AETHead,e=0,s=t;for(;null!==t&&e<this.m_sortHelper.length;)t.currentX>this.m_sortHelper[e].currentX?(this.m_sortHelper[e].prevAET=t.prevAET,t.prevAET?t.prevAET.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=t,t.prevAET=this.m_sortHelper[e],e++):(s=t,t=t.nextAET);for(;e<this.m_sortHelper.length;)this.m_sortHelper[e].prevAET=s,null!==s?s.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=null,s=this.m_sortHelper[e],e++;this.m_sortHelper.length=0}sortAET(){for(let e=this.m_AETHead;null!==e;e=e.nextAET)this.m_sortHelper.push(e);this.sortHelper(),this.m_AETHead=null;let t=null;for(const e of this.m_sortHelper)e.prevAET=t,t?t.nextAET=e:this.m_AETHead=e,e.nextAET=null,t=e;this.m_sortHelper.length=0}sortHelper(){this.m_sortHelper.sort((t,e)=>t.currentX-e.currentX)}trapezoidation(){for(this.m_currentScan=0,this.mergeNewEdgesToAET(),this.m_currentScan++;this.m_currentScan<this.m_sortedNodes.length&&(this.progress(),this.advanceAET(),this.m_cuts.length!==this.m_numberOfCuts);)this.mergeNewEdgesToAET(),this.m_currentScan++}buildEdges(t){const e=t.querySegmentIterator();for(e.stripAttributes();e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(t.isCurve()){const e=t;if(u(e),this.m_bHorizontalSweep){const t=x(T,4);e.queryControlPoints(t);for(const e of t)e.y=A(e.x,e.x=e.y);e.constructPoints(t)}const s=e.getStartY(),r=e.getEndY();if(r===s)continue;r<s&&e.reverse(),this.m_curves.push(e.clone()),this.m_edges.push(O(this.m_curves.at(-1)))}else{const e=this.m_bHorizontalSweep?t.getStartX():t.getStartY();if((this.m_bHorizontalSweep?t.getEndX():t.getEndY())===e)continue;this.m_edges.push(I(t,this.m_bHorizontalSweep))}}this.m_edges.sort((t,e)=>t.y0===e.y0?t.x0-e.x0:t.y0-e.y0)}buildScanNodes(){const t=[];for(const n of this.m_edges){const e=R();e.x=n.x0,e.y=n.y0,e.startEdge=n,e.endEdge=null,t.push(e);const s=R();s.x=n.x1,s.y=n.y1,s.startEdge=null,s.endEdge=n,t.push(s)}t.sort((t,e)=>t.compare(e));let e=0,s=t[e].y;this.m_sortedNodes.push(D(s,t[e].startEdge));let r=e;for(e++;e!==t.length;++e){t[e].y!==s&&(this.m_sortedNodes.push(D(t[e].y,null)),s=t[e].y);const n=t[e].startEdge;if(n){const t=this.m_sortedNodes.at(-1);n.startNodeNext=t.startingEdges,t.startingEdges=n}if(t[r].x!==t[e].x||t[r].y!==t[e].y){if(e-r===2){let e=r;e++,null!==t[r].endEdge&&null!==t[e].startEdge&&(t[r].endEdge.nextInChain=t[e].startEdge)}r=e}}}progress(){}splitPolygonLinear(t,s,i,o,a,l){const u=[];u.push([t,0,l]);const m=[],c=new h;for(c.startPathCoords(i,0),c.lineToCoords(o,0);u.length>0;){const h=u.at(-1);u.pop();const p=h[0],_=h[1],g=h[2],f=(new w).executeMany(new e([p]),s,this.m_progressTracker);for(let e=f.next();null!==e;e=f.next()){const h=e,p=new n;h.queryLooseEnvelope(p);let f=_,d=g;for(let t=_,e=g-1;t<g;++t,--e)p.ymin>=a[t]&&(f=t+1),p.ymax<=a[e]&&(d=e);if(f!==g)if(d!==_)if(f!==d)if(this.isYMonotone(h))this.splitYMonotone(m,h,s,a,f,d);else{const e=Math.trunc((f+d)/2);c.setXYCoords(0,i,a[e]),c.setXYCoords(1,o,a[e]);const _=(new C).execute(!1,h,c,null,this.m_progressTracker),g=_.next(),x=_.next(),T=_.next();if(null!==g){if(g.isEmpty()||(e===d-1?(m.push(y(g,e)),r(L(m.at(-1).first,s,t,m.at(-1).second,a,l))):u.push([g,e+1,d])),x.isEmpty()||(e===f?(m.push(y(x,e-1)),r(L(m.at(-1).first,s,t,m.at(-1).second,a,l))):u.push([x,f,e])),null!==T&&!T.isEmpty()){const t=new n;T.queryLooseEnvelope(t),t.ymin>=a[e]?u.push([T,e+1,d]):t.ymax<=a[e]?u.push([T,f,e]):u.push([T,f,d])}}else e+1===d?(a[e]-p.ymin<p.ymax-a[e]?m.push(y(h,e)):m.push(y(h,e+1)),r(L(m.at(-1).first,s,t,m.at(-1).second,a,l))):u.push([h,e+1,d])}else m.push(y(e,f-1));else m.push(y(e,_-1));else m.push(y(e,g-1))}}return m}splitPolygon(t,e,s,r,i,o){const a=new n;t.queryLooseEnvelope(a),a.inflateCoords(0,Math.max(a.width(),a.height()));const l=[],u=[];for(u.push(B(t,0,o));u.length;){const o={...u.at(-1)};if(u.pop(),o.polygon.hasNonLinearSegments()){const t=Math.trunc((o.to+o.from)/2),h=i[t],m=new n(s,a.ymin,r,h),c=(new S).execute(o.polygon,m,e,this.m_progressTracker);c.isEmpty()||(t-o.from===0?l.push(y(c,t-1)):u.push(B(c,o.from,t)));const p=new n(s,h,r,a.ymax),_=(new S).execute(o.polygon,p,e,this.m_progressTracker);_.isEmpty()||(o.to-t===1?l.push(y(_,t)):u.push(B(_,t+1,o.to)))}else{const n=this.splitPolygonLinear(t,e,s,r,i.slice(o.from),o.to-o.from);l.push(...n)}}l.sort((t,e)=>t.second-e.second);const h=[];return m(l,(t,e)=>t.second===e.second,(t,e)=>{const s=new _;for(let r=t;r!==e;++r)s.add(l[r].first,!1);h.push(y(s,l[t].second))}),h}isYMonotone(t){if(1!==t.getPathCount())return!1;const e=t.getXY(0);let s=0,r=0;const n=new T;for(let i=1,o=t.getPointCount();i<=o;i++){t.queryXY(i===o?0:i,n);const a=n.y>e.y?1:n.y<e.y?-1:0;if(e.setCoordsPoint2D(n),s!==a&&0!==a){if(0!==s&&(r++,r>2))return!1;s=a}}return!0}splitYMonotone(t,e,s,n,i,o){const a=new c;a.addGeometry(e);const l=a.getFirstPath(a.getFirstGeometry()),u=a.getFirstVertex(l),h=new T,m=new T;let _=u,g=u;{const t=a.getXY(u);h.setCoordsPoint2D(t),m.setCoordsPoint2D(t)}let f=a.getNextVertex(u);const d=new T;for(let r=0,c=a.getPathSize(l);r<c;r++,f=a.getNextVertex(f))a.queryXY(f,d),d.compare(h)<0?(_=f,h.setCoordsPoint2D(d)):d.compare(m)>0&&(g=f,m.setCoordsPoint2D(d));let x=_,A=_,E=x,v=A,N=!1,S=!1,w=i,C=h.y,X=h.y,k=!1;for(;w<o;)if(n[w]<=h.y)w++;else{if(n[w]>=m.y)break;if(!N){const t=a.getNextVertex(x),e=a.getY(t);if(e<C)break;const s=n[w];C<=s&&e>=s?N=!0:(C=e,x=t)}if(!S){const t=a.getPrevVertex(A),e=a.getY(t);if(e<X)break;const s=n[w];X<=s&&e>=s?S=!0:(X=e,A=t)}if(N&&S){k=!0;let e=a.getXY(x);const s=a.getNextVertex(x);let i=a.getXY(s),o=p;if(i.y===e.y)o=i.x<e.x?x:s;else{const t=(n[w]-e.y)/(i.y-e.y);if(0===t)o=x;else if(1===t)o=s;else{const e=a.splitSegmentAxisAware(x,[t],1,null,-1);r(1===e),o=a.getNextVertex(x),a.getY(o)!==n[w]&&a.setXYCoords(o,a.getX(o),n[w])}}const l=a.getPrevVertex(A);e=a.getXY(l),i=a.getXY(A);let u=p;if(i.y===e.y)u=i.x<e.x?A:l;else{const t=(n[w]-e.y)/(i.y-e.y);if(0===t)u=l;else if(1===t)u=A;else{const e=a.splitSegmentAxisAware(l,[t],1,null,-1);r(1===e),u=a.getNextVertex(l),a.getY(u)!==n[w]&&a.setXYCoords(u,a.getX(u),n[w])}}t.push(y(this.extractTrapezoid(a,E,o,v,u),w-1)),E=o,v=u,x=o,A=u,C=X=n[w],N=!1,S=!1,w++}}k?t.push(y(this.extractTrapezoid(a,E,g,v,g),w-1)):t.push(y(e,w))}extractTrapezoid(t,e,s,r,n){const i=new _({vd:t.getVertexDescription()}),o=new v;let a=!0;for(let l=e;;l=t.getNextVertex(l)){const e=t.getSegment(l);if(e?i.addSegment(e,a):(t.queryPoint(l,o),a?i.startPathPoint(o):i.lineToPoint(o)),a=!1,l===s)break}s!==n&&(t.queryPoint(n,o),i.lineToPoint(o)),a=!0;for(let l=n;;l=t.getNextVertex(l)){const s=t.getSegment(l);if(s?i.addSegment(s,a):a||l===e||(t.queryPoint(l,o),i.lineToPoint(o)),a=!1,l===r)break}return i}}function G(t){return t.getImpl().ensureXYMonotoneSegments()}function L(t,e,s,r,i,o){const a=new n;t.queryEnvelope(a);const l=4*N(e,s,!0).total();return(!(r>=0)||a.ymin+l>=i[r])&&!(r+1<o&&a.ymax>i[r+1]+l)}class F{getOperatorType(){return 10011}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}sliceIntoStrips(t,e,s,r,n,i){return new W(0,t,e,s,n,0,i)}findSlicesByArea(t,e,s,r,n,i){if(!n||n.isIdentity())return X(t,e,s,r,i);{const o=t.clone();return o.applyTransformation(n),X(o,e,s,r,i)}}recursiveSliceEqualArea(t,e,s,r,n){return new W(1,t,e,null,r,s,n)}}class W extends t{constructor(t,e,s,r,n,i,o){super(),this.m_resultCursor=null,this.m_method=t,this.m_polygon=e,this.m_sr=s,this.m_ySplits=r?.slice()??null,this.m_transform=n,this.m_bReversePaths=n?.isReflective()??!1,this.m_inverseTransform=n?n.clone().invertThis():null,this.m_partCount=i,this.m_tracker=o}tock(){return!0}getRank(){return 1}next(){this.m_resultCursor||(this.m_method?this.recursiveSliceEqualArea():this.sliceIntoStrips());const t=this.m_resultCursor.next();return t?(this.m_inverseTransform&&!this.m_inverseTransform.isIdentity()&&(t.applyTransformation(this.m_inverseTransform),this.m_bReversePaths&&t.reverseAllPaths()),t):t}getGeometryID(){return this.m_resultCursor?this.m_resultCursor.getGeometryID():-1}sliceIntoStrips(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=k(this.m_polygon,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=k(t,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker)}}recursiveSliceEqualArea(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=P(this.m_polygon,this.m_sr,this.m_partCount,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=P(t,this.m_sr,this.m_partCount,this.m_tracker)}}}const K=new F;function J(t,e,s,r,n){return K.findSlicesByArea(t,e,s,r,n,null)}function Q(t,e,s,r){const n=K.recursiveSliceEqualArea(t,e,s,r,null);return Array.from(n)}function U(t,e,s,r){const n=K.sliceIntoStrips(t,e,s,0,r,null);return Array.from(n)}function Z(){return K.supportsCurves()}export{J as findSlicesByArea,Q as recursiveSliceEqualArea,U as sliceIntoStrips,Z as supportsCurves};
