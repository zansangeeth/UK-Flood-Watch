/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.34/esri/copyright.txt for details.
*/
import{__addDisposableResource as e,__disposeResources as t}from"tslib";import{a as n,G as s,h as o,t as r,d as i,g as a}from"./Geometry.js";import{m as c,a as m,c as l}from"./SideCalculator2D-BNwb5gvz.js";import{a as u,b as g,S as f,s as y}from"./MultiPathImpl.js";import{P as S,d,c as N,m as x}from"./Point2D.js";import{P as h,d as p}from"./Envelope.js";import{G as A}from"./SimpleGeometryCursor.js";import{O as C,E as w,ad as P,r as E,a9 as _,av as T,aw as j,ax as G,ag as I,ay as D,az as v,aA as b,a6 as R,a7 as U,aB as q,aC as B}from"./UnitFactory.js";import{O as F}from"./OperatorShapePreservingDensify.js";class O{getOperatorType(){return 10501}supportsCurves(){return!0}accelerateGeometry(e,t,n){return!1}canAccelerateGeometry(e){return!1}getNearestCoordinate(e,t,y,d,N,x){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return c();if(Number.isNaN(d)&&(d=0),d>=0||n("maxDeviationMeters"),0===e.getDimension())return this.getNearestVertex(e,t,y);const A=e.getGeometryType();if(A===s.enumGeometryCollection){const n=e;let s=c();for(let e=0,o=n.getGeometryCount();e<o;++e){const o=n.getGeometry(e),r=this.getNearestCoordinate(o,t,y,d,N,x);if(!r.isEmpty()){if(0===r.m_distance)return r;r.m_distance>=s.m_distance||(s=r,s.m_geometryIndex=e)}}return s}if(A===s.enumEnvelope){const n=new u;return n.addEnvelope(e,!1),this.getNearestCoordinate(n,t,y,d,N,x)}o(A)||r("Operation is not implemented for this geometry type");const D=e;if((N||x)&&A===s.enumPolygon){const n=()=>{const e=m(t,-1,0);return e.m_bRightSide=!0,e};if(y.isPannable()){const s=(new C).foldInto360Range(new h(t),y);if(s.isEmpty())return c();const o=(new C).foldInto360Range(e,y);if(o.isEmpty())return c();if((new w).execute(o,s,y,null)&&N)return n()}else{const e=(new C).clipToSpatialReference(new h(t),y,null,1);if(e.isEmpty())return c();const s=P(D,y,0,null);if(s.isEmpty())return c();if((new w).execute(s,e,y,null)&&N)return n()}}const v=y!==y.getGCS()?y.getSRToGCSTransform():null,b=new S;if(v?(new C).transform(v,[t],1,[b],!1):b.assign(t),b.isNAN())return c();const R=Y(D,t,y,1);let U=R.m_distance;if(0===U)return R;Number.isNaN(U)?U=Number.POSITIVE_INFINITY:U*=1+1e-7;const q=y.getGCS(),B=q.getUnit().getUnitToBaseFactor(),O=b.clone();O.scale(B);const V=E();y.querySpheroidData(V);const M=_(V.majorSemiAxis,V.e2,O),L=T(V.majorSemiAxis,V.e2),z=new X(D.querySegmentIterator());0===d&&(d=.01);const H=V.majorSemiAxis*g(45),J=(new F).executeMany(z,y,H,d,0,null),K=[];let Q=-1;const W=new p,Z=new f;for(let n=J.next();null!==n;n=J.next()){if(n.isEmpty())continue;const t=J.getGeometryID(),s=e.getPathIndexFromPointIndex(t);e.isClosedPath(s)&&D.getPathEnd(s);const o=n;for(let e=0,n=o.getPathCount();e<n;++e){K.length=0;for(let t=o.getPathStart(e),r=o.getPathEnd(e);t<r;++t)K.push(o.getXY(t));if(v&&(new C).transform(v,K,K.length,K,!1),K.length>3){const e=k(K,K.length,b,q,1);if(e.m_distance<U){U=e.m_distance,W.assign(_(V.majorSemiAxis,V.e2,e.m_coordinate.mul(B))),Q=t;let n=e.m_vertexIndex;n+1===K.length&&(n-=1),o.getSegmentBuffer(n,Z,!0)}}K.forEach(e=>e.mulThis(B));const n=_(V.majorSemiAxis,V.e2,K[0]),s=new p;for(let e=1,r=K.length;e<r;++e){const r=_(V.majorSemiAxis,V.e2,K[e]);if(j(L,M,n,r,s)<U){const{second:s}=G(V.majorSemiAxis,V.e2,M,n,r,2,null);if(s<=U){const s=new p,{second:i}=G(V.majorSemiAxis,V.e2,M,n,r,0,s);i<U&&(U=i,W.assign(s),Q=t,o.getSegmentBuffer(e-1,Z,!0))}}n.assign(r)}}}if(!Number.isFinite(U))return c();-1===Q&&n("");const $=I(V.majorSemiAxis,V.e2,W);$.divThis(B);const ee=$.clone(),te=y!==y.getGCS()?y.getGCSToSRTransform():null;te&&(new C).transform(te,[$],1,[ee],!1),ee.isNAN()&&i("closestPoint2DSr.isNAN()"),a(!Z.empty());const ne=Z.get().getClosestCoordinate(ee,!1);ee.assign(Z.get().getCoord2D(ne)),v?(new C).transform(v,[ee],1,[$],!1):$.assign(ee),a(!$.isNAN());const se=this.getNearestVertex(new h($),b,y.getGCS()),oe=m(ee,Q,se.m_distance);if(x&&e.getDimension()>0){const n=l(e,t,-1,-1),s=0!==n&&3!==n;oe.m_bRightSide=s}return oe}getNearestVertex(e,t,o){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return c();switch(e.getGeometryType()){case s.enumPoint:return V(e,t,o);case s.enumMultiPoint:case s.enumPolyline:case s.enumPolygon:return Y(e,t,o);default:r("")}}getNearestVertexPoint2D(e,t,n,s){return k(e,t,n,s)}getNearestVertices(e,t,o,i,a){if(t.isNAN()&&n("NAN xy coordinates are not allowed"),e.isEmpty())return[];switch(e.getGeometryType()){case s.enumPoint:{const n=V(e,t,o);if(!n.isEmpty()&&n.m_distance<i&&a>=1){const e=[];return e.push(n),e}return[]}case s.enumMultiPoint:case s.enumPolyline:case s.enumPolygon:return M(e,t,o,i,a);default:r("")}}}function V(s,o,r){const i={stack:[],error:void 0,hasError:!1};try{if(0===r.getCoordinateSystemType()&&n("Cannot use local SR"),1!==r.getCoordinateSystemType()){const e=new Array(2);e[0]=s.getXY(),e[1]=o.clone();const t=x(S,2);2!==q(r,e,2,t)&&n("Point cannot be projected to GCS");const i=r.getGCS(),a=V(new h(t[0]),t[1],i);return m(a.m_coordinate,0,a.m_distance)}const t=r.getUnit().getUnitToBaseFactor(),a=s.getXY();a.scale(t);const c=o.clone();c.scale(t);const l=E();r.querySpheroidData(l);const u=e(i,new R,!1);U.geodeticDistance(l.majorSemiAxis,l.e2,a.x,a.y,c.x,c.y,u,null,null,B.PE_LINETYPE_GEODESIC);const g=s.getXY();return m(g,0,u.val)}catch(a){i.error=a,i.hasError=!0}finally{t(i)}}function Y(s,o,r,i=0){0===r.getCoordinateSystemType()&&n("Cannot use local SR");let a=s.getAttributeStreamRef(0),c=s.getPointCount();const l=r.getGCS(),u=o.clone();if(1!==r.getCoordinateSystemType()){const e=r.getSRToGCSTransform();if(D(e,[o],1,[u],null),u.isNAN())return m(S.getNAN(),-1,Number.NaN);const t=(new C).execute(s,e,null);a=t.getAttributeStreamRef(0),c=t.getPointCount()}const g=l.getUnit().getUnitToBaseFactor(),f=d(c,0);for(let e=0;e<c;++e)f[e]=e;y(c,f);const x=E();l.querySpheroidData(x);const h=u.clone();h.scale(g);const A=_(x.majorSemiAxis,x.e2,h);let w=-1,P=Number.MAX_VALUE;const T=v(x.majorSemiAxis,x.e2);let j=c;const G=new S,I=new S;for(let e=0;e<j;){if(a.queryPoint2D(2*f[e],G),G.isNAN())continue;I.assign(G),I.scale(g);const t=_(x.majorSemiAxis,x.e2,I);if(p.distance(t,A)>P){f[j-1]=N(f[e],f[e]=f[j-1]),j--;continue}const n=b(T,t,A);n<P&&(w=f[e],P=n),e++}if(0!==x.e2){const n={stack:[],error:void 0,hasError:!1};try{const t=e(n,new R,!1);for(let e=0;e<j;e++){if(a.queryPoint2D(2*f[e],G),G.isNAN())continue;I.assign(G),I.scale(g);const n=_(x.majorSemiAxis,x.e2,I);p.distance(n,A)>P||(U.geodeticDistance(x.majorSemiAxis,x.e2,h.x,h.y,I.x,I.y,t,null,null,i),t.val<P&&(w=f[e],P=t.val))}}catch(B){n.error=B,n.hasError=!0}finally{t(n)}}const q=new S;return-1!==w&&q.assign(s.getXY(w)),m(q,w,P)}function k(s,o,r,i,a=0){0===i.getCoordinateSystemType()&&n("Cannot use local SR");const l=i.getGCS(),u=r.clone();if(1!==i.getCoordinateSystemType()){const e=i.getSRToGCSTransform();if(D(e,[r],1,[u],null),u.isNAN())return c();const t=x(S,o);D(e,s,o,t,null);const n=k(t,o,r,l,a);return n.isEmpty()?n:m(s[n.m_vertexIndex],n.m_vertexIndex,n.m_distance)}const g=l.getUnit().getUnitToBaseFactor(),f=d(o,0);for(let e=0;e<o;++e)f[e]=e;y(o,f);const h=E();l.querySpheroidData(h);const A=u.clone();A.scale(g);const C=_(h.majorSemiAxis,h.e2,A);let w=-1,P=Number.MAX_VALUE;const T=v(h.majorSemiAxis,h.e2);let j=o;for(let e=0;e<j;){const t=s[f[e]];if(t.isNAN())continue;const n=t.clone();n.scale(g);const o=_(h.majorSemiAxis,h.e2,n);if(p.distance(o,C)>P){f[j-1]=N(f[e],f[e]=f[j-1]),j--;continue}const r=b(T,o,C);r<P&&(w=f[e],P=r),e++}if(0!==h.e2){const n={stack:[],error:void 0,hasError:!1};try{const t=e(n,new R,!1);for(let e=0;e<j;e++){const n=s[f[e]];if(n.isNAN())continue;const o=n.clone();o.scale(g);const r=_(h.majorSemiAxis,h.e2,o);p.distance(r,C)>P||(U.geodeticDistance(h.majorSemiAxis,h.e2,A.x,A.y,o.x,o.y,t,null,null,a),t.val<P&&(w=f[e],P=t.val))}}catch(I){n.error=I,n.hasError=!0}finally{t(n)}}const G=new S;return-1!==w&&G.assign(s[w]),m(G,w,P)}function M(s,o,r,i,a){const c={stack:[],error:void 0,hasError:!1};try{0===r.getCoordinateSystemType()&&n("Cannot use local SR");let t=s.getAttributeStreamRef(0),l=s.getPointCount();const u=r.getGCS(),g=o.clone();if(1!==r.getCoordinateSystemType()){const e=r.getSRToGCSTransform();if(D(e,[o],1,[g],null),g.isNAN())return[];const n=(new C).execute(s,e,null);t=n.getAttributeStreamRef(0),l=n.getPointCount()}const f=u.getUnit().getUnitToBaseFactor(),x=d(l,0);for(let e=0;e<l;++e)x[e]=e;y(l,x);const h=E();u.querySpheroidData(h);const A=g.clone();A.scale(f);const w=_(h.majorSemiAxis,h.e2,A),P=[];let T=l;const j=new S,G=new S;for(let e=0;e<T;){if(t.queryPoint2D(2*x[e],j),j.isNAN())continue;G.assign(j),G.scale(f);const n=_(h.majorSemiAxis,h.e2,G);p.distance(n,w)>i?(x[T-1]=N(x[e],x[e]=x[T-1]),T--):e++}const I=(e,t)=>e.m_distance-t.m_distance,v=e(c,new R,!1);for(let e=0;e<T;e++)t.queryPoint2D(2*x[e],j),j.isNAN()||(U.geodeticDistance(h.majorSemiAxis,h.e2,A.x,A.y,j.x*f,j.y*f,v,null,null,B.PE_LINETYPE_GEODESIC),v.val<i&&P.push(m(j,x[e],v.val)));return P.sort(I),P.slice(0,a)}catch(l){c.error=l,c.hasError=!0}finally{t(c)}}class X extends A{constructor(e){super(),this.m_first=!0,this.m_segIter=e,this.m_segIter.stripAttributes()}tock(){return!0}getRank(){return 1}next(){if(this.m_first){if(!this.m_segIter.nextPath())return null;this.m_first=!1}for(;;){if(this.m_segIter.hasNextSegment())return this.m_segIter.nextSegment().clone();if(!this.m_segIter.nextPath())break}return null}getGeometryID(){return this.m_segIter.getStartPointIndex()}}export{O as OperatorProximityGeodesic};
