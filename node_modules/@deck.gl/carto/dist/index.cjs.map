{
  "version": 3,
  "sources": ["../src/index.ts", "../src/layers/cluster-tile-layer.ts", "../src/layers/cluster-utils.ts", "../src/utils.ts", "../src/constants.ts", "../src/layers/quadbin-tileset-2d.ts", "../src/layers/h3-tileset-2d.ts", "../src/layers/quadbin-utils.ts", "../src/layers/schema/fast-pbf.ts", "../src/layers/schema/carto-tile.ts", "../src/layers/schema/carto-spatial-tile.ts", "../src/layers/schema/tile-loader-utils.ts", "../src/layers/schema/spatialjson-utils.ts", "../src/layers/schema/carto-spatial-tile-loader.ts", "../src/layers/utils.ts", "../src/layers/h3-tile-layer.ts", "../src/layers/spatial-index-tile-layer.ts", "../src/layers/heatmap-tile-layer.ts", "../src/layers/heatmap.ts", "../src/layers/post-process-utils.ts", "../src/layers/quadbin-tile-layer.ts", "../src/layers/quadbin-layer.ts", "../src/layers/point-label-layer.ts", "../src/layers/raster-tile-layer.ts", "../src/layers/raster-layer.ts", "../src/layers/raster-layer-vertex.glsl.ts", "../src/layers/schema/carto-raster-tile.ts", "../src/layers/schema/carto-raster-tile-loader.ts", "../src/layers/vector-tile-layer.ts", "../src/layers/schema/carto-properties-tile.ts", "../src/layers/schema/carto-properties-tile-loader.ts", "../src/layers/schema/carto-vector-tile-loader.ts", "../src/layers/label-utils.ts", "../src/basemap.ts", "../src/style/color-bins-style.ts", "../src/style/palette.ts", "../src/style/utils.ts", "../src/style/color-categories-style.ts", "../src/style/color-continuous-style.ts", "../src/api/fetch-map.ts", "../src/api/basemap.ts"],
  "sourcesContent": ["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// CARTO Layers\nimport {default as ClusterTileLayer} from './layers/cluster-tile-layer';\nimport {default as H3TileLayer} from './layers/h3-tile-layer';\nimport {default as HeatmapTileLayer} from './layers/heatmap-tile-layer';\nimport {default as PointLabelLayer} from './layers/point-label-layer';\nimport {default as QuadbinTileLayer} from './layers/quadbin-tile-layer';\nimport {default as RasterTileLayer} from './layers/raster-tile-layer';\nimport {default as VectorTileLayer} from './layers/vector-tile-layer';\n\n// Exports for playground/bindings\nconst CARTO_LAYERS = {\n  ClusterTileLayer,\n  H3TileLayer,\n  HeatmapTileLayer,\n  PointLabelLayer,\n  QuadbinTileLayer,\n  RasterTileLayer,\n  VectorTileLayer\n};\nexport {\n  CARTO_LAYERS,\n  ClusterTileLayer,\n  H3TileLayer,\n  HeatmapTileLayer,\n  PointLabelLayer,\n  QuadbinTileLayer,\n  RasterTileLayer,\n  VectorTileLayer\n};\n\n// Internal Layers\nexport {default as _QuadbinLayer} from './layers/quadbin-layer';\nexport {default as _RasterLayer} from './layers/raster-layer';\nexport {default as _SpatialIndexTileLayer} from './layers/spatial-index-tile-layer';\n\n// Types\nexport type {ClusterTileLayerProps} from './layers/cluster-tile-layer';\nexport type {H3TileLayerProps} from './layers/h3-tile-layer';\nexport type {HeatmapTileLayerProps} from './layers/heatmap-tile-layer';\nexport type {PointLabelLayerProps} from './layers/point-label-layer';\nexport type {QuadbinLayerProps} from './layers/quadbin-layer';\nexport type {QuadbinTileLayerProps} from './layers/quadbin-tile-layer';\nexport type {RasterLayerProps} from './layers/raster-layer';\nexport type {RasterTileLayerProps} from './layers/raster-tile-layer';\nexport type {SpatialIndexTileLayerProps} from './layers/spatial-index-tile-layer';\nexport type {VectorTileLayerProps} from './layers/vector-tile-layer';\n\n// Helpers\nexport {\n  default as BASEMAP,\n  GOOGLE_BASEMAPS as _GOOGLE_BASEMAPS,\n  getStyleUrl as _getStyleUrl,\n  fetchStyle as _fetchStyle,\n  applyLayerGroupFilters as _applyLayerGroupFilters,\n  STYLE_LAYER_GROUPS as _STYLE_LAYER_GROUPS\n} from './basemap';\nexport {default as colorBins} from './style/color-bins-style';\nexport {default as colorCategories} from './style/color-categories-style';\nexport {default as colorContinuous} from './style/color-continuous-style';\nexport {fetchMap, LayerFactory} from './api/fetch-map';\nexport {fetchBasemapProps} from './api/basemap';\nexport type {\n  FetchMapOptions,\n  FetchMapResult,\n  Basemap as _Basemap,\n  MapLibreBasemap as _MapLibreBasemap,\n  GoogleBasemap as _GoogleBasemap\n} from './api/index';\n\n// TODO(v10): Consider removing re-exports from '@carto/api-client' below.\n\nexport {\n  CARTO_SOURCES,\n  boundaryQuerySource,\n  boundaryTableSource,\n  h3QuerySource,\n  h3TableSource,\n  h3TilesetSource,\n  rasterSource,\n  quadbinQuerySource,\n  quadbinTableSource,\n  quadbinTilesetSource,\n  vectorQuerySource,\n  vectorTableSource,\n  vectorTilesetSource,\n  query,\n  CartoAPIError,\n  SOURCE_DEFAULTS\n} from '@carto/api-client';\n\nexport type {\n  TilejsonResult,\n  SourceOptions,\n  QuerySourceOptions,\n  TableSourceOptions,\n  TilesetSourceOptions,\n  BoundaryQuerySourceOptions,\n  BoundaryTableSourceOptions,\n  H3QuerySourceOptions,\n  H3TableSourceOptions,\n  H3TilesetSourceOptions,\n  RasterSourceOptions,\n  QuadbinQuerySourceOptions,\n  QuadbinTableSourceOptions,\n  QuadbinTilesetSourceOptions,\n  VectorQuerySourceOptions,\n  VectorTableSourceOptions,\n  VectorTilesetSourceOptions,\n  QueryParameters\n} from '@carto/api-client';\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable no-shadow */\n\nimport {GeoJsonLayer, GeoJsonLayerProps} from '@deck.gl/layers';\nimport {\n  TileLayer,\n  _Tile2DHeader as Tile2DHeader,\n  TileLayerProps,\n  TileLayerPickingInfo\n} from '@deck.gl/geo-layers';\nimport {registerLoaders} from '@loaders.gl/core';\nimport {binaryToGeojson} from '@loaders.gl/gis';\nimport {BinaryFeatureCollection} from '@loaders.gl/schema';\nimport type {Feature, Geometry} from 'geojson';\n\nimport {\n  Accessor,\n  DefaultProps,\n  CompositeLayer,\n  _deepEqual as deepEqual,\n  GetPickingInfoParams,\n  Layer,\n  LayersList,\n  PickingInfo,\n  WebMercatorViewport\n} from '@deck.gl/core';\n\nimport {\n  aggregateTile,\n  ClusteredFeaturePropertiesT,\n  clustersToBinary,\n  computeAggregationStats,\n  extractAggregationProperties,\n  ParsedQuadbinCell,\n  ParsedQuadbinTile,\n  ParsedH3Cell,\n  ParsedH3Tile\n} from './cluster-utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\nimport QuadbinTileset2D from './quadbin-tileset-2d';\nimport H3Tileset2D, {getHexagonResolution} from './h3-tileset-2d';\nimport {getQuadbinPolygon} from './quadbin-utils';\nimport {getResolution, cellToLatLng} from 'h3-js';\nimport CartoSpatialTileLoader from './schema/carto-spatial-tile-loader';\nimport {TilejsonPropType, mergeLoadOptions} from './utils';\nimport type {TilejsonResult} from '@carto/api-client';\n\nregisterLoaders([CartoSpatialTileLoader]);\n\nfunction getScheme(tilesetClass: typeof H3Tileset2D | typeof QuadbinTileset2D): 'h3' | 'quadbin' {\n  if (tilesetClass === H3Tileset2D) return 'h3';\n  if (tilesetClass === QuadbinTileset2D) return 'quadbin';\n  throw new Error('Invalid tileset class');\n}\n\nconst defaultProps: DefaultProps<ClusterTileLayerProps> = {\n  data: TilejsonPropType,\n  clusterLevel: {type: 'number', value: 5, min: 1},\n  getPosition: {\n    type: 'accessor',\n    value: ({id}) => {\n      // Determine scheme based on ID type: H3 uses string IDs, Quadbin uses bigint IDs\n      if (typeof id === 'string') {\n        const [lat, lng] = cellToLatLng(id);\n        return [lng, lat];\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n      return getQuadbinPolygon(id as bigint, 0.5).slice(2, 4) as [number, number];\n    }\n  },\n  getWeight: {type: 'accessor', value: 1},\n  refinementStrategy: 'no-overlap',\n  tileSize: DEFAULT_TILE_SIZE\n};\n\nexport type ClusterTileLayerPickingInfo<FeaturePropertiesT = {}> = TileLayerPickingInfo<\n  ParsedQuadbinTile<FeaturePropertiesT> | ParsedH3Tile<FeaturePropertiesT>,\n  PickingInfo<Feature<Geometry, FeaturePropertiesT>>\n>;\n\n/** All properties supported by ClusterTileLayer. */\nexport type ClusterTileLayerProps<FeaturePropertiesT = unknown> =\n  _ClusterTileLayerProps<FeaturePropertiesT> &\n    Omit<\n      TileLayerProps<ParsedQuadbinTile<FeaturePropertiesT> | ParsedH3Tile<FeaturePropertiesT>>,\n      'data'\n    >;\n\n/** Properties added by ClusterTileLayer. */\ntype _ClusterTileLayerProps<FeaturePropertiesT> = Omit<\n  GeoJsonLayerProps<ClusteredFeaturePropertiesT<FeaturePropertiesT>>,\n  'data'\n> & {\n  data: null | TilejsonResult | Promise<TilejsonResult>;\n\n  /**\n   * The number of aggregation levels to cluster cells by. Larger values increase\n   * the clustering radius, with an increment of `clusterLevel` doubling the radius.\n   *\n   * @default 5\n   */\n  clusterLevel?: number;\n\n  /**\n   * The (average) position of points in a cell used for clustering.\n   * If not supplied the center of the quadbin cell or H3 cell is used.\n   *\n   * @default cell center\n   */\n  getPosition?: Accessor<\n    ParsedQuadbinCell<FeaturePropertiesT> | ParsedH3Cell<FeaturePropertiesT>,\n    [number, number]\n  >;\n\n  /**\n   * The weight of each cell used for clustering.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<\n    ParsedQuadbinCell<FeaturePropertiesT> | ParsedH3Cell<FeaturePropertiesT>,\n    number\n  >;\n};\n\nclass ClusterGeoJsonLayer<\n  FeaturePropertiesT extends {} = {},\n  ExtraProps extends {} = {}\n> extends TileLayer<\n  ParsedQuadbinTile<FeaturePropertiesT> | ParsedH3Tile<FeaturePropertiesT>,\n  ExtraProps & Required<_ClusterTileLayerProps<FeaturePropertiesT>>\n> {\n  static layerName = 'ClusterGeoJsonLayer';\n  static defaultProps = defaultProps;\n  state!: TileLayer<FeaturePropertiesT>['state'] & {\n    data: BinaryFeatureCollection;\n    clusterIds: (bigint | string)[];\n    hoveredFeatureId: bigint | string | number | null;\n    highlightColor: number[];\n    aggregationCache: WeakMap<any, Map<number, ClusteredFeaturePropertiesT<FeaturePropertiesT>[]>>;\n    scheme: string | null;\n  };\n\n  initializeState() {\n    super.initializeState();\n    this.state.aggregationCache = new WeakMap();\n    this.state.scheme = getScheme(this.props.TilesetClass as any);\n  }\n\n  updateState(opts) {\n    const {props} = opts;\n    const scheme = getScheme(props.TilesetClass);\n    if (this.state.scheme !== scheme) {\n      // Clear caches when scheme changes\n      this.setState({scheme, tileset: null});\n      this.state.aggregationCache = new WeakMap();\n    }\n\n    super.updateState(opts);\n  }\n\n  // eslint-disable-next-line max-statements\n  renderLayers(): Layer | null | LayersList {\n    const visibleTiles = this.state.tileset?.tiles.filter((tile: Tile2DHeader) => {\n      return tile.isLoaded && tile.content && this.state.tileset!.isTileVisible(tile);\n    }) as Tile2DHeader<ParsedQuadbinTile<FeaturePropertiesT> | ParsedH3Tile<FeaturePropertiesT>>[];\n    if (!visibleTiles?.length || !this.state.tileset) {\n      return null;\n    }\n    visibleTiles.sort((a, b) => b.zoom - a.zoom);\n    const {getPosition, getWeight} = this.props;\n    const {aggregationCache, scheme} = this.state;\n\n    const isH3 = scheme === 'h3';\n\n    const properties = extractAggregationProperties(visibleTiles[0]);\n    const data = [] as ClusteredFeaturePropertiesT<FeaturePropertiesT>[];\n    let needsUpdate = false;\n\n    const aggregationLevels = this._getAggregationLevels(visibleTiles);\n\n    for (const tile of visibleTiles) {\n      // Calculate aggregation based on viewport zoom\n      let tileAggregationCache = aggregationCache.get(tile.content);\n      if (!tileAggregationCache) {\n        tileAggregationCache = new Map();\n        aggregationCache.set(tile.content, tileAggregationCache);\n      }\n      const didAggregate = aggregateTile(\n        tile,\n        tileAggregationCache,\n        aggregationLevels,\n        properties,\n        getPosition,\n        getWeight,\n        isH3 ? 'h3' : 'quadbin'\n      );\n      needsUpdate ||= didAggregate;\n      data.push(...tileAggregationCache.get(aggregationLevels)!);\n    }\n\n    data.sort((a, b) => Number(b.count - a.count));\n\n    const clusterIds = data?.map((tile: any) => tile.id);\n    needsUpdate ||= !deepEqual(clusterIds, this.state.clusterIds, 1);\n    this.setState({clusterIds});\n\n    if (needsUpdate) {\n      const stats = computeAggregationStats(data, properties);\n      const binaryData = clustersToBinary(data);\n      binaryData.points.attributes = {stats};\n      this.setState({data: binaryData});\n    }\n\n    const props = {\n      ...this.props,\n      id: 'clusters',\n      data: this.state.data,\n      dataComparator: (data?: BinaryFeatureCollection, oldData?: BinaryFeatureCollection) => {\n        const newIds = data?.points?.properties?.map((tile: any) => tile.id);\n        const oldIds = oldData?.points?.properties?.map((tile: any) => tile.id);\n        return deepEqual(newIds, oldIds, 1);\n      }\n    } as GeoJsonLayerProps<ClusteredFeaturePropertiesT<FeaturePropertiesT>>;\n\n    return new GeoJsonLayer(this.getSubLayerProps(props));\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): ClusterTileLayerPickingInfo<FeaturePropertiesT> {\n    const info = params.info as TileLayerPickingInfo<\n      ParsedQuadbinTile<FeaturePropertiesT> | ParsedH3Tile<FeaturePropertiesT>\n    >;\n\n    if (info.index !== -1) {\n      const {data} = params.sourceLayer!.props;\n      info.object = binaryToGeojson(data as BinaryFeatureCollection, {\n        globalFeatureId: info.index\n      }) as Feature;\n    }\n\n    return info;\n  }\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    for (const layer of this.getSubLayers()) {\n      layer.updateAutoHighlight(info);\n    }\n  }\n\n  filterSubLayer() {\n    return true;\n  }\n\n  private _getAggregationLevels(visibleTiles: Tile2DHeader[]): number {\n    const isH3 = this.state.scheme === 'h3';\n    const firstTile = visibleTiles[0];\n\n    // Resolution of data present in tiles\n    let tileResolution;\n\n    // Resolution of tiles that should be (eventually) visible in the viewport\n    let viewportResolution;\n    if (isH3) {\n      tileResolution = getResolution(firstTile.id);\n      viewportResolution = getHexagonResolution(\n        this.context.viewport as WebMercatorViewport,\n        (this.state.tileset as any).opts.tileSize\n      );\n    } else {\n      tileResolution = firstTile.zoom;\n      viewportResolution = this.context.viewport.zoom;\n    }\n\n    const resolutionDiff = Math.round(viewportResolution - tileResolution);\n    const aggregationLevels = Math.round(this.props.clusterLevel) - resolutionDiff;\n    return aggregationLevels;\n  }\n}\n\n// Adapter layer around ClusterLayer that converts tileJSON into TileLayer API\nexport default class ClusterTileLayer<\n  FeaturePropertiesT = any,\n  ExtraProps extends {} = {}\n> extends CompositeLayer<ExtraProps & Required<_ClusterTileLayerProps<FeaturePropertiesT>>> {\n  static layerName = 'ClusterTileLayer';\n  static defaultProps = defaultProps;\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    const scheme = tileJSON && 'scheme' in tileJSON ? tileJSON.scheme : 'quadbin';\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}},\n      cartoSpatialTile: {scheme}\n    });\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const tileJSON = this.props.data as TilejsonResult;\n    if (!tileJSON) return null;\n\n    const {tiles: data, maxresolution: maxZoom} = tileJSON;\n    const isH3 = tileJSON && 'scheme' in tileJSON && tileJSON.scheme === 'h3';\n    const TilesetClass = isH3 ? H3Tileset2D : QuadbinTileset2D;\n\n    return [\n      // @ts-ignore\n      new ClusterGeoJsonLayer(this.props, {\n        id: `cluster-geojson-layer-${this.props.id}`,\n        data,\n        // TODO: Tileset2D should be generic over TileIndex type\n        TilesetClass: TilesetClass as any,\n        maxZoom,\n        loadOptions: this.getLoadOptions()\n      })\n    ];\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {cellToParent} from 'quadbin';\nimport {cellToParent as h3CellToParent, getResolution as getH3Resolution} from 'h3-js';\nimport {_Tile2DHeader as Tile2DHeader} from '@deck.gl/geo-layers';\nimport {Accessor, log} from '@deck.gl/core';\nimport {BinaryFeatureCollection} from '@loaders.gl/schema';\nimport {createBinaryPointFeature, createEmptyBinary} from '../utils';\n\nexport type Aggregation = 'any' | 'average' | 'count' | 'min' | 'max' | 'sum';\nexport type AggregationProperties<FeaturePropertiesT> = {\n  aggregation: Aggregation;\n  name: keyof FeaturePropertiesT;\n}[];\nexport type ClusteredFeaturePropertiesT<FeaturePropertiesT> = FeaturePropertiesT & {\n  id: bigint | string;\n  count: number;\n  position: [number, number];\n};\nexport type ParsedQuadbinCell<FeaturePropertiesT> = {id: bigint; properties: FeaturePropertiesT};\nexport type ParsedQuadbinTile<FeaturePropertiesT> = ParsedQuadbinCell<FeaturePropertiesT>[];\nexport type ParsedH3Cell<FeaturePropertiesT> = {id: string; properties: FeaturePropertiesT};\nexport type ParsedH3Tile<FeaturePropertiesT> = ParsedH3Cell<FeaturePropertiesT>[];\n\n/**\n * Aggregates tile by specified properties, caching result in tile.userData\n *\n * @returns true if data was aggregated, false if cache used\n */\nexport function aggregateTile<FeaturePropertiesT>(\n  tile: Tile2DHeader<ParsedQuadbinTile<FeaturePropertiesT> | ParsedH3Tile<FeaturePropertiesT>>,\n  tileAggregationCache: Map<number, ClusteredFeaturePropertiesT<FeaturePropertiesT>[]>,\n  aggregationLevels: number,\n  properties: AggregationProperties<FeaturePropertiesT> = [],\n  getPosition: Accessor<\n    ParsedQuadbinCell<FeaturePropertiesT> | ParsedH3Cell<FeaturePropertiesT>,\n    [number, number]\n  >,\n  getWeight: Accessor<\n    ParsedQuadbinCell<FeaturePropertiesT> | ParsedH3Cell<FeaturePropertiesT>,\n    number\n  >,\n  scheme: 'quadbin' | 'h3' = 'quadbin'\n): boolean {\n  if (!tile.content) return false;\n\n  // Aggregate on demand and cache result\n  if (!tile.userData) tile.userData = {};\n  const cell0 = tileAggregationCache.get(aggregationLevels)?.[0];\n  if (cell0) {\n    // Have already aggregated this tile\n    if (properties.every(property => property.name in cell0)) {\n      // Use cached result\n      return false;\n    }\n\n    // Aggregated properties have changed, re-aggregate\n    tileAggregationCache.clear();\n  }\n\n  const out: Record<string, any> = {};\n  for (const cell of tile.content) {\n    let id = cell.id;\n    const position = typeof getPosition === 'function' ? getPosition(cell, {} as any) : getPosition;\n\n    // Aggregate by parent rid\n    for (let i = 0; i < aggregationLevels - 1; i++) {\n      if (scheme === 'h3') {\n        const currentResolution = getH3Resolution(id as string);\n        id = h3CellToParent(id as string, Math.max(0, currentResolution - 1));\n      } else {\n        id = cellToParent(id as bigint);\n      }\n    }\n\n    // Use string key for both H3 and Quadbin to avoid TypeScript Record<bigint, any> issues\n    // https://github.com/microsoft/TypeScript/issues/46395\n    const parentId = String(id);\n    if (!(parentId in out)) {\n      out[parentId] = {id, count: 0, position: [0, 0]};\n      for (const {name, aggregation} of properties) {\n        if (aggregation === 'any') {\n          // Just pick first value for ANY\n          out[parentId][name] = cell.properties[name];\n        } else {\n          out[parentId][name] = 0;\n        }\n      }\n    }\n    // Layout props\n    const prevTotalW = out[parentId].count;\n    out[parentId].count += typeof getWeight === 'function' ? getWeight(cell, {} as any) : getWeight;\n\n    const totalW = out[parentId].count;\n    const W = totalW - prevTotalW;\n    out[parentId].position[0] = (prevTotalW * out[parentId].position[0] + W * position[0]) / totalW;\n    out[parentId].position[1] = (prevTotalW * out[parentId].position[1] + W * position[1]) / totalW;\n\n    // Re-aggregate other properties so clusters can be styled\n    for (const {name, aggregation} of properties) {\n      const prevValue = out[parentId][name];\n      const value = cell.properties[name] as number;\n      if (aggregation === 'average') {\n        out[parentId][name] = (prevTotalW * prevValue + W * value) / totalW;\n      } else if (aggregation === 'count' || aggregation === 'sum') {\n        out[parentId][name] = prevValue + value;\n      } else if (aggregation === 'max') {\n        out[parentId][name] = Math.max(prevValue, value);\n      } else if (aggregation === 'min') {\n        out[parentId][name] = Math.min(prevValue, value);\n      }\n    }\n  }\n\n  tileAggregationCache.set(aggregationLevels, Object.values(out));\n  return true;\n}\n\nexport function extractAggregationProperties<FeaturePropertiesT extends {}>(\n  tile: Tile2DHeader<ParsedQuadbinTile<FeaturePropertiesT> | ParsedH3Tile<FeaturePropertiesT>>\n): AggregationProperties<FeaturePropertiesT> {\n  const properties: AggregationProperties<FeaturePropertiesT> = [];\n  const validAggregations: Aggregation[] = ['any', 'average', 'count', 'min', 'max', 'sum'];\n  for (const name of Object.keys(tile.content![0].properties)) {\n    let aggregation = name.split('_').pop()!.toLowerCase() as Aggregation;\n    if (!validAggregations.includes(aggregation)) {\n      log.warn(`No valid aggregation present in ${name} property`)();\n      aggregation = 'any';\n    }\n    properties.push({name: name as keyof FeaturePropertiesT, aggregation});\n  }\n\n  return properties;\n}\n\nexport function computeAggregationStats<FeaturePropertiesT>(\n  data: ClusteredFeaturePropertiesT<FeaturePropertiesT>[],\n  properties: AggregationProperties<FeaturePropertiesT>\n) {\n  const stats = {} as Record<keyof FeaturePropertiesT, {min: number; max: number}>;\n  for (const {name, aggregation} of properties) {\n    stats[name] = {min: Infinity, max: -Infinity};\n    if (aggregation !== 'any') {\n      for (const d of data) {\n        stats[name].min = Math.min(stats[name].min, d[name] as number);\n        stats[name].max = Math.max(stats[name].max, d[name] as number);\n      }\n    }\n  }\n\n  return stats;\n}\n\ntype BinaryFeatureCollectionWithStats<FeaturePropertiesT> = Omit<\n  BinaryFeatureCollection,\n  'points'\n> & {\n  points: BinaryFeatureCollection['points'] & {\n    attributes?: {\n      stats: Record<keyof FeaturePropertiesT, {min: number; max: number}>;\n    };\n  };\n};\n\nexport function clustersToBinary<FeaturePropertiesT>(\n  data: ClusteredFeaturePropertiesT<FeaturePropertiesT>[]\n): BinaryFeatureCollectionWithStats<FeaturePropertiesT> {\n  const positions = new Float32Array(data.length * 2);\n  const featureIds = new Uint16Array(data.length);\n  for (let i = 0; i < data.length; i++) {\n    positions.set(data[i].position, 2 * i);\n    featureIds[i] = i;\n  }\n\n  return {\n    ...createEmptyBinary(),\n    points: createBinaryPointFeature(positions, featureIds, featureIds, {}, data)\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {BinaryFeatureCollection, BinaryPointFeature} from '@loaders.gl/schema';\nimport {log} from '@deck.gl/core';\nimport type {Properties, NumericProps} from './layers/schema/spatialjson-utils';\n\nexport function assert(condition: unknown, message?: string): asserts condition {\n  log.assert(condition, message);\n}\n\n// Returns a Proxy object that allows accessing binary data\n// as if it were JSON properties\nexport function createBinaryProxy(\n  data: {numericProps: NumericProps; properties: Properties[]},\n  index: number\n) {\n  const {properties, numericProps} = data;\n  return new Proxy(properties[index] || {}, {\n    get(target, property) {\n      if (property in numericProps) {\n        return numericProps[property as string].value[index];\n      }\n      return target[property as string];\n    },\n\n    has(target, property) {\n      return property in numericProps || property in target;\n    },\n\n    ownKeys(target) {\n      return [...Object.keys(numericProps), ...Reflect.ownKeys(target)];\n    },\n\n    getOwnPropertyDescriptor(target, prop) {\n      return {enumerable: true, configurable: true};\n    }\n  });\n}\n\nexport function getWorkerUrl(id: string, version: string) {\n  // For local testing `yarn build-workers` and then host `modules/carto/dist/`\n  // return `http://localhost:8081/dist/${id}-worker.js`;\n  return `https://unpkg.com/@deck.gl/carto@${version}/dist/${id}-worker.js`;\n}\n\nexport function scaleIdentity() {\n  let unknown;\n\n  function scale(x) {\n    return x === null ? unknown : x;\n  }\n\n  scale.invert = scale;\n\n  scale.domain = scale.range = d => d;\n\n  scale.unknown = u => {\n    if (u) {\n      unknown = u;\n    }\n\n    return unknown;\n  };\n\n  scale.copy = () => {\n    const scaleCopy = scaleIdentity();\n    scaleCopy.unknown(unknown);\n    return scaleCopy;\n  };\n\n  return scale;\n}\n\nexport const isObject: (x: unknown) => boolean = x => x !== null && typeof x === 'object';\n\nexport const isPureObject: (x: any) => boolean = x =>\n  isObject(x) && x.constructor === {}.constructor;\n\n// Helpers for binary data\nconst EMPTY_UINT16ARRAY = new Uint16Array();\nconst EMPTY_BINARY_PROPS: Omit<BinaryPointFeature, 'type'> = {\n  positions: {value: new Float32Array(), size: 2},\n  properties: [],\n  numericProps: {},\n  featureIds: {value: EMPTY_UINT16ARRAY, size: 1},\n  globalFeatureIds: {value: EMPTY_UINT16ARRAY, size: 1}\n};\n\nexport function createEmptyBinary(): Required<BinaryFeatureCollection> {\n  return {\n    shape: 'binary-feature-collection',\n    points: {\n      type: 'Point',\n      ...EMPTY_BINARY_PROPS\n    },\n    lines: {\n      type: 'LineString',\n      pathIndices: {value: EMPTY_UINT16ARRAY, size: 1},\n      ...EMPTY_BINARY_PROPS\n    },\n    polygons: {\n      type: 'Polygon',\n      polygonIndices: {value: EMPTY_UINT16ARRAY, size: 1},\n      primitivePolygonIndices: {value: EMPTY_UINT16ARRAY, size: 1},\n      ...EMPTY_BINARY_PROPS\n    }\n  };\n}\n\nexport function createBinaryPointFeature(\n  positions: number[] | Float32Array | Float64Array,\n  featureIds: number[] | Uint16Array | Uint32Array,\n  globalFeatureIds: number[] | Uint16Array | Uint32Array,\n  numericProps: NumericProps,\n  properties: Properties,\n  size: 2 | 3 = 2\n): BinaryPointFeature {\n  return {\n    type: 'Point',\n    positions: {value: new Float32Array(positions), size},\n    featureIds: {value: new Uint16Array(featureIds), size: 1},\n    globalFeatureIds: {value: new Uint32Array(globalFeatureIds), size: 1},\n    numericProps,\n    properties\n  };\n}\n\nexport function initializeNumericProps(\n  numPoints: number,\n  sourceProps?: NumericProps\n): NumericProps {\n  const numericProps: NumericProps = {};\n  if (sourceProps) {\n    Object.keys(sourceProps).forEach(prop => {\n      numericProps[prop] = {value: new Float32Array(numPoints), size: 1};\n    });\n  }\n  return numericProps;\n}\n\nexport function copyNumericProps(\n  sourceProps: NumericProps,\n  targetProps: NumericProps,\n  sourceIndex: number,\n  targetIndex: number\n): void {\n  Object.keys(sourceProps).forEach(prop => {\n    targetProps[prop].value[targetIndex] = sourceProps[prop].value[sourceIndex];\n  });\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport const DEFAULT_TILE_SIZE = 512;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {_Tileset2D as Tileset2D} from '@deck.gl/geo-layers';\nimport {bigIntToHex, cellToParent, cellToTile, getResolution, tileToCell} from 'quadbin';\n\n// For calculations bigint representation is used, but\n// for constructing URL also provide the hexidecimal value\ntype QuadbinTileIndex = {q: bigint; i?: string};\n\nexport default class QuadbinTileset2D extends Tileset2D {\n  // @ts-expect-error for spatial indices, TileSet2d should be parametrized by TileIndexT\n  getTileIndices(opts): QuadbinTileIndex[] {\n    return super\n      .getTileIndices(opts)\n      .map(tileToCell)\n      .map(q => ({q, i: bigIntToHex(q)}));\n  }\n\n  // @ts-expect-error TileIndex must be generic\n  getTileId({q, i}: QuadbinTileIndex): string {\n    return i || bigIntToHex(q);\n  }\n\n  // @ts-expect-error TileIndex must be generic\n  getTileMetadata({q}: QuadbinTileIndex) {\n    return super.getTileMetadata(cellToTile(q));\n  }\n\n  // @ts-expect-error TileIndex must be generic\n  getTileZoom({q}: QuadbinTileIndex): number {\n    return Number(getResolution(q));\n  }\n\n  // @ts-expect-error TileIndex must be generic\n  getParentIndex({q}: QuadbinTileIndex): QuadbinTileIndex {\n    return {q: cellToParent(q)};\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {_Tileset2D as Tileset2D, GeoBoundingBox} from '@deck.gl/geo-layers';\nimport {\n  polygonToCells,\n  latLngToCell,\n  getResolution,\n  cellToBoundary,\n  cellToParent,\n  gridDisk,\n  edgeLength,\n  UNITS,\n  originToDirectedEdges\n} from 'h3-js';\n\nexport type H3TileIndex = {i: string};\n\nconst MAX_LATITUDE = 85.051128;\n\n/**\n * `polygonToCells()` fills based on hexagon center, this function will\n * pad the bounds such that all cells that overlap the bounds will be included.\n *\n * @param bbox - The bounding box to pad.\n * @param resolution - The resolution of the hexagons.\n * @param scale - The scale of the buffer. 1 is to pad by the max edge length of the tile cell.\n * @returns The padded bounding box.\n */\nfunction padBoundingBox(\n  {west, north, east, south}: GeoBoundingBox,\n  resolution: number,\n  scale: number = 1.0\n): GeoBoundingBox {\n  const corners = [\n    [north, east],\n    [south, east],\n    [south, west],\n    [north, west]\n  ];\n  const cornerCells = corners.map(c => latLngToCell(c[0], c[1], resolution));\n  const cornerEdgeLengths = cornerCells.map(\n    c => (Math.max(...originToDirectedEdges(c).map(e => edgeLength(e, UNITS.rads))) * 180) / Math.PI\n  );\n  const bufferLat = Math.max(...cornerEdgeLengths) * scale;\n  const bufferLon = Math.min(180, bufferLat / Math.cos((((north + south) / 2) * Math.PI) / 180));\n\n  return {\n    north: Math.min(north + bufferLat, MAX_LATITUDE),\n    east: east + bufferLon,\n    south: Math.max(south - bufferLat, -MAX_LATITUDE),\n    west: west - bufferLon\n  };\n}\n\nfunction getHexagonsInBoundingBox(\n  {west, north, east, south}: GeoBoundingBox,\n  resolution: number\n): string[] {\n  const longitudeSpan = Math.abs(east - west);\n  if (longitudeSpan > 180) {\n    // This is a known issue in h3-js: polygonToCells does not work correctly\n    // when longitude span is larger than 180 degrees.\n    const nSegments = Math.ceil(longitudeSpan / 180);\n    let h3Indices: string[] = [];\n    for (let s = 0; s < nSegments; s++) {\n      const segmentWest = west + s * 180;\n      const segmentEast = Math.min(segmentWest + 179.9999999, east);\n      h3Indices = h3Indices.concat(\n        getHexagonsInBoundingBox({west: segmentWest, north, east: segmentEast, south}, resolution)\n      );\n    }\n    return [...new Set(h3Indices)];\n  }\n\n  const polygon = [\n    [north, east],\n    [south, east],\n    [south, west],\n    [north, west],\n    [north, east]\n  ];\n  return polygonToCells(polygon, resolution);\n}\n\nfunction tileToBoundingBox(index: string): GeoBoundingBox {\n  const coordinates = cellToBoundary(index);\n  const latitudes = coordinates.map(c => c[0]);\n  const longitudes = coordinates.map(c => c[1]);\n  const west = Math.min(...longitudes);\n  const south = Math.min(...latitudes);\n  const east = Math.max(...longitudes);\n  const north = Math.max(...latitudes);\n  const bbox = {west, south, east, north};\n\n  // H3 child cells extend beyond their parent's boundary forming a \"snowflake\"\n  // fractal pattern. The required buffer is approximately 10% of the\n  // edge length of the tile cell, add a bit more to be safe.\n  return padBoundingBox(bbox, getResolution(index), 0.12);\n}\n\n// Resolution conversion function. Takes a WebMercatorViewport and returns\n// a H3 resolution such that the screen space size of the hexagons is\n// similar\n// Relative scale factor (0 = no biasing, 2 = a few hexagons cover view)\nconst BIAS = 2;\nexport function getHexagonResolution(\n  viewport: {zoom: number; latitude: number},\n  tileSize: number\n): number {\n  // Difference in given tile size compared to deck's internal 512px tile size,\n  // expressed as an offset to the viewport zoom.\n  const zoomOffset = Math.log2(tileSize / 512);\n  const hexagonScaleFactor = (2 / 3) * (viewport.zoom - zoomOffset);\n  const latitudeScaleFactor = Math.log(1 / Math.cos((Math.PI * viewport.latitude) / 180));\n\n  // Clip and bias\n  return Math.max(0, Math.floor(hexagonScaleFactor + latitudeScaleFactor - BIAS));\n}\n\nexport default class H3Tileset2D extends Tileset2D {\n  /**\n   * Returns all tile indices in the current viewport. If the current zoom level is smaller\n   * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,\n   * return tiles that are on maxZoom.\n   */\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileIndices({viewport, minZoom, maxZoom}): H3TileIndex[] {\n    if (viewport.latitude === undefined) return [];\n    const [west, south, east, north] = viewport.getBounds();\n    const {tileSize} = this.opts;\n\n    let z = getHexagonResolution(viewport, tileSize);\n    let indices: string[];\n    if (typeof minZoom === 'number' && Number.isFinite(minZoom) && z < minZoom) {\n      // TODO support `extent` prop\n      return [];\n    }\n    if (typeof maxZoom === 'number' && Number.isFinite(maxZoom) && z > maxZoom) {\n      z = maxZoom;\n\n      // Once we are at max zoom, getHexagonsInBoundingBox doesn't work, simply\n      // get a ring centered on the hexagon in the viewport center\n      const center = latLngToCell(viewport.latitude, viewport.longitude, maxZoom);\n      indices = gridDisk(center, 1);\n    } else {\n      const paddedBounds = padBoundingBox({west, north, east, south}, z);\n      indices = getHexagonsInBoundingBox(paddedBounds, z);\n    }\n\n    return indices.map(i => ({i}));\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileId({i}: H3TileIndex): string {\n    return i;\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileMetadata({i}: H3TileIndex) {\n    return {bbox: tileToBoundingBox(i)};\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getTileZoom({i}: H3TileIndex): number {\n    return getResolution(i);\n  }\n\n  // @ts-expect-error Tileset2D should be generic over TileIndex\n  getParentIndex(index: H3TileIndex): H3TileIndex {\n    const resolution = getResolution(index.i);\n    const i = cellToParent(index.i, resolution - 1);\n    return {i};\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {worldToLngLat} from '@math.gl/web-mercator';\nimport {cellToTile} from 'quadbin';\n\nconst TILE_SIZE = 512;\n\nexport function quadbinToOffset(quadbin: bigint): [number, number, number] {\n  const {x, y, z} = cellToTile(quadbin);\n  const scale = TILE_SIZE / (1 << z);\n  return [x * scale, TILE_SIZE - y * scale, scale];\n}\n\nexport function quadbinToWorldBounds(quadbin: bigint, coverage: number): [number[], number[]] {\n  const [xOffset, yOffset, scale] = quadbinToOffset(quadbin);\n  return [\n    [xOffset, yOffset],\n    [xOffset + coverage * scale, yOffset - coverage * scale]\n  ];\n}\n\nexport function getQuadbinPolygon(quadbin: bigint, coverage = 1): number[] {\n  const [topLeft, bottomRight] = quadbinToWorldBounds(quadbin, coverage);\n  const [w, n] = worldToLngLat(topLeft);\n  const [e, s] = worldToLngLat(bottomRight);\n  return [e, n, e, s, w, s, w, n, e, n];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {GZipCompression} from '@loaders.gl/compression';\n\ntype ReadPackedOptions = {\n  compression: null | 'gzip';\n};\n\n// Optimized (100X speed improvement) reading function for binary data\nexport function readPackedTypedArray(TypedArray, pbf, obj, options?: ReadPackedOptions) {\n  const end = pbf.type === 2 ? pbf.readVarint() + pbf.pos : pbf.pos + 1;\n  const data = pbf.buf.buffer.slice(pbf.pos, end);\n\n  if (options?.compression === 'gzip') {\n    const compression = new GZipCompression();\n    const decompressedData = compression.decompressSync(data);\n    obj.value = new TypedArray(decompressedData);\n  } else {\n    obj.value = new TypedArray(data);\n  }\n\n  pbf.pos = end;\n  return obj.value;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {readPackedTypedArray} from './fast-pbf';\nimport {TypedArray} from '@loaders.gl/loader-utils';\n\n// KeyValueObject ========================================\ninterface KeyValueObject {\n  key: string;\n  value: string;\n}\n\nclass KeyValueObjectReader {\n  static read(pbf, end?: number): KeyValueObject {\n    return pbf.readFields(KeyValueObjectReader._readField, {key: '', value: null}, end);\n  }\n  static _readField(this: void, tag: number, obj: KeyValueObject, pbf) {\n    if (tag === 1) obj.key = pbf.readString();\n    else if (tag === 2) obj.value = pbf.readString();\n  }\n}\n\n// Properties ========================================\n\nexport class PropertiesReader {\n  static read(pbf, end?: number) {\n    return pbf.readFields(PropertiesReader._readField, {}, end);\n  }\n  static _readField(this: void, tag: number, obj: Record<string, string>, pbf) {\n    if (tag === 1) {\n      const {key, value} = KeyValueObjectReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj[key] = value;\n    }\n  }\n}\n\n// Doubles ========================================\n\ninterface Doubles {\n  value: Float64Array;\n  size: number;\n}\n\nclass DoublesReader {\n  static read(pbf, end?: number): Doubles {\n    const {value, size} = pbf.readFields(DoublesReader._readField, {value: [], size: 0}, end);\n    return {value, size};\n  }\n  static _readField(this: void, tag: number, obj, pbf) {\n    if (tag === 1) readPackedTypedArray(Float64Array, pbf, obj);\n    else if (tag === 2) obj.size = pbf.readVarint(true);\n  }\n}\n\n// Ints ========================================\n\ninterface Ints {\n  value: Uint32Array;\n  size: number;\n}\n\nclass IntsReader {\n  static read(pbf, end?: number): Ints {\n    const {value, size} = pbf.readFields(IntsReader._readField, {value: [], size: 0}, end);\n    return {value: new Uint32Array(value), size};\n  }\n  static _readField(this: void, tag: number, obj, pbf) {\n    if (tag === 1) pbf.readPackedVarint(obj.value);\n    else if (tag === 2) obj.size = pbf.readVarint(true);\n  }\n}\n\n// Fields ========================================\n\ninterface Fields {\n  id: number;\n}\n\nclass FieldsReader {\n  static read(pbf, end?: number): Fields {\n    return pbf.readFields(FieldsReader._readField, {id: 0}, end);\n  }\n  static _readField(this: void, tag: number, obj: Fields, pbf) {\n    if (tag === 1) obj.id = pbf.readVarint();\n  }\n}\n\n// NumericProp ========================================\n\nexport interface NumericProp {\n  value: TypedArray;\n  size: number;\n}\n\nclass NumericPropReader {\n  static read(pbf, end?: number): NumericProp {\n    return pbf.readFields(NumericPropReader._readField, {value: []}, end);\n  }\n  static _readField(this: void, tag: number, obj: NumericProp, pbf) {\n    if (tag === 1) readPackedTypedArray(Float64Array, pbf, obj);\n  }\n}\n\n// NumericPropKeyValue ========================================\ninterface NumbericPropKeyValue {\n  key: string;\n  value: NumericProp;\n}\n\nexport class NumericPropKeyValueReader {\n  static read(pbf, end?: number): NumbericPropKeyValue {\n    return pbf.readFields(NumericPropKeyValueReader._readField, {key: '', value: null}, end);\n  }\n  static _readField(this: void, tag: number, obj: NumbericPropKeyValue, pbf) {\n    if (tag === 1) obj.key = pbf.readString();\n    else if (tag === 2) obj.value = NumericPropReader.read(pbf, pbf.readVarint() + pbf.pos);\n  }\n}\n\n// Points ========================================\n\ninterface Points {\n  positions: Doubles;\n  globalFeatureIds: Ints;\n  featureIds: Ints;\n  properties: Record<string, string>[];\n  numericProps: Record<string, NumericProp>;\n  fields: Fields[];\n}\n\nclass PointsReader {\n  static read(pbf, end?: number): Points {\n    return pbf.readFields(\n      PointsReader._readField,\n      {\n        positions: null,\n        globalFeatureIds: null,\n        featureIds: null,\n        properties: [],\n        numericProps: {},\n        fields: []\n      },\n      end\n    );\n  }\n  static _readField(this: void, tag: number, obj: Points, pbf) {\n    if (tag === 1) obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 3) obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 4) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 5) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    } else if (tag === 6) obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));\n  }\n}\n\ninterface Lines extends Points {\n  pathIndices: Ints;\n}\n// Lines ========================================\n\nclass LinesReader {\n  static read(pbf, end?: number): Lines {\n    return pbf.readFields(\n      LinesReader._readField,\n      {\n        positions: null,\n        pathIndices: null,\n        globalFeatureIds: null,\n        featureIds: null,\n        properties: [],\n        numericProps: {},\n        fields: []\n      },\n      end\n    );\n  }\n  static _readField(this: void, tag: number, obj: Lines, pbf) {\n    if (tag === 1) obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.pathIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 3) obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 4) obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 5) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 6) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    } else if (tag === 7) obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));\n  }\n}\n// Polygons ========================================\n\ninterface Polygons extends Points {\n  polygonIndices: Ints;\n  primitivePolygonIndices: Ints;\n  triangles: Ints;\n}\n\nclass PolygonsReader {\n  static read(pbf, end?: number): Polygons {\n    return pbf.readFields(\n      PolygonsReader._readField,\n      {\n        positions: null,\n        polygonIndices: null,\n        globalFeatureIds: null,\n        featureIds: null,\n        primitivePolygonIndices: null,\n        triangles: null,\n        properties: [],\n        numericProps: {},\n        fields: []\n      },\n      end\n    );\n  }\n  static _readField(this: void, tag: number, obj: Polygons, pbf) {\n    if (tag === 1) obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.polygonIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 3) obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 4) obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 5)\n      obj.primitivePolygonIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 6) obj.triangles = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 7) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 8) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    } else if (tag === 9) obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));\n  }\n}\n\n// Tile ========================================\n\nexport interface Tile {\n  points: Points;\n  lines: Lines;\n  polygons: Polygons;\n}\n\nexport class TileReader {\n  static read(pbf, end?: number): Tile {\n    return pbf.readFields(TileReader._readField, {points: null, lines: null, polygons: null}, end);\n  }\n  static _readField(this: void, tag: number, obj: Tile, pbf) {\n    if (tag === 1) obj.points = PointsReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.lines = LinesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 3) obj.polygons = PolygonsReader.read(pbf, pbf.readVarint() + pbf.pos);\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {readPackedTypedArray} from './fast-pbf';\nimport {Indices, IndexScheme} from './spatialjson-utils';\nimport {NumericProp, NumericPropKeyValueReader, PropertiesReader} from './carto-tile';\n\n// Indices =====================================\n\nexport class IndicesReader {\n  static read(pbf, end?: number): Indices {\n    return pbf.readFields(IndicesReader._readField, {value: []}, end);\n  }\n  static _readField(this: void, tag: number, obj, pbf) {\n    if (tag === 1) readPackedTypedArray(BigUint64Array, pbf, obj);\n  }\n}\n\n// Cells =========================================\n\ninterface Cells {\n  indices: Indices;\n  properties: Record<string, string>[];\n  numericProps: Record<string, NumericProp>;\n}\n\nclass CellsReader {\n  static read(pbf, end?: number): Cells {\n    return pbf.readFields(\n      CellsReader._readField,\n      {indices: null, properties: [], numericProps: {}},\n      end\n    );\n  }\n  static _readField(this: void, tag: number, obj: Cells, pbf) {\n    if (tag === 1) obj.indices = IndicesReader.read(pbf, pbf.readVarint() + pbf.pos);\n    else if (tag === 2) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 3) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    }\n  }\n}\n\n// Tile ========================================\n\n// TODO this type is very similar to SpatialBinary, should align\nexport interface Tile {\n  scheme: IndexScheme;\n  cells: Cells;\n}\n\nexport class TileReader {\n  static read(pbf, end?: number): Tile {\n    return pbf.readFields(TileReader._readField, {scheme: 0, cells: null}, end);\n  }\n  static _readField(this: void, tag: number, obj: Tile, pbf) {\n    if (tag === 1) obj.scheme = pbf.readVarint();\n    else if (tag === 2) obj.cells = CellsReader.read(pbf, pbf.readVarint() + pbf.pos);\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport Protobuf from 'pbf';\n\nexport function parsePbf(buffer: ArrayBuffer, TileReader) {\n  const pbf = new Protobuf(buffer);\n  const tile = TileReader.read(pbf);\n  return tile;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {bigIntToHex} from 'quadbin';\nimport {BinaryPointFeature} from '@loaders.gl/schema';\n\nexport type IndexScheme = 'h3' | 'quadbin';\n\nexport type Indices = {value: BigUint64Array};\nexport type NumericProps = BinaryPointFeature['numericProps'];\nexport type Properties = BinaryPointFeature['properties'];\nexport type Cells = {\n  indices: Indices;\n  numericProps: NumericProps;\n  properties: Properties;\n};\nexport type SpatialBinary = {scheme?: IndexScheme; cells: Cells};\nexport type SpatialJson = {\n  id: string | bigint;\n  properties: Properties;\n}[];\n\nexport function binaryToSpatialjson(binary: SpatialBinary): SpatialJson {\n  const {cells, scheme} = binary;\n  const count = cells.indices.value.length;\n  const spatial: any[] = [];\n  for (let i = 0; i < count; i++) {\n    const id = scheme === 'h3' ? bigIntToHex(cells.indices.value[i]) : cells.indices.value[i];\n\n    const properties = {...cells.properties[i]};\n    for (const key of Object.keys(cells.numericProps)) {\n      properties[key] = cells.numericProps[key].value[i];\n    }\n    spatial.push({id, properties});\n  }\n\n  return spatial;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LoaderOptions, LoaderWithParser} from '@loaders.gl/loader-utils';\n\nimport {Tile, TileReader} from './carto-spatial-tile';\nimport {parsePbf} from './tile-loader-utils';\nimport {getWorkerUrl} from '../../utils';\nimport {IndexScheme, binaryToSpatialjson, SpatialJson} from './spatialjson-utils';\n\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\nconst id = 'cartoSpatialTile';\n\ntype CartoSpatialTileLoaderOptions = LoaderOptions & {\n  cartoSpatialTile?: {\n    scheme: IndexScheme;\n    workerUrl: string;\n  };\n};\n\nconst DEFAULT_OPTIONS: CartoSpatialTileLoaderOptions = {\n  cartoSpatialTile: {\n    scheme: 'quadbin',\n    workerUrl: getWorkerUrl(id, VERSION)\n  }\n};\n\nconst CartoSpatialTileLoader: LoaderWithParser = {\n  name: 'CARTO Spatial Tile',\n  version: VERSION,\n  id,\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/vnd.carto-spatial-tile'],\n  category: 'geometry',\n  parse: async (arrayBuffer, options?: CartoSpatialTileLoaderOptions) =>\n    parseCartoSpatialTile(arrayBuffer, options),\n  parseSync: parseCartoSpatialTile,\n  worker: true,\n  options: DEFAULT_OPTIONS\n};\n\nfunction parseCartoSpatialTile(\n  arrayBuffer: ArrayBuffer,\n  options?: CartoSpatialTileLoaderOptions\n): SpatialJson | null {\n  if (!arrayBuffer) return null;\n  const tile: Tile = parsePbf(arrayBuffer, TileReader);\n\n  const {cells} = tile;\n  const scheme = options?.cartoSpatialTile?.scheme;\n  const data = {cells, scheme};\n\n  return binaryToSpatialjson(data);\n}\n\nexport default CartoSpatialTileLoader;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {log} from '@deck.gl/core';\nimport {Tile as PropertiesTile} from './schema/carto-properties-tile';\nimport {Tile as VectorTile} from './schema/carto-tile';\nimport {_deepEqual as deepEqual} from '@deck.gl/core';\nimport type {TilejsonResult} from '@carto/api-client';\n\n/**\n * Merges load options with additional options, creating a new object without mutating the input.\n * Handles nested objects through recursive deep merge with protection against circular references.\n */\nexport function mergeLoadOptions(loadOptions: any, additionalOptions: any, depth = 0): any {\n  if (!loadOptions) {\n    return additionalOptions;\n  }\n  if (!additionalOptions) {\n    return loadOptions;\n  }\n\n  // Safety check against deep recursion\n  if (depth > 10) {\n    return additionalOptions;\n  }\n\n  const result = {...loadOptions};\n\n  for (const key in additionalOptions) {\n    const value = additionalOptions[key];\n    // Skip circular references\n    if (value === loadOptions || value === additionalOptions) {\n      continue;\n    }\n    if (typeof value === 'object' && value !== null) {\n      result[key] = mergeLoadOptions(loadOptions[key], value, depth + 1);\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result;\n}\n\n// eslint-disable-next-line max-statements\nexport function mergeBoundaryData(geometry: VectorTile, properties: PropertiesTile): VectorTile {\n  const mapping = {};\n  for (const {geoid, ...rest} of properties.properties) {\n    if (geoid in mapping) {\n      log.warn('Duplicate geoid key in boundary mapping, using first occurance')();\n    } else {\n      mapping[geoid] = rest;\n    }\n  }\n\n  for (const type of ['points', 'lines', 'polygons']) {\n    const geom = geometry[type];\n    if (geom.positions.value.length === 0) {\n      continue;\n    }\n\n    geom.properties = geom.properties.map(({geoid}) => mapping[geoid]);\n\n    // numericProps need to be filled to match length of positions buffer\n    const {positions, globalFeatureIds} = geom;\n    let indices: Uint16Array | Uint32Array | null = null;\n    if (type === 'lines') indices = geom.pathIndices.value;\n    if (type === 'polygons') indices = geom.polygonIndices.value;\n    const length = positions.value.length / positions.size;\n    for (const key in properties.numericProps) {\n      const sourceProp = properties.numericProps[key].value;\n      const TypedArray = sourceProp.constructor as\n        | Float32ArrayConstructor\n        | Float64ArrayConstructor;\n      const destProp = new TypedArray(length);\n      geom.numericProps[key] = {value: destProp, size: 1};\n\n      if (!indices) {\n        for (let i = 0; i < length; i++) {\n          // points\n          const featureId = globalFeatureIds.value[i];\n          destProp[i] = sourceProp[featureId];\n        }\n      } else {\n        // lines|polygons\n        for (let i = 0; i < indices.length - 1; i++) {\n          const startIndex = indices[i];\n          const endIndex = indices[i + 1];\n          const featureId = globalFeatureIds.value[startIndex];\n          destProp.fill(sourceProp[featureId], startIndex, endIndex);\n        }\n      }\n    }\n  }\n\n  return geometry;\n}\n\nexport const TilejsonPropType = {\n  type: 'object' as const,\n  value: null as null | TilejsonResult,\n  validate: (value: TilejsonResult, propType) =>\n    (propType.optional && value === null) ||\n    (typeof value === 'object' &&\n      Array.isArray(value.tiles) &&\n      value.tiles.every(url => typeof url === 'string')),\n  equal: (value1, value2) => {\n    return deepEqual(value1, value2, 2);\n  },\n  async: true\n};\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {CompositeLayer, CompositeLayerProps, DefaultProps} from '@deck.gl/core';\nimport {H3HexagonLayer, H3HexagonLayerProps} from '@deck.gl/geo-layers';\nimport H3Tileset2D, {getHexagonResolution} from './h3-tileset-2d';\nimport SpatialIndexTileLayer, {SpatialIndexTileLayerProps} from './spatial-index-tile-layer';\nimport type {TilejsonResult} from '@carto/api-client';\nimport {TilejsonPropType, mergeLoadOptions} from './utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\n\nexport const renderSubLayers = props => {\n  const {data} = props;\n  const {index} = props.tile;\n  if (!data || !data.length) return null;\n\n  return new H3HexagonLayer(props, {\n    getHexagon: d => d.id,\n    centerHexagon: index,\n    highPrecision: true\n  });\n};\n\nconst defaultProps: DefaultProps<H3TileLayerProps> = {\n  data: TilejsonPropType,\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by H3TileLayer. */\nexport type H3TileLayerProps<DataT = unknown> = _H3TileLayerProps<DataT> & CompositeLayerProps;\n\n/** Properties added by H3TileLayer. */\ntype _H3TileLayerProps<DataT> = Omit<H3HexagonLayerProps<DataT>, 'data'> &\n  Omit<SpatialIndexTileLayerProps<DataT>, 'data'> & {\n    data: null | TilejsonResult | Promise<TilejsonResult>;\n  };\n\nexport default class H3TileLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_H3TileLayerProps<DataT>>\n> {\n  static layerName = 'H3TileLayer';\n  static defaultProps = defaultProps;\n\n  initializeState(): void {\n    H3HexagonLayer._checkH3Lib();\n  }\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}},\n      cartoSpatialTile: {scheme: 'h3'}\n    });\n  }\n\n  renderLayers(): SpatialIndexTileLayer | null {\n    const tileJSON = this.props.data as TilejsonResult;\n    if (!tileJSON) return null;\n\n    const {tiles: data} = tileJSON;\n    let {minresolution, maxresolution} = tileJSON;\n    // Convert Mercator zooms provided in props into H3 res levels\n    // and clip into valid range provided from the tilejson\n    if (this.props.minZoom) {\n      minresolution = Math.max(\n        minresolution,\n        getHexagonResolution({zoom: this.props.minZoom, latitude: 0}, this.props.tileSize)\n      );\n    }\n    if (this.props.maxZoom) {\n      maxresolution = Math.min(\n        maxresolution,\n        getHexagonResolution({zoom: this.props.maxZoom, latitude: 0}, this.props.tileSize)\n      );\n    }\n\n    const SubLayerClass = this.getSubLayerClass('spatial-index-tile', SpatialIndexTileLayer);\n    // The naming is unfortunate, but minZoom & maxZoom in the context\n    // of a Tileset2D refer to the resolution levels, not the Mercator zooms\n    return new SubLayerClass(this.props, {\n      id: `h3-tile-layer-${this.props.id}`,\n      data,\n      // TODO: Tileset2D should be generic over TileIndex type\n      TilesetClass: H3Tileset2D as any,\n      renderSubLayers,\n      // minZoom and maxZoom are H3 resolutions, however we must use this naming as that is what the Tileset2D class expects\n      minZoom: minresolution,\n      maxZoom: maxresolution,\n      loadOptions: this.getLoadOptions()\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {registerLoaders} from '@loaders.gl/core';\nimport {DefaultProps, LayerProps} from '@deck.gl/core';\nimport CartoSpatialTileLoader from './schema/carto-spatial-tile-loader';\nregisterLoaders([CartoSpatialTileLoader]);\n\nimport {PickingInfo} from '@deck.gl/core';\nimport {TileLayer, _Tile2DHeader as Tile2DHeader, TileLayerProps} from '@deck.gl/geo-layers';\nimport {DEFAULT_TILE_SIZE} from '../constants';\n\nfunction isFeatureIdDefined(value: unknown): boolean {\n  return value !== undefined && value !== null && value !== '';\n}\n\nconst defaultProps: DefaultProps<SpatialIndexTileLayerProps> = {\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by SpatialIndexTileLayer. */\nexport type SpatialIndexTileLayerProps<DataT = unknown> = _SpatialIndexTileLayerProps &\n  TileLayerProps<DataT>;\n\n/** Properties added by SpatialIndexTileLayer. */\ntype _SpatialIndexTileLayerProps = {};\n\nexport default class SpatialIndexTileLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends TileLayer<DataT, ExtraProps & Required<_SpatialIndexTileLayerProps>> {\n  static layerName = 'SpatialIndexTileLayer';\n  static defaultProps = defaultProps;\n\n  state!: TileLayer<DataT>['state'] & {\n    hoveredFeatureId: BigInt | number | null;\n    highlightColor: number[];\n  };\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    const {hoveredFeatureId} = this.state;\n    const hoveredFeature = info.object;\n    let newHoveredFeatureId: BigInt | number | null = null;\n\n    if (hoveredFeature) {\n      newHoveredFeatureId = hoveredFeature.id;\n    }\n\n    if (hoveredFeatureId !== newHoveredFeatureId) {\n      let {highlightColor} = this.props;\n      if (typeof highlightColor === 'function') {\n        highlightColor = highlightColor(info);\n      }\n\n      this.setState({\n        highlightColor,\n        hoveredFeatureId: newHoveredFeatureId\n      });\n    }\n  }\n\n  getSubLayerPropsByTile(tile: Tile2DHeader): Partial<LayerProps> | null {\n    return {\n      highlightedObjectIndex: this.getHighlightedObjectIndex(tile),\n      highlightColor: this.state.highlightColor\n    };\n  }\n\n  getHighlightedObjectIndex(tile: Tile2DHeader) {\n    const {hoveredFeatureId} = this.state;\n    const data = tile.content;\n\n    const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId);\n    if (\n      !isFeatureIdPresent ||\n      !Array.isArray(data) ||\n      // Quick check for whether id is within tile. data.findIndex is expensive\n      !this._featureInTile(tile, hoveredFeatureId!)\n    ) {\n      return -1;\n    }\n\n    return data.findIndex(feature => feature.id === hoveredFeatureId);\n  }\n\n  _featureInTile(tile: Tile2DHeader, featureId: BigInt | number) {\n    // TODO: Tile2DHeader index should be generic for H3TileIndex or QuadbinTileIndex\n    const tileset = this.state.tileset!;\n    const tileZoom = tileset.getTileZoom(tile.index);\n    // @ts-ignore\n    const KEY = tile.index.q ? 'q' : 'i';\n    // TODO - Tileset2D methods expect tile index in the shape of {x, y, z}\n    let featureIndex: any = {[KEY]: featureId};\n    let featureZoom = tileset.getTileZoom(featureIndex);\n    while (!(featureZoom <= tileZoom)) {\n      featureIndex = tileset.getParentIndex(featureIndex);\n      featureZoom = tileset.getTileZoom(featureIndex);\n    }\n\n    return featureIndex[KEY] === tile.index[KEY];\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable @typescript-eslint/no-shadow */\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {getResolution} from 'quadbin';\nimport {getResolution as getH3Resolution, getNumCells} from 'h3-js';\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  _deepEqual as deepEqual,\n  DefaultProps,\n  Layer,\n  UpdateParameters\n} from '@deck.gl/core';\nimport {SolidPolygonLayer} from '@deck.gl/layers';\n\nimport {HeatmapProps, heatmap} from './heatmap';\nimport {RTTModifier, PostProcessModifier} from './post-process-utils';\nimport QuadbinTileLayer, {QuadbinTileLayerProps} from './quadbin-tile-layer';\nimport H3TileLayer, {H3TileLayerProps} from './h3-tile-layer';\nimport {TilejsonPropType} from './utils';\nimport {TilejsonResult} from '@carto/api-client';\nimport {_Tile2DHeader as Tile2DHeader} from '@deck.gl/geo-layers';\nimport {Texture, TextureProps} from '@luma.gl/core';\n\nconst defaultColorRange: Color[] = [\n  [255, 255, 178],\n  [254, 217, 118],\n  [254, 178, 76],\n  [253, 141, 60],\n  [240, 59, 32],\n  [189, 0, 38]\n];\n\nconst TEXTURE_PROPS: TextureProps = {\n  format: 'rgba8unorm',\n  dimension: '2d',\n  width: 1,\n  height: 1,\n  sampler: {\n    minFilter: 'linear',\n    magFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge'\n  }\n};\n/**\n * Computes the unit density for Quadbin cells.\n * The unit density is the number of cells needed to cover the Earth's surface at a given resolution. It is inversely proportional to the cell area.\n */\nfunction unitDensityForQuadbinCell(cell: bigint) {\n  const cellResolution = Number(getResolution(cell));\n  return Math.pow(4.0, cellResolution);\n}\n\n/**\n * Computes the unit density for H3 cells.\n * The unit density is the number of cells needed to cover the Earth's surface at a given resolution. It is inversely proportional to the cell area.\n */\nfunction unitDensityForH3Cell(cellId: string) {\n  const cellResolution = Number(getH3Resolution(cellId));\n  return getNumCells(cellResolution);\n}\n\n/**\n * Converts a colorRange array to a flat array with 4 components per color\n */\nfunction colorRangeToFlatArray(colorRange: Color[]): Uint8Array {\n  const flatArray = new Uint8Array(colorRange.length * 4);\n  let index = 0;\n\n  for (let i = 0; i < colorRange.length; i++) {\n    const color = colorRange[i];\n    flatArray[index++] = color[0];\n    flatArray[index++] = color[1];\n    flatArray[index++] = color[2];\n    flatArray[index++] = Number.isFinite(color[3]) ? (color[3] as number) : 255;\n  }\n\n  return flatArray;\n}\n\nconst uniformBlock = `\\\nuniform densityUniforms {\n  float factor;\n} density;\n`;\n\ntype DensityProps = {factor: number};\nconst densityUniforms = {\n  name: 'density',\n  vs: uniformBlock,\n  uniformTypes: {\n    factor: 'f32'\n  }\n} as const satisfies ShaderModule<DensityProps>;\n\n// Modified polygon layer to draw offscreen and output value expected by heatmap\nclass RTTSolidPolygonLayer extends RTTModifier(SolidPolygonLayer) {\n  static layerName = 'RTTSolidPolygonLayer';\n\n  getShaders(type) {\n    const shaders = super.getShaders(type);\n    shaders.inject = {\n      'vs:#main-end': `\n      // Value from getWeight accessor\n  float weight = elevations;\n\n  // Keep \"power\" delivered to screen constant when tiles update\n  // by outputting normalized density\n  weight *= density.factor;\n\n  // Pack float into 3 channels to pass to heatmap shader\n  // SCALE value important, as we don't want to saturate\n  // but also want enough definition to avoid banding\n  const vec3 SHIFT = vec3(1.0, 256.0, 256.0 * 256.0);\n  const float MAX_VAL = SHIFT.z * 255.0;\n  const float SCALE = MAX_VAL / 8.0;\n  weight *= SCALE;\n  weight = clamp(weight, 0.0, MAX_VAL);\n  vColor = vec4(mod(vec3(weight, floor(weight / SHIFT.yz)), 256.0), 255.0) / 255.0;\n`\n    };\n    shaders.modules = [...shaders.modules, densityUniforms];\n    return shaders;\n  }\n\n  draw(this, opts: any) {\n    const cell = this.props!.data[0];\n    if (cell) {\n      const maxDensity = this.props.elevationScale;\n      const {scheme} = this.parent.parent.parent.parent.parent.state;\n      const unitDensity =\n        scheme === 'h3' ? unitDensityForH3Cell(cell.id) : unitDensityForQuadbinCell(cell.id);\n      const densityProps: DensityProps = {factor: unitDensity / maxDensity};\n      for (const model of this.state.models) {\n        model.shaderInputs.setProps({density: densityProps});\n      }\n    }\n\n    super.draw(opts);\n  }\n}\n\n// Modify QuadbinTileLayer to apply heatmap post process effect\nconst PostProcessQuadbinTileLayer = PostProcessModifier(QuadbinTileLayer, heatmap);\n\n// Modify H3TileLayer to apply heatmap post process effect\nconst PostProcessH3TileLayer = PostProcessModifier(H3TileLayer, heatmap);\n\nconst defaultProps: DefaultProps<HeatmapTileLayerProps> = {\n  data: TilejsonPropType,\n  getWeight: {type: 'accessor', value: 1},\n  onMaxDensityChange: {type: 'function', optional: true, value: null},\n  colorDomain: {type: 'array', value: [0, 1]},\n  colorRange: defaultColorRange,\n  intensity: {type: 'number', value: 1},\n  radiusPixels: {type: 'number', min: 0, max: 100, value: 20}\n};\n\n/** All properties supported by HeatmapTileLayer. */\nexport type HeatmapTileLayerProps<DataT = unknown> = _HeatmapTileLayerProps<DataT> &\n  CompositeLayerProps & {\n    data: null | TilejsonResult | Promise<TilejsonResult>;\n  };\n\n/** Properties added by HeatmapTileLayer. */\ntype _HeatmapTileLayerProps<DataT> = (QuadbinTileLayerProps<DataT> | H3TileLayerProps<DataT>) &\n  HeatmapProps & {\n    /**\n     * Specified as an array of colors [color1, color2, ...].\n     *\n     * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n     */\n    colorRange: Color[];\n\n    /**\n     * The weight of each object.\n     *\n     * @default 1\n     */\n    getWeight?: Accessor<DataT, number>;\n\n    /** Called when maximum density in displayed tiles changes. */\n    onMaxDensityChange?: ((maxDensity: number) => void) | null;\n  };\n\nclass HeatmapTileLayer<DataT = any, ExtraProps extends {} = {}> extends CompositeLayer<\n  ExtraProps & Required<_HeatmapTileLayerProps<DataT>>\n> {\n  static layerName = 'HeatmapTileLayer';\n  static defaultProps = defaultProps;\n\n  state!: {\n    colorTexture?: Texture;\n    isLoaded: boolean;\n    scheme: string | null;\n    tiles: Set<Tile2DHeader>;\n    viewportChanged?: boolean;\n  };\n  initializeState() {\n    this.state = {\n      isLoaded: false,\n      scheme: null,\n      tiles: new Set(),\n      viewportChanged: false\n    };\n  }\n\n  shouldUpdateState({changeFlags}): boolean {\n    const {viewportChanged} = changeFlags;\n    this.setState({viewportChanged});\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    const {props, oldProps} = opts;\n    super.updateState(opts);\n    if (!deepEqual(props.colorRange, oldProps.colorRange, 2)) {\n      this._updateColorTexture(opts);\n    }\n\n    const scheme = props.data && 'scheme' in props.data ? props.data.scheme : null;\n    if (this.state.scheme !== scheme) {\n      this.setState({scheme});\n      this.state.tiles.clear();\n    }\n  }\n\n  renderLayers(): Layer {\n    const {\n      data,\n      getWeight,\n      colorDomain,\n      intensity,\n      radiusPixels,\n      _subLayerProps,\n      updateTriggers,\n      onMaxDensityChange,\n      onViewportLoad,\n      onTileLoad,\n      onTileUnload,\n      ...tileLayerProps\n    } = this.props;\n\n    const isH3 = this.state.scheme === 'h3';\n\n    const cellLayerName = isH3 ? 'hexagon-cell-hifi' : 'cell';\n    // Inject modified polygon layer as sublayer into TileLayer\n    const subLayerProps = {\n      ..._subLayerProps,\n      [cellLayerName]: {\n        ..._subLayerProps?.[cellLayerName],\n        _subLayerProps: {\n          ..._subLayerProps?.[cellLayerName]?._subLayerProps,\n          fill: {\n            ..._subLayerProps?.[cellLayerName]?._subLayerProps?.fill,\n            type: RTTSolidPolygonLayer\n          }\n        }\n      }\n    };\n\n    let tileZ = 0;\n    let maxDensity = 0;\n    const loadedTiles = [...this.state.tiles].filter(t => t.content);\n    const visibleTiles = loadedTiles.filter(t => t.isVisible);\n\n    // As deck.gl initially marks tiles as hidden, use hidden tiles as fallback for calculation.\n    // This avoids an ugly flash/glitch at startup when layer is first rendered\n    const tiles = visibleTiles.length ? visibleTiles : loadedTiles;\n\n    for (const tile of tiles) {\n      const cell = tile.content[0];\n      const unitDensity = isH3 ? unitDensityForH3Cell(cell.id) : unitDensityForQuadbinCell(cell.id);\n      maxDensity = Math.max(tile.userData!.maxWeight * unitDensity, maxDensity);\n      tileZ = Math.max(tile.zoom, tileZ);\n    }\n\n    // Between zoom levels the max density will change, but it isn't possible to know by what factor.\n    // As a heuristic, an estimatedGrowthFactor makes the transitions less obvious.\n    // For quadbin, uniform data distributions lead to an estimatedGrowthFactor of 4, while very localized data gives 1.\n    // For H3 the same logic applies but the aperture is 7, rather than 4, so a slightly higher estimatedGrowthFactor is used.\n    let overzoom: number;\n    let estimatedGrowthFactor: number;\n    if (isH3) {\n      // For H3, we need to account for the viewport zoom to H3 resolution mapping (see getHexagonResolution())\n      overzoom = (2 / 3) * this.context.viewport.zoom - tileZ - 2.25;\n      estimatedGrowthFactor = 2.2;\n    } else {\n      overzoom = this.context.viewport.zoom - tileZ;\n      estimatedGrowthFactor = 2;\n    }\n\n    maxDensity = maxDensity * Math.pow(estimatedGrowthFactor, overzoom);\n    if (typeof onMaxDensityChange === 'function') {\n      onMaxDensityChange(maxDensity);\n    }\n    const PostProcessTileLayer = isH3 ? PostProcessH3TileLayer : PostProcessQuadbinTileLayer;\n    const layerProps = isH3\n      ? (tileLayerProps as Omit<H3TileLayerProps, 'data'>)\n      : (tileLayerProps as Omit<QuadbinTileLayerProps, 'data'>);\n\n    return new PostProcessTileLayer(\n      layerProps,\n      this.getSubLayerProps({\n        id: 'heatmap',\n        data,\n\n        // Re-use existing props to pass down values to sublayer\n        // TODO replace with custom layer\n        getFillColor: 0,\n        getElevation: getWeight,\n        elevationScale: maxDensity,\n\n        colorDomain,\n\n        radiusPixels,\n        intensity,\n        _subLayerProps: subLayerProps,\n        refinementStrategy: 'no-overlap',\n\n        colorTexture: this.state.colorTexture,\n\n        // Disable line rendering\n        extruded: false,\n        stroked: false,\n\n        updateTriggers: {\n          getElevation: updateTriggers.getWeight\n        },\n\n        // Tile stats\n        onViewportLoad: tiles => {\n          this.setState({isLoaded: true});\n          if (typeof onViewportLoad === 'function') {\n            onViewportLoad(tiles);\n          }\n        },\n        onTileLoad: (tile: Tile2DHeader) => {\n          let maxWeight = -Infinity;\n          if (typeof getWeight !== 'function') {\n            maxWeight = getWeight;\n          } else if (tile.content) {\n            for (const d of tile.content) {\n              maxWeight = Math.max(getWeight(d, {} as any), maxWeight);\n            }\n          }\n          tile.userData = {maxWeight};\n\n          this.state.tiles.add(tile);\n\n          if (typeof onTileLoad === 'function') {\n            onTileLoad(tile);\n          }\n        },\n        onTileUnload: (tile: Tile2DHeader) => {\n          this.state.tiles.delete(tile);\n          if (typeof onTileUnload === 'function') {\n            onTileUnload(tile);\n          }\n        },\n        transitions: {elevationScale: {type: 'spring', stiffness: 0.3, damping: 0.5}}\n      })\n    );\n  }\n\n  _updateColorTexture(opts) {\n    const {colorRange} = opts.props;\n    let {colorTexture} = this.state;\n    const colors = colorRangeToFlatArray(colorRange);\n\n    colorTexture?.destroy();\n    colorTexture = this.context.device.createTexture({\n      ...TEXTURE_PROPS,\n      data: colors,\n      width: colorRange.length,\n      height: 1\n    });\n\n    this.setState({colorTexture});\n  }\n}\n\nexport default HeatmapTileLayer;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderPass} from '@luma.gl/shadertools';\nimport {Texture} from '@luma.gl/core';\n\n/**\n * @filter       Heatmap\n * @param radiusPixels Blur radius in pixels, controls smoothness of heatmap\n * @param colorDomain Domain to apply to values prior to applying color scale\n * @param colorTexture 1D RGB lookup texture for color scale\n * @param intensity Multiplier to apply to value\n * @param opacity Output opacity\n */\n\nconst fs = /* glsl */ `\\\nuniform heatmapUniforms {\n  vec2 colorDomain;\n  vec2 delta;\n  float intensity;\n  float opacity;\n  float radiusPixels;\n} heatmap;\n\nuniform sampler2D colorTexture;\n\nvec3 colorGradient(float value) {\n  return texture(colorTexture, vec2(value, 0.5)).rgb;\n}\n\nconst vec3 SHIFT = vec3(1.0, 256.0, 256.0 * 256.0);\nconst float MAX_VAL = SHIFT.z * 255.0;\nconst float SCALE = MAX_VAL / 8.0;\nvec4 pack(float value) {\n  return vec4(mod(vec3(value, floor(value / SHIFT.yz)), 256.0), 255.0) / 255.0;\n}\nfloat unpack(vec3 color) {\n  return 255.0 * dot(color, SHIFT);\n}\n\nvec4 heatmap_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {\n  bool firstPass = (heatmap.delta.y < 0.5);\n  float accumulator = 0.0;\n\n  // Controls quality of heatmap, larger values increase quality at expense of performance\n  float SUPPORT = clamp(heatmap.radiusPixels / 2.0, 8.0, 32.0);\n\n  // Gaussian normalization parameters\n  float sigma = SUPPORT / 3.0;\n  float a = -0.5 / (sigma * sigma);\n  float w0 = 0.3989422804014327 / sigma; // 1D normalization\n  for (float t = -SUPPORT; t <= SUPPORT; t++) {\n    vec2 percent = (t * heatmap.delta - 0.5) / SUPPORT;\n    vec2 delta = percent * heatmap.radiusPixels / texSize;\n    vec4 offsetColor = texture(source, texCoord + delta);\n\n    // Unpack float\n    float value = unpack(offsetColor.rgb);\n\n    // Gaussian\n    float weight = w0 * exp(a * t * t);\n    \n    accumulator += value * weight;\n  }\n\n  if (firstPass) {\n    return pack(accumulator);\n  }\n\n  // Undo scaling to obtain normalized density\n  float density = 10.0 * heatmap.intensity * accumulator / SCALE;\n \n  // Domain also in normalized density units\n  vec2 domain = heatmap.colorDomain;\n\n  // Apply domain\n  float f = (density - domain[0]) / (domain[1] - domain[0]);\n\n  // sqrt/log scaling??\n  // float f = (log(density) - log(domain[0] + 1.0)) / (log(domain[1] + 1.0) - log(domain[0] + 1.0));\n  // f = sqrt(f);\n\n  // Color map\n  vec4 color = vec4(0.0);\n  color.rgb = colorGradient(f);\n\n  color.a = smoothstep(0.0, 0.1, f);\n  color.a = pow(color.a, 1.0 / 2.2);\n  color.a *= heatmap.opacity;\n\n  // Use premultiplied alpha for compatibility with blending in ScreenPass\n  color.rgb *= color.a;\n\n  return color;\n}\n`;\n\nexport type HeatmapProps = {\n  /**\n   * Radius of the heatmap blur in pixels, to which the weight of a cell is distributed.\n   *\n   * @default 20\n   */\n  radiusPixels?: number;\n  /**\n   * Controls how weight values are mapped to the colors in `colorTexture`, as an array of two numbers [`minValue`, `maxValue`].\n   *\n   * @default [0, 1]\n   */\n  colorDomain?: [number, number];\n  /**\n   * Value that is multiplied with the total weight at a pixel to obtain the final weight. A value larger than 1 biases the output color towards the higher end of the spectrum, and a value less than 1 biases the output color towards the lower end of the spectrum.\n   */\n  intensity?: number;\n  /**\n   * Color LUT for color gradient\n   */\n  colorTexture: Texture;\n  opacity: number;\n};\n\ntype PassProps = {\n  delta: [number, number];\n};\n\nexport const heatmap = {\n  name: 'heatmap',\n  uniformPropTypes: {\n    colorDomain: {value: [0, 1]},\n    delta: {value: [0, 1]},\n    intensity: {value: 1, min: 0.1, max: 10},\n    opacity: {value: 1, min: 0, max: 1},\n    radiusPixels: {value: 20, min: 0, softMax: 100}\n  },\n  uniformTypes: {\n    colorDomain: 'vec2<f32>',\n    delta: 'vec2<f32>',\n    intensity: 'f32',\n    opacity: 'f32',\n    radiusPixels: 'f32'\n  },\n  // @ts-ignore TODO v9.1\n  getUniforms: opts => {\n    if (!opts) return {};\n    const {\n      colorDomain = [0, 1],\n      colorTexture,\n      delta = [1, 0],\n      intensity = 1,\n      opacity = 1,\n      radiusPixels = 20\n    } = opts;\n    return {\n      colorDomain,\n      colorTexture,\n      delta,\n      intensity,\n      opacity,\n      radiusPixels\n    };\n  },\n  fs,\n  passes: [\n    // @ts-expect-error Seems typing in luma.gl should be Partial<>\n    {sampler: true, uniforms: {delta: [1, 0]}},\n    // @ts-expect-error Seems typing in luma.gl should be Partial<>\n    {sampler: true, uniforms: {delta: [0, 1]}}\n  ]\n} as const satisfies ShaderPass<HeatmapProps & PassProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Framebuffer, TextureProps} from '@luma.gl/core';\nimport type {ShaderPass} from '@luma.gl/shadertools';\nimport {\n  _ConstructorOf,\n  CompositeLayer,\n  Layer,\n  LayerContext,\n  LayerProps,\n  LayersList,\n  PostProcessEffect,\n  PostRenderOptions\n} from '@deck.gl/core';\n\nconst TEXTURE_PROPS: TextureProps = {\n  format: 'rgba8unorm',\n  width: 1,\n  height: 1,\n  sampler: {\n    minFilter: 'linear',\n    magFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge'\n  }\n};\n\ninterface IPostProcessLayer {\n  applyPostProcess: () => void;\n  enableRTT: Layer['draw'];\n  disableRTT: () => void;\n  props: LayerProps;\n}\n\ntype Constructor<T> = (new (...args: any[]) => T) & {layerName: string};\ntype DrawableCompositeLayer = CompositeLayer & {\n  renderLayers(): Layer<{}> | null | LayersList;\n};\n\nfunction getPostProcessLayer(layer: any): IPostProcessLayer {\n  while (layer.parent && !layer.applyPostProcess) {\n    layer = layer.parent;\n  }\n  return layer as unknown as IPostProcessLayer;\n}\n\n/**\n * Dummy Layer that draws nothing, just calls back to root Layer\n */\nclass DrawCallbackLayer extends Layer {\n  static layerName = 'DrawCallbackLayer';\n\n  initializeState(this: DrawCallbackLayer): void {\n    this.id = `draw-callback-${getPostProcessLayer(this).props.id}`;\n  }\n\n  _drawLayer(this: DrawCallbackLayer) {\n    getPostProcessLayer(this).applyPostProcess();\n  }\n}\n\n/**\n * Modifier that marks a layer for Render-to-Target rendering.\n * Resulting layer must be used as a sublayer of a layer created\n * with `PostProcessModifier`\n */\nexport function RTTModifier<T extends _ConstructorOf<Layer>>(BaseLayer: T): T {\n  // @ts-expect-error initializeState is abstract\n  return class RTTLayer extends BaseLayer {\n    // @ts-expect-error typescript doesn't see static property\n    static layerName = `RTT-${BaseLayer.layerName}`;\n\n    draw(this: RTTLayer, opts: any) {\n      const {shaderModuleProps} = opts;\n      const {picking} = shaderModuleProps;\n      const postProcessLayer = getPostProcessLayer(this);\n      const enableRTT = !picking.isActive && postProcessLayer.enableRTT;\n\n      if (enableRTT) {\n        postProcessLayer.enableRTT(opts);\n      }\n\n      // Draw actual layer\n      super.draw(opts);\n\n      if (enableRTT) {\n        postProcessLayer.disableRTT();\n      }\n    }\n  };\n}\n\n/**\n * Modifier that returns the a modified Layer, which applies a\n * postprocess effect to all subLayers created using `RTTModifier`\n */\nexport function PostProcessModifier<T extends Constructor<DrawableCompositeLayer>>(\n  BaseLayer: T,\n  effect: any\n): T {\n  return class PostProcessLayer extends BaseLayer {\n    static layerName = `PostProcess${BaseLayer.layerName}`;\n\n    internalState: any;\n\n    initializeState(this: PostProcessLayer, context: LayerContext): void {\n      super.initializeState(context);\n\n      this._createTextures();\n      this.internalState.postProcess = new PostProcessEffect(effect, this.props);\n      this.internalState.postProcess.setup(context);\n    }\n\n    updateState(this: PostProcessLayer, params: any): void {\n      super.updateState(params);\n      this.internalState.postProcess.setProps(this.props);\n    }\n\n    renderLayers(): PostProcessLayer | null | LayersList {\n      let subLayers = super.renderLayers();\n      if (!subLayers) {\n        return null;\n      }\n      subLayers = Array.isArray(subLayers) ? subLayers : [subLayers];\n      return [...subLayers, new DrawCallbackLayer()];\n    }\n\n    _createTextures(this: PostProcessLayer) {\n      const {device} = this.context;\n      this.internalState.renderBuffers = [0, 1].map(i => {\n        return device.createFramebuffer({\n          id: `layer-fbo-${i}`,\n          colorAttachments: [device.createTexture(TEXTURE_PROPS)],\n          depthStencilAttachment: 'depth16unorm'\n        });\n      });\n    }\n\n    _resizeBuffers(this: PostProcessLayer, opts: any) {\n      // TODO we could likely render to a smaller buffer for better perf\n      const {shaderModuleProps} = opts;\n      const {viewport} = this.context;\n      const {devicePixelRatio} = shaderModuleProps.project;\n      const width = devicePixelRatio * viewport.width;\n      const height = devicePixelRatio * viewport.height;\n      this.internalState.renderBuffers.forEach((fbo: Framebuffer) => fbo.resize({width, height}));\n    }\n\n    enableRTT(this: PostProcessLayer, opts: any) {\n      this._resizeBuffers(opts);\n      this.internalState.originalRenderPass = this.context.renderPass;\n\n      const [framebuffer] = this.internalState.renderBuffers;\n\n      // Create new render pass for RTT\n      this.internalState.internalRenderPass = this.context.device.beginRenderPass({\n        framebuffer,\n        parameters: {viewport: [0, 0, framebuffer.width, framebuffer.height]},\n        // Only clear on first render\n        clearColor: this.internalState.renderInProgress ? false : [0, 0, 0, 0]\n      });\n      this.internalState.renderInProgress = true;\n      this.context.renderPass = this.internalState.internalRenderPass;\n    }\n\n    disableRTT(this: PostProcessLayer) {\n      // End render pass, and reinstate original\n      this.internalState.internalRenderPass.end();\n      this.context.renderPass = this.internalState.originalRenderPass;\n    }\n\n    applyPostProcess(this: PostProcessLayer) {\n      if (!this.internalState.renderInProgress) {\n        return;\n      }\n\n      // Apply post process effect\n      const [inputBuffer, swapBuffer] = this.internalState.renderBuffers;\n      const {framebuffer: target} = this.context.renderPass.props;\n      this.internalState.postProcess.postRender({\n        inputBuffer,\n        swapBuffer,\n        target\n      } as PostRenderOptions);\n\n      this.internalState.renderInProgress = false;\n    }\n\n    _finalize(): void {\n      this.internalState.renderBuffers.forEach((fbo: Framebuffer) => {\n        fbo.destroy();\n      });\n      this.internalState.renderBuffers = null;\n      this.internalState.postProcess.cleanup();\n    }\n  };\n}\n\nconst fs = /* glsl */ `\\\nvec4 copy_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {\n  return color;\n}\n`;\n\n/**\n * Copy\n * Simple module that just copies input color to output\n */\nexport const copy = {\n  name: 'copy',\n  fs,\n  getUniforms: () => ({}),\n  passes: [{filter: true}]\n} as const satisfies ShaderPass<{}>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {CompositeLayer, CompositeLayerProps, DefaultProps} from '@deck.gl/core';\nimport QuadbinLayer, {QuadbinLayerProps} from './quadbin-layer';\nimport QuadbinTileset2D from './quadbin-tileset-2d';\nimport SpatialIndexTileLayer, {SpatialIndexTileLayerProps} from './spatial-index-tile-layer';\nimport {hexToBigInt} from 'quadbin';\nimport type {TilejsonResult} from '@carto/api-client';\nimport {TilejsonPropType, mergeLoadOptions} from './utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\n\nexport const renderSubLayers = props => {\n  const {data} = props;\n  if (!data || !data.length) return null;\n  const isBigInt = typeof data[0].id === 'bigint';\n  return new QuadbinLayer(props, {\n    getQuadbin: isBigInt ? d => d.id : d => hexToBigInt(d.id)\n  });\n};\n\nconst defaultProps: DefaultProps<QuadbinTileLayerProps> = {\n  data: TilejsonPropType,\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by QuadbinTileLayer. */\nexport type QuadbinTileLayerProps<DataT = unknown> = _QuadbinTileLayerProps<DataT> &\n  CompositeLayerProps;\n\n/** Properties added by QuadbinTileLayer. */\ntype _QuadbinTileLayerProps<DataT> = Omit<QuadbinLayerProps<DataT>, 'data'> &\n  Omit<SpatialIndexTileLayerProps<DataT>, 'data'> & {\n    data: null | TilejsonResult | Promise<TilejsonResult>;\n  };\n\nexport default class QuadbinTileLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends CompositeLayer<ExtraProps & Required<_QuadbinTileLayerProps<DataT>>> {\n  static layerName = 'QuadbinTileLayer';\n  static defaultProps = defaultProps;\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}},\n      cartoSpatialTile: {scheme: 'quadbin'}\n    });\n  }\n\n  renderLayers(): SpatialIndexTileLayer | null {\n    const tileJSON = this.props.data as TilejsonResult;\n    if (!tileJSON) return null;\n\n    const {tiles: data, maxresolution: maxZoom} = tileJSON;\n    const SubLayerClass = this.getSubLayerClass('spatial-index-tile', SpatialIndexTileLayer);\n    return new SubLayerClass(this.props, {\n      id: `quadbin-tile-layer-${this.props.id}`,\n      data,\n      // TODO: Tileset2D should be generic over TileIndex type\n      TilesetClass: QuadbinTileset2D as any,\n      renderSubLayers,\n      maxZoom,\n      loadOptions: this.getLoadOptions()\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {AccessorFunction, DefaultProps} from '@deck.gl/core';\nimport {\n  _GeoCellLayer as GeoCellLayer,\n  _GeoCellLayerProps as GeoCellLayerProps\n} from '@deck.gl/geo-layers';\nimport {getQuadbinPolygon} from './quadbin-utils';\n\nconst defaultProps: DefaultProps<QuadbinLayerProps> = {\n  getQuadbin: {type: 'accessor', value: (d: any) => d.quadbin}\n};\n\n/** All properties supported by QuadbinLayer. */\nexport type QuadbinLayerProps<DataT = unknown> = _QuadbinLayerProps<DataT> &\n  GeoCellLayerProps<DataT>;\n\n/** Properties added by QuadbinLayer. */\ntype _QuadbinLayerProps<DataT> = {\n  /**\n   * Called for each data object to retrieve the quadbin string identifier.\n   *\n   * By default, it reads `quadbin` property of data object.\n   */\n  getQuadbin?: AccessorFunction<DataT, bigint>;\n};\n\nexport default class QuadbinLayer<DataT = any, ExtraProps extends {} = {}> extends GeoCellLayer<\n  DataT,\n  Required<_QuadbinLayerProps<DataT>> & ExtraProps\n> {\n  static layerName = 'QuadbinLayer';\n  static defaultProps = defaultProps;\n\n  indexToBounds(): Partial<GeoCellLayer['props']> | null {\n    const {data, extruded, getQuadbin} = this.props;\n    // To avoid z-fighting reduce polygon footprint when extruding\n    const coverage = extruded ? 0.99 : 1;\n\n    return {\n      data,\n      _normalize: false,\n      positionFormat: 'XY',\n\n      getPolygon: (x: DataT, objectInfo) => getQuadbinPolygon(getQuadbin(x, objectInfo), coverage),\n      updateTriggers: {getPolygon: coverage}\n    };\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Accessor,\n  Color,\n  CompositeLayer,\n  CompositeLayerProps,\n  DefaultProps,\n  Layer,\n  LayersList,\n  log\n} from '@deck.gl/core';\nimport {\n  TextLayer,\n  TextLayerProps,\n  _TextBackgroundLayer as TextBackgroundLayer\n} from '@deck.gl/layers';\nimport VectorTileLayer from './vector-tile-layer';\n\nconst [LEFT, TOP, RIGHT, BOTTOM] = [0, 1, 2, 3];\n\nclass EnhancedTextBackgroundLayer extends TextBackgroundLayer {\n  static layerName = 'EnhancedTextBackgroundLayer';\n\n  getShaders() {\n    const shaders = super.getShaders();\n    let vs = shaders.vs;\n\n    // Modify shader so that the padding is offset by the pixel offset to ensure the padding\n    // always captures the anchor point. As padding is uniform we cannot pass it a per-label value\n    vs = vs.replaceAll('textBackground.padding.', '_padding.');\n    vs = vs.replace(\n      'void main(void) {',\n      'void main(void) {\\n  vec4 _padding = textBackground.padding + instancePixelOffsets.xyxy * vec4(1.0, 1.0, -1.0, -1.0);'\n    );\n\n    return {...shaders, vs};\n  }\n}\n\n// TextLayer which includes modified text-background-layer-vertex shader and only renders the\n// primary background layer in the collision pass\nclass EnhancedTextLayer extends TextLayer {\n  static layerName = 'EnhancedTextLayer';\n\n  filterSubLayer({layer, renderPass}) {\n    const background = layer.id.includes('primary-background');\n    if (renderPass === 'collision') {\n      return background; // Only draw primary background layer in collision pass\n    }\n\n    return !background; // Do not draw background layer in other passes\n  }\n}\n\nconst defaultProps: DefaultProps<PointLabelLayerProps> = {\n  ...TextLayer.defaultProps,\n  getRadius: {type: 'accessor', value: 1},\n  radiusScale: {type: 'number', min: 0, value: 1}\n};\n\n/** All properties supported by PointLabelLayer. */\nexport type PointLabelLayerProps<DataT = unknown> = _PointLabelLayerProps<DataT> &\n  TextLayerProps &\n  CompositeLayerProps;\n\n/** Properties added by PointLabelLayer. */\ntype _PointLabelLayerProps<DataT> = TextLayerProps<DataT> & {\n  /**\n   * Radius multiplier.\n   * @default 1\n   */\n  radiusScale?: number;\n  /**\n   * Radius accessor.\n   * @default 1\n   */\n  getRadius?: Accessor<DataT, number>;\n  /**\n   * Secondary label text accessor\n   */\n  getSecondaryText?: Accessor<DataT, string>;\n  /**\n   * Secondary label color accessor\n   * @default [0, 0, 0, 255]\n   */\n  getSecondaryColor?: Accessor<DataT, Color>;\n  /**\n   * Secondary label color of outline around the text, in `[r, g, b, [a]]`. Each channel is a number between 0-255 and `a` is 255 if not supplied.\n   * @default [0, 0, 0, 255]\n   */\n  secondaryOutlineColor?: Color;\n  /**\n   * Secondary label text size multiplier.\n   * @default 1\n   */\n  secondarySizeScale?: number;\n};\n\n/**\n * PointLabelLayer is a layer that renders point labels.\n * It is a composite layer that renders a primary and secondary label.\n * It behaves like a TextLayer except that getTextSize is **not supported**\n * and the text size for the primary label must be set with **sizeScale**.\n */\nexport default class PointLabelLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends CompositeLayer<ExtraProps & Required<_PointLabelLayerProps<DataT>>> {\n  static layerName = 'PointLabelLayer';\n  static defaultProps = defaultProps;\n\n  calculatePixelOffset(secondary) {\n    const {\n      getTextAnchor: anchor,\n      getAlignmentBaseline: alignment,\n      getRadius,\n      getSecondaryText,\n      radiusScale,\n      secondarySizeScale,\n      sizeScale\n    } = this.props;\n    const xMult = anchor === 'middle' ? 0 : anchor === 'start' ? 1 : -1;\n    const yMult = alignment === 'center' ? 0 : alignment === 'bottom' ? 1 : -1;\n\n    // Padding based on font size (font size / 4)\n    const xPadding = sizeScale / 4;\n    const yPadding = sizeScale * (1 + 1 / 4);\n\n    // Place secondary label under main label (secondary label always 'top' baseline aligned)\n    const secondaryOffset = 0.6 * (1 - yMult) * sizeScale;\n    let yOffset = secondary ? secondaryOffset : 0;\n\n    // Special case, position relative to secondary label\n    if (anchor === 'middle' && alignment === 'top' && getSecondaryText) {\n      yOffset -= secondaryOffset;\n      yOffset -= secondarySizeScale;\n      yOffset += sizeScale;\n    }\n\n    // Padding based on point radius (radius/ 4)\n    const radiusPadding = 1 + 1 / 4;\n\n    return typeof getRadius === 'function'\n      ? (d, info) => {\n          const r = (info ? getRadius(d, info) : 1) * radiusScale * radiusPadding;\n          return [xMult * (r + xPadding), yMult * (r + yPadding) + yOffset];\n        }\n      : [\n          xMult * (getRadius * radiusScale * radiusPadding + xPadding),\n          yMult * (getRadius * radiusScale * radiusPadding + yPadding) + yOffset\n        ];\n  }\n\n  calculateBackgroundPadding() {\n    const {getTextAnchor: anchor, getAlignmentBaseline: alignment, sizeScale} = this.props;\n\n    // Heuristics to avoid label overlap\n    const paddingX = 12 * sizeScale;\n    const paddingY = 3 * sizeScale;\n    const backgroundPadding = [0, 0, 0, 0];\n    if (alignment === 'top') {\n      backgroundPadding[TOP] = paddingY;\n    } else if (alignment === 'bottom') {\n      backgroundPadding[BOTTOM] = paddingY;\n    } else {\n      backgroundPadding[TOP] = 0.5 * paddingY;\n      backgroundPadding[BOTTOM] = 0.5 * paddingY;\n    }\n    if (anchor === 'start') {\n      backgroundPadding[LEFT] = paddingX;\n    } else if (anchor === 'end') {\n      backgroundPadding[RIGHT] = paddingX;\n    } else {\n      backgroundPadding[LEFT] = 0.5 * paddingX;\n      backgroundPadding[RIGHT] = 0.5 * paddingX;\n    }\n\n    return backgroundPadding;\n  }\n\n  renderTextLayer(id, {updateTriggers: updateTriggersOverride = {}, ...props}): EnhancedTextLayer {\n    const {\n      data,\n\n      characterSet,\n      fontFamily,\n      fontSettings,\n      fontWeight,\n      outlineColor,\n      outlineWidth,\n      sizeScale,\n      radiusScale,\n\n      getAlignmentBaseline,\n      getColor,\n      getPosition,\n      getTextAnchor,\n\n      updateTriggers\n    } = this.props;\n\n    if (sizeScale < 2) {\n      const propName = (this.parent as VectorTileLayer)?.props?.textSizeScale\n        ? 'textSizeScale'\n        : 'sizeScale';\n      log.warn(\n        `${propName} has small value (${sizeScale}). Note getTextSize is not supported on PointLabelLayer`\n      )();\n    }\n\n    return new EnhancedTextLayer(\n      this.getSubLayerProps({\n        id,\n        data,\n\n        characterSet,\n        fontFamily,\n        fontSettings,\n        fontWeight,\n        outlineColor,\n        outlineWidth,\n        sizeScale,\n\n        getAlignmentBaseline,\n        getColor,\n        getPosition,\n        getTextAnchor,\n\n        updateTriggers: {\n          ...updateTriggers,\n          ...updateTriggersOverride,\n          getPixelOffset: [\n            updateTriggers.getRadius,\n            updateTriggers.getTextAnchor,\n            updateTriggers.getAlignmentBaseline,\n            radiusScale,\n            sizeScale\n          ]\n        }\n      }),\n      {\n        getSize: 1,\n        _subLayerProps: {background: {type: EnhancedTextBackgroundLayer}}\n      },\n      props\n    );\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const {\n      getText,\n      getSecondaryColor,\n      getSecondaryText,\n      secondaryOutlineColor,\n      secondarySizeScale,\n      updateTriggers\n    } = this.props;\n    const getPixelOffset = this.calculatePixelOffset(false);\n    const backgroundPadding = this.calculateBackgroundPadding();\n    const out = [\n      // Text doesn't update via updateTrigger for some reason\n      this.renderTextLayer(`${updateTriggers.getText}-primary`, {\n        backgroundPadding,\n        getText,\n        getPixelOffset,\n        background: true // Only use background for primary label for faster collisions\n      }),\n      Boolean(getSecondaryText) &&\n        this.renderTextLayer(`${updateTriggers.getSecondaryText}-secondary`, {\n          getText: getSecondaryText,\n          getPixelOffset: this.calculatePixelOffset(true),\n          getAlignmentBaseline: 'top',\n          // updateTriggers: {getText: updateTriggers.getSecondaryText},\n\n          // Optional overrides\n          ...(getSecondaryColor && {getColor: getSecondaryColor}),\n          ...(secondarySizeScale && {sizeScale: secondarySizeScale}),\n          ...(secondaryOutlineColor && {outlineColor: secondaryOutlineColor})\n        })\n    ];\n\n    return out;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  CompositeLayer,\n  CompositeLayerProps,\n  DefaultProps,\n  FilterContext,\n  Layer,\n  LayersList\n} from '@deck.gl/core';\nimport RasterLayer, {RasterLayerProps} from './raster-layer';\nimport QuadbinTileset2D from './quadbin-tileset-2d';\nimport type {TilejsonResult} from '@carto/api-client';\nimport {TilejsonPropType, mergeLoadOptions} from './utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\nimport {TileLayer, TileLayerProps} from '@deck.gl/geo-layers';\nimport {copy, PostProcessModifier} from './post-process-utils';\nimport {registerLoaders} from '@loaders.gl/core';\nimport CartoRasterTileLoader from './schema/carto-raster-tile-loader';\n\nregisterLoaders([CartoRasterTileLoader]);\n\nexport const renderSubLayers = props => {\n  const tileIndex = props.tile?.index?.q;\n  if (!tileIndex) return null;\n  return new RasterLayer(props, {tileIndex});\n};\n\nconst defaultProps: DefaultProps<RasterTileLayerProps> = {\n  data: TilejsonPropType,\n  refinementStrategy: 'no-overlap',\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by RasterTileLayer. */\nexport type RasterTileLayerProps<DataT = unknown> = _RasterTileLayerProps<DataT> &\n  CompositeLayerProps;\n\n/** Properties added by RasterTileLayer. */\ntype _RasterTileLayerProps<DataT> = Omit<RasterLayerProps<DataT>, 'data'> &\n  Omit<TileLayerProps<DataT>, 'data'> & {\n    data: null | TilejsonResult | Promise<TilejsonResult>;\n  };\n\nclass PostProcessTileLayer extends PostProcessModifier(TileLayer, copy) {\n  filterSubLayer(context: FilterContext) {\n    // Handle DrawCallbackLayer\n    const {tile} = (context.layer as Layer<{tile: any}>).props;\n    if (!tile) return true;\n\n    return super.filterSubLayer(context);\n  }\n}\n\nexport default class RasterTileLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends CompositeLayer<ExtraProps & Required<_RasterTileLayerProps<DataT>>> {\n  static layerName = 'RasterTileLayer';\n  static defaultProps = defaultProps;\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}}\n    });\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const tileJSON = this.props.data as TilejsonResult;\n    if (!tileJSON) return null;\n\n    const {tiles: data, minzoom: minZoom, maxzoom: maxZoom, raster_metadata: metadata} = tileJSON;\n    const SubLayerClass = this.getSubLayerClass('tile', PostProcessTileLayer);\n    const loadOptions = this.getLoadOptions();\n    return new SubLayerClass(this.props, {\n      id: `raster-tile-layer-${this.props.id}`,\n      data,\n      // TODO: Tileset2D should be generic over TileIndex type\n      TilesetClass: QuadbinTileset2D as any,\n      renderSubLayers,\n      minZoom,\n      maxZoom,\n      loadOptions: {\n        ...loadOptions,\n        cartoRasterTile: {...loadOptions?.cartoRasterTile, metadata}\n      }\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Accessor,\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  LayersList,\n  DefaultProps,\n  PickingInfo\n} from '@deck.gl/core';\nimport {ColumnLayer, ColumnLayerProps} from '@deck.gl/layers';\nimport {quadbinToOffset} from './quadbin-utils';\nimport {Raster} from './schema/carto-raster-tile-loader';\nimport vs from './raster-layer-vertex.glsl';\nimport {createBinaryProxy} from '../utils';\nimport {RTTModifier} from './post-process-utils';\n\nconst defaultProps: DefaultProps<RasterLayerProps> = {\n  ...ColumnLayer.defaultProps,\n  extruded: false,\n  diskResolution: 4,\n  vertices: [\n    [-0.5, -0.5],\n    [0.5, -0.5],\n    [0.5, 0.5],\n    [-0.5, 0.5]\n  ]\n};\n\n// Modified ColumnLayer with custom vertex shader\n// Use RTT to avoid inter-tile seams\nclass RasterColumnLayer extends RTTModifier(ColumnLayer) {\n  static layerName = 'RasterColumnLayer';\n\n  getShaders() {\n    const shaders = super.getShaders();\n    const data = this.props.data as unknown as {data: Raster; length: number};\n    const BLOCK_WIDTH = data.data.blockSize ?? Math.sqrt(data.length);\n    return {...shaders, defines: {...shaders.defines, BLOCK_WIDTH}, vs};\n  }\n\n  initializeState() {\n    // Only add attributes needed by shader\n    const attributeManager = this.getAttributeManager()!;\n    /* eslint-disable max-len */\n    attributeManager.addInstanced({\n      instanceElevations: {\n        size: 1,\n        transition: true,\n        accessor: 'getElevation'\n      },\n      instanceFillColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        transition: true,\n        accessor: 'getFillColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceLineColors: {\n        size: this.props.colorFormat.length,\n        type: 'unorm8',\n        transition: true,\n        accessor: 'getLineColor',\n        defaultValue: [255, 255, 255, 255]\n      }\n    });\n  }\n}\n\n/** All properties supported by RasterLayer. */\nexport type RasterLayerProps<DataT = unknown> = _RasterLayerProps &\n  ColumnLayerProps<DataT> &\n  CompositeLayerProps;\n\n/** Properties added by RasterLayer. */\ntype _RasterLayerProps = {\n  /**\n   * Quadbin index of tile\n   */\n  tileIndex: bigint;\n};\n\ntype RasterColumnLayerData = {\n  data: Raster;\n  length: number;\n};\n\nfunction wrappedDataComparator(oldData: RasterColumnLayerData, newData: RasterColumnLayerData) {\n  return oldData.data === newData.data && oldData.length === newData.length;\n}\n\n// Adapter layer around RasterColumnLayer that converts data & accessors into correct format\nexport default class RasterLayer<DataT = any, ExtraProps = {}> extends CompositeLayer<\n  Required<RasterLayerProps<DataT>> & ExtraProps\n> {\n  static layerName = 'RasterLayer';\n  static defaultProps = defaultProps;\n\n  state!: {\n    highlightedObjectIndex: number;\n    highlightColor: number[];\n  };\n\n  renderLayers(): Layer | null | LayersList {\n    // Rendering props underlying layer\n    const {\n      data,\n      getElevation,\n      getFillColor,\n      getLineColor,\n      getLineWidth,\n      tileIndex,\n      updateTriggers\n    } = this.props as typeof this.props & {data: Raster};\n    if (!data || !tileIndex || (data as any).length === 0) return null;\n\n    const blockSize = data.blockSize ?? 0;\n    const [xOffset, yOffset, scale] = quadbinToOffset(tileIndex);\n    const offset = [xOffset, yOffset];\n    const lineWidthScale = scale / blockSize;\n\n    // Filled Column Layer\n    const CellLayer = this.getSubLayerClass('column', RasterColumnLayer);\n    const {highlightedObjectIndex, highlightColor} = this.state;\n    return new CellLayer(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell',\n        updateTriggers,\n\n        getElevation: this.getSubLayerAccessor(getElevation),\n        getFillColor: this.getSubLayerAccessor(getFillColor),\n        getLineColor: this.getSubLayerAccessor(getLineColor),\n        getLineWidth: this.getSubLayerAccessor(getLineWidth)\n      }),\n      {\n        data: {\n          data, // Pass through data for getSubLayerAccessor()\n          length: blockSize * blockSize\n        },\n        dataComparator: wrappedDataComparator,\n        offset,\n        lineWidthScale, // Re-use widthScale prop to pass cell scale,\n        highlightedObjectIndex,\n        highlightColor\n      }\n    );\n  }\n\n  protected getSubLayerAccessor<In, Out>(accessor: Accessor<In, Out>): Accessor<In, Out> {\n    if (typeof accessor !== 'function') {\n      return super.getSubLayerAccessor(accessor);\n    }\n\n    // Proxy values back in standard feature format\n    return (object, info) => {\n      const {data, index} = info;\n      const binaryData = (data as unknown as {data: Raster}).data;\n      const proxy = createBinaryProxy(binaryData.cells, index);\n      // @ts-ignore (TS2349) accessor is always function\n      return accessor({properties: proxy}, info);\n    };\n  }\n\n  getPickingInfo(params: any) {\n    const info = super.getPickingInfo(params);\n\n    if (info.index !== -1) {\n      info.object = this.getSubLayerAccessor((x: any) => x)(undefined, {\n        data: this.props,\n        index: info.index\n      });\n    }\n\n    return info;\n  }\n\n  _updateAutoHighlight(info: PickingInfo) {\n    const {highlightedObjectIndex} = this.state;\n    let newHighlightedObjectIndex: number = -1;\n\n    if (info.index !== -1) {\n      newHighlightedObjectIndex = info.index;\n    }\n\n    if (highlightedObjectIndex !== newHighlightedObjectIndex) {\n      let {highlightColor} = this.props;\n      if (typeof highlightColor === 'function') {\n        highlightColor = highlightColor(info);\n      }\n\n      this.setState({\n        highlightColor,\n        highlightedObjectIndex: newHighlightedObjectIndex\n      });\n    }\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME raster-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin float instanceElevations;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\n\nin vec3 instancePickingColors;\n\n// Result\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec4 position_commonspace;\n#endif\n\nvoid main(void) {\n  // Rather than positioning using attribute, layout pixel grid using gl_InstanceID\n  vec2 tileOrigin = column.offset.xy;\n  float scale = column.widthScale; // Re-use widthScale prop to pass cell scale\n\n  int yIndex = - (gl_InstanceID / BLOCK_WIDTH);\n  int xIndex = gl_InstanceID + (yIndex * BLOCK_WIDTH);\n\n  // Avoid precision issues by applying 0.5 offset here, rather than when laying out vertices\n  vec2 cellCenter = scale * vec2(float(xIndex) + 0.5, float(yIndex) - 0.5);\n\n  vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;\n\n  // if alpha == 0.0 or z < 0.0, do not render element\n  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\n  float cellWidth = column.coverage * scale;\n\n  // Get position directly from quadbin, rather than projecting\n  // Important to set geometry.position before using project_ methods below\n  // as geometry.worldPosition is not set (we don't know our lat/long)\n  geometry.position = vec4(tileOrigin, 0.0, 1.0);\n  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    geometry.position.xyz -= project.commonOrigin;\n  }\n\n  // Important to apply after tileOrigin & commonOrigin as they are large values which often\n  // cancel and thus cellCenter precision is lost if applied first.\n  geometry.position.xy += cellCenter;\n\n  // calculate elevation, if 3d not enabled set to 0\n  // cylindar geometry height are between -1.0 to 1.0, transform it to between 0, 1\n  float elevation = 0.0;\n  // calculate stroke offset\n  float strokeOffsetRatio = 1.0;\n\n  if (column.extruded) {\n    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;\n  } else if (column.stroked) {\n    float halfOffset = project_pixel_size(column.widthScale) / cellWidth;\n    if (column.isStroke) {\n      strokeOffsetRatio -= sign(positions.z) * halfOffset;\n    } else {\n      strokeOffsetRatio -= halfOffset;\n    }\n  }\n\n  geometry.pickingColor = instancePickingColors;\n\n  // Cell coordinates centered on origin\n  vec2 base = positions.xy * scale * strokeOffsetRatio * column.coverage * shouldRender;\n  vec3 cell = vec3(base, project_size(elevation));\n  DECKGL_FILTER_SIZE(cell, geometry);\n\n  geometry.position.xyz += cell;\n  gl_Position = project_common_position_to_clipspace(geometry.position);\n\n  geometry.normal = project_normal(normals);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  // Light calculations\n  if (column.extruded && !column.isStroke) {\n#ifdef FLAT_SHADING\n    position_commonspace = geometry.position;\n    vColor = vec4(color.rgb, color.a * layer.opacity);\n#else\n    vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n    vColor = vec4(lightColor, color.a * layer.opacity);\n#endif\n  } else {\n    vColor = vec4(color.rgb, color.a * layer.opacity);\n  }\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {readPackedTypedArray} from './fast-pbf';\n\nconst ARRAY_TYPES = {\n  uint8: Uint8Array,\n  uint16: Uint16Array,\n  uint32: Uint32Array,\n  uint64: BigUint64Array,\n  int8: Int8Array,\n  int16: Int16Array,\n  int32: Int32Array,\n  int64: BigInt64Array,\n  float32: Float32Array,\n  float64: Float64Array\n};\n\n// Band ========================================\n\nexport class BandReader {\n  static read(pbf, end?: number) {\n    return pbf.readFields(BandReader._readField, {name: '', type: '', data: null}, end);\n  }\n\n  static _readField(this: void, tag, obj, pbf) {\n    if (tag === 1) obj.name = pbf.readString();\n    else if (tag === 2) obj.type = pbf.readString();\n    else if (tag === 3) {\n      const TypedArray = ARRAY_TYPES[obj.type];\n      if (!TypedArray) {\n        throw Error(`Invalid data type: ${obj.type}`);\n      }\n      obj.data = {};\n      const {compression} = TileReader;\n      readPackedTypedArray(TypedArray, pbf, obj.data, {compression});\n    }\n  }\n}\n\nexport class TileReader {\n  public static compression: null | 'gzip';\n  static read(pbf, end) {\n    return pbf.readFields(TileReader._readField, {blockSize: 0, bands: []}, end);\n  }\n  static _readField(this: void, tag, obj, pbf) {\n    if (tag === 1) obj.blockSize = pbf.readVarint();\n    else if (tag === 2) obj.bands.push(BandReader.read(pbf, pbf.readVarint() + pbf.pos));\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LoaderOptions, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {RasterMetadata} from '@carto/api-client';\n\nimport {TileReader} from './carto-raster-tile';\nimport {parsePbf} from './tile-loader-utils';\nimport {getWorkerUrl} from '../../utils';\nimport {NumericProps, Properties} from './spatialjson-utils';\n\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\nconst id = 'cartoRasterTile';\n\ntype CartoRasterTileLoaderOptions = LoaderOptions & {\n  cartoRasterTile?: {\n    metadata: RasterMetadata | null;\n    workerUrl: string;\n  };\n};\n\nconst DEFAULT_OPTIONS: CartoRasterTileLoaderOptions = {\n  cartoRasterTile: {\n    metadata: null,\n    workerUrl: getWorkerUrl(id, VERSION)\n  }\n};\n\nconst CartoRasterTileLoader: LoaderWithParser = {\n  name: 'CARTO Raster Tile',\n  version: VERSION,\n  id,\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/vnd.carto-raster-tile'],\n  category: 'geometry',\n  parse: async (arrayBuffer, options?: CartoRasterTileLoaderOptions) =>\n    parseCartoRasterTile(arrayBuffer, options),\n  parseSync: parseCartoRasterTile,\n  worker: true,\n  options: DEFAULT_OPTIONS\n};\n\nexport type Raster = {\n  /** Raster tiles are square, with 'blockSize' width and height in pixels. */\n  blockSize: number;\n  cells: {\n    numericProps: NumericProps;\n    properties: Properties[];\n  };\n};\n\nfunction parseCartoRasterTile(\n  arrayBuffer: ArrayBuffer,\n  options?: CartoRasterTileLoaderOptions\n): Raster | null {\n  const metadata = options?.cartoRasterTile?.metadata;\n  if (!arrayBuffer || !metadata) return null;\n  // @ts-expect-error Upstream type needs to be updated\n  TileReader.compression = metadata.compression;\n  const out = parsePbf(arrayBuffer, TileReader);\n  const {bands, blockSize} = out;\n\n  const numericProps = {};\n  for (let i = 0; i < bands.length; i++) {\n    const {name, data} = bands[i];\n    numericProps[name] = data;\n  }\n  return {blockSize, cells: {numericProps, properties: []}};\n}\n\nexport default CartoRasterTileLoader;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {registerLoaders} from '@loaders.gl/core';\nimport {BinaryPointFeature} from '@loaders.gl/schema';\nimport CartoPropertiesTileLoader from './schema/carto-properties-tile-loader';\nimport CartoVectorTileLoader from './schema/carto-vector-tile-loader';\nregisterLoaders([CartoPropertiesTileLoader, CartoVectorTileLoader]);\n\nimport {DefaultProps, Layer, LayersList} from '@deck.gl/core';\nimport {ClipExtension, CollisionFilterExtension} from '@deck.gl/extensions';\nimport {\n  MVTLayer,\n  MVTLayerProps,\n  _getURLFromTemplate,\n  _Tile2DHeader,\n  _TileLoadProps as TileLoadProps,\n  GeoBoundingBox\n} from '@deck.gl/geo-layers';\nimport {GeoJsonLayer} from '@deck.gl/layers';\n\nimport type {TilejsonResult} from '@carto/api-client';\nimport {TilejsonPropType, mergeLoadOptions, mergeBoundaryData} from './utils';\nimport {DEFAULT_TILE_SIZE} from '../constants';\nimport {createPointsFromLines, createPointsFromPolygons} from './label-utils';\nimport {createEmptyBinary} from '../utils';\nimport PointLabelLayer from './point-label-layer';\n\nconst MVT_BBOX: GeoBoundingBox = {west: 0, east: 1, south: 0, north: 1};\n\nconst defaultProps: DefaultProps<VectorTileLayerProps> = {\n  ...MVTLayer.defaultProps,\n  autoLabels: false,\n  data: TilejsonPropType,\n  dataComparator: TilejsonPropType.equal,\n  tileSize: DEFAULT_TILE_SIZE\n};\n\n/** All properties supported by VectorTileLayer. */\nexport type VectorTileLayerProps<FeaturePropertiesT = unknown> = _VectorTileLayerProps &\n  Omit<MVTLayerProps<FeaturePropertiesT>, 'data'>;\n\n/** Properties added by VectorTileLayer. */\ntype _VectorTileLayerProps = {\n  data: null | TilejsonResult | Promise<TilejsonResult>;\n\n  /**\n   * If true, create labels for lines and polygons.\n   * Specify uniqueIdProperty to only create a single label for each unique feature.\n   */\n  autoLabels?: boolean | {uniqueIdProperty: string};\n};\n\n// @ts-ignore\nexport default class VectorTileLayer<\n  FeaturePropertiesT = any,\n  ExtraProps extends {} = {}\n> extends MVTLayer<FeaturePropertiesT, Required<_VectorTileLayerProps> & ExtraProps> {\n  static layerName = 'VectorTileLayer';\n  static defaultProps = defaultProps;\n\n  state!: MVTLayer['state'] & {\n    mvt: boolean;\n  };\n\n  constructor(...propObjects: VectorTileLayerProps<FeaturePropertiesT>[]) {\n    // Force externally visible props type, as it is not possible modify via extension\n    // @ts-ignore\n    super(...propObjects);\n  }\n\n  initializeState(): void {\n    super.initializeState();\n    this.setState({binary: true});\n  }\n\n  updateState(parameters) {\n    const {props} = parameters;\n    if (props.data) {\n      super.updateState(parameters);\n\n      const formatTiles = new URL(props.data.tiles[0]).searchParams.get('formatTiles');\n      const mvt = formatTiles === 'mvt';\n      this.setState({mvt});\n    }\n  }\n\n  getLoadOptions(): any {\n    const tileJSON = this.props.data as TilejsonResult;\n    return mergeLoadOptions(super.getLoadOptions(), {\n      fetch: {headers: {Authorization: `Bearer ${tileJSON.accessToken}`}},\n      gis: {format: 'binary'} // Use binary for MVT loading\n    });\n  }\n\n  /* eslint-disable camelcase */\n  async getTileData(tile: TileLoadProps) {\n    const tileJSON = this.props.data as TilejsonResult;\n    const {tiles, properties_tiles} = tileJSON;\n    const url = _getURLFromTemplate(tiles, tile);\n    if (!url) {\n      return Promise.reject('Invalid URL');\n    }\n\n    const loadOptions = this.getLoadOptions();\n    const {fetch} = this.props;\n    const {signal} = tile;\n\n    // Fetch geometry and attributes separately\n    const geometryFetch = fetch(url, {propName: 'data', layer: this, loadOptions, signal});\n\n    if (!properties_tiles) {\n      return await geometryFetch;\n    }\n\n    const propertiesUrl = _getURLFromTemplate(properties_tiles, tile);\n    if (!propertiesUrl) {\n      return Promise.reject('Invalid properties URL');\n    }\n\n    const attributesFetch = fetch(propertiesUrl, {\n      propName: 'data',\n      layer: this,\n      loadOptions,\n      signal\n    });\n    const [geometry, attributes] = await Promise.all([geometryFetch, attributesFetch]);\n    if (!geometry) return null;\n\n    return attributes ? mergeBoundaryData(geometry, attributes) : geometry;\n  }\n  /* eslint-enable camelcase */\n\n  renderSubLayers(\n    props: VectorTileLayer['props'] & {\n      id: string;\n      data: any;\n      _offset: number;\n      tile: _Tile2DHeader;\n    }\n  ): GeoJsonLayer | GeoJsonLayer[] | null {\n    if (props.data === null) {\n      return null;\n    }\n\n    const tileBbox = props.tile.bbox as GeoBoundingBox;\n\n    const subLayers: GeoJsonLayer[] = [];\n\n    const defaultToPointLabelLayer = {\n      'points-text': {\n        type: PointLabelLayer,\n        ...props?._subLayerProps?.['points-text'],\n        extensions: [\n          new CollisionFilterExtension(),\n          ...(props.extensions || []),\n          ...(props?._subLayerProps?.['points-text']?.extensions || [])\n        ]\n      }\n    };\n\n    if (this.state.mvt) {\n      const subLayerProps = {\n        ...props,\n        _subLayerProps: {\n          ...props._subLayerProps,\n          ...defaultToPointLabelLayer\n        }\n      };\n      subLayers.push(super.renderSubLayers(subLayerProps) as GeoJsonLayer);\n    } else {\n      const {west, south, east, north} = tileBbox;\n\n      const extensions = [new ClipExtension(), ...(props.extensions || [])];\n      const clipProps = {\n        clipBounds: [west, south, east, north]\n      };\n\n      const applyClipExtensionToSublayerProps = (subLayerId: string) => {\n        return {\n          [subLayerId]: {\n            ...clipProps,\n            ...props?._subLayerProps?.[subLayerId],\n            extensions: [...extensions, ...(props?._subLayerProps?.[subLayerId]?.extensions || [])]\n          }\n        };\n      };\n\n      const subLayerProps = {\n        ...props,\n        data: {...props.data, tileBbox},\n        autoHighlight: false,\n        // Do not perform clipping on points (#9059)\n        _subLayerProps: {\n          ...props._subLayerProps,\n          ...defaultToPointLabelLayer,\n          ...applyClipExtensionToSublayerProps('polygons-fill'),\n          ...applyClipExtensionToSublayerProps('polygons-stroke'),\n          ...applyClipExtensionToSublayerProps('linestrings')\n        }\n      };\n\n      subLayers.push(new GeoJsonLayer(subLayerProps));\n    }\n\n    // Add labels\n    if (subLayers[0] && props.autoLabels) {\n      const labelData = createEmptyBinary();\n      if (props.data.lines && props.data.lines.positions.value.length > 0) {\n        labelData.points = createPointsFromLines(\n          props.data.lines,\n          typeof props.autoLabels === 'object' ? props.autoLabels.uniqueIdProperty : undefined\n        ) as BinaryPointFeature;\n      }\n      if (props.data.polygons && props.data.polygons.positions.value.length > 0) {\n        labelData.points = createPointsFromPolygons(\n          props.data.polygons,\n          this.state.mvt ? MVT_BBOX : tileBbox,\n          props\n        );\n      }\n\n      subLayers.push(\n        subLayers[0].clone({\n          id: `${props.id}-labels`,\n          data: labelData,\n          pickable: false,\n          autoHighlight: false\n        })\n      );\n    }\n    return subLayers;\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    const layers = super.renderLayers() as LayersList;\n    if (!this.props.autoLabels) {\n      return layers;\n    }\n\n    // Sort layers so that label layers are rendered after the main layer\n    const validLayers = (layers || []).flat().filter(Boolean) as Layer[];\n    validLayers.sort((a: Layer, b: Layer) => {\n      const aHasLabel = a.id.includes('labels');\n      const bHasLabel = b.id.includes('labels');\n      if (aHasLabel && !bHasLabel) return 1;\n      if (!aHasLabel && bHasLabel) return -1;\n      return 0;\n    });\n    return validLayers.map(l =>\n      l.id.includes('labels') ? l.clone({highlightedObjectIndex: -1}) : l\n    );\n  }\n\n  protected override _isWGS84(): boolean {\n    // CARTO binary tile coordinates are [lng, lat], not tile-relative like MVT.\n    if (this.state.mvt) return super._isWGS84();\n    return true;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {NumericProp, NumericPropKeyValueReader, PropertiesReader} from './carto-tile';\n\n// Tile ========================================\n\nexport interface Tile {\n  properties: Record<string, string>[];\n  numericProps: Record<string, NumericProp>;\n}\n\nexport class TileReader {\n  static read(pbf, end?: number): Tile {\n    return pbf.readFields(TileReader._readField, {properties: [], numericProps: {}}, end);\n  }\n  static _readField(this: void, tag: number, obj: Tile, pbf) {\n    if (tag === 1) obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));\n    else if (tag === 2) {\n      const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);\n      obj.numericProps[entry.key] = entry.value;\n    }\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {LoaderOptions, LoaderWithParser} from '@loaders.gl/loader-utils';\n\nimport {Tile, TileReader} from './carto-properties-tile';\nimport {parsePbf} from './tile-loader-utils';\nimport {getWorkerUrl} from '../../utils';\n\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\nconst id = 'cartoPropertiesTile';\n\ntype CartoPropertiesTileLoaderOptions = LoaderOptions & {\n  cartoPropertiesTile?: {\n    workerUrl: string;\n  };\n};\n\nconst DEFAULT_OPTIONS: CartoPropertiesTileLoaderOptions = {\n  cartoPropertiesTile: {\n    workerUrl: getWorkerUrl(id, VERSION)\n  }\n};\n\nconst CartoPropertiesTileLoader: LoaderWithParser = {\n  name: 'CARTO Properties Tile',\n  version: VERSION,\n  id,\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/vnd.carto-properties-tile'],\n  category: 'geometry',\n  worker: true,\n  parse: async (arrayBuffer, options) => parseCartoPropertiesTile(arrayBuffer, options),\n  parseSync: parseCartoPropertiesTile,\n  options: DEFAULT_OPTIONS\n};\n\nfunction parseCartoPropertiesTile(arrayBuffer: ArrayBuffer, options?: LoaderOptions): Tile | null {\n  if (!arrayBuffer) return null;\n  return parsePbf(arrayBuffer, TileReader);\n}\n\nexport default CartoPropertiesTileLoader;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport earcut from 'earcut';\nimport {LoaderOptions, LoaderWithParser} from '@loaders.gl/loader-utils';\nimport type {BinaryFeatureCollection, BinaryPolygonFeature, TypedArray} from '@loaders.gl/schema';\n\nimport {TileReader} from './carto-tile';\nimport {parsePbf} from './tile-loader-utils';\nimport {getWorkerUrl} from '../../utils';\n\nconst VERSION = typeof __VERSION__ !== 'undefined' ? __VERSION__ : 'latest';\nconst id = 'cartoVectorTile';\n\ntype CartoVectorTileLoaderOptions = LoaderOptions & {\n  cartoVectorTile?: {\n    workerUrl: string;\n  };\n};\n\nconst DEFAULT_OPTIONS: CartoVectorTileLoaderOptions = {\n  cartoVectorTile: {\n    workerUrl: getWorkerUrl(id, VERSION)\n  }\n};\n\nconst CartoVectorTileLoader: LoaderWithParser = {\n  name: 'CARTO Vector Tile',\n  version: VERSION,\n  id,\n  module: 'carto',\n  extensions: ['pbf'],\n  mimeTypes: ['application/vnd.carto-vector-tile'],\n  category: 'geometry',\n  parse: async (arrayBuffer, options?: CartoVectorTileLoaderOptions) =>\n    parseCartoVectorTile(arrayBuffer, options),\n  parseSync: parseCartoVectorTile,\n  worker: true,\n  options: DEFAULT_OPTIONS\n};\n\nfunction triangulatePolygon(\n  polygons: BinaryPolygonFeature,\n  target: number[],\n  {\n    startPosition,\n    endPosition,\n    indices\n  }: {startPosition: number; endPosition: number; indices: TypedArray}\n): void {\n  const coordLength = polygons.positions.size;\n  const start = startPosition * coordLength;\n  const end = endPosition * coordLength;\n\n  // Extract positions and holes for just this polygon\n  const polygonPositions = polygons.positions.value.subarray(start, end);\n\n  // Holes are referenced relative to outer polygon\n  const holes = indices.slice(1).map((n: number) => n - startPosition);\n\n  // Compute triangulation\n  const triangles = earcut(polygonPositions, holes, coordLength);\n\n  // Indices returned by triangulation are relative to start\n  // of polygon, so we need to offset\n  for (let t = 0, tl = triangles.length; t < tl; ++t) {\n    target.push(startPosition + triangles[t]);\n  }\n}\n\nfunction triangulate(polygons: BinaryPolygonFeature) {\n  const {polygonIndices, primitivePolygonIndices} = polygons;\n  const triangles = [];\n\n  let rangeStart = 0;\n  for (let i = 0; i < polygonIndices.value.length - 1; i++) {\n    const startPosition = polygonIndices.value[i];\n    const endPosition = polygonIndices.value[i + 1];\n\n    // Extract hole indices between start & end position\n    const rangeEnd = primitivePolygonIndices.value.indexOf(endPosition);\n    const indices = primitivePolygonIndices.value.subarray(rangeStart, rangeEnd);\n    rangeStart = rangeEnd;\n\n    triangulatePolygon(polygons, triangles, {startPosition, endPosition, indices});\n  }\n\n  polygons.triangles = {value: new Uint32Array(triangles), size: 1};\n}\n\nfunction parseCartoVectorTile(\n  arrayBuffer: ArrayBuffer,\n  options?: CartoVectorTileLoaderOptions\n): BinaryFeatureCollection | null {\n  if (!arrayBuffer) return null;\n  const tile = parsePbf(arrayBuffer, TileReader);\n\n  if (tile.polygons && !tile.polygons.triangles) {\n    triangulate(tile.polygons);\n  }\n\n  return tile;\n}\n\nexport default CartoVectorTileLoader;\n", "import {GeoBoundingBox} from '@deck.gl/geo-layers';\nimport {TypedArray} from '@loaders.gl/loader-utils';\nimport {BinaryPointFeature, BinaryLineFeature, BinaryPolygonFeature} from '@loaders.gl/schema';\nimport {copyNumericProps, createBinaryPointFeature, initializeNumericProps} from '../utils';\n\ntype Vec2 = [number, number] | TypedArray;\ntype TileBBox = GeoBoundingBox;\ntype Properties = BinaryPointFeature['properties'];\ntype LineInfo = {index: number; length: number};\n\nexport function createPointsFromLines(\n  lines: BinaryLineFeature,\n  uniqueIdProperty?: string\n): BinaryPointFeature | null {\n  const hasNumericUniqueId = uniqueIdProperty ? uniqueIdProperty in lines.numericProps : false;\n  const idToLineInfo = new Map<string | number | undefined, LineInfo>();\n\n  // First pass: find the longest line for each unique ID\n  // If we don't have a uniqueIdProperty, treat each line as unique\n  for (let i = 0; i < lines.pathIndices.value.length - 1; i++) {\n    const pathIndex = lines.pathIndices.value[i];\n    const featureId = lines.featureIds.value[pathIndex];\n    let uniqueId: string | number | undefined;\n\n    if (uniqueIdProperty === undefined) {\n      uniqueId = featureId;\n    } else if (hasNumericUniqueId) {\n      uniqueId = lines.numericProps[uniqueIdProperty].value[pathIndex];\n    } else if (lines.properties[featureId] && uniqueIdProperty in lines.properties[featureId]) {\n      uniqueId = lines.properties[featureId][uniqueIdProperty];\n    } else {\n      uniqueId = undefined;\n    }\n    const length = getLineLength(lines, i);\n    if (!idToLineInfo.has(uniqueId) || length > idToLineInfo.get(uniqueId)!.length) {\n      idToLineInfo.set(uniqueId, {index: i, length});\n    }\n  }\n\n  const positions: number[] = [];\n  const properties: Properties = [];\n  const featureIds: number[] = [];\n  const globalFeatureIds: number[] = [];\n  const numericProps = initializeNumericProps(idToLineInfo.size, lines.numericProps);\n\n  // Second pass: create points for the longest line of each unique ID\n  let pointIndex = 0;\n  for (const [_, {index}] of idToLineInfo) {\n    const midpoint = getLineMidpoint(lines, index);\n    positions.push(...midpoint);\n\n    const pathIndex = lines.pathIndices.value[index];\n    const featureId = lines.featureIds.value[pathIndex];\n    featureIds.push(pointIndex);\n    properties.push(lines.properties[featureId]);\n    globalFeatureIds.push(lines.globalFeatureIds.value[pathIndex]);\n    copyNumericProps(lines.numericProps, numericProps, pathIndex, pointIndex);\n    pointIndex++;\n  }\n\n  return createBinaryPointFeature(\n    positions,\n    featureIds,\n    globalFeatureIds,\n    numericProps,\n    properties\n  );\n}\n\nexport function createPointsFromPolygons(\n  polygons: Required<BinaryPolygonFeature>,\n  tileBbox: TileBBox,\n  props: any\n): BinaryPointFeature {\n  const {west, south, east, north} = tileBbox;\n  const tileArea = (east - west) * (north - south);\n  const minPolygonArea = tileArea * 0.0001; // 0.01% threshold\n\n  const positions: number[] = [];\n  const properties: Properties = [];\n  const featureIds: number[] = [];\n  const globalFeatureIds: number[] = [];\n  const numericProps = initializeNumericProps(\n    polygons.polygonIndices.value.length - 1,\n    polygons.numericProps\n  );\n\n  // Process each polygon\n  let pointIndex = 0;\n  let triangleIndex = 0;\n  const {extruded} = props;\n  for (let i = 0; i < polygons.polygonIndices.value.length - 1; i++) {\n    const startIndex = polygons.polygonIndices.value[i];\n    const endIndex = polygons.polygonIndices.value[i + 1];\n\n    // Skip small polygons\n    if (getPolygonArea(polygons, i) < minPolygonArea) {\n      continue;\n    }\n\n    const centroid = getPolygonCentroid(polygons, i);\n    let maxArea = -1;\n    let largestTriangleCenter: [number, number] = [0, 0];\n    let centroidIsInside = false;\n\n    // Scan triangles until we find ones that don't belong to this polygon\n    while (triangleIndex < polygons.triangles.value.length) {\n      const i1 = polygons.triangles.value[triangleIndex];\n\n      // If we've moved past the current polygon's triangles, break\n      if (i1 >= endIndex) {\n        break;\n      }\n\n      // If we've already found a triangle containing the centroid, skip the rest\n      if (centroidIsInside) {\n        triangleIndex += 3;\n        continue;\n      }\n\n      const i2 = polygons.triangles.value[triangleIndex + 1];\n      const i3 = polygons.triangles.value[triangleIndex + 2];\n      const v1 = polygons.positions.value.subarray(\n        i1 * polygons.positions.size,\n        i1 * polygons.positions.size + polygons.positions.size\n      );\n      const v2 = polygons.positions.value.subarray(\n        i2 * polygons.positions.size,\n        i2 * polygons.positions.size + polygons.positions.size\n      );\n      const v3 = polygons.positions.value.subarray(\n        i3 * polygons.positions.size,\n        i3 * polygons.positions.size + polygons.positions.size\n      );\n\n      if (isPointInTriangle(centroid, v1, v2, v3)) {\n        centroidIsInside = true;\n      } else {\n        const area = getTriangleArea(v1, v2, v3);\n        if (area > maxArea) {\n          maxArea = area;\n          largestTriangleCenter = [(v1[0] + v2[0] + v3[0]) / 3, (v1[1] + v2[1] + v3[1]) / 3];\n        }\n      }\n\n      triangleIndex += 3;\n    }\n\n    const labelPoint = centroidIsInside ? centroid : largestTriangleCenter;\n    if (isPointInBounds(labelPoint, tileBbox)) {\n      positions.push(...labelPoint);\n      const featureId = polygons.featureIds.value[startIndex];\n      if (extruded) {\n        const elevation = props.getElevation(undefined, {\n          data: polygons,\n          index: featureId\n        });\n        positions.push(elevation * props.elevationScale);\n      }\n      properties.push(polygons.properties[featureId]);\n      featureIds.push(pointIndex);\n      globalFeatureIds.push(polygons.globalFeatureIds.value[startIndex]);\n      copyNumericProps(polygons.numericProps, numericProps, startIndex, pointIndex);\n      pointIndex++;\n    }\n  }\n\n  // Trim numeric properties arrays to actual size\n  if (polygons.numericProps) {\n    Object.keys(numericProps).forEach(prop => {\n      numericProps[prop].value = numericProps[prop].value.slice(0, pointIndex);\n    });\n  }\n\n  return createBinaryPointFeature(\n    positions,\n    featureIds,\n    globalFeatureIds,\n    numericProps,\n    properties,\n    extruded ? 3 : 2\n  );\n}\n\n// Helper functions\nfunction getPolygonArea(polygons: Required<BinaryPolygonFeature>, index: number): number {\n  const {\n    positions: {value: positions, size},\n    polygonIndices: {value: indices},\n    triangles: {value: triangles}\n  } = polygons;\n\n  const startIndex = indices[index];\n  const endIndex = indices[index + 1];\n  let area = 0;\n  let triangleIndex = 0;\n\n  // Find first triangle of this polygon\n  // Note: this assumes triangles and polygon indices are sorted.\n  // This is true for the current implementation of geojsonToBinary\n  while (triangleIndex < triangles.length) {\n    const i1 = triangles[triangleIndex];\n    if (i1 >= startIndex) break;\n    triangleIndex += 3;\n  }\n\n  // Process triangles until we hit the next polygon\n  while (triangleIndex < triangles.length) {\n    const i1 = triangles[triangleIndex];\n    if (i1 >= endIndex) break;\n\n    const i2 = triangles[triangleIndex + 1];\n    const i3 = triangles[triangleIndex + 2];\n    const v1 = positions.subarray(i1 * size, i1 * size + size);\n    const v2 = positions.subarray(i2 * size, i2 * size + size);\n    const v3 = positions.subarray(i3 * size, i3 * size + size);\n\n    area += getTriangleArea(v1, v2, v3);\n    triangleIndex += 3;\n  }\n\n  return area;\n}\n\nfunction isPointInBounds([x, y]: [number, number], {west, east, south, north}: TileBBox): boolean {\n  return x >= west && x < east && y >= south && y < north;\n}\n\nfunction isPointInTriangle(p: Vec2, v1: Vec2, v2: Vec2, v3: Vec2): boolean {\n  const area = Math.abs((v2[0] - v1[0]) * (v3[1] - v1[1]) - (v3[0] - v1[0]) * (v2[1] - v1[1])) / 2;\n  const area1 = Math.abs((v1[0] - p[0]) * (v2[1] - p[1]) - (v2[0] - p[0]) * (v1[1] - p[1])) / 2;\n  const area2 = Math.abs((v2[0] - p[0]) * (v3[1] - p[1]) - (v3[0] - p[0]) * (v2[1] - p[1])) / 2;\n  const area3 = Math.abs((v3[0] - p[0]) * (v1[1] - p[1]) - (v1[0] - p[0]) * (v3[1] - p[1])) / 2;\n\n  // Account for floating point precision\n  return Math.abs(area - (area1 + area2 + area3)) < 1e-10;\n}\n\nfunction getTriangleArea([x1, y1]: Vec2, [x2, y2]: Vec2, [x3, y3]: Vec2): number {\n  return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);\n}\n\nfunction getPolygonCentroid(polygons: BinaryPolygonFeature, index: number): [number, number] {\n  const {\n    positions: {value: positions, size}\n  } = polygons;\n  const startIndex = size * polygons.polygonIndices.value[index];\n  const endIndex = size * polygons.polygonIndices.value[index + 1];\n\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (let i = startIndex; i < endIndex; i += size) {\n    const [x, y] = positions.subarray(i, i + 2);\n    minX = Math.min(minX, x);\n    minY = Math.min(minY, y);\n    maxX = Math.max(maxX, x);\n    maxY = Math.max(maxY, y);\n  }\n\n  return [(minX + maxX) / 2, (minY + maxY) / 2];\n}\n\nfunction getSegmentLength(lines: BinaryLineFeature, index: number): number {\n  const {\n    positions: {value}\n  } = lines;\n  const [x1, y1, x2, y2] = value.subarray(index, index + 4);\n  return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n}\n\nfunction getLineLength(lines: BinaryLineFeature, index: number): number {\n  const {\n    positions: {size}\n  } = lines;\n  const startIndex = size * lines.pathIndices.value[index];\n  const endIndex = size * lines.pathIndices.value[index + 1];\n  let length = 0;\n  for (let j = startIndex; j < endIndex; j += size) {\n    length += getSegmentLength(lines, j);\n  }\n  return length;\n}\n\nfunction getLineMidpoint(lines: BinaryLineFeature, index: number): [number, number] {\n  const {\n    positions: {value: positions},\n    pathIndices: {value: pathIndices}\n  } = lines;\n  const startIndex = pathIndices[index] * 2;\n  const endIndex = pathIndices[index + 1] * 2;\n  const numPoints = (endIndex - startIndex) / 2;\n\n  if (numPoints === 2) {\n    // For lines with only two vertices, interpolate between them\n    const [x1, y1, x2, y2] = positions.subarray(startIndex, startIndex + 4);\n    return [(x1 + x2) / 2, (y1 + y2) / 2];\n  }\n  // For lines with multiple vertices, use the middle vertex\n  const midPointIndex = startIndex + Math.floor(numPoints / 2) * 2;\n  return [positions[midPointIndex], positions[midPointIndex + 1]];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {CartoAPIError, APIErrorContext} from '@carto/api-client';\nimport {GoogleBasemapProps} from './api/types';\n\nconst cartoStyleUrlTemplate = 'https://basemaps.cartocdn.com/gl/{basemap}-gl-style/style.json';\n\nexport const CARTO_MAP_STYLES = ['positron', 'dark-matter', 'voyager'];\n\nexport const GOOGLE_BASEMAPS: Record<string, GoogleBasemapProps> = {\n  roadmap: {\n    mapTypeId: 'roadmap',\n    mapId: '3754c817b510f791'\n  },\n  'google-positron': {\n    mapTypeId: 'roadmap',\n    mapId: 'ea84ae4203ef21cd'\n  },\n  'google-dark-matter': {\n    mapTypeId: 'roadmap',\n    mapId: '2fccc3b36c22a0e2'\n  },\n  'google-voyager': {\n    mapTypeId: 'roadmap',\n    mapId: '885caf1e15bb9ef2'\n  },\n  satellite: {\n    mapTypeId: 'satellite'\n  },\n  hybrid: {\n    mapTypeId: 'hybrid'\n  },\n  terrain: {\n    mapTypeId: 'terrain'\n  }\n};\n\ntype StyleLayerGroupSlug = 'label' | 'road' | 'border' | 'building' | 'water' | 'land';\ntype StyleLayerGroup = {\n  slug: StyleLayerGroupSlug;\n  filter: (layer: any) => boolean;\n  defaultVisibility: boolean;\n};\n\nexport const STYLE_LAYER_GROUPS: StyleLayerGroup[] = [\n  {\n    slug: 'label',\n    filter: ({id}: {id: string}) =>\n      Boolean(\n        id.match(/(?=(label|_label|place-|place_|poi-|poi_|watername_|roadname_|housenumber))/)\n      ),\n    defaultVisibility: true\n  },\n  {\n    slug: 'road',\n    filter: ({id}: {id: string}) =>\n      Boolean(id.match(/(?=(road|railway|tunnel|street|bridge))(?!.*label)/)),\n    defaultVisibility: true\n  },\n  {\n    slug: 'border',\n    filter: ({id}: {id: string}) => Boolean(id.match(/border|boundaries|boundary_/)),\n    defaultVisibility: false\n  },\n  {\n    slug: 'building',\n    filter: ({id}: {id: string}) => Boolean(id.match(/building/)),\n    defaultVisibility: true\n  },\n  {\n    slug: 'water',\n    filter: ({id}: {id: string}) => Boolean(id.match(/(?=(water|stream|ferry))/)),\n    defaultVisibility: true\n  },\n  {\n    slug: 'land',\n    filter: ({id}: {id: string}) =>\n      Boolean(id.match(/(?=(parks|landcover|industrial|sand|hillshade|park_))/)),\n    defaultVisibility: true\n  }\n];\n\nexport function applyLayerGroupFilters(\n  style,\n  visibleLayerGroups: Record<StyleLayerGroupSlug, boolean>\n) {\n  if (!Array.isArray(style?.layers)) {\n    return style;\n  }\n\n  const removedLayerFilters = STYLE_LAYER_GROUPS.filter(lg => !visibleLayerGroups[lg.slug]).map(\n    lg => lg.filter\n  );\n\n  const visibleLayers = style.layers.filter(layer =>\n    removedLayerFilters.every(match => !match(layer))\n  );\n\n  return {\n    ...style,\n    layers: visibleLayers\n  };\n}\n\nexport function someLayerGroupsDisabled(visibleLayerGroups?: Record<StyleLayerGroupSlug, boolean>) {\n  return visibleLayerGroups && Object.values(visibleLayerGroups).every(Boolean) === false;\n}\n\nexport function getStyleUrl(styleType: string) {\n  return cartoStyleUrlTemplate.replace('{basemap}', styleType);\n}\n\nexport async function fetchStyle({\n  styleUrl,\n  errorContext\n}: {\n  styleUrl: string;\n  errorContext?: APIErrorContext;\n}) {\n  /* global fetch */\n  let response: Response | undefined;\n  return await fetch(styleUrl, {mode: 'cors'})\n    .then(res => {\n      response = res;\n      return res.json();\n    })\n    .catch(error => {\n      throw new CartoAPIError(error, {...errorContext, requestType: 'Basemap style'}, response);\n    });\n}\n\nexport default {\n  VOYAGER: getStyleUrl('voyager'),\n  POSITRON: getStyleUrl('positron'),\n  DARK_MATTER: getStyleUrl('dark-matter'),\n  VOYAGER_NOLABELS: getStyleUrl('voyager-nolabels'),\n  POSITRON_NOLABELS: getStyleUrl('positron-nolabels'),\n  DARK_MATTER_NOLABELS: getStyleUrl('dark-matter-nolabels')\n} as const;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {scaleThreshold} from 'd3-scale';\nimport {AccessorFunction, Color} from '@deck.gl/core';\nimport {Feature} from 'geojson';\nimport getPalette, {DEFAULT_PALETTE, NULL_COLOR} from './palette';\nimport {assert} from '../utils';\nimport {AttributeSelector, getAttrValue} from './utils';\n\n/**\n * Helper function for quickly creating a color bins style based on `d3` `scaleThreshold`.\n *\n * Data values of each attribute are rounded down to the nearest value in the domain and are then\n * styled with the corresponding color.\n *\n * @return accessor that maps objects to `Color` values\n */\nexport default function colorBins<DataT = Feature>({\n  attr,\n  domain,\n  colors = DEFAULT_PALETTE,\n  nullColor = NULL_COLOR\n}: {\n  /** Attribute or column to symbolize by. */\n  attr: AttributeSelector<DataT, number>;\n\n  /** Category list. Must be a valid list of categories. */\n  domain: number[];\n\n  /**\n   * Color assigned to each domain value.\n   *\n   * Either Array of colors in RGBA or valid named CARTOColors palette.\n   * @default `PurpOr`\n   */\n  colors?: string | Color[];\n\n  /** Color for null values. @default: [204, 204, 204] */\n  nullColor?: Color;\n}): AccessorFunction<DataT, Color> {\n  assert(Array.isArray(domain), 'Expected \"domain\" to be an array of numbers');\n\n  const palette = typeof colors === 'string' ? getPalette(colors, domain.length + 1) : colors;\n\n  const color = scaleThreshold<number, Color>().domain(domain).range(palette);\n\n  return (d, info) => {\n    const value = getAttrValue(attr, d, info);\n    return typeof value === 'number' && Number.isFinite(value) ? color(value) : nullColor;\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport * as cartoColors from 'cartocolor';\nimport {assert} from '../utils';\nimport {Color} from '@deck.gl/core';\n\nexport const DEFAULT_PALETTE = 'PurpOr';\nexport const NULL_COLOR: Color = [204, 204, 204];\nexport const OTHERS_COLOR: Color = [119, 119, 119];\n\ninterface CartoColorsPalette {\n  tags?: string[];\n  [key: number]: string[];\n}\n\nexport default function getPalette(name: string, numCategories: number): Color[] {\n  const palette: CartoColorsPalette | undefined = cartoColors[name];\n  let paletteIndex = numCategories;\n\n  assert(palette, `Palette \"${name}\" not found. Expected a CARTOColors string`);\n\n  const palettesColorVariants = Object.keys(palette)\n    .filter(p => p !== 'tags')\n    .map(Number);\n\n  const longestPaletteIndex = Math.max(...palettesColorVariants);\n  const smallestPaletteIndex = Math.min(...palettesColorVariants);\n\n  if (!Number.isInteger(numCategories) || numCategories > longestPaletteIndex) {\n    paletteIndex = longestPaletteIndex;\n  } else if (numCategories < smallestPaletteIndex) {\n    paletteIndex = smallestPaletteIndex;\n  }\n\n  let colors = palette[paletteIndex];\n\n  if (palette.tags && palette.tags.includes('qualitative')) {\n    colors = colors.slice(0, -1);\n  }\n\n  return colors.map(c => hexToRgb(c));\n}\n\nexport function hexToRgb(hex: string): Color {\n  // Evaluate #ABC\n  let result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      255\n    ];\n  }\n\n  // Evaluate #ABCD\n  result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n\n  if (result) {\n    return [\n      parseInt(result[1] + result[1], 16),\n      parseInt(result[2] + result[2], 16),\n      parseInt(result[3] + result[3], 16),\n      parseInt(result[4] + result[4], 16)\n    ];\n  }\n\n  // Evaluate #ABCDEF\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  if (result) {\n    return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255];\n  }\n\n  // Evaluate #ABCDEFAF\n  result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n  assert(result, `Hexadecimal color \"${hex}\" was not parsed correctly`);\n\n  return [\n    parseInt(result[1], 16),\n    parseInt(result[2], 16),\n    parseInt(result[3], 16),\n    parseInt(result[4], 16)\n  ];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Feature} from 'geojson';\nimport {assert} from '../utils';\n\nconst ALLOWED_ATTR_TYPES = Object.freeze(['function', 'string']);\n\nexport type AttributeSelector<DataT = Feature, OutT = any> =\n  | string\n  | ((d: DataT, info: any) => OutT);\n\nexport function getAttrValue<DataT = Feature, OutT = any>(\n  attr: string | AttributeSelector<DataT, OutT>,\n  d: DataT,\n  info: any\n): OutT {\n  assert(typeof d === 'object', 'Expected \"data\" to be an object');\n  assert(ALLOWED_ATTR_TYPES.includes(typeof attr), 'Expected \"attr\" to be a function or string');\n\n  // Is function\n  if (typeof attr === 'function') {\n    return attr(d, info);\n  }\n  return (d as unknown as Feature)?.properties?.[attr] as OutT;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {AccessorFunction, Color} from '@deck.gl/core';\nimport {Feature} from 'geojson';\nimport getPalette, {DEFAULT_PALETTE, NULL_COLOR, OTHERS_COLOR} from './palette';\nimport {assert} from '../utils';\nimport {AttributeSelector, getAttrValue} from './utils';\n\n/**\n * Helper function for quickly creating a color category style.\n *\n * Data values of each attribute listed in the domain are mapped one to one\n * with corresponding colors in the range.\n *\n * @return accessor that maps objects to `Color` values\n */\nexport default function colorCategories<DataT = Feature>({\n  attr,\n  domain,\n  colors = DEFAULT_PALETTE,\n  nullColor = NULL_COLOR,\n  othersColor = OTHERS_COLOR\n}: {\n  /** Attribute or column to symbolize by */\n  attr: string | AttributeSelector<DataT, number | string>;\n\n  /** Category list. Must be a valid list of categories. */\n  domain: number[] | string[];\n\n  /**\n   * Color assigned to each domain value.\n   *\n   * Either Array of colors in RGBA or valid named CARTOColors palette.\n   * @default `PurpOr`\n   */\n  colors: string | Color[];\n\n  /** Color for null values. @default: [204, 204, 204] */\n  nullColor?: Color;\n\n  /** Fallback color for a category not correctly assigned. @default: [119, 119, 119] */\n  othersColor?: Color;\n}): AccessorFunction<DataT, Color> {\n  assert(Array.isArray(domain), 'Expected \"domain\" to be an array of numbers or strings');\n\n  const colorsByCategory = {};\n  const palette = typeof colors === 'string' ? getPalette(colors, domain.length) : colors;\n\n  for (const [i, c] of domain.entries()) {\n    colorsByCategory[c] = palette[i];\n  }\n\n  return (d, info) => {\n    const value = getAttrValue(attr, d, info);\n    return (typeof value === 'number' && Number.isFinite(value)) || typeof value === 'string'\n      ? colorsByCategory[value] || othersColor\n      : nullColor;\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {AccessorFunction, Color} from '@deck.gl/core';\nimport {scaleLinear} from 'd3-scale';\nimport {Feature} from 'geojson';\nimport getPalette, {DEFAULT_PALETTE, NULL_COLOR} from './palette';\nimport {assert} from '../utils';\nimport {AttributeSelector, getAttrValue} from './utils';\n\n/**\n * Helper function for quickly creating a color continuous style.\n *\n * Data values of each field are interpolated linearly across values in the domain and\n * are then styled with a blend of the corresponding color in the range.\n *\n * @return accessor that maps objects to `Color` values\n */\nexport default function colorContinuous<DataT = Feature>({\n  attr,\n  domain,\n  colors = DEFAULT_PALETTE,\n  nullColor = NULL_COLOR\n}: {\n  /** Attribute or column to symbolize by. */\n  attr: AttributeSelector<DataT, number>;\n\n  /** Attribute domain to define the data range. */\n  domain: number[];\n\n  /**\n   * Color assigned to each domain value.\n   *\n   * Either Array of colors in RGBA or valid named CARTOColors palette.\n   * @default `PurpOr`\n   */\n  colors?: string | Color[];\n\n  /** Color for null values. @default: [204, 204, 204]*/\n  nullColor?: Color;\n}): AccessorFunction<DataT, Color> {\n  assert(Array.isArray(domain), 'Expected \"domain\" to be an array of numbers');\n\n  const palette = typeof colors === 'string' ? getPalette(colors, domain.length) : colors;\n  const color = scaleLinear<Color>().domain(domain).range(palette);\n\n  return (d, info) => {\n    const value = getAttrValue(attr, d, info);\n    return typeof value === 'number' && Number.isFinite(value) ? color(value) : nullColor;\n  };\n}\n", "import {_ConstructorOf, Layer} from '@deck.gl/core';\nimport ClusterTileLayer from '../layers/cluster-tile-layer';\nimport H3TileLayer from '../layers/h3-tile-layer';\nimport HeatmapTileLayer from '../layers/heatmap-tile-layer';\nimport VectorTileLayer from '../layers/vector-tile-layer';\nimport QuadbinTileLayer from '../layers/quadbin-tile-layer';\nimport RasterTileLayer from '../layers/raster-tile-layer';\n\nimport {\n  fetchMap as _fetchMap,\n  FetchMapOptions as _FetchMapOptions,\n  FetchMapResult as _FetchMapResult,\n  LayerDescriptor,\n  LayerType\n} from '@carto/api-client';\n\nexport type FetchMapResult = Omit<_FetchMapResult, 'layers'> & {\n  layers: Layer[];\n};\n\nexport type FetchMapOptions = Omit<_FetchMapOptions, 'onNewData'> & {\n  onNewData?: (result: FetchMapResult) => void;\n};\n\n// Layer factory to create deck.gl layers from layer descriptors\nconst layerClasses: Record<LayerType, _ConstructorOf<Layer>> = {\n  clusterTile: ClusterTileLayer,\n  h3: H3TileLayer,\n  heatmapTile: HeatmapTileLayer,\n  mvt: VectorTileLayer,\n  quadbin: QuadbinTileLayer,\n  raster: RasterTileLayer,\n  tileset: VectorTileLayer\n} as const;\n\nexport function LayerFactory(descriptor: LayerDescriptor): Layer {\n  const LayerClass = layerClasses[descriptor.type];\n  if (!LayerClass) {\n    throw new Error(`No layer class found for type: ${descriptor.type}`);\n  }\n  return new LayerClass(descriptor.props);\n}\n\nfunction createResult(result: _FetchMapResult): FetchMapResult {\n  return {\n    ...result,\n    layers: result.layers.map(descriptor => LayerFactory(descriptor))\n  };\n}\n\n/**\n * fetchMap is a wrapper around the @carto/api-client fetchMap function, with additions for convenience and backward-compatibility.\n * Where @carto/api-client fetchMap returns layer props, @deck.gl/carto fetchMap returns Layer instances ready for use.\n * For greater control, use the @carto/api-client fetchMap function directly and use LayerFactory to create layers manually.\n */\nexport async function fetchMap(options: FetchMapOptions): Promise<FetchMapResult> {\n  const {onNewData, ...rest} = options;\n  const _options: _FetchMapOptions = {\n    ...rest,\n    onNewData:\n      typeof onNewData === 'function'\n        ? result => {\n            onNewData(createResult(result));\n          }\n        : undefined\n  };\n\n  // For backwards compatibility, provide a shim for the old API\n  const _result: _FetchMapResult = await _fetchMap(_options);\n  const result: FetchMapResult = createResult(_result);\n  return result;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {MapViewState} from '@deck.gl/core';\nimport {\n  GOOGLE_BASEMAPS,\n  CARTO_MAP_STYLES,\n  applyLayerGroupFilters,\n  fetchStyle,\n  getStyleUrl,\n  someLayerGroupsDisabled\n} from '../basemap';\nimport {Basemap, KeplerMapConfig, MapLibreBasemapProps} from './types';\nimport {APIErrorContext} from '@carto/api-client';\n\nconst CUSTOM_STYLE_ID_PREFIX = 'custom:';\nconst DEFAULT_CARTO_STYLE = 'positron';\n\nfunction mapLibreViewpros(config: KeplerMapConfig): Omit<MapLibreBasemapProps, 'style'> {\n  const {longitude, latitude, ...rest} = config.mapState as MapViewState;\n  return {\n    center: [longitude, latitude],\n    ...rest\n  };\n}\n\n/**\n * Get basemap properties for Carto map.\n *\n * For maplibre-based basemaps it returns style or style URL that can be used with  `maplibregl.Map` compatible component.\n *  * style url is returned for non-filtered standard Carto basemaps or if user used style URL directly in configuration\n *  * filtered style object returned for Carto basemaps with layer groups filtered\n *\n * For Google-maps base maps, it returns options that can be used with `google.maps.Map` constructor.\n */\nexport async function fetchBasemapProps({\n  config,\n  errorContext,\n\n  applyLayerFilters = true\n}: {\n  config: KeplerMapConfig;\n\n  /** By default `fetchBasemapProps` applies layers filters to style. Set this to `false` to disable it. */\n  applyLayerFilters?: boolean;\n  errorContext?: APIErrorContext;\n}): Promise<Basemap | null> {\n  const {mapStyle} = config;\n  const styleType = mapStyle.styleType || DEFAULT_CARTO_STYLE;\n  if (styleType.startsWith(CUSTOM_STYLE_ID_PREFIX)) {\n    const currentCustomStyle = config.customBaseMaps?.customStyle;\n    if (currentCustomStyle) {\n      return {\n        type: 'maplibre',\n        props: {\n          style: currentCustomStyle.style || currentCustomStyle.url,\n          ...mapLibreViewpros(config)\n        },\n        attribution: currentCustomStyle.customAttribution\n      };\n    }\n  }\n\n  if (CARTO_MAP_STYLES.includes(styleType)) {\n    const {visibleLayerGroups} = mapStyle;\n    const styleUrl = getStyleUrl(styleType);\n    let style = styleUrl;\n    let rawStyle = styleUrl;\n    if (applyLayerFilters && visibleLayerGroups && someLayerGroupsDisabled(visibleLayerGroups)) {\n      rawStyle = await fetchStyle({styleUrl, errorContext});\n      style = applyLayerGroupFilters(rawStyle, visibleLayerGroups);\n    }\n    return {\n      type: 'maplibre',\n      props: {\n        style,\n        ...mapLibreViewpros(config)\n      },\n      visibleLayerGroups,\n      rawStyle\n    };\n  }\n  const googleBasemapDef = GOOGLE_BASEMAPS[styleType];\n  if (googleBasemapDef) {\n    const {mapState} = config;\n    return {\n      type: 'google-maps',\n      props: {\n        ...googleBasemapDef,\n        center: {lat: mapState.latitude, lng: mapState.longitude},\n        zoom: mapState.zoom + 1,\n        tilt: mapState.pitch,\n        heading: mapState.bearing\n      }\n    };\n  }\n  return {\n    type: 'maplibre',\n    props: {\n      style: getStyleUrl(DEFAULT_CARTO_STYLE),\n      ...mapLibreViewpros(config)\n    }\n  };\n}\n"],
  "mappings": "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",
  "names": ["import_geo_layers", "import_core", "import_core", "id", "id", "getH3Resolution", "h3CellToParent", "import_quadbin", "Tileset2D", "import_geo_layers", "import_h3_js", "Tileset2D", "import_quadbin", "import_h3_js", "TileReader", "TileReader", "Protobuf", "import_quadbin", "id", "TileReader", "import_core", "deepEqual", "id", "deepEqual", "data", "_a", "import_core", "import_geo_layers", "import_core", "import_geo_layers", "defaultProps", "defaultProps", "import_quadbin", "import_h3_js", "import_core", "import_layers", "import_core", "fs", "import_core", "import_geo_layers", "defaultProps", "GeoCellLayer", "import_quadbin", "renderSubLayers", "defaultProps", "TEXTURE_PROPS", "getH3Resolution", "defaultProps", "deepEqual", "PostProcessTileLayer", "tiles", "import_core", "import_layers", "TextBackgroundLayer", "defaultProps", "id", "import_core", "import_core", "import_layers", "defaultProps", "import_geo_layers", "import_core", "TileReader", "VERSION", "id", "DEFAULT_OPTIONS", "TileReader", "renderSubLayers", "defaultProps", "import_core", "TileReader", "VERSION", "id", "DEFAULT_OPTIONS", "TileReader", "VERSION", "id", "DEFAULT_OPTIONS", "earcut", "import_geo_layers", "import_layers", "defaultProps", "fetch", "_a", "_b", "_c", "id", "import_d3_scale", "import_api_client", "result", "_fetchMap", "import_api_client"]
}
