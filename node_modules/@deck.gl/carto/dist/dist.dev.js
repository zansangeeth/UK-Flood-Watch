(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod2, secondTarget) => (__copyProps(target, mod2, "default"), secondTarget && __copyProps(secondTarget, mod2, "default"));
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

  // external-global-plugin:@deck.gl/layers
  var require_layers = __commonJS({
    "external-global-plugin:@deck.gl/layers"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // external-global-plugin:@deck.gl/geo-layers
  var require_geo_layers = __commonJS({
    "external-global-plugin:@deck.gl/geo-layers"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // external-global-plugin:@loaders.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@loaders.gl/core"(exports, module) {
      module.exports = globalThis.loaders;
    }
  });

  // external-global-plugin:@deck.gl/core
  var require_core2 = __commonJS({
    "external-global-plugin:@deck.gl/core"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // ../../node_modules/tilebelt/index.js
  var require_tilebelt = __commonJS({
    "../../node_modules/tilebelt/index.js"(exports, module) {
      var d2r2 = Math.PI / 180;
      var r2d2 = 180 / Math.PI;
      function tileToBBOX2(tile) {
        var e = tile2lon2(tile[0] + 1, tile[2]);
        var w = tile2lon2(tile[0], tile[2]);
        var s = tile2lat2(tile[1] + 1, tile[2]);
        var n = tile2lat2(tile[1], tile[2]);
        return [w, s, e, n];
      }
      function tileToGeoJSON2(tile) {
        var bbox2 = tileToBBOX2(tile);
        var poly = {
          type: "Polygon",
          coordinates: [
            [
              [bbox2[0], bbox2[1]],
              [bbox2[0], bbox2[3]],
              [bbox2[2], bbox2[3]],
              [bbox2[2], bbox2[1]],
              [bbox2[0], bbox2[1]]
            ]
          ]
        };
        return poly;
      }
      function tile2lon2(x, z) {
        return x / Math.pow(2, z) * 360 - 180;
      }
      function tile2lat2(y, z) {
        var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
        return r2d2 * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
      }
      function pointToTile2(lon, lat, z) {
        var tile = pointToTileFraction2(lon, lat, z);
        tile[0] = Math.floor(tile[0]);
        tile[1] = Math.floor(tile[1]);
        return tile;
      }
      function getChildren2(tile) {
        return [
          [tile[0] * 2, tile[1] * 2, tile[2] + 1],
          [tile[0] * 2 + 1, tile[1] * 2, tile[2] + 1],
          [tile[0] * 2 + 1, tile[1] * 2 + 1, tile[2] + 1],
          [tile[0] * 2, tile[1] * 2 + 1, tile[2] + 1]
        ];
      }
      function getParent2(tile) {
        if (tile[0] % 2 === 0 && tile[1] % 2 === 0) {
          return [tile[0] / 2, tile[1] / 2, tile[2] - 1];
        } else if (tile[0] % 2 === 0 && !tile[1] % 2 === 0) {
          return [tile[0] / 2, (tile[1] - 1) / 2, tile[2] - 1];
        } else if (!tile[0] % 2 === 0 && tile[1] % 2 === 0) {
          return [(tile[0] - 1) / 2, tile[1] / 2, tile[2] - 1];
        } else {
          return [(tile[0] - 1) / 2, (tile[1] - 1) / 2, tile[2] - 1];
        }
      }
      function getSiblings2(tile) {
        return getChildren2(getParent2(tile));
      }
      function hasSiblings2(tile, tiles3) {
        var siblings = getSiblings2(tile);
        for (var i = 0; i < siblings.length; i++) {
          if (!hasTile2(tiles3, siblings[i]))
            return false;
        }
        return true;
      }
      function hasTile2(tiles3, tile) {
        for (var i = 0; i < tiles3.length; i++) {
          if (tilesEqual2(tiles3[i], tile))
            return true;
        }
        return false;
      }
      function tilesEqual2(tile1, tile2) {
        return tile1[0] === tile2[0] && tile1[1] === tile2[1] && tile1[2] === tile2[2];
      }
      function tileToQuadkey2(tile) {
        var index2 = "";
        for (var z = tile[2]; z > 0; z--) {
          var b = 0;
          var mask = 1 << z - 1;
          if ((tile[0] & mask) !== 0)
            b++;
          if ((tile[1] & mask) !== 0)
            b += 2;
          index2 += b.toString();
        }
        return index2;
      }
      function quadkeyToTile2(quadkey) {
        var x = 0;
        var y = 0;
        var z = quadkey.length;
        for (var i = z; i > 0; i--) {
          var mask = 1 << i - 1;
          switch (quadkey[z - i]) {
            case "0":
              break;
            case "1":
              x |= mask;
              break;
            case "2":
              y |= mask;
              break;
            case "3":
              x |= mask;
              y |= mask;
              break;
          }
        }
        return [x, y, z];
      }
      function bboxToTile2(bboxCoords) {
        var min2 = pointToTile2(bboxCoords[0], bboxCoords[1], 32);
        var max2 = pointToTile2(bboxCoords[2], bboxCoords[3], 32);
        var bbox2 = [min2[0], min2[1], max2[0], max2[1]];
        var z = getBboxZoom2(bbox2);
        if (z === 0)
          return [0, 0, 0];
        var x = bbox2[0] >>> 32 - z;
        var y = bbox2[1] >>> 32 - z;
        return [x, y, z];
      }
      function getBboxZoom2(bbox2) {
        var MAX_ZOOM = 28;
        for (var z = 0; z < MAX_ZOOM; z++) {
          var mask = 1 << 32 - (z + 1);
          if ((bbox2[0] & mask) != (bbox2[2] & mask) || (bbox2[1] & mask) != (bbox2[3] & mask)) {
            return z;
          }
        }
        return MAX_ZOOM;
      }
      function pointToTileFraction2(lon, lat, z) {
        var sin = Math.sin(lat * d2r2), z2 = Math.pow(2, z), x = z2 * (lon / 360 + 0.5), y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
        return [x, y, z];
      }
      module.exports = {
        tileToGeoJSON: tileToGeoJSON2,
        tileToBBOX: tileToBBOX2,
        getChildren: getChildren2,
        getParent: getParent2,
        getSiblings: getSiblings2,
        hasTile: hasTile2,
        hasSiblings: hasSiblings2,
        tilesEqual: tilesEqual2,
        tileToQuadkey: tileToQuadkey2,
        quadkeyToTile: quadkeyToTile2,
        pointToTile: pointToTile2,
        bboxToTile: bboxToTile2,
        pointToTileFraction: pointToTileFraction2
      };
    }
  });

  // ../../node_modules/@mapbox/tile-cover/index.js
  var require_tile_cover = __commonJS({
    "../../node_modules/@mapbox/tile-cover/index.js"(exports) {
      var tilebelt2 = require_tilebelt();
      exports.geojson = function(geom, limits) {
        return {
          type: "FeatureCollection",
          features: getTiles2(geom, limits).map(tileToFeature)
        };
      };
      function tileToFeature(t) {
        return {
          type: "Feature",
          geometry: tilebelt2.tileToGeoJSON(t),
          properties: {}
        };
      }
      exports.tiles = getTiles2;
      exports.indexes = function(geom, limits) {
        return getTiles2(geom, limits).map(tilebelt2.tileToQuadkey);
      };
      function getTiles2(geom, limits) {
        var i, tile, coords = geom.coordinates, maxZoom = limits.max_zoom, tileHash = {}, tiles3 = [];
        if (geom.type === "Point") {
          return [tilebelt2.pointToTile(coords[0], coords[1], maxZoom)];
        } else if (geom.type === "MultiPoint") {
          for (i = 0; i < coords.length; i++) {
            tile = tilebelt2.pointToTile(coords[i][0], coords[i][1], maxZoom);
            tileHash[toID2(tile[0], tile[1], tile[2])] = true;
          }
        } else if (geom.type === "LineString") {
          lineCover2(tileHash, coords, maxZoom);
        } else if (geom.type === "MultiLineString") {
          for (i = 0; i < coords.length; i++) {
            lineCover2(tileHash, coords[i], maxZoom);
          }
        } else if (geom.type === "Polygon") {
          polygonCover2(tileHash, tiles3, coords, maxZoom);
        } else if (geom.type === "MultiPolygon") {
          for (i = 0; i < coords.length; i++) {
            polygonCover2(tileHash, tiles3, coords[i], maxZoom);
          }
        } else {
          throw new Error("Geometry type not implemented");
        }
        if (limits.min_zoom !== maxZoom) {
          var len = tiles3.length;
          appendHashTiles2(tileHash, tiles3);
          for (i = 0; i < len; i++) {
            var t = tiles3[i];
            tileHash[toID2(t[0], t[1], t[2])] = true;
          }
          return mergeTiles2(tileHash, tiles3, limits);
        }
        appendHashTiles2(tileHash, tiles3);
        return tiles3;
      }
      function mergeTiles2(tileHash, tiles3, limits) {
        var mergedTiles = [];
        for (var z = limits.max_zoom; z > limits.min_zoom; z--) {
          var parentTileHash = {};
          var parentTiles = [];
          for (var i = 0; i < tiles3.length; i++) {
            var t = tiles3[i];
            if (t[0] % 2 === 0 && t[1] % 2 === 0) {
              var id22 = toID2(t[0] + 1, t[1], z), id32 = toID2(t[0], t[1] + 1, z), id42 = toID2(t[0] + 1, t[1] + 1, z);
              if (tileHash[id22] && tileHash[id32] && tileHash[id42]) {
                tileHash[toID2(t[0], t[1], t[2])] = false;
                tileHash[id22] = false;
                tileHash[id32] = false;
                tileHash[id42] = false;
                var parentTile = [t[0] / 2, t[1] / 2, z - 1];
                if (z - 1 === limits.min_zoom)
                  mergedTiles.push(parentTile);
                else {
                  parentTileHash[toID2(t[0] / 2, t[1] / 2, z - 1)] = true;
                  parentTiles.push(parentTile);
                }
              }
            }
          }
          for (i = 0; i < tiles3.length; i++) {
            t = tiles3[i];
            if (tileHash[toID2(t[0], t[1], t[2])])
              mergedTiles.push(t);
          }
          tileHash = parentTileHash;
          tiles3 = parentTiles;
        }
        return mergedTiles;
      }
      function polygonCover2(tileHash, tileArray, geom, zoom) {
        var intersections = [];
        for (var i = 0; i < geom.length; i++) {
          var ring = [];
          lineCover2(tileHash, geom[i], zoom, ring);
          for (var j = 0, len = ring.length, k = len - 1; j < len; k = j++) {
            var m = (j + 1) % len;
            var y = ring[j][1];
            if ((y > ring[k][1] || y > ring[m][1]) && // not local minimum
            (y < ring[k][1] || y < ring[m][1]) && // not local maximum
            y !== ring[m][1])
              intersections.push(ring[j]);
          }
        }
        intersections.sort(compareTiles2);
        for (i = 0; i < intersections.length; i += 2) {
          y = intersections[i][1];
          for (var x = intersections[i][0] + 1; x < intersections[i + 1][0]; x++) {
            var id5 = toID2(x, y, zoom);
            if (!tileHash[id5]) {
              tileArray.push([x, y, zoom]);
            }
          }
        }
      }
      function compareTiles2(a, b) {
        return a[1] - b[1] || a[0] - b[0];
      }
      function lineCover2(tileHash, coords, maxZoom, ring) {
        var prevX, prevY;
        for (var i = 0; i < coords.length - 1; i++) {
          var start = tilebelt2.pointToTileFraction(coords[i][0], coords[i][1], maxZoom), stop = tilebelt2.pointToTileFraction(coords[i + 1][0], coords[i + 1][1], maxZoom), x0 = start[0], y0 = start[1], x1 = stop[0], y1 = stop[1], dx = x1 - x0, dy = y1 - y0;
          if (dy === 0 && dx === 0)
            continue;
          var sx = dx > 0 ? 1 : -1, sy = dy > 0 ? 1 : -1, x = Math.floor(x0), y = Math.floor(y0), tMaxX = dx === 0 ? Infinity : Math.abs(((dx > 0 ? 1 : 0) + x - x0) / dx), tMaxY = dy === 0 ? Infinity : Math.abs(((dy > 0 ? 1 : 0) + y - y0) / dy), tdx = Math.abs(sx / dx), tdy = Math.abs(sy / dy);
          if (x !== prevX || y !== prevY) {
            tileHash[toID2(x, y, maxZoom)] = true;
            if (ring && y !== prevY)
              ring.push([x, y]);
            prevX = x;
            prevY = y;
          }
          while (tMaxX < 1 || tMaxY < 1) {
            if (tMaxX < tMaxY) {
              tMaxX += tdx;
              x += sx;
            } else {
              tMaxY += tdy;
              y += sy;
            }
            tileHash[toID2(x, y, maxZoom)] = true;
            if (ring && y !== prevY)
              ring.push([x, y]);
            prevX = x;
            prevY = y;
          }
        }
        if (ring && y === ring[0][1])
          ring.pop();
      }
      function appendHashTiles2(hash, tiles3) {
        var keys = Object.keys(hash);
        for (var i = 0; i < keys.length; i++) {
          tiles3.push(fromID2(+keys[i]));
        }
      }
      function toID2(x, y, z) {
        var dim = 2 * (1 << z);
        return (dim * y + x) * 32 + z;
      }
      function fromID2(id5) {
        var z = id5 % 32, dim = 2 * (1 << z), xy = (id5 - z) / 32, x = xy % dim, y = (xy - x) / dim % dim;
        return [x, y, z];
      }
    }
  });

  // external-global-plugin:h3-js
  var require_h3_js = __commonJS({
    "external-global-plugin:h3-js"(exports, module) {
      module.exports = globalThis.h3 || {};
    }
  });

  // ../../node_modules/pako/lib/utils/common.js
  var require_common = __commonJS({
    "../../node_modules/pako/lib/utils/common.js"(exports) {
      "use strict";
      var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
      function _has(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      }
      exports.assign = function(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        while (sources.length) {
          var source = sources.shift();
          if (!source) {
            continue;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be non-object");
          }
          for (var p in source) {
            if (_has(source, p)) {
              obj[p] = source[p];
            }
          }
        }
        return obj;
      };
      exports.shrinkBuf = function(buf, size) {
        if (buf.length === size) {
          return buf;
        }
        if (buf.subarray) {
          return buf.subarray(0, size);
        }
        buf.length = size;
        return buf;
      };
      var fnTyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          if (src.subarray && dest.subarray) {
            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
            return;
          }
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          var i, l, len, pos, chunk, result;
          len = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            len += chunks[i].length;
          }
          result = new Uint8Array(len);
          pos = 0;
          for (i = 0, l = chunks.length; i < l; i++) {
            chunk = chunks[i];
            result.set(chunk, pos);
            pos += chunk.length;
          }
          return result;
        }
      };
      var fnUntyped = {
        arraySet: function(dest, src, src_offs, len, dest_offs) {
          for (var i = 0; i < len; i++) {
            dest[dest_offs + i] = src[src_offs + i];
          }
        },
        // Join array of chunks to single array.
        flattenChunks: function(chunks) {
          return [].concat.apply([], chunks);
        }
      };
      exports.setTyped = function(on) {
        if (on) {
          exports.Buf8 = Uint8Array;
          exports.Buf16 = Uint16Array;
          exports.Buf32 = Int32Array;
          exports.assign(exports, fnTyped);
        } else {
          exports.Buf8 = Array;
          exports.Buf16 = Array;
          exports.Buf32 = Array;
          exports.assign(exports, fnUntyped);
        }
      };
      exports.setTyped(TYPED_OK);
    }
  });

  // ../../node_modules/pako/lib/zlib/trees.js
  var require_trees = __commonJS({
    "../../node_modules/pako/lib/zlib/trees.js"(exports) {
      "use strict";
      var utils = require_common();
      var Z_FIXED = 4;
      var Z_BINARY = 0;
      var Z_TEXT = 1;
      var Z_UNKNOWN = 2;
      function zero3(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      var STORED_BLOCK = 0;
      var STATIC_TREES = 1;
      var DYN_TREES = 2;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var Buf_size = 16;
      var MAX_BL_BITS = 7;
      var END_BLOCK = 256;
      var REP_3_6 = 16;
      var REPZ_3_10 = 17;
      var REPZ_11_138 = 18;
      var extra_lbits = (
        /* extra bits for each length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
      );
      var extra_dbits = (
        /* extra bits for each distance code */
        [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
      );
      var extra_blbits = (
        /* extra bits for each bit length code */
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
      );
      var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      var DIST_CODE_LEN = 512;
      var static_ltree = new Array((L_CODES + 2) * 2);
      zero3(static_ltree);
      var static_dtree = new Array(D_CODES * 2);
      zero3(static_dtree);
      var _dist_code = new Array(DIST_CODE_LEN);
      zero3(_dist_code);
      var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
      zero3(_length_code);
      var base_length = new Array(LENGTH_CODES);
      zero3(base_length);
      var base_dist = new Array(D_CODES);
      zero3(base_dist);
      function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
        this.static_tree = static_tree;
        this.extra_bits = extra_bits;
        this.extra_base = extra_base;
        this.elems = elems;
        this.max_length = max_length;
        this.has_stree = static_tree && static_tree.length;
      }
      var static_l_desc;
      var static_d_desc;
      var static_bl_desc;
      function TreeDesc(dyn_tree, stat_desc) {
        this.dyn_tree = dyn_tree;
        this.max_code = 0;
        this.stat_desc = stat_desc;
      }
      function d_code(dist) {
        return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
      }
      function put_short(s, w) {
        s.pending_buf[s.pending++] = w & 255;
        s.pending_buf[s.pending++] = w >>> 8 & 255;
      }
      function send_bits(s, value, length2) {
        if (s.bi_valid > Buf_size - length2) {
          s.bi_buf |= value << s.bi_valid & 65535;
          put_short(s, s.bi_buf);
          s.bi_buf = value >> Buf_size - s.bi_valid;
          s.bi_valid += length2 - Buf_size;
        } else {
          s.bi_buf |= value << s.bi_valid & 65535;
          s.bi_valid += length2;
        }
      }
      function send_code(s, c, tree) {
        send_bits(
          s,
          tree[c * 2],
          tree[c * 2 + 1]
          /*.Len*/
        );
      }
      function bi_reverse(code, len) {
        var res = 0;
        do {
          res |= code & 1;
          code >>>= 1;
          res <<= 1;
        } while (--len > 0);
        return res >>> 1;
      }
      function bi_flush(s) {
        if (s.bi_valid === 16) {
          put_short(s, s.bi_buf);
          s.bi_buf = 0;
          s.bi_valid = 0;
        } else if (s.bi_valid >= 8) {
          s.pending_buf[s.pending++] = s.bi_buf & 255;
          s.bi_buf >>= 8;
          s.bi_valid -= 8;
        }
      }
      function gen_bitlen(s, desc) {
        var tree = desc.dyn_tree;
        var max_code = desc.max_code;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var extra = desc.stat_desc.extra_bits;
        var base = desc.stat_desc.extra_base;
        var max_length = desc.stat_desc.max_length;
        var h;
        var n, m;
        var bits;
        var xbits;
        var f;
        var overflow = 0;
        for (bits = 0; bits <= MAX_BITS; bits++) {
          s.bl_count[bits] = 0;
        }
        tree[s.heap[s.heap_max] * 2 + 1] = 0;
        for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
          n = s.heap[h];
          bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
          if (bits > max_length) {
            bits = max_length;
            overflow++;
          }
          tree[n * 2 + 1] = bits;
          if (n > max_code) {
            continue;
          }
          s.bl_count[bits]++;
          xbits = 0;
          if (n >= base) {
            xbits = extra[n - base];
          }
          f = tree[n * 2];
          s.opt_len += f * (bits + xbits);
          if (has_stree) {
            s.static_len += f * (stree[n * 2 + 1] + xbits);
          }
        }
        if (overflow === 0) {
          return;
        }
        do {
          bits = max_length - 1;
          while (s.bl_count[bits] === 0) {
            bits--;
          }
          s.bl_count[bits]--;
          s.bl_count[bits + 1] += 2;
          s.bl_count[max_length]--;
          overflow -= 2;
        } while (overflow > 0);
        for (bits = max_length; bits !== 0; bits--) {
          n = s.bl_count[bits];
          while (n !== 0) {
            m = s.heap[--h];
            if (m > max_code) {
              continue;
            }
            if (tree[m * 2 + 1] !== bits) {
              s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
              tree[m * 2 + 1] = bits;
            }
            n--;
          }
        }
      }
      function gen_codes(tree, max_code, bl_count) {
        var next_code = new Array(MAX_BITS + 1);
        var code = 0;
        var bits;
        var n;
        for (bits = 1; bits <= MAX_BITS; bits++) {
          next_code[bits] = code = code + bl_count[bits - 1] << 1;
        }
        for (n = 0; n <= max_code; n++) {
          var len = tree[n * 2 + 1];
          if (len === 0) {
            continue;
          }
          tree[n * 2] = bi_reverse(next_code[len]++, len);
        }
      }
      function tr_static_init() {
        var n;
        var bits;
        var length2;
        var code;
        var dist;
        var bl_count = new Array(MAX_BITS + 1);
        length2 = 0;
        for (code = 0; code < LENGTH_CODES - 1; code++) {
          base_length[code] = length2;
          for (n = 0; n < 1 << extra_lbits[code]; n++) {
            _length_code[length2++] = code;
          }
        }
        _length_code[length2 - 1] = code;
        dist = 0;
        for (code = 0; code < 16; code++) {
          base_dist[code] = dist;
          for (n = 0; n < 1 << extra_dbits[code]; n++) {
            _dist_code[dist++] = code;
          }
        }
        dist >>= 7;
        for (; code < D_CODES; code++) {
          base_dist[code] = dist << 7;
          for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
            _dist_code[256 + dist++] = code;
          }
        }
        for (bits = 0; bits <= MAX_BITS; bits++) {
          bl_count[bits] = 0;
        }
        n = 0;
        while (n <= 143) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        while (n <= 255) {
          static_ltree[n * 2 + 1] = 9;
          n++;
          bl_count[9]++;
        }
        while (n <= 279) {
          static_ltree[n * 2 + 1] = 7;
          n++;
          bl_count[7]++;
        }
        while (n <= 287) {
          static_ltree[n * 2 + 1] = 8;
          n++;
          bl_count[8]++;
        }
        gen_codes(static_ltree, L_CODES + 1, bl_count);
        for (n = 0; n < D_CODES; n++) {
          static_dtree[n * 2 + 1] = 5;
          static_dtree[n * 2] = bi_reverse(n, 5);
        }
        static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
        static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
        static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
      }
      function init_block(s) {
        var n;
        for (n = 0; n < L_CODES; n++) {
          s.dyn_ltree[n * 2] = 0;
        }
        for (n = 0; n < D_CODES; n++) {
          s.dyn_dtree[n * 2] = 0;
        }
        for (n = 0; n < BL_CODES; n++) {
          s.bl_tree[n * 2] = 0;
        }
        s.dyn_ltree[END_BLOCK * 2] = 1;
        s.opt_len = s.static_len = 0;
        s.last_lit = s.matches = 0;
      }
      function bi_windup(s) {
        if (s.bi_valid > 8) {
          put_short(s, s.bi_buf);
        } else if (s.bi_valid > 0) {
          s.pending_buf[s.pending++] = s.bi_buf;
        }
        s.bi_buf = 0;
        s.bi_valid = 0;
      }
      function copy_block(s, buf, len, header) {
        bi_windup(s);
        if (header) {
          put_short(s, len);
          put_short(s, ~len);
        }
        utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
        s.pending += len;
      }
      function smaller(tree, n, m, depth) {
        var _n2 = n * 2;
        var _m2 = m * 2;
        return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
      }
      function pqdownheap(s, tree, k) {
        var v2 = s.heap[k];
        var j = k << 1;
        while (j <= s.heap_len) {
          if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
            j++;
          }
          if (smaller(tree, v2, s.heap[j], s.depth)) {
            break;
          }
          s.heap[k] = s.heap[j];
          k = j;
          j <<= 1;
        }
        s.heap[k] = v2;
      }
      function compress_block(s, ltree, dtree) {
        var dist;
        var lc;
        var lx = 0;
        var code;
        var extra;
        if (s.last_lit !== 0) {
          do {
            dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
            lc = s.pending_buf[s.l_buf + lx];
            lx++;
            if (dist === 0) {
              send_code(s, lc, ltree);
            } else {
              code = _length_code[lc];
              send_code(s, code + LITERALS + 1, ltree);
              extra = extra_lbits[code];
              if (extra !== 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);
              }
              dist--;
              code = d_code(dist);
              send_code(s, code, dtree);
              extra = extra_dbits[code];
              if (extra !== 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);
              }
            }
          } while (lx < s.last_lit);
        }
        send_code(s, END_BLOCK, ltree);
      }
      function build_tree(s, desc) {
        var tree = desc.dyn_tree;
        var stree = desc.stat_desc.static_tree;
        var has_stree = desc.stat_desc.has_stree;
        var elems = desc.stat_desc.elems;
        var n, m;
        var max_code = -1;
        var node;
        s.heap_len = 0;
        s.heap_max = HEAP_SIZE;
        for (n = 0; n < elems; n++) {
          if (tree[n * 2] !== 0) {
            s.heap[++s.heap_len] = max_code = n;
            s.depth[n] = 0;
          } else {
            tree[n * 2 + 1] = 0;
          }
        }
        while (s.heap_len < 2) {
          node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
          tree[node * 2] = 1;
          s.depth[node] = 0;
          s.opt_len--;
          if (has_stree) {
            s.static_len -= stree[node * 2 + 1];
          }
        }
        desc.max_code = max_code;
        for (n = s.heap_len >> 1; n >= 1; n--) {
          pqdownheap(s, tree, n);
        }
        node = elems;
        do {
          n = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[
            1
            /*SMALLEST*/
          ] = s.heap[s.heap_len--];
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
          m = s.heap[
            1
            /*SMALLEST*/
          ];
          s.heap[--s.heap_max] = n;
          s.heap[--s.heap_max] = m;
          tree[node * 2] = tree[n * 2] + tree[m * 2];
          s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
          tree[n * 2 + 1] = tree[m * 2 + 1] = node;
          s.heap[
            1
            /*SMALLEST*/
          ] = node++;
          pqdownheap(
            s,
            tree,
            1
            /*SMALLEST*/
          );
        } while (s.heap_len >= 2);
        s.heap[--s.heap_max] = s.heap[
          1
          /*SMALLEST*/
        ];
        gen_bitlen(s, desc);
        gen_codes(tree, max_code, s.bl_count);
      }
      function scan_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        tree[(max_code + 1) * 2 + 1] = 65535;
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            s.bl_tree[curlen * 2] += count;
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              s.bl_tree[curlen * 2]++;
            }
            s.bl_tree[REP_3_6 * 2]++;
          } else if (count <= 10) {
            s.bl_tree[REPZ_3_10 * 2]++;
          } else {
            s.bl_tree[REPZ_11_138 * 2]++;
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function send_tree(s, tree, max_code) {
        var n;
        var prevlen = -1;
        var curlen;
        var nextlen = tree[0 * 2 + 1];
        var count = 0;
        var max_count = 7;
        var min_count = 4;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        }
        for (n = 0; n <= max_code; n++) {
          curlen = nextlen;
          nextlen = tree[(n + 1) * 2 + 1];
          if (++count < max_count && curlen === nextlen) {
            continue;
          } else if (count < min_count) {
            do {
              send_code(s, curlen, s.bl_tree);
            } while (--count !== 0);
          } else if (curlen !== 0) {
            if (curlen !== prevlen) {
              send_code(s, curlen, s.bl_tree);
              count--;
            }
            send_code(s, REP_3_6, s.bl_tree);
            send_bits(s, count - 3, 2);
          } else if (count <= 10) {
            send_code(s, REPZ_3_10, s.bl_tree);
            send_bits(s, count - 3, 3);
          } else {
            send_code(s, REPZ_11_138, s.bl_tree);
            send_bits(s, count - 11, 7);
          }
          count = 0;
          prevlen = curlen;
          if (nextlen === 0) {
            max_count = 138;
            min_count = 3;
          } else if (curlen === nextlen) {
            max_count = 6;
            min_count = 3;
          } else {
            max_count = 7;
            min_count = 4;
          }
        }
      }
      function build_bl_tree(s) {
        var max_blindex;
        scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
        scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
        build_tree(s, s.bl_desc);
        for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
          if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
            break;
          }
        }
        s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
        return max_blindex;
      }
      function send_all_trees(s, lcodes, dcodes, blcodes) {
        var rank;
        send_bits(s, lcodes - 257, 5);
        send_bits(s, dcodes - 1, 5);
        send_bits(s, blcodes - 4, 4);
        for (rank = 0; rank < blcodes; rank++) {
          send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
        }
        send_tree(s, s.dyn_ltree, lcodes - 1);
        send_tree(s, s.dyn_dtree, dcodes - 1);
      }
      function detect_data_type(s) {
        var black_mask = 4093624447;
        var n;
        for (n = 0; n <= 31; n++, black_mask >>>= 1) {
          if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
            return Z_BINARY;
          }
        }
        if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
          return Z_TEXT;
        }
        for (n = 32; n < LITERALS; n++) {
          if (s.dyn_ltree[n * 2] !== 0) {
            return Z_TEXT;
          }
        }
        return Z_BINARY;
      }
      var static_init_done = false;
      function _tr_init(s) {
        if (!static_init_done) {
          tr_static_init();
          static_init_done = true;
        }
        s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
        s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
        s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
        s.bi_buf = 0;
        s.bi_valid = 0;
        init_block(s);
      }
      function _tr_stored_block(s, buf, stored_len, last) {
        send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
        copy_block(s, buf, stored_len, true);
      }
      function _tr_align(s) {
        send_bits(s, STATIC_TREES << 1, 3);
        send_code(s, END_BLOCK, static_ltree);
        bi_flush(s);
      }
      function _tr_flush_block(s, buf, stored_len, last) {
        var opt_lenb, static_lenb;
        var max_blindex = 0;
        if (s.level > 0) {
          if (s.strm.data_type === Z_UNKNOWN) {
            s.strm.data_type = detect_data_type(s);
          }
          build_tree(s, s.l_desc);
          build_tree(s, s.d_desc);
          max_blindex = build_bl_tree(s);
          opt_lenb = s.opt_len + 3 + 7 >>> 3;
          static_lenb = s.static_len + 3 + 7 >>> 3;
          if (static_lenb <= opt_lenb) {
            opt_lenb = static_lenb;
          }
        } else {
          opt_lenb = static_lenb = stored_len + 5;
        }
        if (stored_len + 4 <= opt_lenb && buf !== -1) {
          _tr_stored_block(s, buf, stored_len, last);
        } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
          send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
          compress_block(s, static_ltree, static_dtree);
        } else {
          send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
          send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
          compress_block(s, s.dyn_ltree, s.dyn_dtree);
        }
        init_block(s);
        if (last) {
          bi_windup(s);
        }
      }
      function _tr_tally(s, dist, lc) {
        s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
        s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
        s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
        s.last_lit++;
        if (dist === 0) {
          s.dyn_ltree[lc * 2]++;
        } else {
          s.matches++;
          dist--;
          s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
          s.dyn_dtree[d_code(dist) * 2]++;
        }
        return s.last_lit === s.lit_bufsize - 1;
      }
      exports._tr_init = _tr_init;
      exports._tr_stored_block = _tr_stored_block;
      exports._tr_flush_block = _tr_flush_block;
      exports._tr_tally = _tr_tally;
      exports._tr_align = _tr_align;
    }
  });

  // ../../node_modules/pako/lib/zlib/adler32.js
  var require_adler32 = __commonJS({
    "../../node_modules/pako/lib/zlib/adler32.js"(exports, module) {
      "use strict";
      function adler32(adler, buf, len, pos) {
        var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
        while (len !== 0) {
          n = len > 2e3 ? 2e3 : len;
          len -= n;
          do {
            s1 = s1 + buf[pos++] | 0;
            s2 = s2 + s1 | 0;
          } while (--n);
          s1 %= 65521;
          s2 %= 65521;
        }
        return s1 | s2 << 16 | 0;
      }
      module.exports = adler32;
    }
  });

  // ../../node_modules/pako/lib/zlib/crc32.js
  var require_crc32 = __commonJS({
    "../../node_modules/pako/lib/zlib/crc32.js"(exports, module) {
      "use strict";
      function makeTable() {
        var c, table = [];
        for (var n = 0; n < 256; n++) {
          c = n;
          for (var k = 0; k < 8; k++) {
            c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
          }
          table[n] = c;
        }
        return table;
      }
      var crcTable = makeTable();
      function crc32(crc, buf, len, pos) {
        var t = crcTable, end = pos + len;
        crc ^= -1;
        for (var i = pos; i < end; i++) {
          crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
        }
        return crc ^ -1;
      }
      module.exports = crc32;
    }
  });

  // ../../node_modules/pako/lib/zlib/messages.js
  var require_messages = __commonJS({
    "../../node_modules/pako/lib/zlib/messages.js"(exports, module) {
      "use strict";
      module.exports = {
        2: "need dictionary",
        /* Z_NEED_DICT       2  */
        1: "stream end",
        /* Z_STREAM_END      1  */
        0: "",
        /* Z_OK              0  */
        "-1": "file error",
        /* Z_ERRNO         (-1) */
        "-2": "stream error",
        /* Z_STREAM_ERROR  (-2) */
        "-3": "data error",
        /* Z_DATA_ERROR    (-3) */
        "-4": "insufficient memory",
        /* Z_MEM_ERROR     (-4) */
        "-5": "buffer error",
        /* Z_BUF_ERROR     (-5) */
        "-6": "incompatible version"
        /* Z_VERSION_ERROR (-6) */
      };
    }
  });

  // ../../node_modules/pako/lib/zlib/deflate.js
  var require_deflate = __commonJS({
    "../../node_modules/pako/lib/zlib/deflate.js"(exports) {
      "use strict";
      var utils = require_common();
      var trees = require_trees();
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var msg = require_messages();
      var Z_NO_FLUSH = 0;
      var Z_PARTIAL_FLUSH = 1;
      var Z_FULL_FLUSH = 3;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_BUF_ERROR = -5;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_FILTERED = 1;
      var Z_HUFFMAN_ONLY = 2;
      var Z_RLE = 3;
      var Z_FIXED = 4;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_UNKNOWN = 2;
      var Z_DEFLATED = 8;
      var MAX_MEM_LEVEL = 9;
      var MAX_WBITS = 15;
      var DEF_MEM_LEVEL = 8;
      var LENGTH_CODES = 29;
      var LITERALS = 256;
      var L_CODES = LITERALS + 1 + LENGTH_CODES;
      var D_CODES = 30;
      var BL_CODES = 19;
      var HEAP_SIZE = 2 * L_CODES + 1;
      var MAX_BITS = 15;
      var MIN_MATCH = 3;
      var MAX_MATCH = 258;
      var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
      var PRESET_DICT = 32;
      var INIT_STATE = 42;
      var EXTRA_STATE = 69;
      var NAME_STATE = 73;
      var COMMENT_STATE = 91;
      var HCRC_STATE = 103;
      var BUSY_STATE = 113;
      var FINISH_STATE = 666;
      var BS_NEED_MORE = 1;
      var BS_BLOCK_DONE = 2;
      var BS_FINISH_STARTED = 3;
      var BS_FINISH_DONE = 4;
      var OS_CODE = 3;
      function err(strm, errorCode) {
        strm.msg = msg[errorCode];
        return errorCode;
      }
      function rank(f) {
        return (f << 1) - (f > 4 ? 9 : 0);
      }
      function zero3(buf) {
        var len = buf.length;
        while (--len >= 0) {
          buf[len] = 0;
        }
      }
      function flush_pending(strm) {
        var s = strm.state;
        var len = s.pending;
        if (len > strm.avail_out) {
          len = strm.avail_out;
        }
        if (len === 0) {
          return;
        }
        utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
        strm.next_out += len;
        s.pending_out += len;
        strm.total_out += len;
        strm.avail_out -= len;
        s.pending -= len;
        if (s.pending === 0) {
          s.pending_out = 0;
        }
      }
      function flush_block_only(s, last) {
        trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
        s.block_start = s.strstart;
        flush_pending(s.strm);
      }
      function put_byte(s, b) {
        s.pending_buf[s.pending++] = b;
      }
      function putShortMSB(s, b) {
        s.pending_buf[s.pending++] = b >>> 8 & 255;
        s.pending_buf[s.pending++] = b & 255;
      }
      function read_buf(strm, buf, start, size) {
        var len = strm.avail_in;
        if (len > size) {
          len = size;
        }
        if (len === 0) {
          return 0;
        }
        strm.avail_in -= len;
        utils.arraySet(buf, strm.input, strm.next_in, len, start);
        if (strm.state.wrap === 1) {
          strm.adler = adler32(strm.adler, buf, len, start);
        } else if (strm.state.wrap === 2) {
          strm.adler = crc32(strm.adler, buf, len, start);
        }
        strm.next_in += len;
        strm.total_in += len;
        return len;
      }
      function longest_match(s, cur_match) {
        var chain_length = s.max_chain_length;
        var scan = s.strstart;
        var match;
        var len;
        var best_len = s.prev_length;
        var nice_match = s.nice_match;
        var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
        var _win = s.window;
        var wmask = s.w_mask;
        var prev = s.prev;
        var strend = s.strstart + MAX_MATCH;
        var scan_end1 = _win[scan + best_len - 1];
        var scan_end = _win[scan + best_len];
        if (s.prev_length >= s.good_match) {
          chain_length >>= 2;
        }
        if (nice_match > s.lookahead) {
          nice_match = s.lookahead;
        }
        do {
          match = cur_match;
          if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
            continue;
          }
          scan += 2;
          match++;
          do {
          } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
          len = MAX_MATCH - (strend - scan);
          scan = strend - MAX_MATCH;
          if (len > best_len) {
            s.match_start = cur_match;
            best_len = len;
            if (len >= nice_match) {
              break;
            }
            scan_end1 = _win[scan + best_len - 1];
            scan_end = _win[scan + best_len];
          }
        } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
        if (best_len <= s.lookahead) {
          return best_len;
        }
        return s.lookahead;
      }
      function fill_window(s) {
        var _w_size = s.w_size;
        var p, n, m, more, str;
        do {
          more = s.window_size - s.lookahead - s.strstart;
          if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
            s.match_start -= _w_size;
            s.strstart -= _w_size;
            s.block_start -= _w_size;
            n = s.hash_size;
            p = n;
            do {
              m = s.head[--p];
              s.head[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            n = _w_size;
            p = n;
            do {
              m = s.prev[--p];
              s.prev[p] = m >= _w_size ? m - _w_size : 0;
            } while (--n);
            more += _w_size;
          }
          if (s.strm.avail_in === 0) {
            break;
          }
          n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
          s.lookahead += n;
          if (s.lookahead + s.insert >= MIN_MATCH) {
            str = s.strstart - s.insert;
            s.ins_h = s.window[str];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
            while (s.insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
              s.prev[str & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = str;
              str++;
              s.insert--;
              if (s.lookahead + s.insert < MIN_MATCH) {
                break;
              }
            }
          }
        } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
      }
      function deflate_stored(s, flush) {
        var max_block_size = 65535;
        if (max_block_size > s.pending_buf_size - 5) {
          max_block_size = s.pending_buf_size - 5;
        }
        for (; ; ) {
          if (s.lookahead <= 1) {
            fill_window(s);
            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.strstart += s.lookahead;
          s.lookahead = 0;
          var max_start = s.block_start + max_block_size;
          if (s.strstart === 0 || s.strstart >= max_start) {
            s.lookahead = s.strstart - max_start;
            s.strstart = max_start;
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
          if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.strstart > s.block_start) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_NEED_MORE;
      }
      function deflate_fast(s, flush) {
        var hash_head;
        var bflush;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
              s.match_length--;
              do {
                s.strstart++;
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              } while (--s.match_length !== 0);
              s.strstart++;
            } else {
              s.strstart += s.match_length;
              s.match_length = 0;
              s.ins_h = s.window[s.strstart];
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
            }
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_slow(s, flush) {
        var hash_head;
        var bflush;
        var max_insert;
        for (; ; ) {
          if (s.lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          hash_head = 0;
          if (s.lookahead >= MIN_MATCH) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
          s.prev_length = s.match_length;
          s.prev_match = s.match_start;
          s.match_length = MIN_MATCH - 1;
          if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
            s.match_length = longest_match(s, hash_head);
            if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
              s.match_length = MIN_MATCH - 1;
            }
          }
          if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
            max_insert = s.strstart + s.lookahead - MIN_MATCH;
            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
            s.lookahead -= s.prev_length - 1;
            s.prev_length -= 2;
            do {
              if (++s.strstart <= max_insert) {
                s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                s.head[s.ins_h] = s.strstart;
              }
            } while (--s.prev_length !== 0);
            s.match_available = 0;
            s.match_length = MIN_MATCH - 1;
            s.strstart++;
            if (bflush) {
              flush_block_only(s, false);
              if (s.strm.avail_out === 0) {
                return BS_NEED_MORE;
              }
            }
          } else if (s.match_available) {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
            if (bflush) {
              flush_block_only(s, false);
            }
            s.strstart++;
            s.lookahead--;
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          } else {
            s.match_available = 1;
            s.strstart++;
            s.lookahead--;
          }
        }
        if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          s.match_available = 0;
        }
        s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_rle(s, flush) {
        var bflush;
        var prev;
        var scan, strend;
        var _win = s.window;
        for (; ; ) {
          if (s.lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            if (s.lookahead === 0) {
              break;
            }
          }
          s.match_length = 0;
          if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
            scan = s.strstart - 1;
            prev = _win[scan];
            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
              strend = s.strstart + MAX_MATCH;
              do {
              } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
              s.match_length = MAX_MATCH - (strend - scan);
              if (s.match_length > s.lookahead) {
                s.match_length = s.lookahead;
              }
            }
          }
          if (s.match_length >= MIN_MATCH) {
            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
            s.lookahead -= s.match_length;
            s.strstart += s.match_length;
            s.match_length = 0;
          } else {
            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
            s.lookahead--;
            s.strstart++;
          }
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function deflate_huff(s, flush) {
        var bflush;
        for (; ; ) {
          if (s.lookahead === 0) {
            fill_window(s);
            if (s.lookahead === 0) {
              if (flush === Z_NO_FLUSH) {
                return BS_NEED_MORE;
              }
              break;
            }
          }
          s.match_length = 0;
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        }
        s.insert = 0;
        if (flush === Z_FINISH) {
          flush_block_only(s, true);
          if (s.strm.avail_out === 0) {
            return BS_FINISH_STARTED;
          }
          return BS_FINISH_DONE;
        }
        if (s.last_lit) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        return BS_BLOCK_DONE;
      }
      function Config(good_length, max_lazy, nice_length, max_chain, func) {
        this.good_length = good_length;
        this.max_lazy = max_lazy;
        this.nice_length = nice_length;
        this.max_chain = max_chain;
        this.func = func;
      }
      var configuration_table;
      configuration_table = [
        /*      good lazy nice chain */
        new Config(0, 0, 0, 0, deflate_stored),
        /* 0 store only */
        new Config(4, 4, 8, 4, deflate_fast),
        /* 1 max speed, no lazy matches */
        new Config(4, 5, 16, 8, deflate_fast),
        /* 2 */
        new Config(4, 6, 32, 32, deflate_fast),
        /* 3 */
        new Config(4, 4, 16, 16, deflate_slow),
        /* 4 lazy matches */
        new Config(8, 16, 32, 32, deflate_slow),
        /* 5 */
        new Config(8, 16, 128, 128, deflate_slow),
        /* 6 */
        new Config(8, 32, 128, 256, deflate_slow),
        /* 7 */
        new Config(32, 128, 258, 1024, deflate_slow),
        /* 8 */
        new Config(32, 258, 258, 4096, deflate_slow)
        /* 9 max compression */
      ];
      function lm_init(s) {
        s.window_size = 2 * s.w_size;
        zero3(s.head);
        s.max_lazy_match = configuration_table[s.level].max_lazy;
        s.good_match = configuration_table[s.level].good_length;
        s.nice_match = configuration_table[s.level].nice_length;
        s.max_chain_length = configuration_table[s.level].max_chain;
        s.strstart = 0;
        s.block_start = 0;
        s.lookahead = 0;
        s.insert = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        s.ins_h = 0;
      }
      function DeflateState() {
        this.strm = null;
        this.status = 0;
        this.pending_buf = null;
        this.pending_buf_size = 0;
        this.pending_out = 0;
        this.pending = 0;
        this.wrap = 0;
        this.gzhead = null;
        this.gzindex = 0;
        this.method = Z_DEFLATED;
        this.last_flush = -1;
        this.w_size = 0;
        this.w_bits = 0;
        this.w_mask = 0;
        this.window = null;
        this.window_size = 0;
        this.prev = null;
        this.head = null;
        this.ins_h = 0;
        this.hash_size = 0;
        this.hash_bits = 0;
        this.hash_mask = 0;
        this.hash_shift = 0;
        this.block_start = 0;
        this.match_length = 0;
        this.prev_match = 0;
        this.match_available = 0;
        this.strstart = 0;
        this.match_start = 0;
        this.lookahead = 0;
        this.prev_length = 0;
        this.max_chain_length = 0;
        this.max_lazy_match = 0;
        this.level = 0;
        this.strategy = 0;
        this.good_match = 0;
        this.nice_match = 0;
        this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
        this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
        this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
        zero3(this.dyn_ltree);
        zero3(this.dyn_dtree);
        zero3(this.bl_tree);
        this.l_desc = null;
        this.d_desc = null;
        this.bl_desc = null;
        this.bl_count = new utils.Buf16(MAX_BITS + 1);
        this.heap = new utils.Buf16(2 * L_CODES + 1);
        zero3(this.heap);
        this.heap_len = 0;
        this.heap_max = 0;
        this.depth = new utils.Buf16(2 * L_CODES + 1);
        zero3(this.depth);
        this.l_buf = 0;
        this.lit_bufsize = 0;
        this.last_lit = 0;
        this.d_buf = 0;
        this.opt_len = 0;
        this.static_len = 0;
        this.matches = 0;
        this.insert = 0;
        this.bi_buf = 0;
        this.bi_valid = 0;
      }
      function deflateResetKeep(strm) {
        var s;
        if (!strm || !strm.state) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.total_in = strm.total_out = 0;
        strm.data_type = Z_UNKNOWN;
        s = strm.state;
        s.pending = 0;
        s.pending_out = 0;
        if (s.wrap < 0) {
          s.wrap = -s.wrap;
        }
        s.status = s.wrap ? INIT_STATE : BUSY_STATE;
        strm.adler = s.wrap === 2 ? 0 : 1;
        s.last_flush = Z_NO_FLUSH;
        trees._tr_init(s);
        return Z_OK;
      }
      function deflateReset(strm) {
        var ret = deflateResetKeep(strm);
        if (ret === Z_OK) {
          lm_init(strm.state);
        }
        return ret;
      }
      function deflateSetHeader(strm, head) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        if (strm.state.wrap !== 2) {
          return Z_STREAM_ERROR;
        }
        strm.state.gzhead = head;
        return Z_OK;
      }
      function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        var wrap = 1;
        if (level === Z_DEFAULT_COMPRESSION) {
          level = 6;
        }
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else if (windowBits > 15) {
          wrap = 2;
          windowBits -= 16;
        }
        if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
          return err(strm, Z_STREAM_ERROR);
        }
        if (windowBits === 8) {
          windowBits = 9;
        }
        var s = new DeflateState();
        strm.state = s;
        s.strm = strm;
        s.wrap = wrap;
        s.gzhead = null;
        s.w_bits = windowBits;
        s.w_size = 1 << s.w_bits;
        s.w_mask = s.w_size - 1;
        s.hash_bits = memLevel + 7;
        s.hash_size = 1 << s.hash_bits;
        s.hash_mask = s.hash_size - 1;
        s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
        s.window = new utils.Buf8(s.w_size * 2);
        s.head = new utils.Buf16(s.hash_size);
        s.prev = new utils.Buf16(s.w_size);
        s.lit_bufsize = 1 << memLevel + 6;
        s.pending_buf_size = s.lit_bufsize * 4;
        s.pending_buf = new utils.Buf8(s.pending_buf_size);
        s.d_buf = 1 * s.lit_bufsize;
        s.l_buf = (1 + 2) * s.lit_bufsize;
        s.level = level;
        s.strategy = strategy;
        s.method = method;
        return deflateReset(strm);
      }
      function deflateInit(strm, level) {
        return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
      }
      function deflate(strm, flush) {
        var old_flush, s;
        var beg, val;
        if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
          return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
        }
        s = strm.state;
        if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
          return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
        }
        s.strm = strm;
        old_flush = s.last_flush;
        s.last_flush = flush;
        if (s.status === INIT_STATE) {
          if (s.wrap === 2) {
            strm.adler = 0;
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (!s.gzhead) {
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, 0);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, OS_CODE);
              s.status = BUSY_STATE;
            } else {
              put_byte(
                s,
                (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
              );
              put_byte(s, s.gzhead.time & 255);
              put_byte(s, s.gzhead.time >> 8 & 255);
              put_byte(s, s.gzhead.time >> 16 & 255);
              put_byte(s, s.gzhead.time >> 24 & 255);
              put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
              put_byte(s, s.gzhead.os & 255);
              if (s.gzhead.extra && s.gzhead.extra.length) {
                put_byte(s, s.gzhead.extra.length & 255);
                put_byte(s, s.gzhead.extra.length >> 8 & 255);
              }
              if (s.gzhead.hcrc) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
              }
              s.gzindex = 0;
              s.status = EXTRA_STATE;
            }
          } else {
            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
            var level_flags = -1;
            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
              level_flags = 0;
            } else if (s.level < 6) {
              level_flags = 1;
            } else if (s.level === 6) {
              level_flags = 2;
            } else {
              level_flags = 3;
            }
            header |= level_flags << 6;
            if (s.strstart !== 0) {
              header |= PRESET_DICT;
            }
            header += 31 - header % 31;
            s.status = BUSY_STATE;
            putShortMSB(s, header);
            if (s.strstart !== 0) {
              putShortMSB(s, strm.adler >>> 16);
              putShortMSB(s, strm.adler & 65535);
            }
            strm.adler = 1;
          }
        }
        if (s.status === EXTRA_STATE) {
          if (s.gzhead.extra) {
            beg = s.pending;
            while (s.gzindex < (s.gzhead.extra.length & 65535)) {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  break;
                }
              }
              put_byte(s, s.gzhead.extra[s.gzindex] & 255);
              s.gzindex++;
            }
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (s.gzindex === s.gzhead.extra.length) {
              s.gzindex = 0;
              s.status = NAME_STATE;
            }
          } else {
            s.status = NAME_STATE;
          }
        }
        if (s.status === NAME_STATE) {
          if (s.gzhead.name) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.name.length) {
                val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.gzindex = 0;
              s.status = COMMENT_STATE;
            }
          } else {
            s.status = COMMENT_STATE;
          }
        }
        if (s.status === COMMENT_STATE) {
          if (s.gzhead.comment) {
            beg = s.pending;
            do {
              if (s.pending === s.pending_buf_size) {
                if (s.gzhead.hcrc && s.pending > beg) {
                  strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                }
                flush_pending(strm);
                beg = s.pending;
                if (s.pending === s.pending_buf_size) {
                  val = 1;
                  break;
                }
              }
              if (s.gzindex < s.gzhead.comment.length) {
                val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
              } else {
                val = 0;
              }
              put_byte(s, val);
            } while (val !== 0);
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            if (val === 0) {
              s.status = HCRC_STATE;
            }
          } else {
            s.status = HCRC_STATE;
          }
        }
        if (s.status === HCRC_STATE) {
          if (s.gzhead.hcrc) {
            if (s.pending + 2 > s.pending_buf_size) {
              flush_pending(strm);
            }
            if (s.pending + 2 <= s.pending_buf_size) {
              put_byte(s, strm.adler & 255);
              put_byte(s, strm.adler >> 8 & 255);
              strm.adler = 0;
              s.status = BUSY_STATE;
            }
          } else {
            s.status = BUSY_STATE;
          }
        }
        if (s.pending !== 0) {
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
          return err(strm, Z_BUF_ERROR);
        }
        if (s.status === FINISH_STATE && strm.avail_in !== 0) {
          return err(strm, Z_BUF_ERROR);
        }
        if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
          var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
          if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
            s.status = FINISH_STATE;
          }
          if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
            if (strm.avail_out === 0) {
              s.last_flush = -1;
            }
            return Z_OK;
          }
          if (bstate === BS_BLOCK_DONE) {
            if (flush === Z_PARTIAL_FLUSH) {
              trees._tr_align(s);
            } else if (flush !== Z_BLOCK) {
              trees._tr_stored_block(s, 0, 0, false);
              if (flush === Z_FULL_FLUSH) {
                zero3(s.head);
                if (s.lookahead === 0) {
                  s.strstart = 0;
                  s.block_start = 0;
                  s.insert = 0;
                }
              }
            }
            flush_pending(strm);
            if (strm.avail_out === 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
        }
        if (flush !== Z_FINISH) {
          return Z_OK;
        }
        if (s.wrap <= 0) {
          return Z_STREAM_END;
        }
        if (s.wrap === 2) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          put_byte(s, strm.adler >> 16 & 255);
          put_byte(s, strm.adler >> 24 & 255);
          put_byte(s, strm.total_in & 255);
          put_byte(s, strm.total_in >> 8 & 255);
          put_byte(s, strm.total_in >> 16 & 255);
          put_byte(s, strm.total_in >> 24 & 255);
        } else {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        flush_pending(strm);
        if (s.wrap > 0) {
          s.wrap = -s.wrap;
        }
        return s.pending !== 0 ? Z_OK : Z_STREAM_END;
      }
      function deflateEnd(strm) {
        var status;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        status = strm.state.status;
        if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
          return err(strm, Z_STREAM_ERROR);
        }
        strm.state = null;
        return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
      }
      function deflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var s;
        var str, n;
        var wrap;
        var avail;
        var next;
        var input;
        var tmpDict;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        s = strm.state;
        wrap = s.wrap;
        if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
          return Z_STREAM_ERROR;
        }
        if (wrap === 1) {
          strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
        }
        s.wrap = 0;
        if (dictLength >= s.w_size) {
          if (wrap === 0) {
            zero3(s.head);
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
          tmpDict = new utils.Buf8(s.w_size);
          utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
          dictionary = tmpDict;
          dictLength = s.w_size;
        }
        avail = strm.avail_in;
        next = strm.next_in;
        input = strm.input;
        strm.avail_in = dictLength;
        strm.next_in = 0;
        strm.input = dictionary;
        fill_window(s);
        while (s.lookahead >= MIN_MATCH) {
          str = s.strstart;
          n = s.lookahead - (MIN_MATCH - 1);
          do {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
          } while (--n);
          s.strstart = str;
          s.lookahead = MIN_MATCH - 1;
          fill_window(s);
        }
        s.strstart += s.lookahead;
        s.block_start = s.strstart;
        s.insert = s.lookahead;
        s.lookahead = 0;
        s.match_length = s.prev_length = MIN_MATCH - 1;
        s.match_available = 0;
        strm.next_in = next;
        strm.input = input;
        strm.avail_in = avail;
        s.wrap = wrap;
        return Z_OK;
      }
      exports.deflateInit = deflateInit;
      exports.deflateInit2 = deflateInit2;
      exports.deflateReset = deflateReset;
      exports.deflateResetKeep = deflateResetKeep;
      exports.deflateSetHeader = deflateSetHeader;
      exports.deflate = deflate;
      exports.deflateEnd = deflateEnd;
      exports.deflateSetDictionary = deflateSetDictionary;
      exports.deflateInfo = "pako deflate (from Nodeca project)";
    }
  });

  // ../../node_modules/pako/lib/utils/strings.js
  var require_strings = __commonJS({
    "../../node_modules/pako/lib/utils/strings.js"(exports) {
      "use strict";
      var utils = require_common();
      var STR_APPLY_OK = true;
      var STR_APPLY_UIA_OK = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (__) {
        STR_APPLY_OK = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (__) {
        STR_APPLY_UIA_OK = false;
      }
      var _utf8len = new utils.Buf8(256);
      for (q = 0; q < 256; q++) {
        _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
      }
      var q;
      _utf8len[254] = _utf8len[254] = 1;
      exports.string2buf = function(str) {
        var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
        for (m_pos = 0; m_pos < str_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
        }
        buf = new utils.Buf8(buf_len);
        for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
          c = str.charCodeAt(m_pos);
          if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
            c2 = str.charCodeAt(m_pos + 1);
            if ((c2 & 64512) === 56320) {
              c = 65536 + (c - 55296 << 10) + (c2 - 56320);
              m_pos++;
            }
          }
          if (c < 128) {
            buf[i++] = c;
          } else if (c < 2048) {
            buf[i++] = 192 | c >>> 6;
            buf[i++] = 128 | c & 63;
          } else if (c < 65536) {
            buf[i++] = 224 | c >>> 12;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          } else {
            buf[i++] = 240 | c >>> 18;
            buf[i++] = 128 | c >>> 12 & 63;
            buf[i++] = 128 | c >>> 6 & 63;
            buf[i++] = 128 | c & 63;
          }
        }
        return buf;
      };
      function buf2binstring(buf, len) {
        if (len < 65534) {
          if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
            return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
          }
        }
        var result = "";
        for (var i = 0; i < len; i++) {
          result += String.fromCharCode(buf[i]);
        }
        return result;
      }
      exports.buf2binstring = function(buf) {
        return buf2binstring(buf, buf.length);
      };
      exports.binstring2buf = function(str) {
        var buf = new utils.Buf8(str.length);
        for (var i = 0, len = buf.length; i < len; i++) {
          buf[i] = str.charCodeAt(i);
        }
        return buf;
      };
      exports.buf2string = function(buf, max2) {
        var i, out, c, c_len;
        var len = max2 || buf.length;
        var utf16buf = new Array(len * 2);
        for (out = 0, i = 0; i < len; ) {
          c = buf[i++];
          if (c < 128) {
            utf16buf[out++] = c;
            continue;
          }
          c_len = _utf8len[c];
          if (c_len > 4) {
            utf16buf[out++] = 65533;
            i += c_len - 1;
            continue;
          }
          c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
          while (c_len > 1 && i < len) {
            c = c << 6 | buf[i++] & 63;
            c_len--;
          }
          if (c_len > 1) {
            utf16buf[out++] = 65533;
            continue;
          }
          if (c < 65536) {
            utf16buf[out++] = c;
          } else {
            c -= 65536;
            utf16buf[out++] = 55296 | c >> 10 & 1023;
            utf16buf[out++] = 56320 | c & 1023;
          }
        }
        return buf2binstring(utf16buf, out);
      };
      exports.utf8border = function(buf, max2) {
        var pos;
        max2 = max2 || buf.length;
        if (max2 > buf.length) {
          max2 = buf.length;
        }
        pos = max2 - 1;
        while (pos >= 0 && (buf[pos] & 192) === 128) {
          pos--;
        }
        if (pos < 0) {
          return max2;
        }
        if (pos === 0) {
          return max2;
        }
        return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
      };
    }
  });

  // ../../node_modules/pako/lib/zlib/zstream.js
  var require_zstream = __commonJS({
    "../../node_modules/pako/lib/zlib/zstream.js"(exports, module) {
      "use strict";
      function ZStream() {
        this.input = null;
        this.next_in = 0;
        this.avail_in = 0;
        this.total_in = 0;
        this.output = null;
        this.next_out = 0;
        this.avail_out = 0;
        this.total_out = 0;
        this.msg = "";
        this.state = null;
        this.data_type = 2;
        this.adler = 0;
      }
      module.exports = ZStream;
    }
  });

  // ../../node_modules/pako/lib/deflate.js
  var require_deflate2 = __commonJS({
    "../../node_modules/pako/lib/deflate.js"(exports) {
      "use strict";
      var zlib_deflate = require_deflate();
      var utils = require_common();
      var strings = require_strings();
      var msg = require_messages();
      var ZStream = require_zstream();
      var toString = Object.prototype.toString;
      var Z_NO_FLUSH = 0;
      var Z_FINISH = 4;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_SYNC_FLUSH = 2;
      var Z_DEFAULT_COMPRESSION = -1;
      var Z_DEFAULT_STRATEGY = 0;
      var Z_DEFLATED = 8;
      function Deflate(options) {
        if (!(this instanceof Deflate))
          return new Deflate(options);
        this.options = utils.assign({
          level: Z_DEFAULT_COMPRESSION,
          method: Z_DEFLATED,
          chunkSize: 16384,
          windowBits: 15,
          memLevel: 8,
          strategy: Z_DEFAULT_STRATEGY,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits > 0) {
          opt.windowBits = -opt.windowBits;
        } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
          opt.windowBits += 16;
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_deflate.deflateInit2(
          this.strm,
          opt.level,
          opt.method,
          opt.windowBits,
          opt.memLevel,
          opt.strategy
        );
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        if (opt.header) {
          zlib_deflate.deflateSetHeader(this.strm, opt.header);
        }
        if (opt.dictionary) {
          var dict;
          if (typeof opt.dictionary === "string") {
            dict = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            dict = new Uint8Array(opt.dictionary);
          } else {
            dict = opt.dictionary;
          }
          status = zlib_deflate.deflateSetDictionary(this.strm, dict);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
          this._dict_set = true;
        }
      }
      Deflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var status, _mode;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.string2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_deflate.deflate(strm, _mode);
          if (status !== Z_STREAM_END && status !== Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
        if (_mode === Z_FINISH) {
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (_mode === Z_SYNC_FLUSH) {
          this.onEnd(Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Deflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Deflate.prototype.onEnd = function(status) {
        if (status === Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function deflate(input, options) {
        var deflator = new Deflate(options);
        deflator.push(input, true);
        if (deflator.err) {
          throw deflator.msg || msg[deflator.err];
        }
        return deflator.result;
      }
      function deflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return deflate(input, options);
      }
      function gzip(input, options) {
        options = options || {};
        options.gzip = true;
        return deflate(input, options);
      }
      exports.Deflate = Deflate;
      exports.deflate = deflate;
      exports.deflateRaw = deflateRaw;
      exports.gzip = gzip;
    }
  });

  // ../../node_modules/pako/lib/zlib/inffast.js
  var require_inffast = __commonJS({
    "../../node_modules/pako/lib/zlib/inffast.js"(exports, module) {
      "use strict";
      var BAD = 30;
      var TYPE = 12;
      module.exports = function inflate_fast(strm, start) {
        var state;
        var _in;
        var last;
        var _out;
        var beg;
        var end;
        var dmax;
        var wsize;
        var whave;
        var wnext;
        var s_window;
        var hold;
        var bits;
        var lcode;
        var dcode;
        var lmask;
        var dmask;
        var here;
        var op;
        var len;
        var dist;
        var from;
        var from_source;
        var input, output;
        state = strm.state;
        _in = strm.next_in;
        input = strm.input;
        last = _in + (strm.avail_in - 5);
        _out = strm.next_out;
        output = strm.output;
        beg = _out - (start - strm.avail_out);
        end = _out + (strm.avail_out - 257);
        dmax = state.dmax;
        wsize = state.wsize;
        whave = state.whave;
        wnext = state.wnext;
        s_window = state.window;
        hold = state.hold;
        bits = state.bits;
        lcode = state.lencode;
        dcode = state.distcode;
        lmask = (1 << state.lenbits) - 1;
        dmask = (1 << state.distbits) - 1;
        top:
          do {
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = lcode[hold & lmask];
            dolen:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op === 0) {
                  output[_out++] = here & 65535;
                } else if (op & 16) {
                  len = here & 65535;
                  op &= 15;
                  if (op) {
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                    len += hold & (1 << op) - 1;
                    hold >>>= op;
                    bits -= op;
                  }
                  if (bits < 15) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  here = dcode[hold & dmask];
                  dodist:
                    for (; ; ) {
                      op = here >>> 24;
                      hold >>>= op;
                      bits -= op;
                      op = here >>> 16 & 255;
                      if (op & 16) {
                        dist = here & 65535;
                        op &= 15;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                          if (bits < op) {
                            hold += input[_in++] << bits;
                            bits += 8;
                          }
                        }
                        dist += hold & (1 << op) - 1;
                        if (dist > dmax) {
                          strm.msg = "invalid distance too far back";
                          state.mode = BAD;
                          break top;
                        }
                        hold >>>= op;
                        bits -= op;
                        op = _out - beg;
                        if (dist > op) {
                          op = dist - op;
                          if (op > whave) {
                            if (state.sane) {
                              strm.msg = "invalid distance too far back";
                              state.mode = BAD;
                              break top;
                            }
                          }
                          from = 0;
                          from_source = s_window;
                          if (wnext === 0) {
                            from += wsize - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          } else if (wnext < op) {
                            from += wsize + wnext - op;
                            op -= wnext;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = 0;
                              if (wnext < len) {
                                op = wnext;
                                len -= op;
                                do {
                                  output[_out++] = s_window[from++];
                                } while (--op);
                                from = _out - dist;
                                from_source = output;
                              }
                            }
                          } else {
                            from += wnext - op;
                            if (op < len) {
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                          while (len > 2) {
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            output[_out++] = from_source[from++];
                            len -= 3;
                          }
                          if (len) {
                            output[_out++] = from_source[from++];
                            if (len > 1) {
                              output[_out++] = from_source[from++];
                            }
                          }
                        } else {
                          from = _out - dist;
                          do {
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            output[_out++] = output[from++];
                            len -= 3;
                          } while (len > 2);
                          if (len) {
                            output[_out++] = output[from++];
                            if (len > 1) {
                              output[_out++] = output[from++];
                            }
                          }
                        }
                      } else if ((op & 64) === 0) {
                        here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                        continue dodist;
                      } else {
                        strm.msg = "invalid distance code";
                        state.mode = BAD;
                        break top;
                      }
                      break;
                    }
                } else if ((op & 64) === 0) {
                  here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dolen;
                } else if (op & 32) {
                  state.mode = TYPE;
                  break top;
                } else {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } while (_in < last && _out < end);
        len = bits >> 3;
        _in -= len;
        bits -= len << 3;
        hold &= (1 << bits) - 1;
        strm.next_in = _in;
        strm.next_out = _out;
        strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
        strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
        state.hold = hold;
        state.bits = bits;
        return;
      };
    }
  });

  // ../../node_modules/pako/lib/zlib/inftrees.js
  var require_inftrees = __commonJS({
    "../../node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
      "use strict";
      var utils = require_common();
      var MAXBITS = 15;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var lbase = [
        /* Length codes 257..285 base */
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        13,
        15,
        17,
        19,
        23,
        27,
        31,
        35,
        43,
        51,
        59,
        67,
        83,
        99,
        115,
        131,
        163,
        195,
        227,
        258,
        0,
        0
      ];
      var lext = [
        /* Length codes 257..285 extra */
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        16,
        17,
        17,
        17,
        17,
        18,
        18,
        18,
        18,
        19,
        19,
        19,
        19,
        20,
        20,
        20,
        20,
        21,
        21,
        21,
        21,
        16,
        72,
        78
      ];
      var dbase = [
        /* Distance codes 0..29 base */
        1,
        2,
        3,
        4,
        5,
        7,
        9,
        13,
        17,
        25,
        33,
        49,
        65,
        97,
        129,
        193,
        257,
        385,
        513,
        769,
        1025,
        1537,
        2049,
        3073,
        4097,
        6145,
        8193,
        12289,
        16385,
        24577,
        0,
        0
      ];
      var dext = [
        /* Distance codes 0..29 extra */
        16,
        16,
        16,
        16,
        17,
        17,
        18,
        18,
        19,
        19,
        20,
        20,
        21,
        21,
        22,
        22,
        23,
        23,
        24,
        24,
        25,
        25,
        26,
        26,
        27,
        27,
        28,
        28,
        29,
        29,
        64,
        64
      ];
      module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
        var bits = opts.bits;
        var len = 0;
        var sym = 0;
        var min2 = 0, max2 = 0;
        var root = 0;
        var curr = 0;
        var drop = 0;
        var left = 0;
        var used = 0;
        var huff = 0;
        var incr;
        var fill;
        var low;
        var mask;
        var next;
        var base = null;
        var base_index = 0;
        var end;
        var count = new utils.Buf16(MAXBITS + 1);
        var offs = new utils.Buf16(MAXBITS + 1);
        var extra = null;
        var extra_index = 0;
        var here_bits, here_op, here_val;
        for (len = 0; len <= MAXBITS; len++) {
          count[len] = 0;
        }
        for (sym = 0; sym < codes; sym++) {
          count[lens[lens_index + sym]]++;
        }
        root = bits;
        for (max2 = MAXBITS; max2 >= 1; max2--) {
          if (count[max2] !== 0) {
            break;
          }
        }
        if (root > max2) {
          root = max2;
        }
        if (max2 === 0) {
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          table[table_index++] = 1 << 24 | 64 << 16 | 0;
          opts.bits = 1;
          return 0;
        }
        for (min2 = 1; min2 < max2; min2++) {
          if (count[min2] !== 0) {
            break;
          }
        }
        if (root < min2) {
          root = min2;
        }
        left = 1;
        for (len = 1; len <= MAXBITS; len++) {
          left <<= 1;
          left -= count[len];
          if (left < 0) {
            return -1;
          }
        }
        if (left > 0 && (type === CODES || max2 !== 1)) {
          return -1;
        }
        offs[1] = 0;
        for (len = 1; len < MAXBITS; len++) {
          offs[len + 1] = offs[len] + count[len];
        }
        for (sym = 0; sym < codes; sym++) {
          if (lens[lens_index + sym] !== 0) {
            work[offs[lens[lens_index + sym]]++] = sym;
          }
        }
        if (type === CODES) {
          base = extra = work;
          end = 19;
        } else if (type === LENS) {
          base = lbase;
          base_index -= 257;
          extra = lext;
          extra_index -= 257;
          end = 256;
        } else {
          base = dbase;
          extra = dext;
          end = -1;
        }
        huff = 0;
        sym = 0;
        len = min2;
        next = table_index;
        curr = root;
        drop = 0;
        low = -1;
        used = 1 << root;
        mask = used - 1;
        if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        for (; ; ) {
          here_bits = len - drop;
          if (work[sym] < end) {
            here_op = 0;
            here_val = work[sym];
          } else if (work[sym] > end) {
            here_op = extra[extra_index + work[sym]];
            here_val = base[base_index + work[sym]];
          } else {
            here_op = 32 + 64;
            here_val = 0;
          }
          incr = 1 << len - drop;
          fill = 1 << curr;
          min2 = fill;
          do {
            fill -= incr;
            table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
          } while (fill !== 0);
          incr = 1 << len - 1;
          while (huff & incr) {
            incr >>= 1;
          }
          if (incr !== 0) {
            huff &= incr - 1;
            huff += incr;
          } else {
            huff = 0;
          }
          sym++;
          if (--count[len] === 0) {
            if (len === max2) {
              break;
            }
            len = lens[lens_index + work[sym]];
          }
          if (len > root && (huff & mask) !== low) {
            if (drop === 0) {
              drop = root;
            }
            next += min2;
            curr = len - drop;
            left = 1 << curr;
            while (curr + drop < max2) {
              left -= count[curr + drop];
              if (left <= 0) {
                break;
              }
              curr++;
              left <<= 1;
            }
            used += 1 << curr;
            if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
              return 1;
            }
            low = huff & mask;
            table[low] = root << 24 | curr << 16 | next - table_index | 0;
          }
        }
        if (huff !== 0) {
          table[next + huff] = len - drop << 24 | 64 << 16 | 0;
        }
        opts.bits = root;
        return 0;
      };
    }
  });

  // ../../node_modules/pako/lib/zlib/inflate.js
  var require_inflate = __commonJS({
    "../../node_modules/pako/lib/zlib/inflate.js"(exports) {
      "use strict";
      var utils = require_common();
      var adler32 = require_adler32();
      var crc32 = require_crc32();
      var inflate_fast = require_inffast();
      var inflate_table = require_inftrees();
      var CODES = 0;
      var LENS = 1;
      var DISTS = 2;
      var Z_FINISH = 4;
      var Z_BLOCK = 5;
      var Z_TREES = 6;
      var Z_OK = 0;
      var Z_STREAM_END = 1;
      var Z_NEED_DICT = 2;
      var Z_STREAM_ERROR = -2;
      var Z_DATA_ERROR = -3;
      var Z_MEM_ERROR = -4;
      var Z_BUF_ERROR = -5;
      var Z_DEFLATED = 8;
      var HEAD = 1;
      var FLAGS = 2;
      var TIME = 3;
      var OS = 4;
      var EXLEN = 5;
      var EXTRA = 6;
      var NAME = 7;
      var COMMENT = 8;
      var HCRC = 9;
      var DICTID = 10;
      var DICT = 11;
      var TYPE = 12;
      var TYPEDO = 13;
      var STORED = 14;
      var COPY_ = 15;
      var COPY = 16;
      var TABLE = 17;
      var LENLENS = 18;
      var CODELENS = 19;
      var LEN_ = 20;
      var LEN = 21;
      var LENEXT = 22;
      var DIST = 23;
      var DISTEXT = 24;
      var MATCH = 25;
      var LIT = 26;
      var CHECK = 27;
      var LENGTH = 28;
      var DONE = 29;
      var BAD = 30;
      var MEM = 31;
      var SYNC = 32;
      var ENOUGH_LENS = 852;
      var ENOUGH_DISTS = 592;
      var MAX_WBITS = 15;
      var DEF_WBITS = MAX_WBITS;
      function zswap32(q) {
        return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
      }
      function InflateState() {
        this.mode = 0;
        this.last = false;
        this.wrap = 0;
        this.havedict = false;
        this.flags = 0;
        this.dmax = 0;
        this.check = 0;
        this.total = 0;
        this.head = null;
        this.wbits = 0;
        this.wsize = 0;
        this.whave = 0;
        this.wnext = 0;
        this.window = null;
        this.hold = 0;
        this.bits = 0;
        this.length = 0;
        this.offset = 0;
        this.extra = 0;
        this.lencode = null;
        this.distcode = null;
        this.lenbits = 0;
        this.distbits = 0;
        this.ncode = 0;
        this.nlen = 0;
        this.ndist = 0;
        this.have = 0;
        this.next = null;
        this.lens = new utils.Buf16(320);
        this.work = new utils.Buf16(288);
        this.lendyn = null;
        this.distdyn = null;
        this.sane = 0;
        this.back = 0;
        this.was = 0;
      }
      function inflateResetKeep(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        strm.total_in = strm.total_out = state.total = 0;
        strm.msg = "";
        if (state.wrap) {
          strm.adler = state.wrap & 1;
        }
        state.mode = HEAD;
        state.last = 0;
        state.havedict = 0;
        state.dmax = 32768;
        state.head = null;
        state.hold = 0;
        state.bits = 0;
        state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
        state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
        state.sane = 1;
        state.back = -1;
        return Z_OK;
      }
      function inflateReset(strm) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        state.wsize = 0;
        state.whave = 0;
        state.wnext = 0;
        return inflateResetKeep(strm);
      }
      function inflateReset2(strm, windowBits) {
        var wrap;
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (windowBits < 0) {
          wrap = 0;
          windowBits = -windowBits;
        } else {
          wrap = (windowBits >> 4) + 1;
          if (windowBits < 48) {
            windowBits &= 15;
          }
        }
        if (windowBits && (windowBits < 8 || windowBits > 15)) {
          return Z_STREAM_ERROR;
        }
        if (state.window !== null && state.wbits !== windowBits) {
          state.window = null;
        }
        state.wrap = wrap;
        state.wbits = windowBits;
        return inflateReset(strm);
      }
      function inflateInit2(strm, windowBits) {
        var ret;
        var state;
        if (!strm) {
          return Z_STREAM_ERROR;
        }
        state = new InflateState();
        strm.state = state;
        state.window = null;
        ret = inflateReset2(strm, windowBits);
        if (ret !== Z_OK) {
          strm.state = null;
        }
        return ret;
      }
      function inflateInit(strm) {
        return inflateInit2(strm, DEF_WBITS);
      }
      var virgin = true;
      var lenfix;
      var distfix;
      function fixedtables(state) {
        if (virgin) {
          var sym;
          lenfix = new utils.Buf32(512);
          distfix = new utils.Buf32(32);
          sym = 0;
          while (sym < 144) {
            state.lens[sym++] = 8;
          }
          while (sym < 256) {
            state.lens[sym++] = 9;
          }
          while (sym < 280) {
            state.lens[sym++] = 7;
          }
          while (sym < 288) {
            state.lens[sym++] = 8;
          }
          inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
          sym = 0;
          while (sym < 32) {
            state.lens[sym++] = 5;
          }
          inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
          virgin = false;
        }
        state.lencode = lenfix;
        state.lenbits = 9;
        state.distcode = distfix;
        state.distbits = 5;
      }
      function updatewindow(strm, src, end, copy3) {
        var dist;
        var state = strm.state;
        if (state.window === null) {
          state.wsize = 1 << state.wbits;
          state.wnext = 0;
          state.whave = 0;
          state.window = new utils.Buf8(state.wsize);
        }
        if (copy3 >= state.wsize) {
          utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
          state.wnext = 0;
          state.whave = state.wsize;
        } else {
          dist = state.wsize - state.wnext;
          if (dist > copy3) {
            dist = copy3;
          }
          utils.arraySet(state.window, src, end - copy3, dist, state.wnext);
          copy3 -= dist;
          if (copy3) {
            utils.arraySet(state.window, src, end - copy3, copy3, 0);
            state.wnext = copy3;
            state.whave = state.wsize;
          } else {
            state.wnext += dist;
            if (state.wnext === state.wsize) {
              state.wnext = 0;
            }
            if (state.whave < state.wsize) {
              state.whave += dist;
            }
          }
        }
        return 0;
      }
      function inflate(strm, flush) {
        var state;
        var input, output;
        var next;
        var put;
        var have, left;
        var hold;
        var bits;
        var _in, _out;
        var copy3;
        var from;
        var from_source;
        var here = 0;
        var here_bits, here_op, here_val;
        var last_bits, last_op, last_val;
        var len;
        var ret;
        var hbuf = new utils.Buf8(4);
        var opts;
        var n;
        var order = (
          /* permutation of code lengths */
          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
        );
        if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.mode === TYPE) {
          state.mode = TYPEDO;
        }
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        _in = have;
        _out = left;
        ret = Z_OK;
        inf_leave:
          for (; ; ) {
            switch (state.mode) {
              case HEAD:
                if (state.wrap === 0) {
                  state.mode = TYPEDO;
                  break;
                }
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 2 && hold === 35615) {
                  state.check = 0;
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                  hold = 0;
                  bits = 0;
                  state.mode = FLAGS;
                  break;
                }
                state.flags = 0;
                if (state.head) {
                  state.head.done = false;
                }
                if (!(state.wrap & 1) || /* check if zlib header allowed */
                (((hold & 255) << 8) + (hold >> 8)) % 31) {
                  strm.msg = "incorrect header check";
                  state.mode = BAD;
                  break;
                }
                if ((hold & 15) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                hold >>>= 4;
                bits -= 4;
                len = (hold & 15) + 8;
                if (state.wbits === 0) {
                  state.wbits = len;
                } else if (len > state.wbits) {
                  strm.msg = "invalid window size";
                  state.mode = BAD;
                  break;
                }
                state.dmax = 1 << len;
                strm.adler = state.check = 1;
                state.mode = hold & 512 ? DICTID : TYPE;
                hold = 0;
                bits = 0;
                break;
              case FLAGS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.flags = hold;
                if ((state.flags & 255) !== Z_DEFLATED) {
                  strm.msg = "unknown compression method";
                  state.mode = BAD;
                  break;
                }
                if (state.flags & 57344) {
                  strm.msg = "unknown header flags set";
                  state.mode = BAD;
                  break;
                }
                if (state.head) {
                  state.head.text = hold >> 8 & 1;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = TIME;
              case TIME:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.time = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  hbuf[2] = hold >>> 16 & 255;
                  hbuf[3] = hold >>> 24 & 255;
                  state.check = crc32(state.check, hbuf, 4, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = OS;
              case OS:
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.head) {
                  state.head.xflags = hold & 255;
                  state.head.os = hold >> 8;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
                state.mode = EXLEN;
              case EXLEN:
                if (state.flags & 1024) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length = hold;
                  if (state.head) {
                    state.head.extra_len = hold;
                  }
                  if (state.flags & 512) {
                    hbuf[0] = hold & 255;
                    hbuf[1] = hold >>> 8 & 255;
                    state.check = crc32(state.check, hbuf, 2, 0);
                  }
                  hold = 0;
                  bits = 0;
                } else if (state.head) {
                  state.head.extra = null;
                }
                state.mode = EXTRA;
              case EXTRA:
                if (state.flags & 1024) {
                  copy3 = state.length;
                  if (copy3 > have) {
                    copy3 = have;
                  }
                  if (copy3) {
                    if (state.head) {
                      len = state.head.extra_len - state.length;
                      if (!state.head.extra) {
                        state.head.extra = new Array(state.head.extra_len);
                      }
                      utils.arraySet(
                        state.head.extra,
                        input,
                        next,
                        // extra field is limited to 65536 bytes
                        // - no need for additional size check
                        copy3,
                        /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                        len
                      );
                    }
                    if (state.flags & 512) {
                      state.check = crc32(state.check, input, copy3, next);
                    }
                    have -= copy3;
                    next += copy3;
                    state.length -= copy3;
                  }
                  if (state.length) {
                    break inf_leave;
                  }
                }
                state.length = 0;
                state.mode = NAME;
              case NAME:
                if (state.flags & 2048) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy3 = 0;
                  do {
                    len = input[next + copy3++];
                    if (state.head && len && state.length < 65536) {
                      state.head.name += String.fromCharCode(len);
                    }
                  } while (len && copy3 < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy3, next);
                  }
                  have -= copy3;
                  next += copy3;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.name = null;
                }
                state.length = 0;
                state.mode = COMMENT;
              case COMMENT:
                if (state.flags & 4096) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  copy3 = 0;
                  do {
                    len = input[next + copy3++];
                    if (state.head && len && state.length < 65536) {
                      state.head.comment += String.fromCharCode(len);
                    }
                  } while (len && copy3 < have);
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy3, next);
                  }
                  have -= copy3;
                  next += copy3;
                  if (len) {
                    break inf_leave;
                  }
                } else if (state.head) {
                  state.head.comment = null;
                }
                state.mode = HCRC;
              case HCRC:
                if (state.flags & 512) {
                  while (bits < 16) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.check & 65535)) {
                    strm.msg = "header crc mismatch";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                if (state.head) {
                  state.head.hcrc = state.flags >> 9 & 1;
                  state.head.done = true;
                }
                strm.adler = state.check = 0;
                state.mode = TYPE;
                break;
              case DICTID:
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                strm.adler = state.check = zswap32(hold);
                hold = 0;
                bits = 0;
                state.mode = DICT;
              case DICT:
                if (state.havedict === 0) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  return Z_NEED_DICT;
                }
                strm.adler = state.check = 1;
                state.mode = TYPE;
              case TYPE:
                if (flush === Z_BLOCK || flush === Z_TREES) {
                  break inf_leave;
                }
              case TYPEDO:
                if (state.last) {
                  hold >>>= bits & 7;
                  bits -= bits & 7;
                  state.mode = CHECK;
                  break;
                }
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.last = hold & 1;
                hold >>>= 1;
                bits -= 1;
                switch (hold & 3) {
                  case 0:
                    state.mode = STORED;
                    break;
                  case 1:
                    fixedtables(state);
                    state.mode = LEN_;
                    if (flush === Z_TREES) {
                      hold >>>= 2;
                      bits -= 2;
                      break inf_leave;
                    }
                    break;
                  case 2:
                    state.mode = TABLE;
                    break;
                  case 3:
                    strm.msg = "invalid block type";
                    state.mode = BAD;
                }
                hold >>>= 2;
                bits -= 2;
                break;
              case STORED:
                hold >>>= bits & 7;
                bits -= bits & 7;
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                  strm.msg = "invalid stored block lengths";
                  state.mode = BAD;
                  break;
                }
                state.length = hold & 65535;
                hold = 0;
                bits = 0;
                state.mode = COPY_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case COPY_:
                state.mode = COPY;
              case COPY:
                copy3 = state.length;
                if (copy3) {
                  if (copy3 > have) {
                    copy3 = have;
                  }
                  if (copy3 > left) {
                    copy3 = left;
                  }
                  if (copy3 === 0) {
                    break inf_leave;
                  }
                  utils.arraySet(output, input, next, copy3, put);
                  have -= copy3;
                  next += copy3;
                  left -= copy3;
                  put += copy3;
                  state.length -= copy3;
                  break;
                }
                state.mode = TYPE;
                break;
              case TABLE:
                while (bits < 14) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.nlen = (hold & 31) + 257;
                hold >>>= 5;
                bits -= 5;
                state.ndist = (hold & 31) + 1;
                hold >>>= 5;
                bits -= 5;
                state.ncode = (hold & 15) + 4;
                hold >>>= 4;
                bits -= 4;
                if (state.nlen > 286 || state.ndist > 30) {
                  strm.msg = "too many length or distance symbols";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = LENLENS;
              case LENLENS:
                while (state.have < state.ncode) {
                  while (bits < 3) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.lens[order[state.have++]] = hold & 7;
                  hold >>>= 3;
                  bits -= 3;
                }
                while (state.have < 19) {
                  state.lens[order[state.have++]] = 0;
                }
                state.lencode = state.lendyn;
                state.lenbits = 7;
                opts = { bits: state.lenbits };
                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid code lengths set";
                  state.mode = BAD;
                  break;
                }
                state.have = 0;
                state.mode = CODELENS;
              case CODELENS:
                while (state.have < state.nlen + state.ndist) {
                  for (; ; ) {
                    here = state.lencode[hold & (1 << state.lenbits) - 1];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (here_val < 16) {
                    hold >>>= here_bits;
                    bits -= here_bits;
                    state.lens[state.have++] = here_val;
                  } else {
                    if (here_val === 16) {
                      n = here_bits + 2;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      if (state.have === 0) {
                        strm.msg = "invalid bit length repeat";
                        state.mode = BAD;
                        break;
                      }
                      len = state.lens[state.have - 1];
                      copy3 = 3 + (hold & 3);
                      hold >>>= 2;
                      bits -= 2;
                    } else if (here_val === 17) {
                      n = here_bits + 3;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy3 = 3 + (hold & 7);
                      hold >>>= 3;
                      bits -= 3;
                    } else {
                      n = here_bits + 7;
                      while (bits < n) {
                        if (have === 0) {
                          break inf_leave;
                        }
                        have--;
                        hold += input[next++] << bits;
                        bits += 8;
                      }
                      hold >>>= here_bits;
                      bits -= here_bits;
                      len = 0;
                      copy3 = 11 + (hold & 127);
                      hold >>>= 7;
                      bits -= 7;
                    }
                    if (state.have + copy3 > state.nlen + state.ndist) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    while (copy3--) {
                      state.lens[state.have++] = len;
                    }
                  }
                }
                if (state.mode === BAD) {
                  break;
                }
                if (state.lens[256] === 0) {
                  strm.msg = "invalid code -- missing end-of-block";
                  state.mode = BAD;
                  break;
                }
                state.lenbits = 9;
                opts = { bits: state.lenbits };
                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                state.lenbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid literal/lengths set";
                  state.mode = BAD;
                  break;
                }
                state.distbits = 6;
                state.distcode = state.distdyn;
                opts = { bits: state.distbits };
                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                state.distbits = opts.bits;
                if (ret) {
                  strm.msg = "invalid distances set";
                  state.mode = BAD;
                  break;
                }
                state.mode = LEN_;
                if (flush === Z_TREES) {
                  break inf_leave;
                }
              case LEN_:
                state.mode = LEN;
              case LEN:
                if (have >= 6 && left >= 258) {
                  strm.next_out = put;
                  strm.avail_out = left;
                  strm.next_in = next;
                  strm.avail_in = have;
                  state.hold = hold;
                  state.bits = bits;
                  inflate_fast(strm, _out);
                  put = strm.next_out;
                  output = strm.output;
                  left = strm.avail_out;
                  next = strm.next_in;
                  input = strm.input;
                  have = strm.avail_in;
                  hold = state.hold;
                  bits = state.bits;
                  if (state.mode === TYPE) {
                    state.back = -1;
                  }
                  break;
                }
                state.back = 0;
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_op && (here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                state.length = here_val;
                if (here_op === 0) {
                  state.mode = LIT;
                  break;
                }
                if (here_op & 32) {
                  state.back = -1;
                  state.mode = TYPE;
                  break;
                }
                if (here_op & 64) {
                  strm.msg = "invalid literal/length code";
                  state.mode = BAD;
                  break;
                }
                state.extra = here_op & 15;
                state.mode = LENEXT;
              case LENEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.length += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                state.was = state.length;
                state.mode = DIST;
              case DIST:
                for (; ; ) {
                  here = state.distcode[hold & (1 << state.distbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if ((here_op & 240) === 0) {
                  last_bits = here_bits;
                  last_op = here_op;
                  last_val = here_val;
                  for (; ; ) {
                    here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                    here_bits = here >>> 24;
                    here_op = here >>> 16 & 255;
                    here_val = here & 65535;
                    if (last_bits + here_bits <= bits) {
                      break;
                    }
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= last_bits;
                  bits -= last_bits;
                  state.back += last_bits;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                state.back += here_bits;
                if (here_op & 64) {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break;
                }
                state.offset = here_val;
                state.extra = here_op & 15;
                state.mode = DISTEXT;
              case DISTEXT:
                if (state.extra) {
                  n = state.extra;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  state.offset += hold & (1 << state.extra) - 1;
                  hold >>>= state.extra;
                  bits -= state.extra;
                  state.back += state.extra;
                }
                if (state.offset > state.dmax) {
                  strm.msg = "invalid distance too far back";
                  state.mode = BAD;
                  break;
                }
                state.mode = MATCH;
              case MATCH:
                if (left === 0) {
                  break inf_leave;
                }
                copy3 = _out - left;
                if (state.offset > copy3) {
                  copy3 = state.offset - copy3;
                  if (copy3 > state.whave) {
                    if (state.sane) {
                      strm.msg = "invalid distance too far back";
                      state.mode = BAD;
                      break;
                    }
                  }
                  if (copy3 > state.wnext) {
                    copy3 -= state.wnext;
                    from = state.wsize - copy3;
                  } else {
                    from = state.wnext - copy3;
                  }
                  if (copy3 > state.length) {
                    copy3 = state.length;
                  }
                  from_source = state.window;
                } else {
                  from_source = output;
                  from = put - state.offset;
                  copy3 = state.length;
                }
                if (copy3 > left) {
                  copy3 = left;
                }
                left -= copy3;
                state.length -= copy3;
                do {
                  output[put++] = from_source[from++];
                } while (--copy3);
                if (state.length === 0) {
                  state.mode = LEN;
                }
                break;
              case LIT:
                if (left === 0) {
                  break inf_leave;
                }
                output[put++] = state.length;
                left--;
                state.mode = LEN;
                break;
              case CHECK:
                if (state.wrap) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold |= input[next++] << bits;
                    bits += 8;
                  }
                  _out -= left;
                  strm.total_out += _out;
                  state.total += _out;
                  if (_out) {
                    strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                    state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                  }
                  _out = left;
                  if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                    strm.msg = "incorrect data check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = LENGTH;
              case LENGTH:
                if (state.wrap && state.flags) {
                  while (bits < 32) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  if (hold !== (state.total & 4294967295)) {
                    strm.msg = "incorrect length check";
                    state.mode = BAD;
                    break;
                  }
                  hold = 0;
                  bits = 0;
                }
                state.mode = DONE;
              case DONE:
                ret = Z_STREAM_END;
                break inf_leave;
              case BAD:
                ret = Z_DATA_ERROR;
                break inf_leave;
              case MEM:
                return Z_MEM_ERROR;
              case SYNC:
              default:
                return Z_STREAM_ERROR;
            }
          }
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
          if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
            state.mode = MEM;
            return Z_MEM_ERROR;
          }
        }
        _in -= strm.avail_in;
        _out -= strm.avail_out;
        strm.total_in += _in;
        strm.total_out += _out;
        state.total += _out;
        if (state.wrap && _out) {
          strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
        }
        strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
        if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
          ret = Z_BUF_ERROR;
        }
        return ret;
      }
      function inflateEnd(strm) {
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        var state = strm.state;
        if (state.window) {
          state.window = null;
        }
        strm.state = null;
        return Z_OK;
      }
      function inflateGetHeader(strm, head) {
        var state;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if ((state.wrap & 2) === 0) {
          return Z_STREAM_ERROR;
        }
        state.head = head;
        head.done = false;
        return Z_OK;
      }
      function inflateSetDictionary(strm, dictionary) {
        var dictLength = dictionary.length;
        var state;
        var dictid;
        var ret;
        if (!strm || !strm.state) {
          return Z_STREAM_ERROR;
        }
        state = strm.state;
        if (state.wrap !== 0 && state.mode !== DICT) {
          return Z_STREAM_ERROR;
        }
        if (state.mode === DICT) {
          dictid = 1;
          dictid = adler32(dictid, dictionary, dictLength, 0);
          if (dictid !== state.check) {
            return Z_DATA_ERROR;
          }
        }
        ret = updatewindow(strm, dictionary, dictLength, dictLength);
        if (ret) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
        state.havedict = 1;
        return Z_OK;
      }
      exports.inflateReset = inflateReset;
      exports.inflateReset2 = inflateReset2;
      exports.inflateResetKeep = inflateResetKeep;
      exports.inflateInit = inflateInit;
      exports.inflateInit2 = inflateInit2;
      exports.inflate = inflate;
      exports.inflateEnd = inflateEnd;
      exports.inflateGetHeader = inflateGetHeader;
      exports.inflateSetDictionary = inflateSetDictionary;
      exports.inflateInfo = "pako inflate (from Nodeca project)";
    }
  });

  // ../../node_modules/pako/lib/zlib/constants.js
  var require_constants = __commonJS({
    "../../node_modules/pako/lib/zlib/constants.js"(exports, module) {
      "use strict";
      module.exports = {
        /* Allowed flush values; see deflate() and inflate() below for details */
        Z_NO_FLUSH: 0,
        Z_PARTIAL_FLUSH: 1,
        Z_SYNC_FLUSH: 2,
        Z_FULL_FLUSH: 3,
        Z_FINISH: 4,
        Z_BLOCK: 5,
        Z_TREES: 6,
        /* Return codes for the compression/decompression functions. Negative values
        * are errors, positive values are used for special but normal events.
        */
        Z_OK: 0,
        Z_STREAM_END: 1,
        Z_NEED_DICT: 2,
        Z_ERRNO: -1,
        Z_STREAM_ERROR: -2,
        Z_DATA_ERROR: -3,
        //Z_MEM_ERROR:     -4,
        Z_BUF_ERROR: -5,
        //Z_VERSION_ERROR: -6,
        /* compression levels */
        Z_NO_COMPRESSION: 0,
        Z_BEST_SPEED: 1,
        Z_BEST_COMPRESSION: 9,
        Z_DEFAULT_COMPRESSION: -1,
        Z_FILTERED: 1,
        Z_HUFFMAN_ONLY: 2,
        Z_RLE: 3,
        Z_FIXED: 4,
        Z_DEFAULT_STRATEGY: 0,
        /* Possible values of the data_type field (though see inflate()) */
        Z_BINARY: 0,
        Z_TEXT: 1,
        //Z_ASCII:                1, // = Z_TEXT (deprecated)
        Z_UNKNOWN: 2,
        /* The deflate compression method */
        Z_DEFLATED: 8
        //Z_NULL:                 null // Use -1 or null inline, depending on var type
      };
    }
  });

  // ../../node_modules/pako/lib/zlib/gzheader.js
  var require_gzheader = __commonJS({
    "../../node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
      "use strict";
      function GZheader() {
        this.text = 0;
        this.time = 0;
        this.xflags = 0;
        this.os = 0;
        this.extra = null;
        this.extra_len = 0;
        this.name = "";
        this.comment = "";
        this.hcrc = 0;
        this.done = false;
      }
      module.exports = GZheader;
    }
  });

  // ../../node_modules/pako/lib/inflate.js
  var require_inflate2 = __commonJS({
    "../../node_modules/pako/lib/inflate.js"(exports) {
      "use strict";
      var zlib_inflate = require_inflate();
      var utils = require_common();
      var strings = require_strings();
      var c = require_constants();
      var msg = require_messages();
      var ZStream = require_zstream();
      var GZheader = require_gzheader();
      var toString = Object.prototype.toString;
      function Inflate(options) {
        if (!(this instanceof Inflate))
          return new Inflate(options);
        this.options = utils.assign({
          chunkSize: 16384,
          windowBits: 0,
          to: ""
        }, options || {});
        var opt = this.options;
        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
          opt.windowBits = -opt.windowBits;
          if (opt.windowBits === 0) {
            opt.windowBits = -15;
          }
        }
        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
          opt.windowBits += 32;
        }
        if (opt.windowBits > 15 && opt.windowBits < 48) {
          if ((opt.windowBits & 15) === 0) {
            opt.windowBits |= 15;
          }
        }
        this.err = 0;
        this.msg = "";
        this.ended = false;
        this.chunks = [];
        this.strm = new ZStream();
        this.strm.avail_out = 0;
        var status = zlib_inflate.inflateInit2(
          this.strm,
          opt.windowBits
        );
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
        this.header = new GZheader();
        zlib_inflate.inflateGetHeader(this.strm, this.header);
        if (opt.dictionary) {
          if (typeof opt.dictionary === "string") {
            opt.dictionary = strings.string2buf(opt.dictionary);
          } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
            opt.dictionary = new Uint8Array(opt.dictionary);
          }
          if (opt.raw) {
            status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
            if (status !== c.Z_OK) {
              throw new Error(msg[status]);
            }
          }
        }
      }
      Inflate.prototype.push = function(data, mode) {
        var strm = this.strm;
        var chunkSize = this.options.chunkSize;
        var dictionary = this.options.dictionary;
        var status, _mode;
        var next_out_utf8, tail, utf8str;
        var allowBufError = false;
        if (this.ended) {
          return false;
        }
        _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
        if (typeof data === "string") {
          strm.input = strings.binstring2buf(data);
        } else if (toString.call(data) === "[object ArrayBuffer]") {
          strm.input = new Uint8Array(data);
        } else {
          strm.input = data;
        }
        strm.next_in = 0;
        strm.avail_in = strm.input.length;
        do {
          if (strm.avail_out === 0) {
            strm.output = new utils.Buf8(chunkSize);
            strm.next_out = 0;
            strm.avail_out = chunkSize;
          }
          status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
          if (status === c.Z_NEED_DICT && dictionary) {
            status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
          }
          if (status === c.Z_BUF_ERROR && allowBufError === true) {
            status = c.Z_OK;
            allowBufError = false;
          }
          if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
            this.onEnd(status);
            this.ended = true;
            return false;
          }
          if (strm.next_out) {
            if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
              if (this.options.to === "string") {
                next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
                tail = strm.next_out - next_out_utf8;
                utf8str = strings.buf2string(strm.output, next_out_utf8);
                strm.next_out = tail;
                strm.avail_out = chunkSize - tail;
                if (tail) {
                  utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
                }
                this.onData(utf8str);
              } else {
                this.onData(utils.shrinkBuf(strm.output, strm.next_out));
              }
            }
          }
          if (strm.avail_in === 0 && strm.avail_out === 0) {
            allowBufError = true;
          }
        } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
        if (status === c.Z_STREAM_END) {
          _mode = c.Z_FINISH;
        }
        if (_mode === c.Z_FINISH) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === c.Z_OK;
        }
        if (_mode === c.Z_SYNC_FLUSH) {
          this.onEnd(c.Z_OK);
          strm.avail_out = 0;
          return true;
        }
        return true;
      };
      Inflate.prototype.onData = function(chunk) {
        this.chunks.push(chunk);
      };
      Inflate.prototype.onEnd = function(status) {
        if (status === c.Z_OK) {
          if (this.options.to === "string") {
            this.result = this.chunks.join("");
          } else {
            this.result = utils.flattenChunks(this.chunks);
          }
        }
        this.chunks = [];
        this.err = status;
        this.msg = this.strm.msg;
      };
      function inflate(input, options) {
        var inflator = new Inflate(options);
        inflator.push(input, true);
        if (inflator.err) {
          throw inflator.msg || msg[inflator.err];
        }
        return inflator.result;
      }
      function inflateRaw(input, options) {
        options = options || {};
        options.raw = true;
        return inflate(input, options);
      }
      exports.Inflate = Inflate;
      exports.inflate = inflate;
      exports.inflateRaw = inflateRaw;
      exports.ungzip = inflate;
    }
  });

  // ../../node_modules/pako/index.js
  var require_pako = __commonJS({
    "../../node_modules/pako/index.js"(exports, module) {
      "use strict";
      var assign = require_common().assign;
      var deflate = require_deflate2();
      var inflate = require_inflate2();
      var constants2 = require_constants();
      var pako2 = {};
      assign(pako2, deflate, inflate, constants2);
      module.exports = pako2;
    }
  });

  // (disabled):zlib
  var require_zlib = __commonJS({
    "(disabled):zlib"() {
    }
  });

  // ../../node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../../node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // ../../node_modules/pbf/index.js
  var require_pbf = __commonJS({
    "../../node_modules/pbf/index.js"(exports, module) {
      "use strict";
      module.exports = Pbf;
      var ieee754 = require_ieee754();
      function Pbf(buf) {
        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);
        this.pos = 0;
        this.type = 0;
        this.length = this.buf.length;
      }
      Pbf.Varint = 0;
      Pbf.Fixed64 = 1;
      Pbf.Bytes = 2;
      Pbf.Fixed32 = 5;
      var SHIFT_LEFT_32 = (1 << 16) * (1 << 16);
      var SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;
      var TEXT_DECODER_MIN_LENGTH = 12;
      var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
      Pbf.prototype = {
        destroy: function() {
          this.buf = null;
        },
        // === READING =================================================================
        readFields: function(readField, result, end) {
          end = end || this.length;
          while (this.pos < end) {
            var val = this.readVarint(), tag = val >> 3, startPos = this.pos;
            this.type = val & 7;
            readField(tag, result, this);
            if (this.pos === startPos)
              this.skip(val);
          }
          return result;
        },
        readMessage: function(readField, result) {
          return this.readFields(readField, result, this.readVarint() + this.pos);
        },
        readFixed32: function() {
          var val = readUInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        readSFixed32: function() {
          var val = readInt32(this.buf, this.pos);
          this.pos += 4;
          return val;
        },
        // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)
        readFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readSFixed64: function() {
          var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;
          this.pos += 8;
          return val;
        },
        readFloat: function() {
          var val = ieee754.read(this.buf, this.pos, true, 23, 4);
          this.pos += 4;
          return val;
        },
        readDouble: function() {
          var val = ieee754.read(this.buf, this.pos, true, 52, 8);
          this.pos += 8;
          return val;
        },
        readVarint: function(isSigned) {
          var buf = this.buf, val, b;
          b = buf[this.pos++];
          val = b & 127;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 7;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 14;
          if (b < 128)
            return val;
          b = buf[this.pos++];
          val |= (b & 127) << 21;
          if (b < 128)
            return val;
          b = buf[this.pos];
          val |= (b & 15) << 28;
          return readVarintRemainder(val, isSigned, this);
        },
        readVarint64: function() {
          return this.readVarint(true);
        },
        readSVarint: function() {
          var num = this.readVarint();
          return num % 2 === 1 ? (num + 1) / -2 : num / 2;
        },
        readBoolean: function() {
          return Boolean(this.readVarint());
        },
        readString: function() {
          var end = this.readVarint() + this.pos;
          var pos = this.pos;
          this.pos = end;
          if (end - pos >= TEXT_DECODER_MIN_LENGTH && utf8TextDecoder) {
            return readUtf8TextDecoder(this.buf, pos, end);
          }
          return readUtf8(this.buf, pos, end);
        },
        readBytes: function() {
          var end = this.readVarint() + this.pos, buffer = this.buf.subarray(this.pos, end);
          this.pos = end;
          return buffer;
        },
        // verbose for performance reasons; doesn't affect gzipped size
        readPackedVarint: function(arr, isSigned) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readVarint(isSigned));
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readVarint(isSigned));
          return arr;
        },
        readPackedSVarint: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSVarint());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSVarint());
          return arr;
        },
        readPackedBoolean: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readBoolean());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readBoolean());
          return arr;
        },
        readPackedFloat: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFloat());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFloat());
          return arr;
        },
        readPackedDouble: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readDouble());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readDouble());
          return arr;
        },
        readPackedFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed32());
          return arr;
        },
        readPackedSFixed32: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed32());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed32());
          return arr;
        },
        readPackedFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readFixed64());
          return arr;
        },
        readPackedSFixed64: function(arr) {
          if (this.type !== Pbf.Bytes)
            return arr.push(this.readSFixed64());
          var end = readPackedEnd(this);
          arr = arr || [];
          while (this.pos < end)
            arr.push(this.readSFixed64());
          return arr;
        },
        skip: function(val) {
          var type = val & 7;
          if (type === Pbf.Varint)
            while (this.buf[this.pos++] > 127) {
            }
          else if (type === Pbf.Bytes)
            this.pos = this.readVarint() + this.pos;
          else if (type === Pbf.Fixed32)
            this.pos += 4;
          else if (type === Pbf.Fixed64)
            this.pos += 8;
          else
            throw new Error("Unimplemented type: " + type);
        },
        // === WRITING =================================================================
        writeTag: function(tag, type) {
          this.writeVarint(tag << 3 | type);
        },
        realloc: function(min2) {
          var length2 = this.length || 16;
          while (length2 < this.pos + min2)
            length2 *= 2;
          if (length2 !== this.length) {
            var buf = new Uint8Array(length2);
            buf.set(this.buf);
            this.buf = buf;
            this.length = length2;
          }
        },
        finish: function() {
          this.length = this.pos;
          this.pos = 0;
          return this.buf.subarray(0, this.length);
        },
        writeFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeSFixed32: function(val) {
          this.realloc(4);
          writeInt32(this.buf, val, this.pos);
          this.pos += 4;
        },
        writeFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeSFixed64: function(val) {
          this.realloc(8);
          writeInt32(this.buf, val & -1, this.pos);
          writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);
          this.pos += 8;
        },
        writeVarint: function(val) {
          val = +val || 0;
          if (val > 268435455 || val < 0) {
            writeBigVarint(val, this);
            return;
          }
          this.realloc(4);
          this.buf[this.pos++] = val & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = (val >>>= 7) & 127 | (val > 127 ? 128 : 0);
          if (val <= 127)
            return;
          this.buf[this.pos++] = val >>> 7 & 127;
        },
        writeSVarint: function(val) {
          this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);
        },
        writeBoolean: function(val) {
          this.writeVarint(Boolean(val));
        },
        writeString: function(str) {
          str = String(str);
          this.realloc(str.length * 4);
          this.pos++;
          var startPos = this.pos;
          this.pos = writeUtf8(this.buf, str, this.pos);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeFloat: function(val) {
          this.realloc(4);
          ieee754.write(this.buf, val, this.pos, true, 23, 4);
          this.pos += 4;
        },
        writeDouble: function(val) {
          this.realloc(8);
          ieee754.write(this.buf, val, this.pos, true, 52, 8);
          this.pos += 8;
        },
        writeBytes: function(buffer) {
          var len = buffer.length;
          this.writeVarint(len);
          this.realloc(len);
          for (var i = 0; i < len; i++)
            this.buf[this.pos++] = buffer[i];
        },
        writeRawMessage: function(fn, obj) {
          this.pos++;
          var startPos = this.pos;
          fn(obj, this);
          var len = this.pos - startPos;
          if (len >= 128)
            makeRoomForExtraLength(startPos, len, this);
          this.pos = startPos - 1;
          this.writeVarint(len);
          this.pos += len;
        },
        writeMessage: function(tag, fn, obj) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeRawMessage(fn, obj);
        },
        writePackedVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedVarint, arr);
        },
        writePackedSVarint: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSVarint, arr);
        },
        writePackedBoolean: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedBoolean, arr);
        },
        writePackedFloat: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFloat, arr);
        },
        writePackedDouble: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedDouble, arr);
        },
        writePackedFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed32, arr);
        },
        writePackedSFixed32: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed32, arr);
        },
        writePackedFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedFixed64, arr);
        },
        writePackedSFixed64: function(tag, arr) {
          if (arr.length)
            this.writeMessage(tag, writePackedSFixed64, arr);
        },
        writeBytesField: function(tag, buffer) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeBytes(buffer);
        },
        writeFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFixed32(val);
        },
        writeSFixed32Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeSFixed32(val);
        },
        writeFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeFixed64(val);
        },
        writeSFixed64Field: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeSFixed64(val);
        },
        writeVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeVarint(val);
        },
        writeSVarintField: function(tag, val) {
          this.writeTag(tag, Pbf.Varint);
          this.writeSVarint(val);
        },
        writeStringField: function(tag, str) {
          this.writeTag(tag, Pbf.Bytes);
          this.writeString(str);
        },
        writeFloatField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed32);
          this.writeFloat(val);
        },
        writeDoubleField: function(tag, val) {
          this.writeTag(tag, Pbf.Fixed64);
          this.writeDouble(val);
        },
        writeBooleanField: function(tag, val) {
          this.writeVarintField(tag, Boolean(val));
        }
      };
      function readVarintRemainder(l, s, p) {
        var buf = p.buf, h, b;
        b = buf[p.pos++];
        h = (b & 112) >> 4;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 3;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 10;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 17;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 127) << 24;
        if (b < 128)
          return toNum(l, h, s);
        b = buf[p.pos++];
        h |= (b & 1) << 31;
        if (b < 128)
          return toNum(l, h, s);
        throw new Error("Expected varint not more than 10 bytes");
      }
      function readPackedEnd(pbf) {
        return pbf.type === Pbf.Bytes ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
      }
      function toNum(low, high, isSigned) {
        if (isSigned) {
          return high * 4294967296 + (low >>> 0);
        }
        return (high >>> 0) * 4294967296 + (low >>> 0);
      }
      function writeBigVarint(val, pbf) {
        var low, high;
        if (val >= 0) {
          low = val % 4294967296 | 0;
          high = val / 4294967296 | 0;
        } else {
          low = ~(-val % 4294967296);
          high = ~(-val / 4294967296);
          if (low ^ 4294967295) {
            low = low + 1 | 0;
          } else {
            low = 0;
            high = high + 1 | 0;
          }
        }
        if (val >= 18446744073709552e3 || val < -18446744073709552e3) {
          throw new Error("Given varint doesn't fit into 10 bytes");
        }
        pbf.realloc(10);
        writeBigVarintLow(low, high, pbf);
        writeBigVarintHigh(high, pbf);
      }
      function writeBigVarintLow(low, high, pbf) {
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos++] = low & 127 | 128;
        low >>>= 7;
        pbf.buf[pbf.pos] = low & 127;
      }
      function writeBigVarintHigh(high, pbf) {
        var lsb = (high & 7) << 4;
        pbf.buf[pbf.pos++] |= lsb | ((high >>>= 3) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127 | ((high >>>= 7) ? 128 : 0);
        if (!high)
          return;
        pbf.buf[pbf.pos++] = high & 127;
      }
      function makeRoomForExtraLength(startPos, len, pbf) {
        var extraLen = len <= 16383 ? 1 : len <= 2097151 ? 2 : len <= 268435455 ? 3 : Math.floor(Math.log(len) / (Math.LN2 * 7));
        pbf.realloc(extraLen);
        for (var i = pbf.pos - 1; i >= startPos; i--)
          pbf.buf[i + extraLen] = pbf.buf[i];
      }
      function writePackedVarint(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeVarint(arr[i]);
      }
      function writePackedSVarint(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeSVarint(arr[i]);
      }
      function writePackedFloat(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeFloat(arr[i]);
      }
      function writePackedDouble(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeDouble(arr[i]);
      }
      function writePackedBoolean(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeBoolean(arr[i]);
      }
      function writePackedFixed32(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeFixed32(arr[i]);
      }
      function writePackedSFixed32(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeSFixed32(arr[i]);
      }
      function writePackedFixed64(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeFixed64(arr[i]);
      }
      function writePackedSFixed64(arr, pbf) {
        for (var i = 0; i < arr.length; i++)
          pbf.writeSFixed64(arr[i]);
      }
      function readUInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + buf[pos + 3] * 16777216;
      }
      function writeInt32(buf, val, pos) {
        buf[pos] = val;
        buf[pos + 1] = val >>> 8;
        buf[pos + 2] = val >>> 16;
        buf[pos + 3] = val >>> 24;
      }
      function readInt32(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16) + (buf[pos + 3] << 24);
      }
      function readUtf8(buf, pos, end) {
        var str = "";
        var i = pos;
        while (i < end) {
          var b0 = buf[i];
          var c = null;
          var bytesPerSequence = b0 > 239 ? 4 : b0 > 223 ? 3 : b0 > 191 ? 2 : 1;
          if (i + bytesPerSequence > end)
            break;
          var b1, b2, b3;
          if (bytesPerSequence === 1) {
            if (b0 < 128) {
              c = b0;
            }
          } else if (bytesPerSequence === 2) {
            b1 = buf[i + 1];
            if ((b1 & 192) === 128) {
              c = (b0 & 31) << 6 | b1 & 63;
              if (c <= 127) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 3) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            if ((b1 & 192) === 128 && (b2 & 192) === 128) {
              c = (b0 & 15) << 12 | (b1 & 63) << 6 | b2 & 63;
              if (c <= 2047 || c >= 55296 && c <= 57343) {
                c = null;
              }
            }
          } else if (bytesPerSequence === 4) {
            b1 = buf[i + 1];
            b2 = buf[i + 2];
            b3 = buf[i + 3];
            if ((b1 & 192) === 128 && (b2 & 192) === 128 && (b3 & 192) === 128) {
              c = (b0 & 15) << 18 | (b1 & 63) << 12 | (b2 & 63) << 6 | b3 & 63;
              if (c <= 65535 || c >= 1114112) {
                c = null;
              }
            }
          }
          if (c === null) {
            c = 65533;
            bytesPerSequence = 1;
          } else if (c > 65535) {
            c -= 65536;
            str += String.fromCharCode(c >>> 10 & 1023 | 55296);
            c = 56320 | c & 1023;
          }
          str += String.fromCharCode(c);
          i += bytesPerSequence;
        }
        return str;
      }
      function readUtf8TextDecoder(buf, pos, end) {
        return utf8TextDecoder.decode(buf.subarray(pos, end));
      }
      function writeUtf8(buf, str, pos) {
        for (var i = 0, c, lead; i < str.length; i++) {
          c = str.charCodeAt(i);
          if (c > 55295 && c < 57344) {
            if (lead) {
              if (c < 56320) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
                lead = c;
                continue;
              } else {
                c = lead - 55296 << 10 | c - 56320 | 65536;
                lead = null;
              }
            } else {
              if (c > 56319 || i + 1 === str.length) {
                buf[pos++] = 239;
                buf[pos++] = 191;
                buf[pos++] = 189;
              } else {
                lead = c;
              }
              continue;
            }
          } else if (lead) {
            buf[pos++] = 239;
            buf[pos++] = 191;
            buf[pos++] = 189;
            lead = null;
          }
          if (c < 128) {
            buf[pos++] = c;
          } else {
            if (c < 2048) {
              buf[pos++] = c >> 6 | 192;
            } else {
              if (c < 65536) {
                buf[pos++] = c >> 12 | 224;
              } else {
                buf[pos++] = c >> 18 | 240;
                buf[pos++] = c >> 12 & 63 | 128;
              }
              buf[pos++] = c >> 6 & 63 | 128;
            }
            buf[pos++] = c & 63 | 128;
          }
        }
        return pos;
      }
    }
  });

  // ../../node_modules/earcut/src/earcut.js
  var require_earcut = __commonJS({
    "../../node_modules/earcut/src/earcut.js"(exports, module) {
      "use strict";
      module.exports = earcut2;
      module.exports.default = earcut2;
      function earcut2(data, holeIndices, dim) {
        dim = dim || 2;
        var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
        if (!outerNode || outerNode.next === outerNode.prev)
          return triangles;
        var minX, minY, maxX, maxY, x, y, invSize;
        if (hasHoles)
          outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
        if (data.length > 80 * dim) {
          minX = maxX = data[0];
          minY = maxY = data[1];
          for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX)
              minX = x;
            if (y < minY)
              minY = y;
            if (x > maxX)
              maxX = x;
            if (y > maxY)
              maxY = y;
          }
          invSize = Math.max(maxX - minX, maxY - minY);
          invSize = invSize !== 0 ? 32767 / invSize : 0;
        }
        earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
        return triangles;
      }
      function linkedList(data, start, end, dim, clockwise) {
        var i, last;
        if (clockwise === signedArea(data, start, end, dim) > 0) {
          for (i = start; i < end; i += dim)
            last = insertNode(i, data[i], data[i + 1], last);
        } else {
          for (i = end - dim; i >= start; i -= dim)
            last = insertNode(i, data[i], data[i + 1], last);
        }
        if (last && equals(last, last.next)) {
          removeNode(last);
          last = last.next;
        }
        return last;
      }
      function filterPoints(start, end) {
        if (!start)
          return start;
        if (!end)
          end = start;
        var p = start, again;
        do {
          again = false;
          if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next)
              break;
            again = true;
          } else {
            p = p.next;
          }
        } while (again || p !== end);
        return end;
      }
      function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
        if (!ear)
          return;
        if (!pass && invSize)
          indexCurve(ear, minX, minY, invSize);
        var stop = ear, prev, next;
        while (ear.prev !== ear.next) {
          prev = ear.prev;
          next = ear.next;
          if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            triangles.push(prev.i / dim | 0);
            triangles.push(ear.i / dim | 0);
            triangles.push(next.i / dim | 0);
            removeNode(ear);
            ear = next.next;
            stop = next.next;
            continue;
          }
          ear = next;
          if (ear === stop) {
            if (!pass) {
              earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
            } else if (pass === 1) {
              ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
              earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
            } else if (pass === 2) {
              splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }
            break;
          }
        }
      }
      function isEar(ear) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var p = c.next;
        while (p !== a) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.next;
        }
        return true;
      }
      function isEarHashed(ear, minX, minY, invSize) {
        var a = ear.prev, b = ear, c = ear.next;
        if (area(a, b, c) >= 0)
          return false;
        var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
        var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
        var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
        var p = ear.prevZ, n = ear.nextZ;
        while (p && p.z >= minZ && n && n.z <= maxZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        while (p && p.z >= minZ) {
          if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
            return false;
          p = p.prevZ;
        }
        while (n && n.z <= maxZ) {
          if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
            return false;
          n = n.nextZ;
        }
        return true;
      }
      function cureLocalIntersections(start, triangles, dim) {
        var p = start;
        do {
          var a = p.prev, b = p.next.next;
          if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
            triangles.push(a.i / dim | 0);
            triangles.push(p.i / dim | 0);
            triangles.push(b.i / dim | 0);
            removeNode(p);
            removeNode(p.next);
            p = start = b;
          }
          p = p.next;
        } while (p !== start);
        return filterPoints(p);
      }
      function splitEarcut(start, triangles, dim, minX, minY, invSize) {
        var a = start;
        do {
          var b = a.next.next;
          while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
              var c = splitPolygon(a, b);
              a = filterPoints(a, a.next);
              c = filterPoints(c, c.next);
              earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
              earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
              return;
            }
            b = b.next;
          }
          a = a.next;
        } while (a !== start);
      }
      function eliminateHoles(data, holeIndices, outerNode, dim) {
        var queue = [], i, len, start, end, list;
        for (i = 0, len = holeIndices.length; i < len; i++) {
          start = holeIndices[i] * dim;
          end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
          list = linkedList(data, start, end, dim, false);
          if (list === list.next)
            list.steiner = true;
          queue.push(getLeftmost(list));
        }
        queue.sort(compareX);
        for (i = 0; i < queue.length; i++) {
          outerNode = eliminateHole(queue[i], outerNode);
        }
        return outerNode;
      }
      function compareX(a, b) {
        return a.x - b.x;
      }
      function eliminateHole(hole, outerNode) {
        var bridge = findHoleBridge(hole, outerNode);
        if (!bridge) {
          return outerNode;
        }
        var bridgeReverse = splitPolygon(bridge, hole);
        filterPoints(bridgeReverse, bridgeReverse.next);
        return filterPoints(bridge, bridge.next);
      }
      function findHoleBridge(hole, outerNode) {
        var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
        do {
          if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
              qx = x;
              m = p.x < p.next.x ? p : p.next;
              if (x === hx)
                return m;
            }
          }
          p = p.next;
        } while (p !== outerNode);
        if (!m)
          return null;
        var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
        p = m;
        do {
          if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
            tan = Math.abs(hy - p.y) / (hx - p.x);
            if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
              m = p;
              tanMin = tan;
            }
          }
          p = p.next;
        } while (p !== stop);
        return m;
      }
      function sectorContainsSector(m, p) {
        return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
      }
      function indexCurve(start, minX, minY, invSize) {
        var p = start;
        do {
          if (p.z === 0)
            p.z = zOrder(p.x, p.y, minX, minY, invSize);
          p.prevZ = p.prev;
          p.nextZ = p.next;
          p = p.next;
        } while (p !== start);
        p.prevZ.nextZ = null;
        p.prevZ = null;
        sortLinked(p);
      }
      function sortLinked(list) {
        var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
        do {
          p = list;
          list = null;
          tail = null;
          numMerges = 0;
          while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
              pSize++;
              q = q.nextZ;
              if (!q)
                break;
            }
            qSize = inSize;
            while (pSize > 0 || qSize > 0 && q) {
              if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                e = p;
                p = p.nextZ;
                pSize--;
              } else {
                e = q;
                q = q.nextZ;
                qSize--;
              }
              if (tail)
                tail.nextZ = e;
              else
                list = e;
              e.prevZ = tail;
              tail = e;
            }
            p = q;
          }
          tail.nextZ = null;
          inSize *= 2;
        } while (numMerges > 1);
        return list;
      }
      function zOrder(x, y, minX, minY, invSize) {
        x = (x - minX) * invSize | 0;
        y = (y - minY) * invSize | 0;
        x = (x | x << 8) & 16711935;
        x = (x | x << 4) & 252645135;
        x = (x | x << 2) & 858993459;
        x = (x | x << 1) & 1431655765;
        y = (y | y << 8) & 16711935;
        y = (y | y << 4) & 252645135;
        y = (y | y << 2) & 858993459;
        y = (y | y << 1) & 1431655765;
        return x | y << 1;
      }
      function getLeftmost(start) {
        var p = start, leftmost = start;
        do {
          if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
            leftmost = p;
          p = p.next;
        } while (p !== start);
        return leftmost;
      }
      function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
      }
      function isValidDiagonal(a, b) {
        return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
        (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
        equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
      }
      function area(p, q, r) {
        return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      }
      function equals(p1, p2) {
        return p1.x === p2.x && p1.y === p2.y;
      }
      function intersects(p1, q1, p2, q2) {
        var o1 = sign(area(p1, q1, p2));
        var o2 = sign(area(p1, q1, q2));
        var o3 = sign(area(p2, q2, p1));
        var o4 = sign(area(p2, q2, q1));
        if (o1 !== o2 && o3 !== o4)
          return true;
        if (o1 === 0 && onSegment(p1, p2, q1))
          return true;
        if (o2 === 0 && onSegment(p1, q2, q1))
          return true;
        if (o3 === 0 && onSegment(p2, p1, q2))
          return true;
        if (o4 === 0 && onSegment(p2, q1, q2))
          return true;
        return false;
      }
      function onSegment(p, q, r) {
        return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
      }
      function sign(num) {
        return num > 0 ? 1 : num < 0 ? -1 : 0;
      }
      function intersectsPolygon(a, b) {
        var p = a;
        do {
          if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
            return true;
          p = p.next;
        } while (p !== a);
        return false;
      }
      function locallyInside(a, b) {
        return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
      }
      function middleInside(a, b) {
        var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
        do {
          if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
            inside = !inside;
          p = p.next;
        } while (p !== a);
        return inside;
      }
      function splitPolygon(a, b) {
        var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
        a.next = b;
        b.prev = a;
        a2.next = an;
        an.prev = a2;
        b2.next = a2;
        a2.prev = b2;
        bp.next = b2;
        b2.prev = bp;
        return b2;
      }
      function insertNode(i, x, y, last) {
        var p = new Node(i, x, y);
        if (!last) {
          p.prev = p;
          p.next = p;
        } else {
          p.next = last.next;
          p.prev = last;
          last.next.prev = p;
          last.next = p;
        }
        return p;
      }
      function removeNode(p) {
        p.next.prev = p.prev;
        p.prev.next = p.next;
        if (p.prevZ)
          p.prevZ.nextZ = p.nextZ;
        if (p.nextZ)
          p.nextZ.prevZ = p.prevZ;
      }
      function Node(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = 0;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
      earcut2.deviation = function(data, holeIndices, dim, triangles) {
        var hasHoles = holeIndices && holeIndices.length;
        var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
        var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
        if (hasHoles) {
          for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
          }
        }
        var trianglesArea = 0;
        for (i = 0; i < triangles.length; i += 3) {
          var a = triangles[i] * dim;
          var b = triangles[i + 1] * dim;
          var c = triangles[i + 2] * dim;
          trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
          );
        }
        return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
      };
      function signedArea(data, start, end, dim) {
        var sum3 = 0;
        for (var i = start, j = end - dim; i < end; i += dim) {
          sum3 += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
          j = i;
        }
        return sum3;
      }
      earcut2.flatten = function(data) {
        var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
        for (var i = 0; i < data.length; i++) {
          for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++)
              result.vertices.push(data[i][j][d]);
          }
          if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
          }
        }
        return result;
      };
    }
  });

  // external-global-plugin:@deck.gl/extensions
  var require_extensions = __commonJS({
    "external-global-plugin:@deck.gl/extensions"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    carto: () => carto
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    BASEMAP: () => basemap_default,
    CARTO_LAYERS: () => CARTO_LAYERS,
    CARTO_SOURCES: () => CARTO_SOURCES,
    CartoAPIError: () => CartoAPIError,
    ClusterTileLayer: () => ClusterTileLayer,
    H3TileLayer: () => H3TileLayer,
    HeatmapTileLayer: () => heatmap_tile_layer_default,
    LayerFactory: () => LayerFactory,
    PointLabelLayer: () => PointLabelLayer,
    QuadbinTileLayer: () => QuadbinTileLayer,
    RasterTileLayer: () => RasterTileLayer,
    SOURCE_DEFAULTS: () => SOURCE_DEFAULTS,
    VectorTileLayer: () => VectorTileLayer,
    _GOOGLE_BASEMAPS: () => GOOGLE_BASEMAPS2,
    _QuadbinLayer: () => QuadbinLayer,
    _RasterLayer: () => RasterLayer,
    _STYLE_LAYER_GROUPS: () => STYLE_LAYER_GROUPS2,
    _SpatialIndexTileLayer: () => SpatialIndexTileLayer,
    _applyLayerGroupFilters: () => applyLayerGroupFilters2,
    _fetchStyle: () => fetchStyle2,
    _getStyleUrl: () => getStyleUrl2,
    boundaryQuerySource: () => boundaryQuerySource,
    boundaryTableSource: () => boundaryTableSource,
    colorBins: () => colorBins,
    colorCategories: () => colorCategories,
    colorContinuous: () => colorContinuous,
    fetchBasemapProps: () => fetchBasemapProps2,
    fetchMap: () => fetchMap2,
    h3QuerySource: () => h3QuerySource,
    h3TableSource: () => h3TableSource,
    h3TilesetSource: () => h3TilesetSource,
    quadbinQuerySource: () => quadbinQuerySource,
    quadbinTableSource: () => quadbinTableSource,
    quadbinTilesetSource: () => quadbinTilesetSource,
    query: () => query,
    rasterSource: () => rasterSource,
    vectorQuerySource: () => vectorQuerySource,
    vectorTableSource: () => vectorTableSource,
    vectorTilesetSource: () => vectorTilesetSource
  });

  // src/layers/cluster-tile-layer.ts
  var import_layers = __toESM(require_layers(), 1);
  var import_geo_layers3 = __toESM(require_geo_layers(), 1);
  var import_core5 = __toESM(require_core(), 1);

  // ../../node_modules/@loaders.gl/gis/dist/lib/binary-features/binary-to-geojson.js
  function binaryToGeojson(data, options) {
    const globalFeatureId = options?.globalFeatureId;
    if (globalFeatureId !== void 0) {
      return getSingleFeature(data, globalFeatureId);
    }
    return parseFeatures(data, options?.type);
  }
  function getSingleFeature(data, globalFeatureId) {
    const dataArray = normalizeInput(data);
    for (const data2 of dataArray) {
      let lastIndex = 0;
      let lastValue = data2.featureIds.value[0];
      for (let i = 0; i < data2.featureIds.value.length; i++) {
        const currValue = data2.featureIds.value[i];
        if (currValue === lastValue) {
          continue;
        }
        if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
          return parseFeature(data2, lastIndex, i);
        }
        lastIndex = i;
        lastValue = currValue;
      }
      if (globalFeatureId === data2.globalFeatureIds.value[lastIndex]) {
        return parseFeature(data2, lastIndex, data2.featureIds.value.length);
      }
    }
    throw new Error(`featureId:${globalFeatureId} not found`);
  }
  function parseFeatures(data, type) {
    const dataArray = normalizeInput(data, type);
    return parseFeatureCollection(dataArray);
  }
  function binaryToGeometry(data, startIndex, endIndex) {
    switch (data.type) {
      case "Point":
        return pointToGeoJson(data, startIndex, endIndex);
      case "LineString":
        return lineStringToGeoJson(data, startIndex, endIndex);
      case "Polygon":
        return polygonToGeoJson(data, startIndex, endIndex);
      default:
        const unexpectedInput = data;
        throw new Error(`Unsupported geometry type: ${unexpectedInput?.type}`);
    }
  }
  function normalizeInput(data, type) {
    const features = [];
    if (data.points) {
      data.points.type = "Point";
      features.push(data.points);
    }
    if (data.lines) {
      data.lines.type = "LineString";
      features.push(data.lines);
    }
    if (data.polygons) {
      data.polygons.type = "Polygon";
      features.push(data.polygons);
    }
    return features;
  }
  function parseFeatureCollection(dataArray) {
    const features = [];
    for (const data of dataArray) {
      if (data.featureIds.value.length === 0) {
        continue;
      }
      let lastIndex = 0;
      let lastValue = data.featureIds.value[0];
      for (let i = 0; i < data.featureIds.value.length; i++) {
        const currValue = data.featureIds.value[i];
        if (currValue === lastValue) {
          continue;
        }
        features.push(parseFeature(data, lastIndex, i));
        lastIndex = i;
        lastValue = currValue;
      }
      features.push(parseFeature(data, lastIndex, data.featureIds.value.length));
    }
    return features;
  }
  function parseFeature(data, startIndex, endIndex) {
    const geometry = binaryToGeometry(data, startIndex, endIndex);
    const properties = parseProperties(data, startIndex, endIndex);
    const fields = parseFields(data, startIndex, endIndex);
    return { type: "Feature", geometry, properties, ...fields };
  }
  function parseFields(data, startIndex = 0, endIndex) {
    return data.fields && data.fields[data.featureIds.value[startIndex]];
  }
  function parseProperties(data, startIndex = 0, endIndex) {
    const properties = Object.assign({}, data.properties[data.featureIds.value[startIndex]]);
    for (const key in data.numericProps) {
      properties[key] = data.numericProps[key].value[startIndex];
    }
    return properties;
  }
  function polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
    const { positions } = data;
    const polygonIndices = data.polygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);
    const primitivePolygonIndices = data.primitivePolygonIndices.value.filter((x) => x >= startIndex && x <= endIndex);
    const multi = polygonIndices.length > 2;
    if (!multi) {
      const coordinates2 = [];
      for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {
        const startRingIndex = primitivePolygonIndices[i];
        const endRingIndex = primitivePolygonIndices[i + 1];
        const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);
        coordinates2.push(ringCoordinates);
      }
      return { type: "Polygon", coordinates: coordinates2 };
    }
    const coordinates = [];
    for (let i = 0; i < polygonIndices.length - 1; i++) {
      const startPolygonIndex = polygonIndices[i];
      const endPolygonIndex = polygonIndices[i + 1];
      const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex).coordinates;
      coordinates.push(polygonCoordinates);
    }
    return { type: "MultiPolygon", coordinates };
  }
  function lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {
    const { positions } = data;
    const pathIndices = data.pathIndices.value.filter((x) => x >= startIndex && x <= endIndex);
    const multi = pathIndices.length > 2;
    if (!multi) {
      const coordinates2 = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);
      return { type: "LineString", coordinates: coordinates2 };
    }
    const coordinates = [];
    for (let i = 0; i < pathIndices.length - 1; i++) {
      const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);
      coordinates.push(ringCoordinates);
    }
    return { type: "MultiLineString", coordinates };
  }
  function pointToGeoJson(data, startIndex, endIndex) {
    const { positions } = data;
    const coordinates = ringToGeoJson(positions, startIndex, endIndex);
    const multi = coordinates.length > 1;
    if (multi) {
      return { type: "MultiPoint", coordinates };
    }
    return { type: "Point", coordinates: coordinates[0] };
  }
  function ringToGeoJson(positions, startIndex, endIndex) {
    startIndex = startIndex || 0;
    endIndex = endIndex || positions.value.length / positions.size;
    const ringCoordinates = [];
    for (let j = startIndex; j < endIndex; j++) {
      const coord = Array();
      for (let k = j * positions.size; k < (j + 1) * positions.size; k++) {
        coord.push(Number(positions.value[k]));
      }
      ringCoordinates.push(coord);
    }
    return ringCoordinates;
  }

  // src/layers/cluster-tile-layer.ts
  var import_core6 = __toESM(require_core2(), 1);

  // ../../node_modules/quadbin/dist/index.esm.js
  var import_tile_cover = __toESM(require_tile_cover(), 1);

  // ../../node_modules/@math.gl/web-mercator/dist/web-mercator-utils.js
  var PI = Math.PI;
  var PI_4 = PI / 4;
  var DEGREES_TO_RADIANS = PI / 180;
  var RADIANS_TO_DEGREES = 180 / PI;
  var TILE_SIZE = 512;
  function worldToLngLat(xy) {
    const [x, y] = xy;
    const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
    const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [lambda2 * RADIANS_TO_DEGREES, phi2 * RADIANS_TO_DEGREES];
  }

  // ../../node_modules/@math.gl/web-mercator/dist/get-bounds.js
  var DEGREES_TO_RADIANS2 = Math.PI / 180;

  // ../../node_modules/quadbin/dist/index.esm.js
  var B = [0x5555555555555555n, 0x3333333333333333n, 0x0f0f0f0f0f0f0f0fn, 0x00ff00ff00ff00ffn, 0x0000ffff0000ffffn, 0x00000000ffffffffn];
  var S = [0n, 1n, 2n, 4n, 8n, 16n];
  function hexToBigInt(hex3) {
    return BigInt(`0x${hex3}`);
  }
  function bigIntToHex(index2) {
    return index2.toString(16);
  }
  function tileToCell(tile) {
    if (tile.z < 0 || tile.z > 26) {
      throw new Error("Wrong zoom");
    }
    const z = BigInt(tile.z);
    let x = BigInt(tile.x) << 32n - z;
    let y = BigInt(tile.y) << 32n - z;
    for (let i = 0; i < 5; i++) {
      const s = S[5 - i];
      const b = B[4 - i];
      x = (x | x << s) & b;
      y = (y | y << s) & b;
    }
    const quadbin = 0x4000000000000000n | 1n << 59n | // | (mode << 59) | (mode_dep << 57)
    z << 52n | (x | y << 1n) >> 12n | 0xfffffffffffffn >> z * 2n;
    return quadbin;
  }
  function cellToTile(quadbin) {
    const mode = quadbin >> 59n & 7n;
    const modeDep = quadbin >> 57n & 3n;
    const z = quadbin >> 52n & 0x1fn;
    const q = (quadbin & 0xfffffffffffffn) << 12n;
    if (mode !== 1n && modeDep !== 0n) {
      throw new Error("Wrong mode");
    }
    let x = q;
    let y = q >> 1n;
    for (let i = 0; i < 6; i++) {
      const s = S[i];
      const b = B[i];
      x = (x | x >> s) & b;
      y = (y | y >> s) & b;
    }
    x = x >> 32n - z;
    y = y >> 32n - z;
    return {
      z: Number(z),
      x: Number(x),
      y: Number(y)
    };
  }
  function getResolution(quadbin) {
    return quadbin >> 52n & 0x1fn;
  }
  function cellToParent(quadbin) {
    const zparent = getResolution(quadbin) - 1n;
    const parent = quadbin & ~(0x1fn << 52n) | zparent << 52n | 0xfffffffffffffn >> zparent * 2n;
    return parent;
  }

  // src/layers/cluster-utils.ts
  var import_h3_js = __toESM(require_h3_js(), 1);
  var import_core2 = __toESM(require_core2(), 1);

  // src/utils.ts
  var import_core = __toESM(require_core2(), 1);
  function assert2(condition, message) {
    import_core.log.assert(condition, message);
  }
  function createBinaryProxy(data, index2) {
    const { properties, numericProps } = data;
    return new Proxy(properties[index2] || {}, {
      get(target, property) {
        if (property in numericProps) {
          return numericProps[property].value[index2];
        }
        return target[property];
      },
      has(target, property) {
        return property in numericProps || property in target;
      },
      ownKeys(target) {
        return [...Object.keys(numericProps), ...Reflect.ownKeys(target)];
      },
      getOwnPropertyDescriptor(target, prop) {
        return { enumerable: true, configurable: true };
      }
    });
  }
  function getWorkerUrl(id5, version) {
    return `https://unpkg.com/@deck.gl/carto@${version}/dist/${id5}-worker.js`;
  }
  var EMPTY_UINT16ARRAY = new Uint16Array();
  var EMPTY_BINARY_PROPS = {
    positions: { value: new Float32Array(), size: 2 },
    properties: [],
    numericProps: {},
    featureIds: { value: EMPTY_UINT16ARRAY, size: 1 },
    globalFeatureIds: { value: EMPTY_UINT16ARRAY, size: 1 }
  };
  function createEmptyBinary() {
    return {
      shape: "binary-feature-collection",
      points: {
        type: "Point",
        ...EMPTY_BINARY_PROPS
      },
      lines: {
        type: "LineString",
        pathIndices: { value: EMPTY_UINT16ARRAY, size: 1 },
        ...EMPTY_BINARY_PROPS
      },
      polygons: {
        type: "Polygon",
        polygonIndices: { value: EMPTY_UINT16ARRAY, size: 1 },
        primitivePolygonIndices: { value: EMPTY_UINT16ARRAY, size: 1 },
        ...EMPTY_BINARY_PROPS
      }
    };
  }
  function createBinaryPointFeature(positions, featureIds, globalFeatureIds, numericProps, properties, size = 2) {
    return {
      type: "Point",
      positions: { value: new Float32Array(positions), size },
      featureIds: { value: new Uint16Array(featureIds), size: 1 },
      globalFeatureIds: { value: new Uint32Array(globalFeatureIds), size: 1 },
      numericProps,
      properties
    };
  }
  function initializeNumericProps(numPoints, sourceProps) {
    const numericProps = {};
    if (sourceProps) {
      Object.keys(sourceProps).forEach((prop) => {
        numericProps[prop] = { value: new Float32Array(numPoints), size: 1 };
      });
    }
    return numericProps;
  }
  function copyNumericProps(sourceProps, targetProps, sourceIndex, targetIndex) {
    Object.keys(sourceProps).forEach((prop) => {
      targetProps[prop].value[targetIndex] = sourceProps[prop].value[sourceIndex];
    });
  }

  // src/layers/cluster-utils.ts
  function aggregateTile(tile, tileAggregationCache, aggregationLevels, properties = [], getPosition, getWeight, scheme = "quadbin") {
    if (!tile.content)
      return false;
    if (!tile.userData)
      tile.userData = {};
    const cell0 = tileAggregationCache.get(aggregationLevels)?.[0];
    if (cell0) {
      if (properties.every((property) => property.name in cell0)) {
        return false;
      }
      tileAggregationCache.clear();
    }
    const out = {};
    for (const cell of tile.content) {
      let id5 = cell.id;
      const position = typeof getPosition === "function" ? getPosition(cell, {}) : getPosition;
      for (let i = 0; i < aggregationLevels - 1; i++) {
        if (scheme === "h3") {
          const currentResolution = (0, import_h3_js.getResolution)(id5);
          id5 = (0, import_h3_js.cellToParent)(id5, Math.max(0, currentResolution - 1));
        } else {
          id5 = cellToParent(id5);
        }
      }
      const parentId = String(id5);
      if (!(parentId in out)) {
        out[parentId] = { id: id5, count: 0, position: [0, 0] };
        for (const { name, aggregation } of properties) {
          if (aggregation === "any") {
            out[parentId][name] = cell.properties[name];
          } else {
            out[parentId][name] = 0;
          }
        }
      }
      const prevTotalW = out[parentId].count;
      out[parentId].count += typeof getWeight === "function" ? getWeight(cell, {}) : getWeight;
      const totalW = out[parentId].count;
      const W = totalW - prevTotalW;
      out[parentId].position[0] = (prevTotalW * out[parentId].position[0] + W * position[0]) / totalW;
      out[parentId].position[1] = (prevTotalW * out[parentId].position[1] + W * position[1]) / totalW;
      for (const { name, aggregation } of properties) {
        const prevValue = out[parentId][name];
        const value = cell.properties[name];
        if (aggregation === "average") {
          out[parentId][name] = (prevTotalW * prevValue + W * value) / totalW;
        } else if (aggregation === "count" || aggregation === "sum") {
          out[parentId][name] = prevValue + value;
        } else if (aggregation === "max") {
          out[parentId][name] = Math.max(prevValue, value);
        } else if (aggregation === "min") {
          out[parentId][name] = Math.min(prevValue, value);
        }
      }
    }
    tileAggregationCache.set(aggregationLevels, Object.values(out));
    return true;
  }
  function extractAggregationProperties(tile) {
    const properties = [];
    const validAggregations = ["any", "average", "count", "min", "max", "sum"];
    for (const name of Object.keys(tile.content[0].properties)) {
      let aggregation = name.split("_").pop().toLowerCase();
      if (!validAggregations.includes(aggregation)) {
        import_core2.log.warn(`No valid aggregation present in ${name} property`)();
        aggregation = "any";
      }
      properties.push({ name, aggregation });
    }
    return properties;
  }
  function computeAggregationStats(data, properties) {
    const stats = {};
    for (const { name, aggregation } of properties) {
      stats[name] = { min: Infinity, max: -Infinity };
      if (aggregation !== "any") {
        for (const d of data) {
          stats[name].min = Math.min(stats[name].min, d[name]);
          stats[name].max = Math.max(stats[name].max, d[name]);
        }
      }
    }
    return stats;
  }
  function clustersToBinary(data) {
    const positions = new Float32Array(data.length * 2);
    const featureIds = new Uint16Array(data.length);
    for (let i = 0; i < data.length; i++) {
      positions.set(data[i].position, 2 * i);
      featureIds[i] = i;
    }
    return {
      ...createEmptyBinary(),
      points: createBinaryPointFeature(positions, featureIds, featureIds, {}, data)
    };
  }

  // src/constants.ts
  var DEFAULT_TILE_SIZE = 512;

  // src/layers/quadbin-tileset-2d.ts
  var import_geo_layers = __toESM(require_geo_layers(), 1);
  var QuadbinTileset2D = class extends import_geo_layers._Tileset2D {
    // @ts-expect-error for spatial indices, TileSet2d should be parametrized by TileIndexT
    getTileIndices(opts) {
      return super.getTileIndices(opts).map(tileToCell).map((q) => ({ q, i: bigIntToHex(q) }));
    }
    // @ts-expect-error TileIndex must be generic
    getTileId({ q, i }) {
      return i || bigIntToHex(q);
    }
    // @ts-expect-error TileIndex must be generic
    getTileMetadata({ q }) {
      return super.getTileMetadata(cellToTile(q));
    }
    // @ts-expect-error TileIndex must be generic
    getTileZoom({ q }) {
      return Number(getResolution(q));
    }
    // @ts-expect-error TileIndex must be generic
    getParentIndex({ q }) {
      return { q: cellToParent(q) };
    }
  };

  // src/layers/h3-tileset-2d.ts
  var import_geo_layers2 = __toESM(require_geo_layers(), 1);
  var import_h3_js2 = __toESM(require_h3_js(), 1);
  var MAX_LATITUDE2 = 85.051128;
  function padBoundingBox({ west, north, east, south }, resolution, scale = 1) {
    const corners = [
      [north, east],
      [south, east],
      [south, west],
      [north, west]
    ];
    const cornerCells = corners.map((c) => (0, import_h3_js2.latLngToCell)(c[0], c[1], resolution));
    const cornerEdgeLengths = cornerCells.map(
      (c) => Math.max(...(0, import_h3_js2.originToDirectedEdges)(c).map((e) => (0, import_h3_js2.edgeLength)(e, import_h3_js2.UNITS.rads))) * 180 / Math.PI
    );
    const bufferLat = Math.max(...cornerEdgeLengths) * scale;
    const bufferLon = Math.min(180, bufferLat / Math.cos((north + south) / 2 * Math.PI / 180));
    return {
      north: Math.min(north + bufferLat, MAX_LATITUDE2),
      east: east + bufferLon,
      south: Math.max(south - bufferLat, -MAX_LATITUDE2),
      west: west - bufferLon
    };
  }
  function getHexagonsInBoundingBox({ west, north, east, south }, resolution) {
    const longitudeSpan = Math.abs(east - west);
    if (longitudeSpan > 180) {
      const nSegments = Math.ceil(longitudeSpan / 180);
      let h3Indices = [];
      for (let s = 0; s < nSegments; s++) {
        const segmentWest = west + s * 180;
        const segmentEast = Math.min(segmentWest + 179.9999999, east);
        h3Indices = h3Indices.concat(
          getHexagonsInBoundingBox({ west: segmentWest, north, east: segmentEast, south }, resolution)
        );
      }
      return [...new Set(h3Indices)];
    }
    const polygon2 = [
      [north, east],
      [south, east],
      [south, west],
      [north, west],
      [north, east]
    ];
    return (0, import_h3_js2.polygonToCells)(polygon2, resolution);
  }
  function tileToBoundingBox(index2) {
    const coordinates = (0, import_h3_js2.cellToBoundary)(index2);
    const latitudes = coordinates.map((c) => c[0]);
    const longitudes = coordinates.map((c) => c[1]);
    const west = Math.min(...longitudes);
    const south = Math.min(...latitudes);
    const east = Math.max(...longitudes);
    const north = Math.max(...latitudes);
    const bbox2 = { west, south, east, north };
    return padBoundingBox(bbox2, (0, import_h3_js2.getResolution)(index2), 0.12);
  }
  var BIAS = 2;
  function getHexagonResolution(viewport, tileSize) {
    const zoomOffset = Math.log2(tileSize / 512);
    const hexagonScaleFactor = 2 / 3 * (viewport.zoom - zoomOffset);
    const latitudeScaleFactor = Math.log(1 / Math.cos(Math.PI * viewport.latitude / 180));
    return Math.max(0, Math.floor(hexagonScaleFactor + latitudeScaleFactor - BIAS));
  }
  var H3Tileset2D = class extends import_geo_layers2._Tileset2D {
    /**
     * Returns all tile indices in the current viewport. If the current zoom level is smaller
     * than minZoom, return an empty array. If the current zoom level is greater than maxZoom,
     * return tiles that are on maxZoom.
     */
    // @ts-expect-error Tileset2D should be generic over TileIndex
    getTileIndices({ viewport, minZoom, maxZoom }) {
      if (viewport.latitude === void 0)
        return [];
      const [west, south, east, north] = viewport.getBounds();
      const { tileSize } = this.opts;
      let z = getHexagonResolution(viewport, tileSize);
      let indices;
      if (typeof minZoom === "number" && Number.isFinite(minZoom) && z < minZoom) {
        return [];
      }
      if (typeof maxZoom === "number" && Number.isFinite(maxZoom) && z > maxZoom) {
        z = maxZoom;
        const center = (0, import_h3_js2.latLngToCell)(viewport.latitude, viewport.longitude, maxZoom);
        indices = (0, import_h3_js2.gridDisk)(center, 1);
      } else {
        const paddedBounds = padBoundingBox({ west, north, east, south }, z);
        indices = getHexagonsInBoundingBox(paddedBounds, z);
      }
      return indices.map((i) => ({ i }));
    }
    // @ts-expect-error Tileset2D should be generic over TileIndex
    getTileId({ i }) {
      return i;
    }
    // @ts-expect-error Tileset2D should be generic over TileIndex
    getTileMetadata({ i }) {
      return { bbox: tileToBoundingBox(i) };
    }
    // @ts-expect-error Tileset2D should be generic over TileIndex
    getTileZoom({ i }) {
      return (0, import_h3_js2.getResolution)(i);
    }
    // @ts-expect-error Tileset2D should be generic over TileIndex
    getParentIndex(index2) {
      const resolution = (0, import_h3_js2.getResolution)(index2.i);
      const i = (0, import_h3_js2.cellToParent)(index2.i, resolution - 1);
      return { i };
    }
  };

  // src/layers/quadbin-utils.ts
  var TILE_SIZE2 = 512;
  function quadbinToOffset(quadbin) {
    const { x, y, z } = cellToTile(quadbin);
    const scale = TILE_SIZE2 / (1 << z);
    return [x * scale, TILE_SIZE2 - y * scale, scale];
  }
  function quadbinToWorldBounds(quadbin, coverage) {
    const [xOffset, yOffset, scale] = quadbinToOffset(quadbin);
    return [
      [xOffset, yOffset],
      [xOffset + coverage * scale, yOffset - coverage * scale]
    ];
  }
  function getQuadbinPolygon(quadbin, coverage = 1) {
    const [topLeft, bottomRight] = quadbinToWorldBounds(quadbin, coverage);
    const [w, n] = worldToLngLat(topLeft);
    const [e, s] = worldToLngLat(bottomRight);
    return [e, n, e, s, w, s, w, n, e, n];
  }

  // src/layers/cluster-tile-layer.ts
  var import_h3_js3 = __toESM(require_h3_js(), 1);

  // node_modules/@loaders.gl/compression/node_modules/@loaders.gl/loader-utils/dist/lib/env-utils/globals.js
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_ = globals.self || globals.window || globals.global || {};
  var window_ = globals.window || globals.self || globals.global || {};
  var global_ = globals.global || globals.self || globals.window || {};
  var document_ = globals.document || {};
  var isBrowser = (
    // @ts-ignore process does not exist on browser
    Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser)
  );
  var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // node_modules/@loaders.gl/compression/node_modules/@loaders.gl/loader-utils/dist/lib/module-utils/js-module-utils.js
  function registerJSModules(modules) {
    globalThis.loaders ||= {};
    globalThis.loaders.modules ||= {};
    Object.assign(globalThis.loaders.modules, modules);
  }

  // node_modules/@loaders.gl/compression/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/array-buffer-utils.js
  function concatenateArrayBuffers(...sources) {
    return concatenateArrayBuffersFromArray(sources);
  }
  function concatenateArrayBuffersFromArray(sources) {
    const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
    const byteLength = sourceArrays.reduce((length2, typedArray) => length2 + typedArray.byteLength, 0);
    const result = new Uint8Array(byteLength);
    let offset = 0;
    for (const sourceArray of sourceArrays) {
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
    return result.buffer;
  }

  // node_modules/@loaders.gl/compression/node_modules/@loaders.gl/loader-utils/dist/lib/iterators/async-iteration.js
  async function concatenateArrayBuffersAsync(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator) {
      arrayBuffers.push(chunk);
    }
    return concatenateArrayBuffers(...arrayBuffers);
  }

  // node_modules/@loaders.gl/compression/node_modules/@loaders.gl/loader-utils/dist/lib/node/buffer.browser.js
  function toArrayBuffer(buffer) {
    return buffer;
  }

  // node_modules/@loaders.gl/compression/node_modules/@loaders.gl/loader-utils/dist/lib/binary-utils/memory-conversion-utils.js
  function isBuffer(value) {
    return value && typeof value === "object" && value.isBuffer;
  }
  function toArrayBuffer2(data) {
    if (isBuffer(data)) {
      return toArrayBuffer(data);
    }
    if (data instanceof ArrayBuffer) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
        return data.buffer;
      }
      return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === "string") {
      const text = data;
      const uint8Array = new TextEncoder().encode(text);
      return uint8Array.buffer;
    }
    if (data && typeof data === "object" && data._toArrayBuffer) {
      return data._toArrayBuffer();
    }
    throw new Error("toArrayBuffer");
  }

  // node_modules/@loaders.gl/compression/node_modules/@loaders.gl/loader-utils/dist/lib/node/promisify.js
  function promisify1(fn) {
    return (args) => new Promise((resolve, reject) => fn(args, (error, callbackArgs) => error ? reject(error) : resolve(callbackArgs)));
  }

  // node_modules/@loaders.gl/compression/dist/lib/compression.js
  var Compression = class {
    constructor(options) {
      this.compressBatches = this.compressBatches.bind(this);
      this.decompressBatches = this.decompressBatches.bind(this);
    }
    /** Preloads any dynamic libraries. May enable sync functions */
    async preload(modules = {}) {
      registerJSModules(modules);
      return;
    }
    /** Asynchronously compress data */
    async compress(input) {
      await this.preload();
      return this.compressSync(input);
    }
    /** Asynchronously decompress data */
    async decompress(input, size) {
      await this.preload();
      return this.decompressSync(input, size);
    }
    /** Synchronously compress data */
    compressSync(input) {
      throw new Error(`${this.name}: sync compression not supported`);
    }
    /** Synchronously compress data */
    decompressSync(input, size) {
      throw new Error(`${this.name}: sync decompression not supported`);
    }
    /** Compress batches */
    async *compressBatches(asyncIterator) {
      const input = await this.concatenate(asyncIterator);
      yield this.compress(input);
    }
    /** Decompress batches */
    async *decompressBatches(asyncIterator) {
      const input = await this.concatenate(asyncIterator);
      yield this.decompress(input);
    }
    // HELPERS
    concatenate(asyncIterator) {
      return concatenateArrayBuffersAsync(asyncIterator);
    }
    improveError(error) {
      if (!error.message.includes(this.name)) {
        error.message = `${this.name} ${error.message}`;
      }
      return error;
    }
  };

  // node_modules/@loaders.gl/compression/dist/lib/deflate-compression.js
  var import_pako = __toESM(require_pako(), 1);
  var import_zlib = __toESM(require_zlib(), 1);
  var DeflateCompression = class extends Compression {
    name = "deflate";
    extensions = [];
    contentEncodings = ["deflate"];
    isSupported = true;
    options;
    _chunks = [];
    constructor(options = {}) {
      super(options);
      this.options = options;
    }
    async compress(input) {
      if (!isBrowser && this.options.deflate?.useZlib) {
        const buffer = this.options.deflate?.gzip ? await promisify1(import_zlib.default.gzip)(input) : await promisify1(import_zlib.default.deflate)(input);
        return toArrayBuffer2(buffer);
      }
      return this.compressSync(input);
    }
    async decompress(input) {
      if (!isBrowser && this.options.deflate?.useZlib) {
        const buffer = this.options.deflate?.gzip ? await promisify1(import_zlib.default.gunzip)(input) : await promisify1(import_zlib.default.inflate)(input);
        return toArrayBuffer2(buffer);
      }
      return this.decompressSync(input);
    }
    compressSync(input) {
      if (!isBrowser && this.options.deflate?.useZlib) {
        const buffer = this.options.deflate?.gzip ? import_zlib.default.gzipSync(input) : import_zlib.default.deflateSync(input);
        return toArrayBuffer2(buffer);
      }
      const pakoOptions = this.options?.deflate || {};
      const inputArray = new Uint8Array(input);
      const deflate = this.options?.raw ? import_pako.default.deflateRaw : import_pako.default.deflate;
      return deflate(inputArray, pakoOptions).buffer;
    }
    decompressSync(input) {
      if (!isBrowser && this.options.deflate?.useZlib) {
        const buffer = this.options.deflate?.gzip ? import_zlib.default.gunzipSync(input) : import_zlib.default.inflateSync(input);
        return toArrayBuffer2(buffer);
      }
      const pakoOptions = this.options?.deflate || {};
      const inputArray = new Uint8Array(input);
      const inflate = this.options?.raw ? import_pako.default.inflateRaw : import_pako.default.inflate;
      return inflate(inputArray, pakoOptions).buffer;
    }
    async *compressBatches(asyncIterator) {
      const pakoOptions = this.options?.deflate || {};
      const pakoProcessor = new import_pako.default.Deflate(pakoOptions);
      yield* this.transformBatches(pakoProcessor, asyncIterator);
    }
    async *decompressBatches(asyncIterator) {
      const pakoOptions = this.options?.deflate || {};
      const pakoProcessor = new import_pako.default.Inflate(pakoOptions);
      yield* this.transformBatches(pakoProcessor, asyncIterator);
    }
    async *transformBatches(pakoProcessor, asyncIterator) {
      pakoProcessor.onData = this._onData.bind(this);
      pakoProcessor.onEnd = this._onEnd.bind(this);
      for await (const chunk of asyncIterator) {
        const uint8Array = new Uint8Array(chunk);
        const ok2 = pakoProcessor.push(uint8Array, false);
        if (!ok2) {
          throw new Error(`${this._getError()}write`);
        }
        const chunks2 = this._getChunks();
        yield* chunks2;
      }
      const emptyChunk = new Uint8Array(0);
      const ok = pakoProcessor.push(emptyChunk, true);
      if (!ok) {
      }
      const chunks = this._getChunks();
      yield* chunks;
    }
    _onData(chunk) {
      this._chunks.push(chunk);
    }
    _onEnd(status) {
      if (status !== 0) {
        throw new Error(this._getError(status) + this._chunks.length);
      }
    }
    _getChunks() {
      const chunks = this._chunks;
      this._chunks = [];
      return chunks;
    }
    // TODO - For some reason we don't get the error message from pako in _onEnd?
    _getError(code = 0) {
      const MESSAGES = {
        /* Z_NEED_DICT       2  */
        2: "need dictionary",
        /* Z_STREAM_END      1  */
        1: "stream end",
        /* Z_OK              0  */
        0: "",
        /* Z_ERRNO         (-1) */
        "-1": "file error",
        /* Z_STREAM_ERROR  (-2) */
        "-2": "stream error",
        /* Z_DATA_ERROR    (-3) */
        "-3": "data error",
        /* Z_MEM_ERROR     (-4) */
        "-4": "insufficient memory",
        /* Z_BUF_ERROR     (-5) */
        "-5": "buffer error",
        /* Z_VERSION_ERROR (-6) */
        "-6": "incompatible version"
      };
      return `${this.name}: ${MESSAGES[code]}`;
    }
  };

  // node_modules/@loaders.gl/compression/dist/lib/gzip-compression.js
  var GZipCompression = class extends DeflateCompression {
    name = "gzip";
    extensions = ["gz", "gzip"];
    contentEncodings = ["gzip", "x-gzip"];
    isSupported = true;
    constructor(options) {
      super({ ...options, deflate: { ...options?.gzip, gzip: true } });
    }
  };

  // src/layers/schema/fast-pbf.ts
  function readPackedTypedArray(TypedArray, pbf, obj, options) {
    const end = pbf.type === 2 ? pbf.readVarint() + pbf.pos : pbf.pos + 1;
    const data = pbf.buf.buffer.slice(pbf.pos, end);
    if (options?.compression === "gzip") {
      const compression = new GZipCompression();
      const decompressedData = compression.decompressSync(data);
      obj.value = new TypedArray(decompressedData);
    } else {
      obj.value = new TypedArray(data);
    }
    pbf.pos = end;
    return obj.value;
  }

  // src/layers/schema/carto-tile.ts
  var KeyValueObjectReader = class {
    static read(pbf, end) {
      return pbf.readFields(KeyValueObjectReader._readField, { key: "", value: null }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.key = pbf.readString();
      else if (tag === 2)
        obj.value = pbf.readString();
    }
  };
  var PropertiesReader = class {
    static read(pbf, end) {
      return pbf.readFields(PropertiesReader._readField, {}, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1) {
        const { key, value } = KeyValueObjectReader.read(pbf, pbf.readVarint() + pbf.pos);
        obj[key] = value;
      }
    }
  };
  var DoublesReader = class {
    static read(pbf, end) {
      const { value, size } = pbf.readFields(DoublesReader._readField, { value: [], size: 0 }, end);
      return { value, size };
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        readPackedTypedArray(Float64Array, pbf, obj);
      else if (tag === 2)
        obj.size = pbf.readVarint(true);
    }
  };
  var IntsReader = class {
    static read(pbf, end) {
      const { value, size } = pbf.readFields(IntsReader._readField, { value: [], size: 0 }, end);
      return { value: new Uint32Array(value), size };
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        pbf.readPackedVarint(obj.value);
      else if (tag === 2)
        obj.size = pbf.readVarint(true);
    }
  };
  var FieldsReader = class {
    static read(pbf, end) {
      return pbf.readFields(FieldsReader._readField, { id: 0 }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.id = pbf.readVarint();
    }
  };
  var NumericPropReader = class {
    static read(pbf, end) {
      return pbf.readFields(NumericPropReader._readField, { value: [] }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        readPackedTypedArray(Float64Array, pbf, obj);
    }
  };
  var NumericPropKeyValueReader = class {
    static read(pbf, end) {
      return pbf.readFields(NumericPropKeyValueReader._readField, { key: "", value: null }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.key = pbf.readString();
      else if (tag === 2)
        obj.value = NumericPropReader.read(pbf, pbf.readVarint() + pbf.pos);
    }
  };
  var PointsReader = class {
    static read(pbf, end) {
      return pbf.readFields(
        PointsReader._readField,
        {
          positions: null,
          globalFeatureIds: null,
          featureIds: null,
          properties: [],
          numericProps: {},
          fields: []
        },
        end
      );
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 2)
        obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 3)
        obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 4)
        obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
      else if (tag === 5) {
        const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
        obj.numericProps[entry.key] = entry.value;
      } else if (tag === 6)
        obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));
    }
  };
  var LinesReader = class {
    static read(pbf, end) {
      return pbf.readFields(
        LinesReader._readField,
        {
          positions: null,
          pathIndices: null,
          globalFeatureIds: null,
          featureIds: null,
          properties: [],
          numericProps: {},
          fields: []
        },
        end
      );
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 2)
        obj.pathIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 3)
        obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 4)
        obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 5)
        obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
      else if (tag === 6) {
        const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
        obj.numericProps[entry.key] = entry.value;
      } else if (tag === 7)
        obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));
    }
  };
  var PolygonsReader = class {
    static read(pbf, end) {
      return pbf.readFields(
        PolygonsReader._readField,
        {
          positions: null,
          polygonIndices: null,
          globalFeatureIds: null,
          featureIds: null,
          primitivePolygonIndices: null,
          triangles: null,
          properties: [],
          numericProps: {},
          fields: []
        },
        end
      );
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.positions = DoublesReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 2)
        obj.polygonIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 3)
        obj.globalFeatureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 4)
        obj.featureIds = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 5)
        obj.primitivePolygonIndices = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 6)
        obj.triangles = IntsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 7)
        obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
      else if (tag === 8) {
        const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
        obj.numericProps[entry.key] = entry.value;
      } else if (tag === 9)
        obj.fields.push(FieldsReader.read(pbf, pbf.readVarint() + pbf.pos));
    }
  };
  var TileReader = class {
    static read(pbf, end) {
      return pbf.readFields(TileReader._readField, { points: null, lines: null, polygons: null }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.points = PointsReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 2)
        obj.lines = LinesReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 3)
        obj.polygons = PolygonsReader.read(pbf, pbf.readVarint() + pbf.pos);
    }
  };

  // src/layers/schema/carto-spatial-tile.ts
  var IndicesReader = class {
    static read(pbf, end) {
      return pbf.readFields(IndicesReader._readField, { value: [] }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        readPackedTypedArray(BigUint64Array, pbf, obj);
    }
  };
  var CellsReader = class {
    static read(pbf, end) {
      return pbf.readFields(
        CellsReader._readField,
        { indices: null, properties: [], numericProps: {} },
        end
      );
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.indices = IndicesReader.read(pbf, pbf.readVarint() + pbf.pos);
      else if (tag === 2)
        obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
      else if (tag === 3) {
        const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
        obj.numericProps[entry.key] = entry.value;
      }
    }
  };
  var TileReader2 = class {
    static read(pbf, end) {
      return pbf.readFields(TileReader2._readField, { scheme: 0, cells: null }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.scheme = pbf.readVarint();
      else if (tag === 2)
        obj.cells = CellsReader.read(pbf, pbf.readVarint() + pbf.pos);
    }
  };

  // src/layers/schema/tile-loader-utils.ts
  var import_pbf = __toESM(require_pbf(), 1);
  function parsePbf(buffer, TileReader5) {
    const pbf = new import_pbf.default(buffer);
    const tile = TileReader5.read(pbf);
    return tile;
  }

  // src/layers/schema/spatialjson-utils.ts
  function binaryToSpatialjson(binary) {
    const { cells, scheme } = binary;
    const count = cells.indices.value.length;
    const spatial = [];
    for (let i = 0; i < count; i++) {
      const id5 = scheme === "h3" ? bigIntToHex(cells.indices.value[i]) : cells.indices.value[i];
      const properties = { ...cells.properties[i] };
      for (const key of Object.keys(cells.numericProps)) {
        properties[key] = cells.numericProps[key].value[i];
      }
      spatial.push({ id: id5, properties });
    }
    return spatial;
  }

  // src/layers/schema/carto-spatial-tile-loader.ts
  var VERSION = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var id = "cartoSpatialTile";
  var DEFAULT_OPTIONS = {
    cartoSpatialTile: {
      scheme: "quadbin",
      workerUrl: getWorkerUrl(id, VERSION)
    }
  };
  var CartoSpatialTileLoader = {
    name: "CARTO Spatial Tile",
    version: VERSION,
    id,
    module: "carto",
    extensions: ["pbf"],
    mimeTypes: ["application/vnd.carto-spatial-tile"],
    category: "geometry",
    parse: async (arrayBuffer, options) => parseCartoSpatialTile(arrayBuffer, options),
    parseSync: parseCartoSpatialTile,
    worker: true,
    options: DEFAULT_OPTIONS
  };
  function parseCartoSpatialTile(arrayBuffer, options) {
    if (!arrayBuffer)
      return null;
    const tile = parsePbf(arrayBuffer, TileReader2);
    const { cells } = tile;
    const scheme = options?.cartoSpatialTile?.scheme;
    const data = { cells, scheme };
    return binaryToSpatialjson(data);
  }
  var carto_spatial_tile_loader_default = CartoSpatialTileLoader;

  // src/layers/utils.ts
  var import_core3 = __toESM(require_core2(), 1);
  var import_core4 = __toESM(require_core2(), 1);
  function mergeLoadOptions(loadOptions, additionalOptions, depth = 0) {
    if (!loadOptions) {
      return additionalOptions;
    }
    if (!additionalOptions) {
      return loadOptions;
    }
    if (depth > 10) {
      return additionalOptions;
    }
    const result = { ...loadOptions };
    for (const key in additionalOptions) {
      const value = additionalOptions[key];
      if (value === loadOptions || value === additionalOptions) {
        continue;
      }
      if (typeof value === "object" && value !== null) {
        result[key] = mergeLoadOptions(loadOptions[key], value, depth + 1);
      } else {
        result[key] = value;
      }
    }
    return result;
  }
  function mergeBoundaryData(geometry, properties) {
    const mapping = {};
    for (const { geoid, ...rest } of properties.properties) {
      if (geoid in mapping) {
        import_core3.log.warn("Duplicate geoid key in boundary mapping, using first occurance")();
      } else {
        mapping[geoid] = rest;
      }
    }
    for (const type of ["points", "lines", "polygons"]) {
      const geom = geometry[type];
      if (geom.positions.value.length === 0) {
        continue;
      }
      geom.properties = geom.properties.map(({ geoid }) => mapping[geoid]);
      const { positions, globalFeatureIds } = geom;
      let indices = null;
      if (type === "lines")
        indices = geom.pathIndices.value;
      if (type === "polygons")
        indices = geom.polygonIndices.value;
      const length2 = positions.value.length / positions.size;
      for (const key in properties.numericProps) {
        const sourceProp = properties.numericProps[key].value;
        const TypedArray = sourceProp.constructor;
        const destProp = new TypedArray(length2);
        geom.numericProps[key] = { value: destProp, size: 1 };
        if (!indices) {
          for (let i = 0; i < length2; i++) {
            const featureId2 = globalFeatureIds.value[i];
            destProp[i] = sourceProp[featureId2];
          }
        } else {
          for (let i = 0; i < indices.length - 1; i++) {
            const startIndex = indices[i];
            const endIndex = indices[i + 1];
            const featureId2 = globalFeatureIds.value[startIndex];
            destProp.fill(sourceProp[featureId2], startIndex, endIndex);
          }
        }
      }
    }
    return geometry;
  }
  var TilejsonPropType = {
    type: "object",
    value: null,
    validate: (value, propType) => propType.optional && value === null || typeof value === "object" && Array.isArray(value.tiles) && value.tiles.every((url) => typeof url === "string"),
    equal: (value1, value2) => {
      return (0, import_core4._deepEqual)(value1, value2, 2);
    },
    async: true
  };

  // src/layers/cluster-tile-layer.ts
  (0, import_core5.registerLoaders)([carto_spatial_tile_loader_default]);
  function getScheme(tilesetClass) {
    if (tilesetClass === H3Tileset2D)
      return "h3";
    if (tilesetClass === QuadbinTileset2D)
      return "quadbin";
    throw new Error("Invalid tileset class");
  }
  var defaultProps = {
    data: TilejsonPropType,
    clusterLevel: { type: "number", value: 5, min: 1 },
    getPosition: {
      type: "accessor",
      value: ({ id: id5 }) => {
        if (typeof id5 === "string") {
          const [lat, lng] = (0, import_h3_js3.cellToLatLng)(id5);
          return [lng, lat];
        }
        return getQuadbinPolygon(id5, 0.5).slice(2, 4);
      }
    },
    getWeight: { type: "accessor", value: 1 },
    refinementStrategy: "no-overlap",
    tileSize: DEFAULT_TILE_SIZE
  };
  var ClusterGeoJsonLayer = class extends import_geo_layers3.TileLayer {
    initializeState() {
      super.initializeState();
      this.state.aggregationCache = /* @__PURE__ */ new WeakMap();
      this.state.scheme = getScheme(this.props.TilesetClass);
    }
    updateState(opts) {
      const { props } = opts;
      const scheme = getScheme(props.TilesetClass);
      if (this.state.scheme !== scheme) {
        this.setState({ scheme, tileset: null });
        this.state.aggregationCache = /* @__PURE__ */ new WeakMap();
      }
      super.updateState(opts);
    }
    // eslint-disable-next-line max-statements
    renderLayers() {
      const visibleTiles = this.state.tileset?.tiles.filter((tile) => {
        return tile.isLoaded && tile.content && this.state.tileset.isTileVisible(tile);
      });
      if (!visibleTiles?.length || !this.state.tileset) {
        return null;
      }
      visibleTiles.sort((a, b) => b.zoom - a.zoom);
      const { getPosition, getWeight } = this.props;
      const { aggregationCache, scheme } = this.state;
      const isH3 = scheme === "h3";
      const properties = extractAggregationProperties(visibleTiles[0]);
      const data = [];
      let needsUpdate = false;
      const aggregationLevels = this._getAggregationLevels(visibleTiles);
      for (const tile of visibleTiles) {
        let tileAggregationCache = aggregationCache.get(tile.content);
        if (!tileAggregationCache) {
          tileAggregationCache = /* @__PURE__ */ new Map();
          aggregationCache.set(tile.content, tileAggregationCache);
        }
        const didAggregate = aggregateTile(
          tile,
          tileAggregationCache,
          aggregationLevels,
          properties,
          getPosition,
          getWeight,
          isH3 ? "h3" : "quadbin"
        );
        needsUpdate ||= didAggregate;
        data.push(...tileAggregationCache.get(aggregationLevels));
      }
      data.sort((a, b) => Number(b.count - a.count));
      const clusterIds = data?.map((tile) => tile.id);
      needsUpdate ||= !(0, import_core6._deepEqual)(clusterIds, this.state.clusterIds, 1);
      this.setState({ clusterIds });
      if (needsUpdate) {
        const stats = computeAggregationStats(data, properties);
        const binaryData = clustersToBinary(data);
        binaryData.points.attributes = { stats };
        this.setState({ data: binaryData });
      }
      const props = {
        ...this.props,
        id: "clusters",
        data: this.state.data,
        dataComparator: (data2, oldData) => {
          const newIds = data2?.points?.properties?.map((tile) => tile.id);
          const oldIds = oldData?.points?.properties?.map((tile) => tile.id);
          return (0, import_core6._deepEqual)(newIds, oldIds, 1);
        }
      };
      return new import_layers.GeoJsonLayer(this.getSubLayerProps(props));
    }
    getPickingInfo(params) {
      const info = params.info;
      if (info.index !== -1) {
        const { data } = params.sourceLayer.props;
        info.object = binaryToGeojson(data, {
          globalFeatureId: info.index
        });
      }
      return info;
    }
    _updateAutoHighlight(info) {
      for (const layer of this.getSubLayers()) {
        layer.updateAutoHighlight(info);
      }
    }
    filterSubLayer() {
      return true;
    }
    _getAggregationLevels(visibleTiles) {
      const isH3 = this.state.scheme === "h3";
      const firstTile = visibleTiles[0];
      let tileResolution;
      let viewportResolution;
      if (isH3) {
        tileResolution = (0, import_h3_js3.getResolution)(firstTile.id);
        viewportResolution = getHexagonResolution(
          this.context.viewport,
          this.state.tileset.opts.tileSize
        );
      } else {
        tileResolution = firstTile.zoom;
        viewportResolution = this.context.viewport.zoom;
      }
      const resolutionDiff = Math.round(viewportResolution - tileResolution);
      const aggregationLevels = Math.round(this.props.clusterLevel) - resolutionDiff;
      return aggregationLevels;
    }
  };
  ClusterGeoJsonLayer.layerName = "ClusterGeoJsonLayer";
  ClusterGeoJsonLayer.defaultProps = defaultProps;
  var ClusterTileLayer = class extends import_core6.CompositeLayer {
    getLoadOptions() {
      const tileJSON = this.props.data;
      const scheme = tileJSON && "scheme" in tileJSON ? tileJSON.scheme : "quadbin";
      return mergeLoadOptions(super.getLoadOptions(), {
        fetch: { headers: { Authorization: `Bearer ${tileJSON.accessToken}` } },
        cartoSpatialTile: { scheme }
      });
    }
    renderLayers() {
      const tileJSON = this.props.data;
      if (!tileJSON)
        return null;
      const { tiles: data, maxresolution: maxZoom } = tileJSON;
      const isH3 = tileJSON && "scheme" in tileJSON && tileJSON.scheme === "h3";
      const TilesetClass = isH3 ? H3Tileset2D : QuadbinTileset2D;
      return [
        // @ts-ignore
        new ClusterGeoJsonLayer(this.props, {
          id: `cluster-geojson-layer-${this.props.id}`,
          data,
          // TODO: Tileset2D should be generic over TileIndex type
          TilesetClass,
          maxZoom,
          loadOptions: this.getLoadOptions()
        })
      ];
    }
  };
  ClusterTileLayer.layerName = "ClusterTileLayer";
  ClusterTileLayer.defaultProps = defaultProps;

  // src/layers/h3-tile-layer.ts
  var import_core8 = __toESM(require_core2(), 1);
  var import_geo_layers5 = __toESM(require_geo_layers(), 1);

  // src/layers/spatial-index-tile-layer.ts
  var import_core7 = __toESM(require_core(), 1);
  var import_geo_layers4 = __toESM(require_geo_layers(), 1);
  (0, import_core7.registerLoaders)([carto_spatial_tile_loader_default]);
  function isFeatureIdDefined(value) {
    return value !== void 0 && value !== null && value !== "";
  }
  var defaultProps2 = {
    tileSize: DEFAULT_TILE_SIZE
  };
  var SpatialIndexTileLayer = class extends import_geo_layers4.TileLayer {
    _updateAutoHighlight(info) {
      const { hoveredFeatureId } = this.state;
      const hoveredFeature = info.object;
      let newHoveredFeatureId = null;
      if (hoveredFeature) {
        newHoveredFeatureId = hoveredFeature.id;
      }
      if (hoveredFeatureId !== newHoveredFeatureId) {
        let { highlightColor } = this.props;
        if (typeof highlightColor === "function") {
          highlightColor = highlightColor(info);
        }
        this.setState({
          highlightColor,
          hoveredFeatureId: newHoveredFeatureId
        });
      }
    }
    getSubLayerPropsByTile(tile) {
      return {
        highlightedObjectIndex: this.getHighlightedObjectIndex(tile),
        highlightColor: this.state.highlightColor
      };
    }
    getHighlightedObjectIndex(tile) {
      const { hoveredFeatureId } = this.state;
      const data = tile.content;
      const isFeatureIdPresent = isFeatureIdDefined(hoveredFeatureId);
      if (!isFeatureIdPresent || !Array.isArray(data) || // Quick check for whether id is within tile. data.findIndex is expensive
      !this._featureInTile(tile, hoveredFeatureId)) {
        return -1;
      }
      return data.findIndex((feature2) => feature2.id === hoveredFeatureId);
    }
    _featureInTile(tile, featureId2) {
      const tileset = this.state.tileset;
      const tileZoom = tileset.getTileZoom(tile.index);
      const KEY = tile.index.q ? "q" : "i";
      let featureIndex = { [KEY]: featureId2 };
      let featureZoom = tileset.getTileZoom(featureIndex);
      while (!(featureZoom <= tileZoom)) {
        featureIndex = tileset.getParentIndex(featureIndex);
        featureZoom = tileset.getTileZoom(featureIndex);
      }
      return featureIndex[KEY] === tile.index[KEY];
    }
  };
  SpatialIndexTileLayer.layerName = "SpatialIndexTileLayer";
  SpatialIndexTileLayer.defaultProps = defaultProps2;

  // src/layers/h3-tile-layer.ts
  var renderSubLayers = (props) => {
    const { data } = props;
    const { index: index2 } = props.tile;
    if (!data || !data.length)
      return null;
    return new import_geo_layers5.H3HexagonLayer(props, {
      getHexagon: (d) => d.id,
      centerHexagon: index2,
      highPrecision: true
    });
  };
  var defaultProps3 = {
    data: TilejsonPropType,
    tileSize: DEFAULT_TILE_SIZE
  };
  var H3TileLayer = class extends import_core8.CompositeLayer {
    initializeState() {
      import_geo_layers5.H3HexagonLayer._checkH3Lib();
    }
    getLoadOptions() {
      const tileJSON = this.props.data;
      return mergeLoadOptions(super.getLoadOptions(), {
        fetch: { headers: { Authorization: `Bearer ${tileJSON.accessToken}` } },
        cartoSpatialTile: { scheme: "h3" }
      });
    }
    renderLayers() {
      const tileJSON = this.props.data;
      if (!tileJSON)
        return null;
      const { tiles: data } = tileJSON;
      let { minresolution, maxresolution } = tileJSON;
      if (this.props.minZoom) {
        minresolution = Math.max(
          minresolution,
          getHexagonResolution({ zoom: this.props.minZoom, latitude: 0 }, this.props.tileSize)
        );
      }
      if (this.props.maxZoom) {
        maxresolution = Math.min(
          maxresolution,
          getHexagonResolution({ zoom: this.props.maxZoom, latitude: 0 }, this.props.tileSize)
        );
      }
      const SubLayerClass = this.getSubLayerClass("spatial-index-tile", SpatialIndexTileLayer);
      return new SubLayerClass(this.props, {
        id: `h3-tile-layer-${this.props.id}`,
        data,
        // TODO: Tileset2D should be generic over TileIndex type
        TilesetClass: H3Tileset2D,
        renderSubLayers,
        // minZoom and maxZoom are H3 resolutions, however we must use this naming as that is what the Tileset2D class expects
        minZoom: minresolution,
        maxZoom: maxresolution,
        loadOptions: this.getLoadOptions()
      });
    }
  };
  H3TileLayer.layerName = "H3TileLayer";
  H3TileLayer.defaultProps = defaultProps3;

  // src/layers/heatmap-tile-layer.ts
  var import_h3_js4 = __toESM(require_h3_js(), 1);
  var import_core11 = __toESM(require_core2(), 1);
  var import_layers2 = __toESM(require_layers(), 1);

  // src/layers/heatmap.ts
  var fs = (
    /* glsl */
    `uniform heatmapUniforms {
  vec2 colorDomain;
  vec2 delta;
  float intensity;
  float opacity;
  float radiusPixels;
} heatmap;

uniform sampler2D colorTexture;

vec3 colorGradient(float value) {
  return texture(colorTexture, vec2(value, 0.5)).rgb;
}

const vec3 SHIFT = vec3(1.0, 256.0, 256.0 * 256.0);
const float MAX_VAL = SHIFT.z * 255.0;
const float SCALE = MAX_VAL / 8.0;
vec4 pack(float value) {
  return vec4(mod(vec3(value, floor(value / SHIFT.yz)), 256.0), 255.0) / 255.0;
}
float unpack(vec3 color) {
  return 255.0 * dot(color, SHIFT);
}

vec4 heatmap_sampleColor(sampler2D source, vec2 texSize, vec2 texCoord) {
  bool firstPass = (heatmap.delta.y < 0.5);
  float accumulator = 0.0;

  // Controls quality of heatmap, larger values increase quality at expense of performance
  float SUPPORT = clamp(heatmap.radiusPixels / 2.0, 8.0, 32.0);

  // Gaussian normalization parameters
  float sigma = SUPPORT / 3.0;
  float a = -0.5 / (sigma * sigma);
  float w0 = 0.3989422804014327 / sigma; // 1D normalization
  for (float t = -SUPPORT; t <= SUPPORT; t++) {
    vec2 percent = (t * heatmap.delta - 0.5) / SUPPORT;
    vec2 delta = percent * heatmap.radiusPixels / texSize;
    vec4 offsetColor = texture(source, texCoord + delta);

    // Unpack float
    float value = unpack(offsetColor.rgb);

    // Gaussian
    float weight = w0 * exp(a * t * t);
    
    accumulator += value * weight;
  }

  if (firstPass) {
    return pack(accumulator);
  }

  // Undo scaling to obtain normalized density
  float density = 10.0 * heatmap.intensity * accumulator / SCALE;
 
  // Domain also in normalized density units
  vec2 domain = heatmap.colorDomain;

  // Apply domain
  float f = (density - domain[0]) / (domain[1] - domain[0]);

  // sqrt/log scaling??
  // float f = (log(density) - log(domain[0] + 1.0)) / (log(domain[1] + 1.0) - log(domain[0] + 1.0));
  // f = sqrt(f);

  // Color map
  vec4 color = vec4(0.0);
  color.rgb = colorGradient(f);

  color.a = smoothstep(0.0, 0.1, f);
  color.a = pow(color.a, 1.0 / 2.2);
  color.a *= heatmap.opacity;

  // Use premultiplied alpha for compatibility with blending in ScreenPass
  color.rgb *= color.a;

  return color;
}
`
  );
  var heatmap = {
    name: "heatmap",
    uniformPropTypes: {
      colorDomain: { value: [0, 1] },
      delta: { value: [0, 1] },
      intensity: { value: 1, min: 0.1, max: 10 },
      opacity: { value: 1, min: 0, max: 1 },
      radiusPixels: { value: 20, min: 0, softMax: 100 }
    },
    uniformTypes: {
      colorDomain: "vec2<f32>",
      delta: "vec2<f32>",
      intensity: "f32",
      opacity: "f32",
      radiusPixels: "f32"
    },
    // @ts-ignore TODO v9.1
    getUniforms: (opts) => {
      if (!opts)
        return {};
      const {
        colorDomain = [0, 1],
        colorTexture,
        delta = [1, 0],
        intensity = 1,
        opacity = 1,
        radiusPixels = 20
      } = opts;
      return {
        colorDomain,
        colorTexture,
        delta,
        intensity,
        opacity,
        radiusPixels
      };
    },
    fs,
    passes: [
      // @ts-expect-error Seems typing in luma.gl should be Partial<>
      { sampler: true, uniforms: { delta: [1, 0] } },
      // @ts-expect-error Seems typing in luma.gl should be Partial<>
      { sampler: true, uniforms: { delta: [0, 1] } }
    ]
  };

  // src/layers/post-process-utils.ts
  var import_core9 = __toESM(require_core2(), 1);
  var TEXTURE_PROPS = {
    format: "rgba8unorm",
    width: 1,
    height: 1,
    sampler: {
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  function getPostProcessLayer(layer) {
    while (layer.parent && !layer.applyPostProcess) {
      layer = layer.parent;
    }
    return layer;
  }
  var DrawCallbackLayer = class extends import_core9.Layer {
    initializeState() {
      this.id = `draw-callback-${getPostProcessLayer(this).props.id}`;
    }
    _drawLayer() {
      getPostProcessLayer(this).applyPostProcess();
    }
  };
  DrawCallbackLayer.layerName = "DrawCallbackLayer";
  function RTTModifier(BaseLayer) {
    var _a2;
    return _a2 = class extends BaseLayer {
      draw(opts) {
        const { shaderModuleProps } = opts;
        const { picking } = shaderModuleProps;
        const postProcessLayer = getPostProcessLayer(this);
        const enableRTT = !picking.isActive && postProcessLayer.enableRTT;
        if (enableRTT) {
          postProcessLayer.enableRTT(opts);
        }
        super.draw(opts);
        if (enableRTT) {
          postProcessLayer.disableRTT();
        }
      }
    }, // @ts-expect-error typescript doesn't see static property
    _a2.layerName = `RTT-${BaseLayer.layerName}`, _a2;
  }
  function PostProcessModifier(BaseLayer, effect) {
    var _a2;
    return _a2 = class extends BaseLayer {
      initializeState(context) {
        super.initializeState(context);
        this._createTextures();
        this.internalState.postProcess = new import_core9.PostProcessEffect(effect, this.props);
        this.internalState.postProcess.setup(context);
      }
      updateState(params) {
        super.updateState(params);
        this.internalState.postProcess.setProps(this.props);
      }
      renderLayers() {
        let subLayers = super.renderLayers();
        if (!subLayers) {
          return null;
        }
        subLayers = Array.isArray(subLayers) ? subLayers : [subLayers];
        return [...subLayers, new DrawCallbackLayer()];
      }
      _createTextures() {
        const { device } = this.context;
        this.internalState.renderBuffers = [0, 1].map((i) => {
          return device.createFramebuffer({
            id: `layer-fbo-${i}`,
            colorAttachments: [device.createTexture(TEXTURE_PROPS)],
            depthStencilAttachment: "depth16unorm"
          });
        });
      }
      _resizeBuffers(opts) {
        const { shaderModuleProps } = opts;
        const { viewport } = this.context;
        const { devicePixelRatio } = shaderModuleProps.project;
        const width = devicePixelRatio * viewport.width;
        const height = devicePixelRatio * viewport.height;
        this.internalState.renderBuffers.forEach((fbo) => fbo.resize({ width, height }));
      }
      enableRTT(opts) {
        this._resizeBuffers(opts);
        this.internalState.originalRenderPass = this.context.renderPass;
        const [framebuffer] = this.internalState.renderBuffers;
        this.internalState.internalRenderPass = this.context.device.beginRenderPass({
          framebuffer,
          parameters: { viewport: [0, 0, framebuffer.width, framebuffer.height] },
          // Only clear on first render
          clearColor: this.internalState.renderInProgress ? false : [0, 0, 0, 0]
        });
        this.internalState.renderInProgress = true;
        this.context.renderPass = this.internalState.internalRenderPass;
      }
      disableRTT() {
        this.internalState.internalRenderPass.end();
        this.context.renderPass = this.internalState.originalRenderPass;
      }
      applyPostProcess() {
        if (!this.internalState.renderInProgress) {
          return;
        }
        const [inputBuffer, swapBuffer] = this.internalState.renderBuffers;
        const { framebuffer: target } = this.context.renderPass.props;
        this.internalState.postProcess.postRender({
          inputBuffer,
          swapBuffer,
          target
        });
        this.internalState.renderInProgress = false;
      }
      _finalize() {
        this.internalState.renderBuffers.forEach((fbo) => {
          fbo.destroy();
        });
        this.internalState.renderBuffers = null;
        this.internalState.postProcess.cleanup();
      }
    }, _a2.layerName = `PostProcess${BaseLayer.layerName}`, _a2;
  }
  var fs2 = (
    /* glsl */
    `vec4 copy_filterColor_ext(vec4 color, vec2 texSize, vec2 texCoord) {
  return color;
}
`
  );
  var copy = {
    name: "copy",
    fs: fs2,
    getUniforms: () => ({}),
    passes: [{ filter: true }]
  };

  // src/layers/quadbin-tile-layer.ts
  var import_core10 = __toESM(require_core2(), 1);

  // src/layers/quadbin-layer.ts
  var import_geo_layers6 = __toESM(require_geo_layers(), 1);
  var defaultProps4 = {
    getQuadbin: { type: "accessor", value: (d) => d.quadbin }
  };
  var QuadbinLayer = class extends import_geo_layers6._GeoCellLayer {
    indexToBounds() {
      const { data, extruded, getQuadbin } = this.props;
      const coverage = extruded ? 0.99 : 1;
      return {
        data,
        _normalize: false,
        positionFormat: "XY",
        getPolygon: (x, objectInfo) => getQuadbinPolygon(getQuadbin(x, objectInfo), coverage),
        updateTriggers: { getPolygon: coverage }
      };
    }
  };
  QuadbinLayer.layerName = "QuadbinLayer";
  QuadbinLayer.defaultProps = defaultProps4;

  // src/layers/quadbin-tile-layer.ts
  var renderSubLayers2 = (props) => {
    const { data } = props;
    if (!data || !data.length)
      return null;
    const isBigInt = typeof data[0].id === "bigint";
    return new QuadbinLayer(props, {
      getQuadbin: isBigInt ? (d) => d.id : (d) => hexToBigInt(d.id)
    });
  };
  var defaultProps5 = {
    data: TilejsonPropType,
    tileSize: DEFAULT_TILE_SIZE
  };
  var QuadbinTileLayer = class extends import_core10.CompositeLayer {
    getLoadOptions() {
      const tileJSON = this.props.data;
      return mergeLoadOptions(super.getLoadOptions(), {
        fetch: { headers: { Authorization: `Bearer ${tileJSON.accessToken}` } },
        cartoSpatialTile: { scheme: "quadbin" }
      });
    }
    renderLayers() {
      const tileJSON = this.props.data;
      if (!tileJSON)
        return null;
      const { tiles: data, maxresolution: maxZoom } = tileJSON;
      const SubLayerClass = this.getSubLayerClass("spatial-index-tile", SpatialIndexTileLayer);
      return new SubLayerClass(this.props, {
        id: `quadbin-tile-layer-${this.props.id}`,
        data,
        // TODO: Tileset2D should be generic over TileIndex type
        TilesetClass: QuadbinTileset2D,
        renderSubLayers: renderSubLayers2,
        maxZoom,
        loadOptions: this.getLoadOptions()
      });
    }
  };
  QuadbinTileLayer.layerName = "QuadbinTileLayer";
  QuadbinTileLayer.defaultProps = defaultProps5;

  // src/layers/heatmap-tile-layer.ts
  var defaultColorRange = [
    [255, 255, 178],
    [254, 217, 118],
    [254, 178, 76],
    [253, 141, 60],
    [240, 59, 32],
    [189, 0, 38]
  ];
  var TEXTURE_PROPS2 = {
    format: "rgba8unorm",
    dimension: "2d",
    width: 1,
    height: 1,
    sampler: {
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  function unitDensityForQuadbinCell(cell) {
    const cellResolution = Number(getResolution(cell));
    return Math.pow(4, cellResolution);
  }
  function unitDensityForH3Cell(cellId) {
    const cellResolution = Number((0, import_h3_js4.getResolution)(cellId));
    return (0, import_h3_js4.getNumCells)(cellResolution);
  }
  function colorRangeToFlatArray(colorRange) {
    const flatArray = new Uint8Array(colorRange.length * 4);
    let index2 = 0;
    for (let i = 0; i < colorRange.length; i++) {
      const color3 = colorRange[i];
      flatArray[index2++] = color3[0];
      flatArray[index2++] = color3[1];
      flatArray[index2++] = color3[2];
      flatArray[index2++] = Number.isFinite(color3[3]) ? color3[3] : 255;
    }
    return flatArray;
  }
  var uniformBlock = `uniform densityUniforms {
  float factor;
} density;
`;
  var densityUniforms = {
    name: "density",
    vs: uniformBlock,
    uniformTypes: {
      factor: "f32"
    }
  };
  var RTTSolidPolygonLayer = class extends RTTModifier(import_layers2.SolidPolygonLayer) {
    getShaders(type) {
      const shaders = super.getShaders(type);
      shaders.inject = {
        "vs:#main-end": `
      // Value from getWeight accessor
  float weight = elevations;

  // Keep "power" delivered to screen constant when tiles update
  // by outputting normalized density
  weight *= density.factor;

  // Pack float into 3 channels to pass to heatmap shader
  // SCALE value important, as we don't want to saturate
  // but also want enough definition to avoid banding
  const vec3 SHIFT = vec3(1.0, 256.0, 256.0 * 256.0);
  const float MAX_VAL = SHIFT.z * 255.0;
  const float SCALE = MAX_VAL / 8.0;
  weight *= SCALE;
  weight = clamp(weight, 0.0, MAX_VAL);
  vColor = vec4(mod(vec3(weight, floor(weight / SHIFT.yz)), 256.0), 255.0) / 255.0;
`
      };
      shaders.modules = [...shaders.modules, densityUniforms];
      return shaders;
    }
    draw(opts) {
      const cell = this.props.data[0];
      if (cell) {
        const maxDensity = this.props.elevationScale;
        const { scheme } = this.parent.parent.parent.parent.parent.state;
        const unitDensity = scheme === "h3" ? unitDensityForH3Cell(cell.id) : unitDensityForQuadbinCell(cell.id);
        const densityProps = { factor: unitDensity / maxDensity };
        for (const model of this.state.models) {
          model.shaderInputs.setProps({ density: densityProps });
        }
      }
      super.draw(opts);
    }
  };
  RTTSolidPolygonLayer.layerName = "RTTSolidPolygonLayer";
  var PostProcessQuadbinTileLayer = PostProcessModifier(QuadbinTileLayer, heatmap);
  var PostProcessH3TileLayer = PostProcessModifier(H3TileLayer, heatmap);
  var defaultProps6 = {
    data: TilejsonPropType,
    getWeight: { type: "accessor", value: 1 },
    onMaxDensityChange: { type: "function", optional: true, value: null },
    colorDomain: { type: "array", value: [0, 1] },
    colorRange: defaultColorRange,
    intensity: { type: "number", value: 1 },
    radiusPixels: { type: "number", min: 0, max: 100, value: 20 }
  };
  var HeatmapTileLayer = class extends import_core11.CompositeLayer {
    initializeState() {
      this.state = {
        isLoaded: false,
        scheme: null,
        tiles: /* @__PURE__ */ new Set(),
        viewportChanged: false
      };
    }
    shouldUpdateState({ changeFlags }) {
      const { viewportChanged } = changeFlags;
      this.setState({ viewportChanged });
      return changeFlags.somethingChanged;
    }
    updateState(opts) {
      const { props, oldProps } = opts;
      super.updateState(opts);
      if (!(0, import_core11._deepEqual)(props.colorRange, oldProps.colorRange, 2)) {
        this._updateColorTexture(opts);
      }
      const scheme = props.data && "scheme" in props.data ? props.data.scheme : null;
      if (this.state.scheme !== scheme) {
        this.setState({ scheme });
        this.state.tiles.clear();
      }
    }
    renderLayers() {
      const {
        data,
        getWeight,
        colorDomain,
        intensity,
        radiusPixels,
        _subLayerProps,
        updateTriggers,
        onMaxDensityChange,
        onViewportLoad,
        onTileLoad,
        onTileUnload,
        ...tileLayerProps
      } = this.props;
      const isH3 = this.state.scheme === "h3";
      const cellLayerName = isH3 ? "hexagon-cell-hifi" : "cell";
      const subLayerProps = {
        ..._subLayerProps,
        [cellLayerName]: {
          ..._subLayerProps?.[cellLayerName],
          _subLayerProps: {
            ..._subLayerProps?.[cellLayerName]?._subLayerProps,
            fill: {
              ..._subLayerProps?.[cellLayerName]?._subLayerProps?.fill,
              type: RTTSolidPolygonLayer
            }
          }
        }
      };
      let tileZ = 0;
      let maxDensity = 0;
      const loadedTiles = [...this.state.tiles].filter((t) => t.content);
      const visibleTiles = loadedTiles.filter((t) => t.isVisible);
      const tiles3 = visibleTiles.length ? visibleTiles : loadedTiles;
      for (const tile of tiles3) {
        const cell = tile.content[0];
        const unitDensity = isH3 ? unitDensityForH3Cell(cell.id) : unitDensityForQuadbinCell(cell.id);
        maxDensity = Math.max(tile.userData.maxWeight * unitDensity, maxDensity);
        tileZ = Math.max(tile.zoom, tileZ);
      }
      let overzoom;
      let estimatedGrowthFactor;
      if (isH3) {
        overzoom = 2 / 3 * this.context.viewport.zoom - tileZ - 2.25;
        estimatedGrowthFactor = 2.2;
      } else {
        overzoom = this.context.viewport.zoom - tileZ;
        estimatedGrowthFactor = 2;
      }
      maxDensity = maxDensity * Math.pow(estimatedGrowthFactor, overzoom);
      if (typeof onMaxDensityChange === "function") {
        onMaxDensityChange(maxDensity);
      }
      const PostProcessTileLayer2 = isH3 ? PostProcessH3TileLayer : PostProcessQuadbinTileLayer;
      const layerProps = isH3 ? tileLayerProps : tileLayerProps;
      return new PostProcessTileLayer2(
        layerProps,
        this.getSubLayerProps({
          id: "heatmap",
          data,
          // Re-use existing props to pass down values to sublayer
          // TODO replace with custom layer
          getFillColor: 0,
          getElevation: getWeight,
          elevationScale: maxDensity,
          colorDomain,
          radiusPixels,
          intensity,
          _subLayerProps: subLayerProps,
          refinementStrategy: "no-overlap",
          colorTexture: this.state.colorTexture,
          // Disable line rendering
          extruded: false,
          stroked: false,
          updateTriggers: {
            getElevation: updateTriggers.getWeight
          },
          // Tile stats
          onViewportLoad: (tiles4) => {
            this.setState({ isLoaded: true });
            if (typeof onViewportLoad === "function") {
              onViewportLoad(tiles4);
            }
          },
          onTileLoad: (tile) => {
            let maxWeight = -Infinity;
            if (typeof getWeight !== "function") {
              maxWeight = getWeight;
            } else if (tile.content) {
              for (const d of tile.content) {
                maxWeight = Math.max(getWeight(d, {}), maxWeight);
              }
            }
            tile.userData = { maxWeight };
            this.state.tiles.add(tile);
            if (typeof onTileLoad === "function") {
              onTileLoad(tile);
            }
          },
          onTileUnload: (tile) => {
            this.state.tiles.delete(tile);
            if (typeof onTileUnload === "function") {
              onTileUnload(tile);
            }
          },
          transitions: { elevationScale: { type: "spring", stiffness: 0.3, damping: 0.5 } }
        })
      );
    }
    _updateColorTexture(opts) {
      const { colorRange } = opts.props;
      let { colorTexture } = this.state;
      const colors = colorRangeToFlatArray(colorRange);
      colorTexture?.destroy();
      colorTexture = this.context.device.createTexture({
        ...TEXTURE_PROPS2,
        data: colors,
        width: colorRange.length,
        height: 1
      });
      this.setState({ colorTexture });
    }
  };
  HeatmapTileLayer.layerName = "HeatmapTileLayer";
  HeatmapTileLayer.defaultProps = defaultProps6;
  var heatmap_tile_layer_default = HeatmapTileLayer;

  // src/layers/point-label-layer.ts
  var import_core12 = __toESM(require_core2(), 1);
  var import_layers3 = __toESM(require_layers(), 1);
  var [LEFT, TOP, RIGHT, BOTTOM] = [0, 1, 2, 3];
  var EnhancedTextBackgroundLayer = class extends import_layers3._TextBackgroundLayer {
    getShaders() {
      const shaders = super.getShaders();
      let vs = shaders.vs;
      vs = vs.replaceAll("textBackground.padding.", "_padding.");
      vs = vs.replace(
        "void main(void) {",
        "void main(void) {\n  vec4 _padding = textBackground.padding + instancePixelOffsets.xyxy * vec4(1.0, 1.0, -1.0, -1.0);"
      );
      return { ...shaders, vs };
    }
  };
  EnhancedTextBackgroundLayer.layerName = "EnhancedTextBackgroundLayer";
  var EnhancedTextLayer = class extends import_layers3.TextLayer {
    filterSubLayer({ layer, renderPass }) {
      const background = layer.id.includes("primary-background");
      if (renderPass === "collision") {
        return background;
      }
      return !background;
    }
  };
  EnhancedTextLayer.layerName = "EnhancedTextLayer";
  var defaultProps7 = {
    ...import_layers3.TextLayer.defaultProps,
    getRadius: { type: "accessor", value: 1 },
    radiusScale: { type: "number", min: 0, value: 1 }
  };
  var PointLabelLayer = class extends import_core12.CompositeLayer {
    calculatePixelOffset(secondary) {
      const {
        getTextAnchor: anchor,
        getAlignmentBaseline: alignment,
        getRadius,
        getSecondaryText,
        radiusScale,
        secondarySizeScale,
        sizeScale
      } = this.props;
      const xMult = anchor === "middle" ? 0 : anchor === "start" ? 1 : -1;
      const yMult = alignment === "center" ? 0 : alignment === "bottom" ? 1 : -1;
      const xPadding = sizeScale / 4;
      const yPadding = sizeScale * (1 + 1 / 4);
      const secondaryOffset = 0.6 * (1 - yMult) * sizeScale;
      let yOffset = secondary ? secondaryOffset : 0;
      if (anchor === "middle" && alignment === "top" && getSecondaryText) {
        yOffset -= secondaryOffset;
        yOffset -= secondarySizeScale;
        yOffset += sizeScale;
      }
      const radiusPadding = 1 + 1 / 4;
      return typeof getRadius === "function" ? (d, info) => {
        const r = (info ? getRadius(d, info) : 1) * radiusScale * radiusPadding;
        return [xMult * (r + xPadding), yMult * (r + yPadding) + yOffset];
      } : [
        xMult * (getRadius * radiusScale * radiusPadding + xPadding),
        yMult * (getRadius * radiusScale * radiusPadding + yPadding) + yOffset
      ];
    }
    calculateBackgroundPadding() {
      const { getTextAnchor: anchor, getAlignmentBaseline: alignment, sizeScale } = this.props;
      const paddingX = 12 * sizeScale;
      const paddingY = 3 * sizeScale;
      const backgroundPadding = [0, 0, 0, 0];
      if (alignment === "top") {
        backgroundPadding[TOP] = paddingY;
      } else if (alignment === "bottom") {
        backgroundPadding[BOTTOM] = paddingY;
      } else {
        backgroundPadding[TOP] = 0.5 * paddingY;
        backgroundPadding[BOTTOM] = 0.5 * paddingY;
      }
      if (anchor === "start") {
        backgroundPadding[LEFT] = paddingX;
      } else if (anchor === "end") {
        backgroundPadding[RIGHT] = paddingX;
      } else {
        backgroundPadding[LEFT] = 0.5 * paddingX;
        backgroundPadding[RIGHT] = 0.5 * paddingX;
      }
      return backgroundPadding;
    }
    renderTextLayer(id5, { updateTriggers: updateTriggersOverride = {}, ...props }) {
      const {
        data,
        characterSet,
        fontFamily,
        fontSettings,
        fontWeight,
        outlineColor,
        outlineWidth,
        sizeScale,
        radiusScale,
        getAlignmentBaseline,
        getColor,
        getPosition,
        getTextAnchor,
        updateTriggers
      } = this.props;
      if (sizeScale < 2) {
        const propName = this.parent?.props?.textSizeScale ? "textSizeScale" : "sizeScale";
        import_core12.log.warn(
          `${propName} has small value (${sizeScale}). Note getTextSize is not supported on PointLabelLayer`
        )();
      }
      return new EnhancedTextLayer(
        this.getSubLayerProps({
          id: id5,
          data,
          characterSet,
          fontFamily,
          fontSettings,
          fontWeight,
          outlineColor,
          outlineWidth,
          sizeScale,
          getAlignmentBaseline,
          getColor,
          getPosition,
          getTextAnchor,
          updateTriggers: {
            ...updateTriggers,
            ...updateTriggersOverride,
            getPixelOffset: [
              updateTriggers.getRadius,
              updateTriggers.getTextAnchor,
              updateTriggers.getAlignmentBaseline,
              radiusScale,
              sizeScale
            ]
          }
        }),
        {
          getSize: 1,
          _subLayerProps: { background: { type: EnhancedTextBackgroundLayer } }
        },
        props
      );
    }
    renderLayers() {
      const {
        getText,
        getSecondaryColor,
        getSecondaryText,
        secondaryOutlineColor,
        secondarySizeScale,
        updateTriggers
      } = this.props;
      const getPixelOffset = this.calculatePixelOffset(false);
      const backgroundPadding = this.calculateBackgroundPadding();
      const out = [
        // Text doesn't update via updateTrigger for some reason
        this.renderTextLayer(`${updateTriggers.getText}-primary`, {
          backgroundPadding,
          getText,
          getPixelOffset,
          background: true
          // Only use background for primary label for faster collisions
        }),
        Boolean(getSecondaryText) && this.renderTextLayer(`${updateTriggers.getSecondaryText}-secondary`, {
          getText: getSecondaryText,
          getPixelOffset: this.calculatePixelOffset(true),
          getAlignmentBaseline: "top",
          // updateTriggers: {getText: updateTriggers.getSecondaryText},
          // Optional overrides
          ...getSecondaryColor && { getColor: getSecondaryColor },
          ...secondarySizeScale && { sizeScale: secondarySizeScale },
          ...secondaryOutlineColor && { outlineColor: secondaryOutlineColor }
        })
      ];
      return out;
    }
  };
  PointLabelLayer.layerName = "PointLabelLayer";
  PointLabelLayer.defaultProps = defaultProps7;

  // src/layers/raster-tile-layer.ts
  var import_core14 = __toESM(require_core2(), 1);

  // src/layers/raster-layer.ts
  var import_core13 = __toESM(require_core2(), 1);
  var import_layers4 = __toESM(require_layers(), 1);

  // src/layers/raster-layer-vertex.glsl.ts
  var raster_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME raster-layer-vertex-shader

in vec3 positions;
in vec3 normals;

in float instanceElevations;
in vec4 instanceFillColors;
in vec4 instanceLineColors;

in vec3 instancePickingColors;

// Result
out vec4 vColor;
#ifdef FLAT_SHADING
out vec4 position_commonspace;
#endif

void main(void) {
  // Rather than positioning using attribute, layout pixel grid using gl_InstanceID
  vec2 tileOrigin = column.offset.xy;
  float scale = column.widthScale; // Re-use widthScale prop to pass cell scale

  int yIndex = - (gl_InstanceID / BLOCK_WIDTH);
  int xIndex = gl_InstanceID + (yIndex * BLOCK_WIDTH);

  // Avoid precision issues by applying 0.5 offset here, rather than when laying out vertices
  vec2 cellCenter = scale * vec2(float(xIndex) + 0.5, float(yIndex) - 0.5);

  vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;

  // if alpha == 0.0 or z < 0.0, do not render element
  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
  float cellWidth = column.coverage * scale;

  // Get position directly from quadbin, rather than projecting
  // Important to set geometry.position before using project_ methods below
  // as geometry.worldPosition is not set (we don't know our lat/long)
  geometry.position = vec4(tileOrigin, 0.0, 1.0);
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    geometry.position.xyz -= project.commonOrigin;
  }

  // Important to apply after tileOrigin & commonOrigin as they are large values which often
  // cancel and thus cellCenter precision is lost if applied first.
  geometry.position.xy += cellCenter;

  // calculate elevation, if 3d not enabled set to 0
  // cylindar geometry height are between -1.0 to 1.0, transform it to between 0, 1
  float elevation = 0.0;
  // calculate stroke offset
  float strokeOffsetRatio = 1.0;

  if (column.extruded) {
    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
  } else if (column.stroked) {
    float halfOffset = project_pixel_size(column.widthScale) / cellWidth;
    if (column.isStroke) {
      strokeOffsetRatio -= sign(positions.z) * halfOffset;
    } else {
      strokeOffsetRatio -= halfOffset;
    }
  }

  geometry.pickingColor = instancePickingColors;

  // Cell coordinates centered on origin
  vec2 base = positions.xy * scale * strokeOffsetRatio * column.coverage * shouldRender;
  vec3 cell = vec3(base, project_size(elevation));
  DECKGL_FILTER_SIZE(cell, geometry);

  geometry.position.xyz += cell;
  gl_Position = project_common_position_to_clipspace(geometry.position);

  geometry.normal = project_normal(normals);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  // Light calculations
  if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
    position_commonspace = geometry.position;
    vColor = vec4(color.rgb, color.a * layer.opacity);
#else
    vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
    vColor = vec4(lightColor, color.a * layer.opacity);
#endif
  } else {
    vColor = vec4(color.rgb, color.a * layer.opacity);
  }

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`;

  // src/layers/raster-layer.ts
  var defaultProps8 = {
    ...import_layers4.ColumnLayer.defaultProps,
    extruded: false,
    diskResolution: 4,
    vertices: [
      [-0.5, -0.5],
      [0.5, -0.5],
      [0.5, 0.5],
      [-0.5, 0.5]
    ]
  };
  var RasterColumnLayer = class extends RTTModifier(import_layers4.ColumnLayer) {
    getShaders() {
      const shaders = super.getShaders();
      const data = this.props.data;
      const BLOCK_WIDTH = data.data.blockSize ?? Math.sqrt(data.length);
      return { ...shaders, defines: { ...shaders.defines, BLOCK_WIDTH }, vs: raster_layer_vertex_glsl_default };
    }
    initializeState() {
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        instanceElevations: {
          size: 1,
          transition: true,
          accessor: "getElevation"
        },
        instanceFillColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getFillColor",
          defaultValue: [0, 0, 0, 255]
        },
        instanceLineColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getLineColor",
          defaultValue: [255, 255, 255, 255]
        }
      });
    }
  };
  RasterColumnLayer.layerName = "RasterColumnLayer";
  function wrappedDataComparator(oldData, newData) {
    return oldData.data === newData.data && oldData.length === newData.length;
  }
  var RasterLayer = class extends import_core13.CompositeLayer {
    renderLayers() {
      const {
        data,
        getElevation,
        getFillColor,
        getLineColor,
        getLineWidth,
        tileIndex,
        updateTriggers
      } = this.props;
      if (!data || !tileIndex || data.length === 0)
        return null;
      const blockSize = data.blockSize ?? 0;
      const [xOffset, yOffset, scale] = quadbinToOffset(tileIndex);
      const offset = [xOffset, yOffset];
      const lineWidthScale = scale / blockSize;
      const CellLayer = this.getSubLayerClass("column", RasterColumnLayer);
      const { highlightedObjectIndex, highlightColor } = this.state;
      return new CellLayer(
        this.props,
        this.getSubLayerProps({
          id: "cell",
          updateTriggers,
          getElevation: this.getSubLayerAccessor(getElevation),
          getFillColor: this.getSubLayerAccessor(getFillColor),
          getLineColor: this.getSubLayerAccessor(getLineColor),
          getLineWidth: this.getSubLayerAccessor(getLineWidth)
        }),
        {
          data: {
            data,
            // Pass through data for getSubLayerAccessor()
            length: blockSize * blockSize
          },
          dataComparator: wrappedDataComparator,
          offset,
          lineWidthScale,
          // Re-use widthScale prop to pass cell scale,
          highlightedObjectIndex,
          highlightColor
        }
      );
    }
    getSubLayerAccessor(accessor) {
      if (typeof accessor !== "function") {
        return super.getSubLayerAccessor(accessor);
      }
      return (object, info) => {
        const { data, index: index2 } = info;
        const binaryData = data.data;
        const proxy = createBinaryProxy(binaryData.cells, index2);
        return accessor({ properties: proxy }, info);
      };
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      if (info.index !== -1) {
        info.object = this.getSubLayerAccessor((x) => x)(void 0, {
          data: this.props,
          index: info.index
        });
      }
      return info;
    }
    _updateAutoHighlight(info) {
      const { highlightedObjectIndex } = this.state;
      let newHighlightedObjectIndex = -1;
      if (info.index !== -1) {
        newHighlightedObjectIndex = info.index;
      }
      if (highlightedObjectIndex !== newHighlightedObjectIndex) {
        let { highlightColor } = this.props;
        if (typeof highlightColor === "function") {
          highlightColor = highlightColor(info);
        }
        this.setState({
          highlightColor,
          highlightedObjectIndex: newHighlightedObjectIndex
        });
      }
    }
  };
  RasterLayer.layerName = "RasterLayer";
  RasterLayer.defaultProps = defaultProps8;

  // src/layers/raster-tile-layer.ts
  var import_geo_layers7 = __toESM(require_geo_layers(), 1);
  var import_core15 = __toESM(require_core(), 1);

  // src/layers/schema/carto-raster-tile.ts
  var ARRAY_TYPES = {
    uint8: Uint8Array,
    uint16: Uint16Array,
    uint32: Uint32Array,
    uint64: BigUint64Array,
    int8: Int8Array,
    int16: Int16Array,
    int32: Int32Array,
    int64: BigInt64Array,
    float32: Float32Array,
    float64: Float64Array
  };
  var BandReader = class {
    static read(pbf, end) {
      return pbf.readFields(BandReader._readField, { name: "", type: "", data: null }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.name = pbf.readString();
      else if (tag === 2)
        obj.type = pbf.readString();
      else if (tag === 3) {
        const TypedArray = ARRAY_TYPES[obj.type];
        if (!TypedArray) {
          throw Error(`Invalid data type: ${obj.type}`);
        }
        obj.data = {};
        const { compression } = TileReader3;
        readPackedTypedArray(TypedArray, pbf, obj.data, { compression });
      }
    }
  };
  var TileReader3 = class {
    static read(pbf, end) {
      return pbf.readFields(TileReader3._readField, { blockSize: 0, bands: [] }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.blockSize = pbf.readVarint();
      else if (tag === 2)
        obj.bands.push(BandReader.read(pbf, pbf.readVarint() + pbf.pos));
    }
  };

  // src/layers/schema/carto-raster-tile-loader.ts
  var VERSION2 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var id2 = "cartoRasterTile";
  var DEFAULT_OPTIONS2 = {
    cartoRasterTile: {
      metadata: null,
      workerUrl: getWorkerUrl(id2, VERSION2)
    }
  };
  var CartoRasterTileLoader = {
    name: "CARTO Raster Tile",
    version: VERSION2,
    id: id2,
    module: "carto",
    extensions: ["pbf"],
    mimeTypes: ["application/vnd.carto-raster-tile"],
    category: "geometry",
    parse: async (arrayBuffer, options) => parseCartoRasterTile(arrayBuffer, options),
    parseSync: parseCartoRasterTile,
    worker: true,
    options: DEFAULT_OPTIONS2
  };
  function parseCartoRasterTile(arrayBuffer, options) {
    const metadata = options?.cartoRasterTile?.metadata;
    if (!arrayBuffer || !metadata)
      return null;
    TileReader3.compression = metadata.compression;
    const out = parsePbf(arrayBuffer, TileReader3);
    const { bands, blockSize } = out;
    const numericProps = {};
    for (let i = 0; i < bands.length; i++) {
      const { name, data } = bands[i];
      numericProps[name] = data;
    }
    return { blockSize, cells: { numericProps, properties: [] } };
  }
  var carto_raster_tile_loader_default = CartoRasterTileLoader;

  // src/layers/raster-tile-layer.ts
  (0, import_core15.registerLoaders)([carto_raster_tile_loader_default]);
  var renderSubLayers3 = (props) => {
    const tileIndex = props.tile?.index?.q;
    if (!tileIndex)
      return null;
    return new RasterLayer(props, { tileIndex });
  };
  var defaultProps9 = {
    data: TilejsonPropType,
    refinementStrategy: "no-overlap",
    tileSize: DEFAULT_TILE_SIZE
  };
  var PostProcessTileLayer = class extends PostProcessModifier(import_geo_layers7.TileLayer, copy) {
    filterSubLayer(context) {
      const { tile } = context.layer.props;
      if (!tile)
        return true;
      return super.filterSubLayer(context);
    }
  };
  var RasterTileLayer = class extends import_core14.CompositeLayer {
    getLoadOptions() {
      const tileJSON = this.props.data;
      return mergeLoadOptions(super.getLoadOptions(), {
        fetch: { headers: { Authorization: `Bearer ${tileJSON.accessToken}` } }
      });
    }
    renderLayers() {
      const tileJSON = this.props.data;
      if (!tileJSON)
        return null;
      const { tiles: data, minzoom: minZoom, maxzoom: maxZoom, raster_metadata: metadata } = tileJSON;
      const SubLayerClass = this.getSubLayerClass("tile", PostProcessTileLayer);
      const loadOptions = this.getLoadOptions();
      return new SubLayerClass(this.props, {
        id: `raster-tile-layer-${this.props.id}`,
        data,
        // TODO: Tileset2D should be generic over TileIndex type
        TilesetClass: QuadbinTileset2D,
        renderSubLayers: renderSubLayers3,
        minZoom,
        maxZoom,
        loadOptions: {
          ...loadOptions,
          cartoRasterTile: { ...loadOptions?.cartoRasterTile, metadata }
        }
      });
    }
  };
  RasterTileLayer.layerName = "RasterTileLayer";
  RasterTileLayer.defaultProps = defaultProps9;

  // src/layers/vector-tile-layer.ts
  var import_core16 = __toESM(require_core(), 1);

  // src/layers/schema/carto-properties-tile.ts
  var TileReader4 = class {
    static read(pbf, end) {
      return pbf.readFields(TileReader4._readField, { properties: [], numericProps: {} }, end);
    }
    static _readField(tag, obj, pbf) {
      if (tag === 1)
        obj.properties.push(PropertiesReader.read(pbf, pbf.readVarint() + pbf.pos));
      else if (tag === 2) {
        const entry = NumericPropKeyValueReader.read(pbf, pbf.readVarint() + pbf.pos);
        obj.numericProps[entry.key] = entry.value;
      }
    }
  };

  // src/layers/schema/carto-properties-tile-loader.ts
  var VERSION3 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var id3 = "cartoPropertiesTile";
  var DEFAULT_OPTIONS3 = {
    cartoPropertiesTile: {
      workerUrl: getWorkerUrl(id3, VERSION3)
    }
  };
  var CartoPropertiesTileLoader = {
    name: "CARTO Properties Tile",
    version: VERSION3,
    id: id3,
    module: "carto",
    extensions: ["pbf"],
    mimeTypes: ["application/vnd.carto-properties-tile"],
    category: "geometry",
    worker: true,
    parse: async (arrayBuffer, options) => parseCartoPropertiesTile(arrayBuffer, options),
    parseSync: parseCartoPropertiesTile,
    options: DEFAULT_OPTIONS3
  };
  function parseCartoPropertiesTile(arrayBuffer, options) {
    if (!arrayBuffer)
      return null;
    return parsePbf(arrayBuffer, TileReader4);
  }
  var carto_properties_tile_loader_default = CartoPropertiesTileLoader;

  // src/layers/schema/carto-vector-tile-loader.ts
  var import_earcut = __toESM(require_earcut(), 1);
  var VERSION4 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "latest";
  var id4 = "cartoVectorTile";
  var DEFAULT_OPTIONS4 = {
    cartoVectorTile: {
      workerUrl: getWorkerUrl(id4, VERSION4)
    }
  };
  var CartoVectorTileLoader = {
    name: "CARTO Vector Tile",
    version: VERSION4,
    id: id4,
    module: "carto",
    extensions: ["pbf"],
    mimeTypes: ["application/vnd.carto-vector-tile"],
    category: "geometry",
    parse: async (arrayBuffer, options) => parseCartoVectorTile(arrayBuffer, options),
    parseSync: parseCartoVectorTile,
    worker: true,
    options: DEFAULT_OPTIONS4
  };
  function triangulatePolygon(polygons, target, {
    startPosition,
    endPosition,
    indices
  }) {
    const coordLength = polygons.positions.size;
    const start = startPosition * coordLength;
    const end = endPosition * coordLength;
    const polygonPositions = polygons.positions.value.subarray(start, end);
    const holes = indices.slice(1).map((n) => n - startPosition);
    const triangles = (0, import_earcut.default)(polygonPositions, holes, coordLength);
    for (let t = 0, tl = triangles.length; t < tl; ++t) {
      target.push(startPosition + triangles[t]);
    }
  }
  function triangulate(polygons) {
    const { polygonIndices, primitivePolygonIndices } = polygons;
    const triangles = [];
    let rangeStart = 0;
    for (let i = 0; i < polygonIndices.value.length - 1; i++) {
      const startPosition = polygonIndices.value[i];
      const endPosition = polygonIndices.value[i + 1];
      const rangeEnd = primitivePolygonIndices.value.indexOf(endPosition);
      const indices = primitivePolygonIndices.value.subarray(rangeStart, rangeEnd);
      rangeStart = rangeEnd;
      triangulatePolygon(polygons, triangles, { startPosition, endPosition, indices });
    }
    polygons.triangles = { value: new Uint32Array(triangles), size: 1 };
  }
  function parseCartoVectorTile(arrayBuffer, options) {
    if (!arrayBuffer)
      return null;
    const tile = parsePbf(arrayBuffer, TileReader);
    if (tile.polygons && !tile.polygons.triangles) {
      triangulate(tile.polygons);
    }
    return tile;
  }
  var carto_vector_tile_loader_default = CartoVectorTileLoader;

  // src/layers/vector-tile-layer.ts
  var import_extensions = __toESM(require_extensions(), 1);
  var import_geo_layers8 = __toESM(require_geo_layers(), 1);
  var import_layers5 = __toESM(require_layers(), 1);

  // src/layers/label-utils.ts
  function createPointsFromLines(lines, uniqueIdProperty) {
    const hasNumericUniqueId = uniqueIdProperty ? uniqueIdProperty in lines.numericProps : false;
    const idToLineInfo = /* @__PURE__ */ new Map();
    for (let i = 0; i < lines.pathIndices.value.length - 1; i++) {
      const pathIndex = lines.pathIndices.value[i];
      const featureId2 = lines.featureIds.value[pathIndex];
      let uniqueId;
      if (uniqueIdProperty === void 0) {
        uniqueId = featureId2;
      } else if (hasNumericUniqueId) {
        uniqueId = lines.numericProps[uniqueIdProperty].value[pathIndex];
      } else if (lines.properties[featureId2] && uniqueIdProperty in lines.properties[featureId2]) {
        uniqueId = lines.properties[featureId2][uniqueIdProperty];
      } else {
        uniqueId = void 0;
      }
      const length2 = getLineLength(lines, i);
      if (!idToLineInfo.has(uniqueId) || length2 > idToLineInfo.get(uniqueId).length) {
        idToLineInfo.set(uniqueId, { index: i, length: length2 });
      }
    }
    const positions = [];
    const properties = [];
    const featureIds = [];
    const globalFeatureIds = [];
    const numericProps = initializeNumericProps(idToLineInfo.size, lines.numericProps);
    let pointIndex = 0;
    for (const [_, { index: index2 }] of idToLineInfo) {
      const midpoint = getLineMidpoint(lines, index2);
      positions.push(...midpoint);
      const pathIndex = lines.pathIndices.value[index2];
      const featureId2 = lines.featureIds.value[pathIndex];
      featureIds.push(pointIndex);
      properties.push(lines.properties[featureId2]);
      globalFeatureIds.push(lines.globalFeatureIds.value[pathIndex]);
      copyNumericProps(lines.numericProps, numericProps, pathIndex, pointIndex);
      pointIndex++;
    }
    return createBinaryPointFeature(
      positions,
      featureIds,
      globalFeatureIds,
      numericProps,
      properties
    );
  }
  function createPointsFromPolygons(polygons, tileBbox, props) {
    const { west, south, east, north } = tileBbox;
    const tileArea = (east - west) * (north - south);
    const minPolygonArea = tileArea * 1e-4;
    const positions = [];
    const properties = [];
    const featureIds = [];
    const globalFeatureIds = [];
    const numericProps = initializeNumericProps(
      polygons.polygonIndices.value.length - 1,
      polygons.numericProps
    );
    let pointIndex = 0;
    let triangleIndex = 0;
    const { extruded } = props;
    for (let i = 0; i < polygons.polygonIndices.value.length - 1; i++) {
      const startIndex = polygons.polygonIndices.value[i];
      const endIndex = polygons.polygonIndices.value[i + 1];
      if (getPolygonArea(polygons, i) < minPolygonArea) {
        continue;
      }
      const centroid = getPolygonCentroid(polygons, i);
      let maxArea = -1;
      let largestTriangleCenter = [0, 0];
      let centroidIsInside = false;
      while (triangleIndex < polygons.triangles.value.length) {
        const i1 = polygons.triangles.value[triangleIndex];
        if (i1 >= endIndex) {
          break;
        }
        if (centroidIsInside) {
          triangleIndex += 3;
          continue;
        }
        const i2 = polygons.triangles.value[triangleIndex + 1];
        const i3 = polygons.triangles.value[triangleIndex + 2];
        const v1 = polygons.positions.value.subarray(
          i1 * polygons.positions.size,
          i1 * polygons.positions.size + polygons.positions.size
        );
        const v2 = polygons.positions.value.subarray(
          i2 * polygons.positions.size,
          i2 * polygons.positions.size + polygons.positions.size
        );
        const v3 = polygons.positions.value.subarray(
          i3 * polygons.positions.size,
          i3 * polygons.positions.size + polygons.positions.size
        );
        if (isPointInTriangle(centroid, v1, v2, v3)) {
          centroidIsInside = true;
        } else {
          const area = getTriangleArea(v1, v2, v3);
          if (area > maxArea) {
            maxArea = area;
            largestTriangleCenter = [(v1[0] + v2[0] + v3[0]) / 3, (v1[1] + v2[1] + v3[1]) / 3];
          }
        }
        triangleIndex += 3;
      }
      const labelPoint = centroidIsInside ? centroid : largestTriangleCenter;
      if (isPointInBounds(labelPoint, tileBbox)) {
        positions.push(...labelPoint);
        const featureId2 = polygons.featureIds.value[startIndex];
        if (extruded) {
          const elevation = props.getElevation(void 0, {
            data: polygons,
            index: featureId2
          });
          positions.push(elevation * props.elevationScale);
        }
        properties.push(polygons.properties[featureId2]);
        featureIds.push(pointIndex);
        globalFeatureIds.push(polygons.globalFeatureIds.value[startIndex]);
        copyNumericProps(polygons.numericProps, numericProps, startIndex, pointIndex);
        pointIndex++;
      }
    }
    if (polygons.numericProps) {
      Object.keys(numericProps).forEach((prop) => {
        numericProps[prop].value = numericProps[prop].value.slice(0, pointIndex);
      });
    }
    return createBinaryPointFeature(
      positions,
      featureIds,
      globalFeatureIds,
      numericProps,
      properties,
      extruded ? 3 : 2
    );
  }
  function getPolygonArea(polygons, index2) {
    const {
      positions: { value: positions, size },
      polygonIndices: { value: indices },
      triangles: { value: triangles }
    } = polygons;
    const startIndex = indices[index2];
    const endIndex = indices[index2 + 1];
    let area = 0;
    let triangleIndex = 0;
    while (triangleIndex < triangles.length) {
      const i1 = triangles[triangleIndex];
      if (i1 >= startIndex)
        break;
      triangleIndex += 3;
    }
    while (triangleIndex < triangles.length) {
      const i1 = triangles[triangleIndex];
      if (i1 >= endIndex)
        break;
      const i2 = triangles[triangleIndex + 1];
      const i3 = triangles[triangleIndex + 2];
      const v1 = positions.subarray(i1 * size, i1 * size + size);
      const v2 = positions.subarray(i2 * size, i2 * size + size);
      const v3 = positions.subarray(i3 * size, i3 * size + size);
      area += getTriangleArea(v1, v2, v3);
      triangleIndex += 3;
    }
    return area;
  }
  function isPointInBounds([x, y], { west, east, south, north }) {
    return x >= west && x < east && y >= south && y < north;
  }
  function isPointInTriangle(p, v1, v2, v3) {
    const area = Math.abs((v2[0] - v1[0]) * (v3[1] - v1[1]) - (v3[0] - v1[0]) * (v2[1] - v1[1])) / 2;
    const area1 = Math.abs((v1[0] - p[0]) * (v2[1] - p[1]) - (v2[0] - p[0]) * (v1[1] - p[1])) / 2;
    const area2 = Math.abs((v2[0] - p[0]) * (v3[1] - p[1]) - (v3[0] - p[0]) * (v2[1] - p[1])) / 2;
    const area3 = Math.abs((v3[0] - p[0]) * (v1[1] - p[1]) - (v1[0] - p[0]) * (v3[1] - p[1])) / 2;
    return Math.abs(area - (area1 + area2 + area3)) < 1e-10;
  }
  function getTriangleArea([x1, y1], [x2, y2], [x3, y3]) {
    return Math.abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2);
  }
  function getPolygonCentroid(polygons, index2) {
    const {
      positions: { value: positions, size }
    } = polygons;
    const startIndex = size * polygons.polygonIndices.value[index2];
    const endIndex = size * polygons.polygonIndices.value[index2 + 1];
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i = startIndex; i < endIndex; i += size) {
      const [x, y] = positions.subarray(i, i + 2);
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    }
    return [(minX + maxX) / 2, (minY + maxY) / 2];
  }
  function getSegmentLength(lines, index2) {
    const {
      positions: { value }
    } = lines;
    const [x1, y1, x2, y2] = value.subarray(index2, index2 + 4);
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }
  function getLineLength(lines, index2) {
    const {
      positions: { size }
    } = lines;
    const startIndex = size * lines.pathIndices.value[index2];
    const endIndex = size * lines.pathIndices.value[index2 + 1];
    let length2 = 0;
    for (let j = startIndex; j < endIndex; j += size) {
      length2 += getSegmentLength(lines, j);
    }
    return length2;
  }
  function getLineMidpoint(lines, index2) {
    const {
      positions: { value: positions },
      pathIndices: { value: pathIndices }
    } = lines;
    const startIndex = pathIndices[index2] * 2;
    const endIndex = pathIndices[index2 + 1] * 2;
    const numPoints = (endIndex - startIndex) / 2;
    if (numPoints === 2) {
      const [x1, y1, x2, y2] = positions.subarray(startIndex, startIndex + 4);
      return [(x1 + x2) / 2, (y1 + y2) / 2];
    }
    const midPointIndex = startIndex + Math.floor(numPoints / 2) * 2;
    return [positions[midPointIndex], positions[midPointIndex + 1]];
  }

  // src/layers/vector-tile-layer.ts
  (0, import_core16.registerLoaders)([carto_properties_tile_loader_default, carto_vector_tile_loader_default]);
  var MVT_BBOX = { west: 0, east: 1, south: 0, north: 1 };
  var defaultProps10 = {
    ...import_geo_layers8.MVTLayer.defaultProps,
    autoLabels: false,
    data: TilejsonPropType,
    dataComparator: TilejsonPropType.equal,
    tileSize: DEFAULT_TILE_SIZE
  };
  var VectorTileLayer = class extends import_geo_layers8.MVTLayer {
    constructor(...propObjects) {
      super(...propObjects);
    }
    initializeState() {
      super.initializeState();
      this.setState({ binary: true });
    }
    updateState(parameters) {
      const { props } = parameters;
      if (props.data) {
        super.updateState(parameters);
        const formatTiles = new URL(props.data.tiles[0]).searchParams.get("formatTiles");
        const mvt = formatTiles === "mvt";
        this.setState({ mvt });
      }
    }
    getLoadOptions() {
      const tileJSON = this.props.data;
      return mergeLoadOptions(super.getLoadOptions(), {
        fetch: { headers: { Authorization: `Bearer ${tileJSON.accessToken}` } },
        gis: { format: "binary" }
        // Use binary for MVT loading
      });
    }
    /* eslint-disable camelcase */
    async getTileData(tile) {
      const tileJSON = this.props.data;
      const { tiles: tiles3, properties_tiles } = tileJSON;
      const url = (0, import_geo_layers8._getURLFromTemplate)(tiles3, tile);
      if (!url) {
        return Promise.reject("Invalid URL");
      }
      const loadOptions = this.getLoadOptions();
      const { fetch: fetch2 } = this.props;
      const { signal } = tile;
      const geometryFetch = fetch2(url, { propName: "data", layer: this, loadOptions, signal });
      if (!properties_tiles) {
        return await geometryFetch;
      }
      const propertiesUrl = (0, import_geo_layers8._getURLFromTemplate)(properties_tiles, tile);
      if (!propertiesUrl) {
        return Promise.reject("Invalid properties URL");
      }
      const attributesFetch = fetch2(propertiesUrl, {
        propName: "data",
        layer: this,
        loadOptions,
        signal
      });
      const [geometry, attributes] = await Promise.all([geometryFetch, attributesFetch]);
      if (!geometry)
        return null;
      return attributes ? mergeBoundaryData(geometry, attributes) : geometry;
    }
    /* eslint-enable camelcase */
    renderSubLayers(props) {
      if (props.data === null) {
        return null;
      }
      const tileBbox = props.tile.bbox;
      const subLayers = [];
      const defaultToPointLabelLayer = {
        "points-text": {
          type: PointLabelLayer,
          ...props?._subLayerProps?.["points-text"],
          extensions: [
            new import_extensions.CollisionFilterExtension(),
            ...props.extensions || [],
            ...props?._subLayerProps?.["points-text"]?.extensions || []
          ]
        }
      };
      if (this.state.mvt) {
        const subLayerProps = {
          ...props,
          _subLayerProps: {
            ...props._subLayerProps,
            ...defaultToPointLabelLayer
          }
        };
        subLayers.push(super.renderSubLayers(subLayerProps));
      } else {
        const { west, south, east, north } = tileBbox;
        const extensions = [new import_extensions.ClipExtension(), ...props.extensions || []];
        const clipProps = {
          clipBounds: [west, south, east, north]
        };
        const applyClipExtensionToSublayerProps = (subLayerId) => {
          return {
            [subLayerId]: {
              ...clipProps,
              ...props?._subLayerProps?.[subLayerId],
              extensions: [...extensions, ...props?._subLayerProps?.[subLayerId]?.extensions || []]
            }
          };
        };
        const subLayerProps = {
          ...props,
          data: { ...props.data, tileBbox },
          autoHighlight: false,
          // Do not perform clipping on points (#9059)
          _subLayerProps: {
            ...props._subLayerProps,
            ...defaultToPointLabelLayer,
            ...applyClipExtensionToSublayerProps("polygons-fill"),
            ...applyClipExtensionToSublayerProps("polygons-stroke"),
            ...applyClipExtensionToSublayerProps("linestrings")
          }
        };
        subLayers.push(new import_layers5.GeoJsonLayer(subLayerProps));
      }
      if (subLayers[0] && props.autoLabels) {
        const labelData = createEmptyBinary();
        if (props.data.lines && props.data.lines.positions.value.length > 0) {
          labelData.points = createPointsFromLines(
            props.data.lines,
            typeof props.autoLabels === "object" ? props.autoLabels.uniqueIdProperty : void 0
          );
        }
        if (props.data.polygons && props.data.polygons.positions.value.length > 0) {
          labelData.points = createPointsFromPolygons(
            props.data.polygons,
            this.state.mvt ? MVT_BBOX : tileBbox,
            props
          );
        }
        subLayers.push(
          subLayers[0].clone({
            id: `${props.id}-labels`,
            data: labelData,
            pickable: false,
            autoHighlight: false
          })
        );
      }
      return subLayers;
    }
    renderLayers() {
      const layers = super.renderLayers();
      if (!this.props.autoLabels) {
        return layers;
      }
      const validLayers = (layers || []).flat().filter(Boolean);
      validLayers.sort((a, b) => {
        const aHasLabel = a.id.includes("labels");
        const bHasLabel = b.id.includes("labels");
        if (aHasLabel && !bHasLabel)
          return 1;
        if (!aHasLabel && bHasLabel)
          return -1;
        return 0;
      });
      return validLayers.map(
        (l) => l.id.includes("labels") ? l.clone({ highlightedObjectIndex: -1 }) : l
      );
    }
    _isWGS84() {
      if (this.state.mvt)
        return super._isWGS84();
      return true;
    }
  };
  VectorTileLayer.layerName = "VectorTileLayer";
  VectorTileLayer.defaultProps = defaultProps10;

  // ../../node_modules/@carto/api-client/node_modules/quadbin/dist/index.esm.js
  var d2r = Math.PI / 180;
  var r2d = 180 / Math.PI;
  function tileToBBOX(tile) {
    var e = tile2lon(tile[0] + 1, tile[2]);
    var w = tile2lon(tile[0], tile[2]);
    var s = tile2lat(tile[1] + 1, tile[2]);
    var n = tile2lat(tile[1], tile[2]);
    return [w, s, e, n];
  }
  function tileToGeoJSON(tile) {
    var bbox2 = tileToBBOX(tile);
    var poly = {
      type: "Polygon",
      coordinates: [
        [
          [bbox2[0], bbox2[1]],
          [bbox2[0], bbox2[3]],
          [bbox2[2], bbox2[3]],
          [bbox2[2], bbox2[1]],
          [bbox2[0], bbox2[1]]
        ]
      ]
    };
    return poly;
  }
  function tile2lon(x, z) {
    return x / Math.pow(2, z) * 360 - 180;
  }
  function tile2lat(y, z) {
    var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
    return r2d * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
  }
  function pointToTile(lon, lat, z) {
    var tile = pointToTileFraction(lon, lat, z);
    tile[0] = Math.floor(tile[0]);
    tile[1] = Math.floor(tile[1]);
    return tile;
  }
  function getChildren(tile) {
    return [
      [tile[0] * 2, tile[1] * 2, tile[2] + 1],
      [tile[0] * 2 + 1, tile[1] * 2, tile[2] + 1],
      [tile[0] * 2 + 1, tile[1] * 2 + 1, tile[2] + 1],
      [tile[0] * 2, tile[1] * 2 + 1, tile[2] + 1]
    ];
  }
  function getParent(tile) {
    if (tile[0] % 2 === 0 && tile[1] % 2 === 0) {
      return [tile[0] / 2, tile[1] / 2, tile[2] - 1];
    } else if (tile[0] % 2 === 0 && !tile[1] % 2 === 0) {
      return [tile[0] / 2, (tile[1] - 1) / 2, tile[2] - 1];
    } else if (!tile[0] % 2 === 0 && tile[1] % 2 === 0) {
      return [(tile[0] - 1) / 2, tile[1] / 2, tile[2] - 1];
    } else {
      return [(tile[0] - 1) / 2, (tile[1] - 1) / 2, tile[2] - 1];
    }
  }
  function getSiblings(tile) {
    return getChildren(getParent(tile));
  }
  function hasSiblings(tile, tiles3) {
    var siblings = getSiblings(tile);
    for (var i = 0; i < siblings.length; i++) {
      if (!hasTile(tiles3, siblings[i]))
        return false;
    }
    return true;
  }
  function hasTile(tiles3, tile) {
    for (var i = 0; i < tiles3.length; i++) {
      if (tilesEqual(tiles3[i], tile))
        return true;
    }
    return false;
  }
  function tilesEqual(tile1, tile2) {
    return tile1[0] === tile2[0] && tile1[1] === tile2[1] && tile1[2] === tile2[2];
  }
  function tileToQuadkey(tile) {
    var index2 = "";
    for (var z = tile[2]; z > 0; z--) {
      var b = 0;
      var mask = 1 << z - 1;
      if ((tile[0] & mask) !== 0)
        b++;
      if ((tile[1] & mask) !== 0)
        b += 2;
      index2 += b.toString();
    }
    return index2;
  }
  function quadkeyToTile(quadkey) {
    var x = 0;
    var y = 0;
    var z = quadkey.length;
    for (var i = z; i > 0; i--) {
      var mask = 1 << i - 1;
      switch (quadkey[z - i]) {
        case "0":
          break;
        case "1":
          x |= mask;
          break;
        case "2":
          y |= mask;
          break;
        case "3":
          x |= mask;
          y |= mask;
          break;
      }
    }
    return [x, y, z];
  }
  function bboxToTile(bboxCoords) {
    var min2 = pointToTile(bboxCoords[0], bboxCoords[1], 32);
    var max2 = pointToTile(bboxCoords[2], bboxCoords[3], 32);
    var bbox2 = [min2[0], min2[1], max2[0], max2[1]];
    var z = getBboxZoom(bbox2);
    if (z === 0)
      return [0, 0, 0];
    var x = bbox2[0] >>> 32 - z;
    var y = bbox2[1] >>> 32 - z;
    return [x, y, z];
  }
  function getBboxZoom(bbox2) {
    var MAX_ZOOM = 28;
    for (var z = 0; z < MAX_ZOOM; z++) {
      var mask = 1 << 32 - (z + 1);
      if ((bbox2[0] & mask) != (bbox2[2] & mask) || (bbox2[1] & mask) != (bbox2[3] & mask)) {
        return z;
      }
    }
    return MAX_ZOOM;
  }
  function pointToTileFraction(lon, lat, z) {
    var sin = Math.sin(lat * d2r), z2 = Math.pow(2, z), x = z2 * (lon / 360 + 0.5), y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
    return [x, y, z];
  }
  var tilebelt = {
    tileToGeoJSON,
    tileToBBOX,
    getChildren,
    getParent,
    getSiblings,
    hasTile,
    hasSiblings,
    tilesEqual,
    tileToQuadkey,
    quadkeyToTile,
    pointToTile,
    bboxToTile,
    pointToTileFraction
  };
  var tiles2 = getTiles;
  function getTiles(geom, limits) {
    var i, tile, coords = geom.coordinates, maxZoom = limits.max_zoom, tileHash = {}, tiles3 = [];
    if (geom.type === "Point") {
      return [tilebelt.pointToTile(coords[0], coords[1], maxZoom)];
    } else if (geom.type === "MultiPoint") {
      for (i = 0; i < coords.length; i++) {
        tile = tilebelt.pointToTile(coords[i][0], coords[i][1], maxZoom);
        tileHash[toID(tile[0], tile[1], tile[2])] = true;
      }
    } else if (geom.type === "LineString") {
      lineCover(tileHash, coords, maxZoom);
    } else if (geom.type === "MultiLineString") {
      for (i = 0; i < coords.length; i++) {
        lineCover(tileHash, coords[i], maxZoom);
      }
    } else if (geom.type === "Polygon") {
      polygonCover(tileHash, tiles3, coords, maxZoom);
    } else if (geom.type === "MultiPolygon") {
      for (i = 0; i < coords.length; i++) {
        polygonCover(tileHash, tiles3, coords[i], maxZoom);
      }
    } else {
      throw new Error("Geometry type not implemented");
    }
    if (limits.min_zoom !== maxZoom) {
      var len = tiles3.length;
      appendHashTiles(tileHash, tiles3);
      for (i = 0; i < len; i++) {
        var t = tiles3[i];
        tileHash[toID(t[0], t[1], t[2])] = true;
      }
      return mergeTiles(tileHash, tiles3, limits);
    }
    appendHashTiles(tileHash, tiles3);
    return tiles3;
  }
  function mergeTiles(tileHash, tiles3, limits) {
    var mergedTiles = [];
    for (var z = limits.max_zoom; z > limits.min_zoom; z--) {
      var parentTileHash = {};
      var parentTiles = [];
      for (var i = 0; i < tiles3.length; i++) {
        var t = tiles3[i];
        if (t[0] % 2 === 0 && t[1] % 2 === 0) {
          var id22 = toID(t[0] + 1, t[1], z), id32 = toID(t[0], t[1] + 1, z), id42 = toID(t[0] + 1, t[1] + 1, z);
          if (tileHash[id22] && tileHash[id32] && tileHash[id42]) {
            tileHash[toID(t[0], t[1], t[2])] = false;
            tileHash[id22] = false;
            tileHash[id32] = false;
            tileHash[id42] = false;
            var parentTile = [t[0] / 2, t[1] / 2, z - 1];
            if (z - 1 === limits.min_zoom)
              mergedTiles.push(parentTile);
            else {
              parentTileHash[toID(t[0] / 2, t[1] / 2, z - 1)] = true;
              parentTiles.push(parentTile);
            }
          }
        }
      }
      for (i = 0; i < tiles3.length; i++) {
        t = tiles3[i];
        if (tileHash[toID(t[0], t[1], t[2])])
          mergedTiles.push(t);
      }
      tileHash = parentTileHash;
      tiles3 = parentTiles;
    }
    return mergedTiles;
  }
  function polygonCover(tileHash, tileArray, geom, zoom) {
    var intersections = [];
    for (var i = 0; i < geom.length; i++) {
      var ring = [];
      lineCover(tileHash, geom[i], zoom, ring);
      for (var j = 0, len = ring.length, k = len - 1; j < len; k = j++) {
        var m = (j + 1) % len;
        var y = ring[j][1];
        if ((y > ring[k][1] || y > ring[m][1]) && // not local minimum
        (y < ring[k][1] || y < ring[m][1]) && // not local maximum
        y !== ring[m][1])
          intersections.push(ring[j]);
      }
    }
    intersections.sort(compareTiles);
    for (i = 0; i < intersections.length; i += 2) {
      y = intersections[i][1];
      for (var x = intersections[i][0] + 1; x < intersections[i + 1][0]; x++) {
        var id5 = toID(x, y, zoom);
        if (!tileHash[id5]) {
          tileArray.push([x, y, zoom]);
        }
      }
    }
  }
  function compareTiles(a, b) {
    return a[1] - b[1] || a[0] - b[0];
  }
  function lineCover(tileHash, coords, maxZoom, ring) {
    var prevX, prevY;
    for (var i = 0; i < coords.length - 1; i++) {
      var start = tilebelt.pointToTileFraction(coords[i][0], coords[i][1], maxZoom), stop = tilebelt.pointToTileFraction(coords[i + 1][0], coords[i + 1][1], maxZoom), x0 = start[0], y0 = start[1], x1 = stop[0], y1 = stop[1], dx = x1 - x0, dy = y1 - y0;
      if (dy === 0 && dx === 0)
        continue;
      var sx = dx > 0 ? 1 : -1, sy = dy > 0 ? 1 : -1, x = Math.floor(x0), y = Math.floor(y0), tMaxX = dx === 0 ? Infinity : Math.abs(((dx > 0 ? 1 : 0) + x - x0) / dx), tMaxY = dy === 0 ? Infinity : Math.abs(((dy > 0 ? 1 : 0) + y - y0) / dy), tdx = Math.abs(sx / dx), tdy = Math.abs(sy / dy);
      if (x !== prevX || y !== prevY) {
        tileHash[toID(x, y, maxZoom)] = true;
        if (ring && y !== prevY)
          ring.push([x, y]);
        prevX = x;
        prevY = y;
      }
      while (tMaxX < 1 || tMaxY < 1) {
        if (tMaxX < tMaxY) {
          tMaxX += tdx;
          x += sx;
        } else {
          tMaxY += tdy;
          y += sy;
        }
        tileHash[toID(x, y, maxZoom)] = true;
        if (ring && y !== prevY)
          ring.push([x, y]);
        prevX = x;
        prevY = y;
      }
    }
    if (ring && y === ring[0][1])
      ring.pop();
  }
  function appendHashTiles(hash, tiles3) {
    var keys = Object.keys(hash);
    for (var i = 0; i < keys.length; i++) {
      tiles3.push(fromID(+keys[i]));
    }
  }
  function toID(x, y, z) {
    var dim = 2 * (1 << z);
    return (dim * y + x) * 32 + z;
  }
  function fromID(id5) {
    var z = id5 % 32, dim = 2 * (1 << z), xy = (id5 - z) / 32, x = xy % dim, y = (xy - x) / dim % dim;
    return [x, y, z];
  }
  var B2 = [0x5555555555555555n, 0x3333333333333333n, 0x0f0f0f0f0f0f0f0fn, 0x00ff00ff00ff00ffn, 0x0000ffff0000ffffn, 0x00000000ffffffffn];
  var S2 = [0n, 1n, 2n, 4n, 8n, 16n];
  var TILE_SIZE3 = 512;
  function cellToOffset(quadbin) {
    const {
      x,
      y,
      z
    } = cellToTile2(quadbin);
    const scale = TILE_SIZE3 / (1 << z);
    return [x * scale, TILE_SIZE3 - y * scale, scale];
  }
  function cellToWorldBounds(quadbin, coverage) {
    const [xOffset, yOffset, scale] = cellToOffset(quadbin);
    return [[xOffset, yOffset], [xOffset + coverage * scale, yOffset - coverage * scale]];
  }
  function getCellPolygon(quadbin, coverage = 1) {
    const [topLeft, bottomRight] = cellToWorldBounds(quadbin, coverage);
    const [w, n] = worldToLngLat(topLeft);
    const [e, s] = worldToLngLat(bottomRight);
    return [e, n, e, s, w, s, w, n, e, n];
  }
  function tileToCell2(tile) {
    if (tile.z < 0 || tile.z > 26) {
      throw new Error("Wrong zoom");
    }
    const z = BigInt(tile.z);
    let x = BigInt(tile.x) << 32n - z;
    let y = BigInt(tile.y) << 32n - z;
    for (let i = 0; i < 5; i++) {
      const s = S2[5 - i];
      const b = B2[4 - i];
      x = (x | x << s) & b;
      y = (y | y << s) & b;
    }
    const quadbin = 0x4000000000000000n | 1n << 59n | // | (mode << 59) | (mode_dep << 57)
    z << 52n | (x | y << 1n) >> 12n | 0xfffffffffffffn >> z * 2n;
    return quadbin;
  }
  function cellToTile2(quadbin) {
    const mode = quadbin >> 59n & 7n;
    const modeDep = quadbin >> 57n & 3n;
    const z = quadbin >> 52n & 0x1fn;
    const q = (quadbin & 0xfffffffffffffn) << 12n;
    if (mode !== 1n && modeDep !== 0n) {
      throw new Error("Wrong mode");
    }
    let x = q;
    let y = q >> 1n;
    for (let i = 0; i < 6; i++) {
      const s = S2[i];
      const b = B2[i];
      x = (x | x >> s) & b;
      y = (y | y >> s) & b;
    }
    x = x >> 32n - z;
    y = y >> 32n - z;
    return {
      z: Number(z),
      x: Number(x),
      y: Number(y)
    };
  }
  function getResolution4(quadbin) {
    return quadbin >> 52n & 0x1fn;
  }
  function geometryToCells(geometry, resolution) {
    const zoom = Number(resolution);
    return tiles2(geometry, {
      min_zoom: zoom,
      max_zoom: zoom
    }).map(([x, y, z]) => tileToCell2({
      x,
      y,
      z
    }));
  }
  function cellToBoundary2(cell) {
    const bbox2 = getCellPolygon(cell);
    const boundary = [[bbox2[0], bbox2[1]], [bbox2[2], bbox2[3]], [bbox2[4], bbox2[5]], [bbox2[6], bbox2[7]], [bbox2[0], bbox2[1]]];
    return {
      type: "Polygon",
      coordinates: [boundary]
    };
  }

  // ../../node_modules/@carto/api-client/build/api-client.js
  var import_h3_js5 = __toESM(require_h3_js(), 1);
  var import_h3_js6 = __toESM(require_h3_js(), 1);

  // ../../node_modules/@carto/api-client/node_modules/jsep/dist/jsep.js
  var Hooks = class {
    /**
     * @callback HookCallback
     * @this {*|Jsep} this
     * @param {Jsep} env
     * @returns: void
     */
    /**
     * Adds the given callback to the list of callbacks for the given hook.
     *
     * The callback will be invoked when the hook it is registered for is run.
     *
     * One callback function can be registered to multiple hooks and the same hook multiple times.
     *
     * @param {string|object} name The name of the hook, or an object of callbacks keyed by name
     * @param {HookCallback|boolean} callback The callback function which is given environment variables.
     * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)
     * @public
     */
    add(name, callback, first) {
      if (typeof arguments[0] != "string") {
        for (let name2 in arguments[0]) {
          this.add(name2, arguments[0][name2], arguments[1]);
        }
      } else {
        (Array.isArray(name) ? name : [name]).forEach(function(name2) {
          this[name2] = this[name2] || [];
          if (callback) {
            this[name2][first ? "unshift" : "push"](callback);
          }
        }, this);
      }
    }
    /**
     * Runs a hook invoking all registered callbacks with the given environment variables.
     *
     * Callbacks will be invoked synchronously and in the order in which they were registered.
     *
     * @param {string} name The name of the hook.
     * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
     * @public
     */
    run(name, env) {
      this[name] = this[name] || [];
      this[name].forEach(function(callback) {
        callback.call(env && env.context ? env.context : env, env);
      });
    }
  };
  var Plugins = class {
    constructor(jsep2) {
      this.jsep = jsep2;
      this.registered = {};
    }
    /**
     * @callback PluginSetup
     * @this {Jsep} jsep
     * @returns: void
     */
    /**
     * Adds the given plugin(s) to the registry
     *
     * @param {object} plugins
     * @param {string} plugins.name The name of the plugin
     * @param {PluginSetup} plugins.init The init function
     * @public
     */
    register(...plugins) {
      plugins.forEach((plugin) => {
        if (typeof plugin !== "object" || !plugin.name || !plugin.init) {
          throw new Error("Invalid JSEP plugin format");
        }
        if (this.registered[plugin.name]) {
          return;
        }
        plugin.init(this.jsep);
        this.registered[plugin.name] = plugin;
      });
    }
  };
  var Jsep = class {
    /**
     * @returns {string}
     */
    static get version() {
      return "1.4.0";
    }
    /**
     * @returns {string}
     */
    static toString() {
      return "JavaScript Expression Parser (JSEP) v" + Jsep.version;
    }
    // ==================== CONFIG ================================
    /**
     * @method addUnaryOp
     * @param {string} op_name The name of the unary op to add
     * @returns {Jsep}
     */
    static addUnaryOp(op_name) {
      Jsep.max_unop_len = Math.max(op_name.length, Jsep.max_unop_len);
      Jsep.unary_ops[op_name] = 1;
      return Jsep;
    }
    /**
     * @method jsep.addBinaryOp
     * @param {string} op_name The name of the binary op to add
     * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence
     * @param {boolean} [isRightAssociative=false] whether operator is right-associative
     * @returns {Jsep}
     */
    static addBinaryOp(op_name, precedence, isRightAssociative) {
      Jsep.max_binop_len = Math.max(op_name.length, Jsep.max_binop_len);
      Jsep.binary_ops[op_name] = precedence;
      if (isRightAssociative) {
        Jsep.right_associative.add(op_name);
      } else {
        Jsep.right_associative.delete(op_name);
      }
      return Jsep;
    }
    /**
     * @method addIdentifierChar
     * @param {string} char The additional character to treat as a valid part of an identifier
     * @returns {Jsep}
     */
    static addIdentifierChar(char) {
      Jsep.additional_identifier_chars.add(char);
      return Jsep;
    }
    /**
     * @method addLiteral
     * @param {string} literal_name The name of the literal to add
     * @param {*} literal_value The value of the literal
     * @returns {Jsep}
     */
    static addLiteral(literal_name, literal_value) {
      Jsep.literals[literal_name] = literal_value;
      return Jsep;
    }
    /**
     * @method removeUnaryOp
     * @param {string} op_name The name of the unary op to remove
     * @returns {Jsep}
     */
    static removeUnaryOp(op_name) {
      delete Jsep.unary_ops[op_name];
      if (op_name.length === Jsep.max_unop_len) {
        Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
      }
      return Jsep;
    }
    /**
     * @method removeAllUnaryOps
     * @returns {Jsep}
     */
    static removeAllUnaryOps() {
      Jsep.unary_ops = {};
      Jsep.max_unop_len = 0;
      return Jsep;
    }
    /**
     * @method removeIdentifierChar
     * @param {string} char The additional character to stop treating as a valid part of an identifier
     * @returns {Jsep}
     */
    static removeIdentifierChar(char) {
      Jsep.additional_identifier_chars.delete(char);
      return Jsep;
    }
    /**
     * @method removeBinaryOp
     * @param {string} op_name The name of the binary op to remove
     * @returns {Jsep}
     */
    static removeBinaryOp(op_name) {
      delete Jsep.binary_ops[op_name];
      if (op_name.length === Jsep.max_binop_len) {
        Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);
      }
      Jsep.right_associative.delete(op_name);
      return Jsep;
    }
    /**
     * @method removeAllBinaryOps
     * @returns {Jsep}
     */
    static removeAllBinaryOps() {
      Jsep.binary_ops = {};
      Jsep.max_binop_len = 0;
      return Jsep;
    }
    /**
     * @method removeLiteral
     * @param {string} literal_name The name of the literal to remove
     * @returns {Jsep}
     */
    static removeLiteral(literal_name) {
      delete Jsep.literals[literal_name];
      return Jsep;
    }
    /**
     * @method removeAllLiterals
     * @returns {Jsep}
     */
    static removeAllLiterals() {
      Jsep.literals = {};
      return Jsep;
    }
    // ==================== END CONFIG ============================
    /**
     * @returns {string}
     */
    get char() {
      return this.expr.charAt(this.index);
    }
    /**
     * @returns {number}
     */
    get code() {
      return this.expr.charCodeAt(this.index);
    }
    /**
     * @param {string} expr a string with the passed in express
     * @returns Jsep
     */
    constructor(expr) {
      this.expr = expr;
      this.index = 0;
    }
    /**
     * static top-level parser
     * @returns {jsep.Expression}
     */
    static parse(expr) {
      return new Jsep(expr).parse();
    }
    /**
     * Get the longest key length of any object
     * @param {object} obj
     * @returns {number}
     */
    static getMaxKeyLen(obj) {
      return Math.max(0, ...Object.keys(obj).map((k) => k.length));
    }
    /**
     * `ch` is a character code in the next three functions
     * @param {number} ch
     * @returns {boolean}
     */
    static isDecimalDigit(ch) {
      return ch >= 48 && ch <= 57;
    }
    /**
     * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.
     * @param {string} op_val
     * @returns {number}
     */
    static binaryPrecedence(op_val) {
      return Jsep.binary_ops[op_val] || 0;
    }
    /**
     * Looks for start of identifier
     * @param {number} ch
     * @returns {boolean}
     */
    static isIdentifierStart(ch) {
      return ch >= 65 && ch <= 90 || // A...Z
      ch >= 97 && ch <= 122 || // a...z
      ch >= 128 && !Jsep.binary_ops[String.fromCharCode(ch)] || // any non-ASCII that is not an operator
      Jsep.additional_identifier_chars.has(String.fromCharCode(ch));
    }
    /**
     * @param {number} ch
     * @returns {boolean}
     */
    static isIdentifierPart(ch) {
      return Jsep.isIdentifierStart(ch) || Jsep.isDecimalDigit(ch);
    }
    /**
     * throw error at index of the expression
     * @param {string} message
     * @throws
     */
    throwError(message) {
      const error = new Error(message + " at character " + this.index);
      error.index = this.index;
      error.description = message;
      throw error;
    }
    /**
     * Run a given hook
     * @param {string} name
     * @param {jsep.Expression|false} [node]
     * @returns {?jsep.Expression}
     */
    runHook(name, node) {
      if (Jsep.hooks[name]) {
        const env = { context: this, node };
        Jsep.hooks.run(name, env);
        return env.node;
      }
      return node;
    }
    /**
     * Runs a given hook until one returns a node
     * @param {string} name
     * @returns {?jsep.Expression}
     */
    searchHook(name) {
      if (Jsep.hooks[name]) {
        const env = { context: this };
        Jsep.hooks[name].find(function(callback) {
          callback.call(env.context, env);
          return env.node;
        });
        return env.node;
      }
    }
    /**
     * Push `index` up to the next non-space character
     */
    gobbleSpaces() {
      let ch = this.code;
      while (ch === Jsep.SPACE_CODE || ch === Jsep.TAB_CODE || ch === Jsep.LF_CODE || ch === Jsep.CR_CODE) {
        ch = this.expr.charCodeAt(++this.index);
      }
      this.runHook("gobble-spaces");
    }
    /**
     * Top-level method to parse all expressions and returns compound or single node
     * @returns {jsep.Expression}
     */
    parse() {
      this.runHook("before-all");
      const nodes = this.gobbleExpressions();
      const node = nodes.length === 1 ? nodes[0] : {
        type: Jsep.COMPOUND,
        body: nodes
      };
      return this.runHook("after-all", node);
    }
    /**
     * top-level parser (but can be reused within as well)
     * @param {number} [untilICode]
     * @returns {jsep.Expression[]}
     */
    gobbleExpressions(untilICode) {
      let nodes = [], ch_i, node;
      while (this.index < this.expr.length) {
        ch_i = this.code;
        if (ch_i === Jsep.SEMCOL_CODE || ch_i === Jsep.COMMA_CODE) {
          this.index++;
        } else {
          if (node = this.gobbleExpression()) {
            nodes.push(node);
          } else if (this.index < this.expr.length) {
            if (ch_i === untilICode) {
              break;
            }
            this.throwError('Unexpected "' + this.char + '"');
          }
        }
      }
      return nodes;
    }
    /**
     * The main parsing function.
     * @returns {?jsep.Expression}
     */
    gobbleExpression() {
      const node = this.searchHook("gobble-expression") || this.gobbleBinaryExpression();
      this.gobbleSpaces();
      return this.runHook("after-expression", node);
    }
    /**
     * Search for the operation portion of the string (e.g. `+`, `===`)
     * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
     * and move down from 3 to 2 to 1 character until a matching binary operation is found
     * then, return that binary operation
     * @returns {string|boolean}
     */
    gobbleBinaryOp() {
      this.gobbleSpaces();
      let to_check = this.expr.substr(this.index, Jsep.max_binop_len);
      let tc_len = to_check.length;
      while (tc_len > 0) {
        if (Jsep.binary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
          this.index += tc_len;
          return to_check;
        }
        to_check = to_check.substr(0, --tc_len);
      }
      return false;
    }
    /**
     * This function is responsible for gobbling an individual expression,
     * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
     * @returns {?jsep.BinaryExpression}
     */
    gobbleBinaryExpression() {
      let node, biop, prec, stack, biop_info, left, right, i, cur_biop;
      left = this.gobbleToken();
      if (!left) {
        return left;
      }
      biop = this.gobbleBinaryOp();
      if (!biop) {
        return left;
      }
      biop_info = { value: biop, prec: Jsep.binaryPrecedence(biop), right_a: Jsep.right_associative.has(biop) };
      right = this.gobbleToken();
      if (!right) {
        this.throwError("Expected expression after " + biop);
      }
      stack = [left, biop_info, right];
      while (biop = this.gobbleBinaryOp()) {
        prec = Jsep.binaryPrecedence(biop);
        if (prec === 0) {
          this.index -= biop.length;
          break;
        }
        biop_info = { value: biop, prec, right_a: Jsep.right_associative.has(biop) };
        cur_biop = biop;
        const comparePrev = (prev) => biop_info.right_a && prev.right_a ? prec > prev.prec : prec <= prev.prec;
        while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {
          right = stack.pop();
          biop = stack.pop().value;
          left = stack.pop();
          node = {
            type: Jsep.BINARY_EXP,
            operator: biop,
            left,
            right
          };
          stack.push(node);
        }
        node = this.gobbleToken();
        if (!node) {
          this.throwError("Expected expression after " + cur_biop);
        }
        stack.push(biop_info, node);
      }
      i = stack.length - 1;
      node = stack[i];
      while (i > 1) {
        node = {
          type: Jsep.BINARY_EXP,
          operator: stack[i - 1].value,
          left: stack[i - 2],
          right: node
        };
        i -= 2;
      }
      return node;
    }
    /**
     * An individual part of a binary expression:
     * e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
     * @returns {boolean|jsep.Expression}
     */
    gobbleToken() {
      let ch, to_check, tc_len, node;
      this.gobbleSpaces();
      node = this.searchHook("gobble-token");
      if (node) {
        return this.runHook("after-token", node);
      }
      ch = this.code;
      if (Jsep.isDecimalDigit(ch) || ch === Jsep.PERIOD_CODE) {
        return this.gobbleNumericLiteral();
      }
      if (ch === Jsep.SQUOTE_CODE || ch === Jsep.DQUOTE_CODE) {
        node = this.gobbleStringLiteral();
      } else if (ch === Jsep.OBRACK_CODE) {
        node = this.gobbleArray();
      } else {
        to_check = this.expr.substr(this.index, Jsep.max_unop_len);
        tc_len = to_check.length;
        while (tc_len > 0) {
          if (Jsep.unary_ops.hasOwnProperty(to_check) && (!Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
            this.index += tc_len;
            const argument = this.gobbleToken();
            if (!argument) {
              this.throwError("missing unaryOp argument");
            }
            return this.runHook("after-token", {
              type: Jsep.UNARY_EXP,
              operator: to_check,
              argument,
              prefix: true
            });
          }
          to_check = to_check.substr(0, --tc_len);
        }
        if (Jsep.isIdentifierStart(ch)) {
          node = this.gobbleIdentifier();
          if (Jsep.literals.hasOwnProperty(node.name)) {
            node = {
              type: Jsep.LITERAL,
              value: Jsep.literals[node.name],
              raw: node.name
            };
          } else if (node.name === Jsep.this_str) {
            node = { type: Jsep.THIS_EXP };
          }
        } else if (ch === Jsep.OPAREN_CODE) {
          node = this.gobbleGroup();
        }
      }
      if (!node) {
        return this.runHook("after-token", false);
      }
      node = this.gobbleTokenProperty(node);
      return this.runHook("after-token", node);
    }
    /**
     * Gobble properties of of identifiers/strings/arrays/groups.
     * e.g. `foo`, `bar.baz`, `foo['bar'].baz`
     * It also gobbles function calls:
     * e.g. `Math.acos(obj.angle)`
     * @param {jsep.Expression} node
     * @returns {jsep.Expression}
     */
    gobbleTokenProperty(node) {
      this.gobbleSpaces();
      let ch = this.code;
      while (ch === Jsep.PERIOD_CODE || ch === Jsep.OBRACK_CODE || ch === Jsep.OPAREN_CODE || ch === Jsep.QUMARK_CODE) {
        let optional;
        if (ch === Jsep.QUMARK_CODE) {
          if (this.expr.charCodeAt(this.index + 1) !== Jsep.PERIOD_CODE) {
            break;
          }
          optional = true;
          this.index += 2;
          this.gobbleSpaces();
          ch = this.code;
        }
        this.index++;
        if (ch === Jsep.OBRACK_CODE) {
          node = {
            type: Jsep.MEMBER_EXP,
            computed: true,
            object: node,
            property: this.gobbleExpression()
          };
          if (!node.property) {
            this.throwError('Unexpected "' + this.char + '"');
          }
          this.gobbleSpaces();
          ch = this.code;
          if (ch !== Jsep.CBRACK_CODE) {
            this.throwError("Unclosed [");
          }
          this.index++;
        } else if (ch === Jsep.OPAREN_CODE) {
          node = {
            type: Jsep.CALL_EXP,
            "arguments": this.gobbleArguments(Jsep.CPAREN_CODE),
            callee: node
          };
        } else if (ch === Jsep.PERIOD_CODE || optional) {
          if (optional) {
            this.index--;
          }
          this.gobbleSpaces();
          node = {
            type: Jsep.MEMBER_EXP,
            computed: false,
            object: node,
            property: this.gobbleIdentifier()
          };
        }
        if (optional) {
          node.optional = true;
        }
        this.gobbleSpaces();
        ch = this.code;
      }
      return node;
    }
    /**
     * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
     * keep track of everything in the numeric literal and then calling `parseFloat` on that string
     * @returns {jsep.Literal}
     */
    gobbleNumericLiteral() {
      let number3 = "", ch, chCode;
      while (Jsep.isDecimalDigit(this.code)) {
        number3 += this.expr.charAt(this.index++);
      }
      if (this.code === Jsep.PERIOD_CODE) {
        number3 += this.expr.charAt(this.index++);
        while (Jsep.isDecimalDigit(this.code)) {
          number3 += this.expr.charAt(this.index++);
        }
      }
      ch = this.char;
      if (ch === "e" || ch === "E") {
        number3 += this.expr.charAt(this.index++);
        ch = this.char;
        if (ch === "+" || ch === "-") {
          number3 += this.expr.charAt(this.index++);
        }
        while (Jsep.isDecimalDigit(this.code)) {
          number3 += this.expr.charAt(this.index++);
        }
        if (!Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {
          this.throwError("Expected exponent (" + number3 + this.char + ")");
        }
      }
      chCode = this.code;
      if (Jsep.isIdentifierStart(chCode)) {
        this.throwError("Variable names cannot start with a number (" + number3 + this.char + ")");
      } else if (chCode === Jsep.PERIOD_CODE || number3.length === 1 && number3.charCodeAt(0) === Jsep.PERIOD_CODE) {
        this.throwError("Unexpected period");
      }
      return {
        type: Jsep.LITERAL,
        value: parseFloat(number3),
        raw: number3
      };
    }
    /**
     * Parses a string literal, staring with single or double quotes with basic support for escape codes
     * e.g. `"hello world"`, `'this is\nJSEP'`
     * @returns {jsep.Literal}
     */
    gobbleStringLiteral() {
      let str = "";
      const startIndex = this.index;
      const quote = this.expr.charAt(this.index++);
      let closed = false;
      while (this.index < this.expr.length) {
        let ch = this.expr.charAt(this.index++);
        if (ch === quote) {
          closed = true;
          break;
        } else if (ch === "\\") {
          ch = this.expr.charAt(this.index++);
          switch (ch) {
            case "n":
              str += "\n";
              break;
            case "r":
              str += "\r";
              break;
            case "t":
              str += "	";
              break;
            case "b":
              str += "\b";
              break;
            case "f":
              str += "\f";
              break;
            case "v":
              str += "\v";
              break;
            default:
              str += ch;
          }
        } else {
          str += ch;
        }
      }
      if (!closed) {
        this.throwError('Unclosed quote after "' + str + '"');
      }
      return {
        type: Jsep.LITERAL,
        value: str,
        raw: this.expr.substring(startIndex, this.index)
      };
    }
    /**
     * Gobbles only identifiers
     * e.g.: `foo`, `_value`, `$x1`
     * Also, this function checks if that identifier is a literal:
     * (e.g. `true`, `false`, `null`) or `this`
     * @returns {jsep.Identifier}
     */
    gobbleIdentifier() {
      let ch = this.code, start = this.index;
      if (Jsep.isIdentifierStart(ch)) {
        this.index++;
      } else {
        this.throwError("Unexpected " + this.char);
      }
      while (this.index < this.expr.length) {
        ch = this.code;
        if (Jsep.isIdentifierPart(ch)) {
          this.index++;
        } else {
          break;
        }
      }
      return {
        type: Jsep.IDENTIFIER,
        name: this.expr.slice(start, this.index)
      };
    }
    /**
     * Gobbles a list of arguments within the context of a function call
     * or array literal. This function also assumes that the opening character
     * `(` or `[` has already been gobbled, and gobbles expressions and commas
     * until the terminator character `)` or `]` is encountered.
     * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
     * @param {number} termination
     * @returns {jsep.Expression[]}
     */
    gobbleArguments(termination) {
      const args = [];
      let closed = false;
      let separator_count = 0;
      while (this.index < this.expr.length) {
        this.gobbleSpaces();
        let ch_i = this.code;
        if (ch_i === termination) {
          closed = true;
          this.index++;
          if (termination === Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {
            this.throwError("Unexpected token " + String.fromCharCode(termination));
          }
          break;
        } else if (ch_i === Jsep.COMMA_CODE) {
          this.index++;
          separator_count++;
          if (separator_count !== args.length) {
            if (termination === Jsep.CPAREN_CODE) {
              this.throwError("Unexpected token ,");
            } else if (termination === Jsep.CBRACK_CODE) {
              for (let arg = args.length; arg < separator_count; arg++) {
                args.push(null);
              }
            }
          }
        } else if (args.length !== separator_count && separator_count !== 0) {
          this.throwError("Expected comma");
        } else {
          const node = this.gobbleExpression();
          if (!node || node.type === Jsep.COMPOUND) {
            this.throwError("Expected comma");
          }
          args.push(node);
        }
      }
      if (!closed) {
        this.throwError("Expected " + String.fromCharCode(termination));
      }
      return args;
    }
    /**
     * Responsible for parsing a group of things within parentheses `()`
     * that have no identifier in front (so not a function call)
     * This function assumes that it needs to gobble the opening parenthesis
     * and then tries to gobble everything within that parenthesis, assuming
     * that the next thing it should see is the close parenthesis. If not,
     * then the expression probably doesn't have a `)`
     * @returns {boolean|jsep.Expression}
     */
    gobbleGroup() {
      this.index++;
      let nodes = this.gobbleExpressions(Jsep.CPAREN_CODE);
      if (this.code === Jsep.CPAREN_CODE) {
        this.index++;
        if (nodes.length === 1) {
          return nodes[0];
        } else if (!nodes.length) {
          return false;
        } else {
          return {
            type: Jsep.SEQUENCE_EXP,
            expressions: nodes
          };
        }
      } else {
        this.throwError("Unclosed (");
      }
    }
    /**
     * Responsible for parsing Array literals `[1, 2, 3]`
     * This function assumes that it needs to gobble the opening bracket
     * and then tries to gobble the expressions as arguments.
     * @returns {jsep.ArrayExpression}
     */
    gobbleArray() {
      this.index++;
      return {
        type: Jsep.ARRAY_EXP,
        elements: this.gobbleArguments(Jsep.CBRACK_CODE)
      };
    }
  };
  var hooks = new Hooks();
  Object.assign(Jsep, {
    hooks,
    plugins: new Plugins(Jsep),
    // Node Types
    // ----------
    // This is the full set of types that any JSEP node can be.
    // Store them here to save space when minified
    COMPOUND: "Compound",
    SEQUENCE_EXP: "SequenceExpression",
    IDENTIFIER: "Identifier",
    MEMBER_EXP: "MemberExpression",
    LITERAL: "Literal",
    THIS_EXP: "ThisExpression",
    CALL_EXP: "CallExpression",
    UNARY_EXP: "UnaryExpression",
    BINARY_EXP: "BinaryExpression",
    ARRAY_EXP: "ArrayExpression",
    TAB_CODE: 9,
    LF_CODE: 10,
    CR_CODE: 13,
    SPACE_CODE: 32,
    PERIOD_CODE: 46,
    // '.'
    COMMA_CODE: 44,
    // ','
    SQUOTE_CODE: 39,
    // single quote
    DQUOTE_CODE: 34,
    // double quotes
    OPAREN_CODE: 40,
    // (
    CPAREN_CODE: 41,
    // )
    OBRACK_CODE: 91,
    // [
    CBRACK_CODE: 93,
    // ]
    QUMARK_CODE: 63,
    // ?
    SEMCOL_CODE: 59,
    // ;
    COLON_CODE: 58,
    // :
    // Operations
    // ----------
    // Use a quickly-accessible map to store all of the unary operators
    // Values are set to `1` (it really doesn't matter)
    unary_ops: {
      "-": 1,
      "!": 1,
      "~": 1,
      "+": 1
    },
    // Also use a map for the binary operations but set their values to their
    // binary precedence for quick reference (higher number = higher precedence)
    // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
    binary_ops: {
      "||": 1,
      "??": 1,
      "&&": 2,
      "|": 3,
      "^": 4,
      "&": 5,
      "==": 6,
      "!=": 6,
      "===": 6,
      "!==": 6,
      "<": 7,
      ">": 7,
      "<=": 7,
      ">=": 7,
      "<<": 8,
      ">>": 8,
      ">>>": 8,
      "+": 9,
      "-": 9,
      "*": 10,
      "/": 10,
      "%": 10,
      "**": 11
    },
    // sets specific binary_ops as right-associative
    right_associative: /* @__PURE__ */ new Set(["**"]),
    // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)
    additional_identifier_chars: /* @__PURE__ */ new Set(["$", "_"]),
    // Literals
    // ----------
    // Store the values to return for the various literals we may encounter
    literals: {
      "true": true,
      "false": false,
      "null": null
    },
    // Except for `this`, which is special. This could be changed to something like `'self'` as well
    this_str: "this"
  });
  Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
  Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);
  var jsep = (expr) => new Jsep(expr).parse();
  var stdClassProps = Object.getOwnPropertyNames(class Test {
  });
  Object.getOwnPropertyNames(Jsep).filter((prop) => !stdClassProps.includes(prop) && jsep[prop] === void 0).forEach((m) => {
    jsep[m] = Jsep[m];
  });
  jsep.Jsep = Jsep;
  var CONDITIONAL_EXP = "ConditionalExpression";
  var ternary = {
    name: "ternary",
    init(jsep2) {
      jsep2.hooks.add("after-expression", function gobbleTernary(env) {
        if (env.node && this.code === jsep2.QUMARK_CODE) {
          this.index++;
          const test = env.node;
          const consequent = this.gobbleExpression();
          if (!consequent) {
            this.throwError("Expected expression");
          }
          this.gobbleSpaces();
          if (this.code === jsep2.COLON_CODE) {
            this.index++;
            const alternate = this.gobbleExpression();
            if (!alternate) {
              this.throwError("Expected expression");
            }
            env.node = {
              type: CONDITIONAL_EXP,
              test,
              consequent,
              alternate
            };
            if (test.operator && jsep2.binary_ops[test.operator] <= 0.9) {
              let newTest = test;
              while (newTest.right.operator && jsep2.binary_ops[newTest.right.operator] <= 0.9) {
                newTest = newTest.right;
              }
              env.node.test = newTest.right;
              newTest.right = env.node;
              env.node = test;
            }
          } else {
            this.throwError("Expected :");
          }
        }
      });
    }
  };
  jsep.plugins.register(ternary);

  // ../../node_modules/d3-array/src/ascending.js
  function ascending(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // ../../node_modules/d3-array/src/descending.js
  function descending(a, b) {
    return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  // ../../node_modules/d3-array/src/bisector.js
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d, x) => ascending(f(d), x);
      delta = (d, x) => f(d) - x;
    } else {
      compare1 = f === ascending || f === descending ? f : zero;
      compare2 = f;
      delta = f;
    }
    function left(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) < 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0)
          return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) <= 0)
            lo = mid + 1;
          else
            hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center(a, x, lo = 0, hi = a.length) {
      const i = left(a, x, lo, hi - 1);
      return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }
    return { left, center, right };
  }
  function zero() {
    return 0;
  }

  // ../../node_modules/d3-array/src/number.js
  function number(x) {
    return x === null ? NaN : +x;
  }

  // ../../node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number).center;
  var bisect_default = bisectRight;

  // ../../node_modules/internmap/src/index.js
  var InternMap = class extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null)
        for (const [key2, value] of entries)
          this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  };
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key))
      return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  // ../../node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function tickSpec(start, stop, count) {
    const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start * inc);
      i2 = Math.round(stop * inc);
      if (i1 / inc < start)
        ++i1;
      if (i2 / inc > stop)
        --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start / inc);
      i2 = Math.round(stop / inc);
      if (i1 * inc < start)
        ++i1;
      if (i2 * inc > stop)
        --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2)
      return tickSpec(start, stop, count * 2);
    return [i1, i2, inc];
  }
  function ticks(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    if (!(count > 0))
      return [];
    if (start === stop)
      return [start];
    const reverse = stop < start, [i1, i2, inc] = reverse ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
    if (!(i2 >= i1))
      return [];
    const n = i2 - i1 + 1, ticks2 = new Array(n);
    if (reverse) {
      if (inc < 0)
        for (let i = 0; i < n; ++i)
          ticks2[i] = (i2 - i) / -inc;
      else
        for (let i = 0; i < n; ++i)
          ticks2[i] = (i2 - i) * inc;
    } else {
      if (inc < 0)
        for (let i = 0; i < n; ++i)
          ticks2[i] = (i1 + i) / -inc;
      else
        for (let i = 0; i < n; ++i)
          ticks2[i] = (i1 + i) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    return tickSpec(start, stop, count)[2];
  }
  function tickStep(start, stop, count) {
    stop = +stop, start = +start, count = +count;
    const reverse = stop < start, inc = reverse ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
    return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
  }

  // ../../node_modules/d3-array/src/quantile.js
  function quantileSorted(values, p, valueof = number) {
    if (!(n = values.length) || isNaN(p = +p))
      return;
    if (p <= 0 || n < 2)
      return +valueof(values[0], 0, values);
    if (p >= 1)
      return +valueof(values[n - 1], n - 1, values);
    var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
    return value0 + (value1 - value0) * (i - i0);
  }

  // ../../node_modules/d3-array/src/range.js
  function range(start, stop, step) {
    start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop - start) / step)) | 0, range2 = new Array(n);
    while (++i < n) {
      range2[i] = start + i * step;
    }
    return range2;
  }

  // ../../node_modules/d3-scale/src/init.js
  function initRange(domain, range2) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range2).domain(domain);
        break;
    }
    return this;
  }

  // ../../node_modules/d3-scale/src/ordinal.js
  var implicit = Symbol("implicit");
  function ordinal() {
    var index2 = new InternMap(), domain = [], range2 = [], unknown = implicit;
    function scale(d) {
      let i = index2.get(d);
      if (i === void 0) {
        if (unknown !== implicit)
          return unknown;
        index2.set(d, i = domain.push(d) - 1);
      }
      return range2[i % range2.length];
    }
    scale.domain = function(_) {
      if (!arguments.length)
        return domain.slice();
      domain = [], index2 = new InternMap();
      for (const value of _) {
        if (index2.has(value))
          continue;
        index2.set(value, domain.push(value) - 1);
      }
      return scale;
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), scale) : range2.slice();
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return ordinal(domain, range2).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return scale;
  }

  // ../../node_modules/d3-scale/src/band.js
  function band() {
    var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
      var n = domain().length, reverse = r1 < r0, start = reverse ? r1 : r0, stop = reverse ? r0 : r1;
      step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round)
        step = Math.floor(step);
      start += (stop - start - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round)
        start = Math.round(start), bandwidth = Math.round(bandwidth);
      var values = range(n).map(function(i) {
        return start + step * i;
      });
      return ordinalRange(reverse ? values.reverse() : values);
    }
    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.range = function(_) {
      return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale.rangeRound = function(_) {
      return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
    };
    scale.bandwidth = function() {
      return bandwidth;
    };
    scale.step = function() {
      return step;
    };
    scale.round = function(_) {
      return arguments.length ? (round = !!_, rescale()) : round;
    };
    scale.padding = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_) {
      return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_) {
      return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
    };
    scale.align = function(_) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
    };
    scale.copy = function() {
      return band(domain(), [r0, r1]).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }
  function pointish(scale) {
    var copy3 = scale.copy;
    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;
    scale.copy = function() {
      return pointish(copy3());
    };
    return scale;
  }
  function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }

  // ../../node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }

  // ../../node_modules/d3-color/src/color.js
  function Color3() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color3, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba(r, g, b, a) {
    if (a <= 0)
      r = g = b = NaN;
    return new Rgb(r, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color3))
      o = color(o);
    if (!o)
      return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend(Color3, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla(h, s, l, a) {
    if (a <= 0)
      h = s = l = NaN;
    else if (l <= 0 || l >= 1)
      h = s = NaN;
    else if (s <= 0)
      h = NaN;
    return new Hsl(h, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl)
      return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color3))
      o = color(o);
    if (!o)
      return new Hsl();
    if (o instanceof Hsl)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
    if (s) {
      if (r === max2)
        h = (g - b) / s + (g < b) * 6;
      else if (g === max2)
        h = (b - r) / s + 2;
      else
        h = (r - g) / s + 4;
      s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }
  function hsl(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend(Color3, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  // ../../node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values) {
    var n = values.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // ../../node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // ../../node_modules/d3-interpolate/src/constant.js
  var constant_default = (x) => () => x;

  // ../../node_modules/d3-interpolate/src/color.js
  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }
  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }
  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
  }

  // ../../node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y) {
    var color3 = gamma(y);
    function rgb3(start, end) {
      var r = color3((start = rgb(start)).r, (end = rgb(end)).r), g = color3(start.g, end.g), b = color3(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.r = r(t);
        start.g = g(t);
        start.b = b(t);
        start.opacity = opacity(t);
        return start + "";
      };
    }
    rgb3.gamma = rgbGamma;
    return rgb3;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color3;
      for (i = 0; i < n; ++i) {
        color3 = rgb(colors[i]);
        r[i] = color3.r || 0;
        g[i] = color3.g || 0;
        b[i] = color3.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color3.opacity = 1;
      return function(t) {
        color3.r = r(t);
        color3.g = g(t);
        color3.b = b(t);
        return color3 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // ../../node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a, b) {
    if (!b)
      b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
      for (i = 0; i < n; ++i)
        c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }
  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  // ../../node_modules/d3-interpolate/src/array.js
  function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i)
      x[i] = value_default(a[i], b[i]);
    for (; i < nb; ++i)
      c[i] = b[i];
    return function(t) {
      for (i = 0; i < na; ++i)
        c[i] = x[i](t);
      return c;
    };
  }

  // ../../node_modules/d3-interpolate/src/date.js
  function date_default(a, b) {
    var d = new Date();
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  // ../../node_modules/d3-interpolate/src/number.js
  function number_default(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  // ../../node_modules/d3-interpolate/src/object.js
  function object_default(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object")
      a = {};
    if (b === null || typeof b !== "object")
      b = {};
    for (k in b) {
      if (k in a) {
        i[k] = value_default(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i)
        c[k] = i[k](t);
      return c;
    };
  }

  // ../../node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero2(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i])
          s[i] += bs;
        else
          s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i])
          s[i] += bm;
        else
          s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2)
        s[(o = q[i2]).i] = o.x(t);
      return s.join("");
    });
  }

  // ../../node_modules/d3-interpolate/src/value.js
  function value_default(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
  }

  // ../../node_modules/d3-interpolate/src/round.js
  function round_default(a, b) {
    return a = +a, b = +b, function(t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }

  // ../../node_modules/d3-scale/src/constant.js
  function constants(x) {
    return function() {
      return x;
    };
  }

  // ../../node_modules/d3-scale/src/number.js
  function number2(x) {
    return +x;
  }

  // ../../node_modules/d3-scale/src/continuous.js
  var unit = [0, 1];
  function identity(x) {
    return x;
  }
  function normalize(a, b) {
    return (b -= a = +a) ? function(x) {
      return (x - a) / b;
    } : constants(isNaN(b) ? NaN : 0.5);
  }
  function clamper(a, b) {
    var t;
    if (a > b)
      t = a, a = b, b = t;
    return function(x) {
      return Math.max(a, Math.min(b, x));
    };
  }
  function bimap(domain, range2, interpolate) {
    var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
    if (d1 < d0)
      d0 = normalize(d1, d0), r0 = interpolate(r1, r0);
    else
      d0 = normalize(d0, d1), r0 = interpolate(r0, r1);
    return function(x) {
      return r0(d0(x));
    };
  }
  function polymap(domain, range2, interpolate) {
    var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range2 = range2.slice().reverse();
    }
    while (++i < j) {
      d[i] = normalize(domain[i], domain[i + 1]);
      r[i] = interpolate(range2[i], range2[i + 1]);
    }
    return function(x) {
      var i2 = bisect_default(domain, x, 1, j) - 1;
      return r[i2](d[i2](x));
    };
  }
  function copy2(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer() {
    var domain = unit, range2 = unit, interpolate = value_default, transform, untransform, unknown, clamp2 = identity, piecewise, output, input;
    function rescale() {
      var n = Math.min(domain.length, range2.length);
      if (clamp2 !== identity)
        clamp2 = clamper(domain[0], domain[n - 1]);
      piecewise = n > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }
    function scale(x) {
      return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range2, interpolate)))(transform(clamp2(x)));
    }
    scale.invert = function(y) {
      return clamp2(untransform((input || (input = piecewise(range2, domain.map(transform), number_default)))(y)));
    };
    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
    };
    scale.rangeRound = function(_) {
      return range2 = Array.from(_), interpolate = round_default, rescale();
    };
    scale.clamp = function(_) {
      return arguments.length ? (clamp2 = _ ? true : identity, rescale()) : clamp2 !== identity;
    };
    scale.interpolate = function(_) {
      return arguments.length ? (interpolate = _, rescale()) : interpolate;
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    return function(t, u4) {
      transform = t, untransform = u4;
      return rescale();
    };
  }
  function continuous() {
    return transformer()(identity, identity);
  }

  // ../../node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x) {
    return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
  }
  function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
      return null;
    var i, coefficient = x.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  // ../../node_modules/d3-format/src/exponent.js
  function exponent_default(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
  }

  // ../../node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width) {
      var i = value.length, t = [], j = 0, g = grouping[0], length2 = 0;
      while (i > 0 && g > 0) {
        if (length2 + g + 1 > width)
          g = Math.max(1, width - length2);
        t.push(value.substring(i -= g, i + g));
        if ((length2 += g + 1) > width)
          break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }

  // ../../node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // ../../node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match = re.exec(specifier)))
      throw new Error("invalid format: " + specifier);
    var match;
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // ../../node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s) {
    out:
      for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
        switch (s[i]) {
          case ".":
            i0 = i1 = i;
            break;
          case "0":
            if (i0 === 0)
              i0 = i;
            i1 = i;
            break;
          default:
            if (!+s[i])
              break out;
            if (i0 > 0)
              i0 = 0;
            break;
        }
      }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  // ../../node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d)
      return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
  }

  // ../../node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d)
      return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // ../../node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x, p) => (x * 100).toFixed(p),
    "b": (x) => Math.round(x).toString(2),
    "c": (x) => x + "",
    "d": formatDecimal_default,
    "e": (x, p) => x.toExponential(p),
    "f": (x, p) => x.toFixed(p),
    "g": (x, p) => x.toPrecision(p),
    "o": (x) => Math.round(x).toString(8),
    "p": (x, p) => formatRounded_default(x * 100, p),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x) => Math.round(x).toString(16).toUpperCase(),
    "x": (x) => Math.round(x).toString(16)
  };

  // ../../node_modules/d3-format/src/identity.js
  function identity_default(x) {
    return x;
  }

  // ../../node_modules/d3-format/src/locale.js
  var map = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale2) {
    var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default : formatGroup_default(map.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default : formatNumerals_default(map.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width = specifier.width, comma = specifier.comma, precision2 = specifier.precision, trim = specifier.trim, type = specifier.type;
      if (type === "n")
        comma = true, type = "g";
      else if (!formatTypes_default[type])
        precision2 === void 0 && (precision2 = 12), trim = true, type = "g";
      if (zero3 || fill === "0" && align === "=")
        zero3 = true, fill = "0", align = "=";
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
      var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
      precision2 = precision2 === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision2)) : Math.max(0, Math.min(20, precision2));
      function format2(value) {
        var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision2);
          if (trim)
            value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign !== "+")
            valueNegative = false;
          valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero3)
          value = group(value, Infinity);
        var length2 = valuePrefix.length + value.length + valueSuffix.length, padding = length2 < width ? new Array(width - length2 + 1).join(fill) : "";
        if (comma && zero3)
          value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding;
            break;
          case "=":
            value = valuePrefix + padding + value + valueSuffix;
            break;
          case "^":
            value = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length2);
            break;
          default:
            value = padding + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
      return function(value2) {
        return f(k * value2) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // ../../node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // ../../node_modules/d3-format/src/precisionFixed.js
  function precisionFixed_default(step) {
    return Math.max(0, -exponent_default(Math.abs(step)));
  }

  // ../../node_modules/d3-format/src/precisionPrefix.js
  function precisionPrefix_default(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
  }

  // ../../node_modules/d3-format/src/precisionRound.js
  function precisionRound_default(step, max2) {
    step = Math.abs(step), max2 = Math.abs(max2) - step;
    return Math.max(0, exponent_default(max2) - exponent_default(step)) + 1;
  }

  // ../../node_modules/d3-scale/src/tickFormat.js
  function tickFormat(start, stop, count, specifier) {
    var step = tickStep(start, stop, count), precision2;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision2 = precisionPrefix_default(step, value)))
          specifier.precision = precision2;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision2 = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop)))))
          specifier.precision = precision2 - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision2 = precisionFixed_default(step)))
          specifier.precision = precision2 - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  // ../../node_modules/d3-scale/src/linear.js
  function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
      if (count == null)
        count = 10;
      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start = d[i0];
      var stop = d[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop < start) {
        step = start, start = stop, stop = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start, stop, count);
        if (step === prestep) {
          d[i0] = start;
          d[i1] = stop;
          return domain(d);
        } else if (step > 0) {
          start = Math.floor(start / step) * step;
          stop = Math.ceil(stop / step) * step;
        } else if (step < 0) {
          start = Math.ceil(start * step) / step;
          stop = Math.floor(stop * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale;
    };
    return scale;
  }
  function linear2() {
    var scale = continuous();
    scale.copy = function() {
      return copy2(scale, linear2());
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }

  // ../../node_modules/d3-scale/src/nice.js
  function nice(domain, interval) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }

  // ../../node_modules/d3-scale/src/log.js
  function transformLog(x) {
    return Math.log(x);
  }
  function transformExp(x) {
    return Math.exp(x);
  }
  function transformLogn(x) {
    return -Math.log(-x);
  }
  function transformExpn(x) {
    return -Math.exp(-x);
  }
  function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
  }
  function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x) => Math.pow(base, x);
  }
  function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x) => Math.log(x) / base);
  }
  function reflect(f) {
    return (x, k) => -f(-x, k);
  }
  function loggish(transform) {
    const scale = transform(transformLog, transformExp);
    const domain = scale.domain;
    let base = 10;
    let logs;
    let pows;
    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform(transformLogn, transformExpn);
      } else {
        transform(transformLog, transformExp);
      }
      return scale;
    }
    scale.base = function(_) {
      return arguments.length ? (base = +_, rescale()) : base;
    };
    scale.domain = function(_) {
      return arguments.length ? (domain(_), rescale()) : domain();
    };
    scale.ticks = (count) => {
      const d = domain();
      let u4 = d[0];
      let v2 = d[d.length - 1];
      const r = v2 < u4;
      if (r)
        [u4, v2] = [v2, u4];
      let i = logs(u4);
      let j = logs(v2);
      let k;
      let t;
      const n = count == null ? 10 : +count;
      let z = [];
      if (!(base % 1) && j - i < n) {
        i = Math.floor(i), j = Math.ceil(j);
        if (u4 > 0)
          for (; i <= j; ++i) {
            for (k = 1; k < base; ++k) {
              t = i < 0 ? k / pows(-i) : k * pows(i);
              if (t < u4)
                continue;
              if (t > v2)
                break;
              z.push(t);
            }
          }
        else
          for (; i <= j; ++i) {
            for (k = base - 1; k >= 1; --k) {
              t = i > 0 ? k / pows(-i) : k * pows(i);
              if (t < u4)
                continue;
              if (t > v2)
                break;
              z.push(t);
            }
          }
        if (z.length * 2 < n)
          z = ticks(u4, v2, n);
      } else {
        z = ticks(i, j, Math.min(j - i, n)).map(pows);
      }
      return r ? z.reverse() : z;
    };
    scale.tickFormat = (count, specifier) => {
      if (count == null)
        count = 10;
      if (specifier == null)
        specifier = base === 10 ? "s" : ",";
      if (typeof specifier !== "function") {
        if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
          specifier.trim = true;
        specifier = format(specifier);
      }
      if (count === Infinity)
        return specifier;
      const k = Math.max(1, base * count / scale.ticks().length);
      return (d) => {
        let i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5)
          i *= base;
        return i <= k ? specifier(d) : "";
      };
    };
    scale.nice = () => {
      return domain(nice(domain(), {
        floor: (x) => pows(Math.floor(logs(x))),
        ceil: (x) => pows(Math.ceil(logs(x)))
      }));
    };
    return scale;
  }
  function log6() {
    const scale = loggish(transformer()).domain([1, 10]);
    scale.copy = () => copy2(scale, log6()).base(scale.base());
    initRange.apply(scale, arguments);
    return scale;
  }

  // ../../node_modules/d3-scale/src/pow.js
  function transformPow(exponent) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
    };
  }
  function transformSqrt(x) {
    return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
  }
  function transformSquare(x) {
    return x < 0 ? -x * x : x * x;
  }
  function powish(transform) {
    var scale = transform(identity, identity), exponent = 1;
    function rescale() {
      return exponent === 1 ? transform(identity, identity) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
    }
    scale.exponent = function(_) {
      return arguments.length ? (exponent = +_, rescale()) : exponent;
    };
    return linearish(scale);
  }
  function pow() {
    var scale = powish(transformer());
    scale.copy = function() {
      return copy2(scale, pow()).exponent(scale.exponent());
    };
    initRange.apply(scale, arguments);
    return scale;
  }
  function sqrt() {
    return pow.apply(null, arguments).exponent(0.5);
  }

  // ../../node_modules/d3-scale/src/quantile.js
  function quantile2() {
    var domain = [], range2 = [], thresholds = [], unknown;
    function rescale() {
      var i = 0, n = Math.max(1, range2.length);
      thresholds = new Array(n - 1);
      while (++i < n)
        thresholds[i - 1] = quantileSorted(domain, i / n);
      return scale;
    }
    function scale(x) {
      return x == null || isNaN(x = +x) ? unknown : range2[bisect_default(thresholds, x)];
    }
    scale.invertExtent = function(y) {
      var i = range2.indexOf(y);
      return i < 0 ? [NaN, NaN] : [
        i > 0 ? thresholds[i - 1] : domain[0],
        i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
      ];
    };
    scale.domain = function(_) {
      if (!arguments.length)
        return domain.slice();
      domain = [];
      for (let d of _)
        if (d != null && !isNaN(d = +d))
          domain.push(d);
      domain.sort(ascending);
      return rescale();
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.quantiles = function() {
      return thresholds.slice();
    };
    scale.copy = function() {
      return quantile2().domain(domain).range(range2).unknown(unknown);
    };
    return initRange.apply(scale, arguments);
  }

  // ../../node_modules/d3-scale/src/quantize.js
  function quantize() {
    var x0 = 0, x1 = 1, n = 1, domain = [0.5], range2 = [0, 1], unknown;
    function scale(x) {
      return x != null && x <= x ? range2[bisect_default(domain, x, 0, n)] : unknown;
    }
    function rescale() {
      var i = -1;
      domain = new Array(n);
      while (++i < n)
        domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
      return scale;
    }
    scale.domain = function(_) {
      return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
    };
    scale.range = function(_) {
      return arguments.length ? (n = (range2 = Array.from(_)).length - 1, rescale()) : range2.slice();
    };
    scale.invertExtent = function(y) {
      var i = range2.indexOf(y);
      return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : scale;
    };
    scale.thresholds = function() {
      return domain.slice();
    };
    scale.copy = function() {
      return quantize().domain([x0, x1]).range(range2).unknown(unknown);
    };
    return initRange.apply(linearish(scale), arguments);
  }

  // ../../node_modules/d3-scale/src/threshold.js
  function threshold() {
    var domain = [0.5], range2 = [0, 1], unknown, n = 1;
    function scale(x) {
      return x != null && x <= x ? range2[bisect_default(domain, x, 0, n)] : unknown;
    }
    scale.domain = function(_) {
      return arguments.length ? (domain = Array.from(_), n = Math.min(domain.length, range2.length - 1), scale) : domain.slice();
    };
    scale.range = function(_) {
      return arguments.length ? (range2 = Array.from(_), n = Math.min(domain.length, range2.length - 1), scale) : range2.slice();
    };
    scale.invertExtent = function(y) {
      var i = range2.indexOf(y);
      return [domain[i - 1], domain[i]];
    };
    scale.unknown = function(_) {
      return arguments.length ? (unknown = _, scale) : unknown;
    };
    scale.copy = function() {
      return threshold().domain(domain).range(range2).unknown(unknown);
    };
    return initRange.apply(scale, arguments);
  }

  // ../../node_modules/@carto/api-client/build/api-client.js
  var import_meta = {};
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS2 = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames2(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __copyProps2 = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod2, isNodeMode, target) => (target = mod2 != null ? __create2(__getProtoOf2(mod2)) : {}, __copyProps2(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp2(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  var require_thenBy_module = __commonJS2({
    "node_modules/thenby/thenBy.module.js"(exports, module) {
      "use strict";
      module.exports = function() {
        function identity3(v2) {
          return v2;
        }
        function ignoreCase(v2) {
          return typeof v2 === "string" ? v2.toLowerCase() : v2;
        }
        function makeCompareFunction(f, opt) {
          opt = typeof opt === "object" ? opt : { direction: opt };
          if (typeof f != "function") {
            var prop = f;
            f = function(v1) {
              return !!v1[prop] ? v1[prop] : "";
            };
          }
          if (f.length === 1) {
            var uf = f;
            var preprocess = opt.ignoreCase ? ignoreCase : identity3;
            var cmp = opt.cmp || function(v1, v2) {
              return v1 < v2 ? -1 : v1 > v2 ? 1 : 0;
            };
            f = function(v1, v2) {
              return cmp(preprocess(uf(v1)), preprocess(uf(v2)));
            };
          }
          const descTokens = { "-1": "", desc: "" };
          if (opt.direction in descTokens)
            return function(v1, v2) {
              return -f(v1, v2);
            };
          return f;
        }
        function tb(func, opt) {
          var x = typeof this == "function" && !this.firstBy ? this : false;
          var y = makeCompareFunction(func, opt);
          var f = x ? function(a, b) {
            return x(a, b) || y(a, b);
          } : y;
          f.thenBy = tb;
          return f;
        }
        tb.firstBy = tb;
        return tb;
      }();
    }
  });
  var client = "deck-gl-carto";
  function getClient() {
    return client;
  }
  var FilterType = /* @__PURE__ */ ((FilterType2) => {
    FilterType2["IN"] = "in";
    FilterType2["BETWEEN"] = "between";
    FilterType2["CLOSED_OPEN"] = "closed_open";
    FilterType2["TIME"] = "time";
    FilterType2["STRING_SEARCH"] = "stringSearch";
    return FilterType2;
  })(FilterType || {});
  var ApiVersion = /* @__PURE__ */ ((ApiVersion2) => {
    ApiVersion2["V1"] = "v1";
    ApiVersion2["V2"] = "v2";
    ApiVersion2["V3"] = "v3";
    return ApiVersion2;
  })(ApiVersion || {});
  var DEFAULT_API_BASE_URL = "https://gcp-us-east1.api.carto.com";
  var SpatialIndex = /* @__PURE__ */ ((SpatialIndex2) => {
    SpatialIndex2["H3"] = "h3";
    SpatialIndex2["QUADBIN"] = "quadbin";
    return SpatialIndex2;
  })(SpatialIndex || {});
  var SpatialIndexColumn = Object.freeze({
    [
      "h3"
      /* H3 */
    ]: ["h3", "hex", "h3id", "hex_id", "h3hex"],
    [
      "quadbin"
      /* QUADBIN */
    ]: ["quadbin"]
  });
  var AggregationTypes = {
    Count: "count",
    Avg: "avg",
    Min: "min",
    Max: "max",
    Sum: "sum",
    Custom: "custom"
  };
  function makeIntervalComplete(intervals) {
    return intervals.map((val) => {
      if (val[0] === void 0 || val[0] === null) {
        return [Number.MIN_SAFE_INTEGER, val[1]];
      }
      if (val[1] === void 0 || val[1] === null) {
        return [val[0], Number.MAX_SAFE_INTEGER];
      }
      return val;
    });
  }
  var filterFunctions = {
    [
      "in"
      /* IN */
    ]: filterIn,
    [
      "between"
      /* BETWEEN */
    ]: filterBetween,
    [
      "time"
      /* TIME */
    ]: filterTime,
    [
      "closed_open"
      /* CLOSED_OPEN */
    ]: filterClosedOpen,
    [
      "stringSearch"
      /* STRING_SEARCH */
    ]: filterStringSearch
  };
  function filterIn(filterValues, featureValue) {
    return filterValues.includes(featureValue);
  }
  function filterBetween(filterValues, featureValue) {
    const checkRange = (range2) => {
      const [lowerBound, upperBound] = range2;
      return featureValue >= lowerBound && featureValue <= upperBound;
    };
    return makeIntervalComplete(filterValues).some(
      checkRange
    );
  }
  function filterTime(filterValues, featureValue) {
    const featureValueAsTimestamp = new Date(featureValue).getTime();
    if (isFinite(featureValueAsTimestamp)) {
      return filterBetween(filterValues, featureValueAsTimestamp);
    } else {
      throw new Error(`Column used to filter by time isn't well formatted.`);
    }
  }
  function filterClosedOpen(filterValues, featureValue) {
    const checkRange = (range2) => {
      const [lowerBound, upperBound] = range2;
      return featureValue >= lowerBound && featureValue < upperBound;
    };
    return makeIntervalComplete(filterValues).some(
      checkRange
    );
  }
  function filterStringSearch(filterValues, featureValue, params = {}) {
    const normalizedFeatureValue = normalize2(featureValue, params);
    const stringRegExp = params.useRegExp ? filterValues : filterValues.map((filterValue) => {
      let stringRegExp2 = escapeRegExp(normalize2(filterValue, params));
      if (params.mustStart)
        stringRegExp2 = `^${stringRegExp2}`;
      if (params.mustEnd)
        stringRegExp2 = `${stringRegExp2}$`;
      return stringRegExp2;
    });
    const regex = new RegExp(
      stringRegExp.join("|"),
      params.caseSensitive ? "g" : "gi"
    );
    return !!normalizedFeatureValue.match(regex);
  }
  var specialCharRegExp = /[.*+?^${}()|[\]\\]/g;
  var normalizeRegExp = /\p{Diacritic}/gu;
  function escapeRegExp(value) {
    return value.replace(specialCharRegExp, "\\$&");
  }
  function normalize2(data, params) {
    let normalizedData = String(data);
    if (!params.keepSpecialCharacters)
      normalizedData = normalizedData.normalize("NFD").replace(normalizeRegExp, "");
    return normalizedData;
  }
  var LOGICAL_OPERATOR_METHODS = {
    and: "every",
    or: "some"
  };
  function passesFilter(columns, filters, feature2, filtersLogicalOperator) {
    const method = LOGICAL_OPERATOR_METHODS[filtersLogicalOperator];
    return columns[method]((column) => {
      const columnFilters = filters[column];
      const columnFilterTypes = Object.keys(columnFilters);
      if (!feature2 || feature2[column] === null || feature2[column] === void 0) {
        return false;
      }
      return columnFilterTypes.every((filter) => {
        const filterFunction = filterFunctions[filter];
        if (!filterFunction) {
          throw new Error(`"${filter}" filter is not implemented.`);
        }
        return filterFunction(
          columnFilters[filter].values,
          feature2[column],
          columnFilters[filter].params
        );
      });
    });
  }
  function _buildFeatureFilter({
    filters = {},
    type = "boolean",
    filtersLogicalOperator = "and"
  }) {
    const columns = Object.keys(filters);
    if (!columns.length) {
      return () => type === "number" ? 1 : true;
    }
    return (feature2) => {
      const f = feature2.properties || feature2;
      const featurePassesFilter = passesFilter(
        columns,
        filters,
        f,
        filtersLogicalOperator
      );
      return type === "number" ? Number(featurePassesFilter) : featurePassesFilter;
    };
  }
  function applyFilters(features, filters, filtersLogicalOperator) {
    return Object.keys(filters).length ? features.filter(_buildFeatureFilter({ filters, filtersLogicalOperator })) : features;
  }
  var epsilon = 11102230246251565e-32;
  var splitter = 134217729;
  var resulterrbound = (3 + 8 * epsilon) * epsilon;
  function sum(elen, e, flen, f, h) {
    let Q, Qnew, hh, bvirt;
    let enow = e[0];
    let fnow = f[0];
    let eindex = 0;
    let findex = 0;
    if (fnow > enow === fnow > -enow) {
      Q = enow;
      enow = e[++eindex];
    } else {
      Q = fnow;
      fnow = f[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = enow + Q;
        hh = Q - (Qnew - enow);
        enow = e[++eindex];
      } else {
        Qnew = fnow + Q;
        hh = Q - (Qnew - fnow);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
      while (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
          Qnew = Q + enow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (enow - bvirt);
          enow = e[++eindex];
        } else {
          Qnew = Q + fnow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (fnow - bvirt);
          fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) {
          h[hindex++] = hh;
        }
      }
    }
    while (eindex < elen) {
      Qnew = Q + enow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (enow - bvirt);
      enow = e[++eindex];
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
    while (findex < flen) {
      Qnew = Q + fnow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (fnow - bvirt);
      fnow = f[++findex];
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
    if (Q !== 0 || hindex === 0) {
      h[hindex++] = Q;
    }
    return hindex;
  }
  function estimate(elen, e) {
    let Q = e[0];
    for (let i = 1; i < elen; i++)
      Q += e[i];
    return Q;
  }
  function vec(n) {
    return new Float64Array(n);
  }
  var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
  var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
  var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
  var B3 = vec(4);
  var C1 = vec(8);
  var C2 = vec(12);
  var D = vec(16);
  var u = vec(4);
  function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;
    s1 = acx * bcy;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcx;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    B3[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    B3[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u32 = _j + _i;
    bvirt = u32 - _j;
    B3[2] = _j - (u32 - bvirt) + (_i - bvirt);
    B3[3] = u32;
    let det = estimate(4, B3);
    let errbound = ccwerrboundB * detsum;
    if (det >= errbound || -det >= errbound) {
      return det;
    }
    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);
    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
      return det;
    }
    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
    det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
    if (det >= errbound || -det >= errbound)
      return det;
    s1 = acxtail * bcy;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcx;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u[3] = u32;
    const C1len = sum(4, B3, 4, u, C1);
    s1 = acx * bcytail;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcxtail;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u[3] = u32;
    const C2len = sum(C1len, C1, 4, u, C2);
    s1 = acxtail * bcytail;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcxtail;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u[3] = u32;
    const Dlen = sum(C2len, C2, 4, u, D);
    return D[Dlen - 1];
  }
  function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det = detleft - detright;
    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det) >= ccwerrboundA * detsum)
      return det;
    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
  }
  var o3derrboundA = (7 + 56 * epsilon) * epsilon;
  var o3derrboundB = (3 + 28 * epsilon) * epsilon;
  var o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
  var bc = vec(4);
  var ca = vec(4);
  var ab = vec(4);
  var at_b = vec(4);
  var at_c = vec(4);
  var bt_c = vec(4);
  var bt_a = vec(4);
  var ct_a = vec(4);
  var ct_b = vec(4);
  var bct = vec(8);
  var cat = vec(8);
  var abt = vec(8);
  var u2 = vec(4);
  var _8 = vec(8);
  var _8b = vec(8);
  var _16 = vec(8);
  var _12 = vec(12);
  var fin = vec(192);
  var fin2 = vec(192);
  var iccerrboundA = (10 + 96 * epsilon) * epsilon;
  var iccerrboundB = (4 + 48 * epsilon) * epsilon;
  var iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
  var bc2 = vec(4);
  var ca2 = vec(4);
  var ab2 = vec(4);
  var aa = vec(4);
  var bb = vec(4);
  var cc = vec(4);
  var u3 = vec(4);
  var v = vec(4);
  var axtbc = vec(8);
  var aytbc = vec(8);
  var bxtca = vec(8);
  var bytca = vec(8);
  var cxtab = vec(8);
  var cytab = vec(8);
  var abt2 = vec(8);
  var bct2 = vec(8);
  var cat2 = vec(8);
  var abtt = vec(4);
  var bctt = vec(4);
  var catt = vec(4);
  var _82 = vec(8);
  var _162 = vec(16);
  var _16b = vec(16);
  var _16c = vec(16);
  var _32 = vec(32);
  var _32b = vec(32);
  var _48 = vec(48);
  var _64 = vec(64);
  var fin3 = vec(1152);
  var fin22 = vec(1152);
  var isperrboundA = (16 + 224 * epsilon) * epsilon;
  var isperrboundB = (5 + 72 * epsilon) * epsilon;
  var isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
  var ab3 = vec(4);
  var bc3 = vec(4);
  var cd = vec(4);
  var de = vec(4);
  var ea = vec(4);
  var ac = vec(4);
  var bd = vec(4);
  var ce = vec(4);
  var da = vec(4);
  var eb = vec(4);
  var abc = vec(24);
  var bcd = vec(24);
  var cde = vec(24);
  var dea = vec(24);
  var eab = vec(24);
  var abd = vec(24);
  var bce = vec(24);
  var cda = vec(24);
  var deb = vec(24);
  var eac = vec(24);
  var adet = vec(1152);
  var bdet = vec(1152);
  var cdet = vec(1152);
  var ddet = vec(1152);
  var edet = vec(1152);
  var abdet = vec(2304);
  var cddet = vec(2304);
  var cdedet = vec(3456);
  var deter = vec(5760);
  var _83 = vec(8);
  var _8b2 = vec(8);
  var _8c = vec(8);
  var _163 = vec(16);
  var _24 = vec(24);
  var _482 = vec(48);
  var _48b = vec(48);
  var _96 = vec(96);
  var _192 = vec(192);
  var _384x = vec(384);
  var _384y = vec(384);
  var _384z = vec(384);
  var _768 = vec(768);
  var xdet = vec(96);
  var ydet = vec(96);
  var zdet = vec(96);
  var fin4 = vec(1152);
  function pointInPolygon(p, polygon2) {
    var i;
    var ii;
    var k = 0;
    var f;
    var u1;
    var v1;
    var u22;
    var v2;
    var currentP;
    var nextP;
    var x = p[0];
    var y = p[1];
    var numContours = polygon2.length;
    for (i = 0; i < numContours; i++) {
      ii = 0;
      var contour = polygon2[i];
      var contourLen = contour.length - 1;
      currentP = contour[0];
      if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
        throw new Error("First and last coordinates in a ring must be the same");
      }
      u1 = currentP[0] - x;
      v1 = currentP[1] - y;
      for (ii; ii < contourLen; ii++) {
        nextP = contour[ii + 1];
        u22 = nextP[0] - x;
        v2 = nextP[1] - y;
        if (v1 === 0 && v2 === 0) {
          if (u22 <= 0 && u1 >= 0 || u1 <= 0 && u22 >= 0) {
            return 0;
          }
        } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {
          f = orient2d(u1, u22, v1, v2, 0, 0);
          if (f === 0) {
            return 0;
          }
          if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {
            k++;
          }
        }
        currentP = nextP;
        v1 = v2;
        u1 = u22;
      }
    }
    if (k % 2 === 0) {
      return false;
    }
    return true;
  }
  var earthRadius = 63710088e-1;
  var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: 360 / (2 * Math.PI),
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
  };
  function feature(geom, properties, options = {}) {
    const feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
      feat.id = options.id;
    }
    if (options.bbox) {
      feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
  }
  function point2(coordinates, properties, options = {}) {
    if (!coordinates) {
      throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
      throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
      throw new Error("coordinates must contain numbers");
    }
    const geom = {
      type: "Point",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function polygon(coordinates, properties, options = {}) {
    for (const ring of coordinates) {
      if (ring.length < 4) {
        throw new Error(
          "Each LinearRing of a Polygon must have 4 or more Positions."
        );
      }
      if (ring[ring.length - 1].length !== ring[0].length) {
        throw new Error("First and last Position are not equivalent.");
      }
      for (let j = 0; j < ring[ring.length - 1].length; j++) {
        if (ring[ring.length - 1][j] !== ring[0][j]) {
          throw new Error("First and last Position are not equivalent.");
        }
      }
    }
    const geom = {
      type: "Polygon",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function lineString(coordinates, properties, options = {}) {
    if (coordinates.length < 2) {
      throw new Error("coordinates must be an array of two or more positions");
    }
    const geom = {
      type: "LineString",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function featureCollection(features, options = {}) {
    const fc = { type: "FeatureCollection" };
    if (options.id) {
      fc.id = options.id;
    }
    if (options.bbox) {
      fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
  }
  function multiLineString(coordinates, properties, options = {}) {
    const geom = {
      type: "MultiLineString",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function multiPolygon(coordinates, properties, options = {}) {
    const geom = {
      type: "MultiPolygon",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
  }
  function getCoord(coord) {
    if (!coord) {
      throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
      if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
        return [...coord.geometry.coordinates];
      }
      if (coord.type === "Point") {
        return [...coord.coordinates];
      }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
      return [...coord];
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  function getCoords(coords) {
    if (Array.isArray(coords)) {
      return coords;
    }
    if (coords.type === "Feature") {
      if (coords.geometry !== null) {
        return coords.geometry.coordinates;
      }
    } else {
      if (coords.coordinates) {
        return coords.coordinates;
      }
    }
    throw new Error(
      "coords must be GeoJSON Feature, Geometry Object or an Array"
    );
  }
  function getGeom(geojson) {
    if (geojson.type === "Feature") {
      return geojson.geometry;
    }
    return geojson;
  }
  function getType(geojson, _name) {
    if (geojson.type === "FeatureCollection") {
      return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
      return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
      return geojson.geometry.type;
    }
    return geojson.type;
  }
  function booleanPointInPolygon(point22, polygon2, options = {}) {
    if (!point22) {
      throw new Error("point is required");
    }
    if (!polygon2) {
      throw new Error("polygon is required");
    }
    const pt = getCoord(point22);
    const geom = getGeom(polygon2);
    const type = geom.type;
    const bbox2 = polygon2.bbox;
    let polys = geom.coordinates;
    if (bbox2 && inBBox(pt, bbox2) === false) {
      return false;
    }
    if (type === "Polygon") {
      polys = [polys];
    }
    let result = false;
    for (var i = 0; i < polys.length; ++i) {
      const polyResult = pointInPolygon(pt, polys[i]);
      if (polyResult === 0)
        return options.ignoreBoundary ? false : true;
      else if (polyResult)
        result = true;
    }
    return result;
  }
  function inBBox(pt, bbox2) {
    return bbox2[0] <= pt[0] && bbox2[1] <= pt[1] && bbox2[2] >= pt[0] && bbox2[3] >= pt[1];
  }
  var TinyQueue = class {
    constructor(data = [], compare2 = defaultCompare) {
      this.data = data;
      this.length = this.data.length;
      this.compare = compare2;
      if (this.length > 0) {
        for (let i = (this.length >> 1) - 1; i >= 0; i--)
          this._down(i);
      }
    }
    push(item) {
      this.data.push(item);
      this.length++;
      this._up(this.length - 1);
    }
    pop() {
      if (this.length === 0)
        return void 0;
      const top = this.data[0];
      const bottom = this.data.pop();
      this.length--;
      if (this.length > 0) {
        this.data[0] = bottom;
        this._down(0);
      }
      return top;
    }
    peek() {
      return this.data[0];
    }
    _up(pos) {
      const { data, compare: compare2 } = this;
      const item = data[pos];
      while (pos > 0) {
        const parent = pos - 1 >> 1;
        const current = data[parent];
        if (compare2(item, current) >= 0)
          break;
        data[pos] = current;
        pos = parent;
      }
      data[pos] = item;
    }
    _down(pos) {
      const { data, compare: compare2 } = this;
      const halfLength = this.length >> 1;
      const item = data[pos];
      while (pos < halfLength) {
        let left = (pos << 1) + 1;
        let best = data[left];
        const right = left + 1;
        if (right < this.length && compare2(data[right], best) < 0) {
          left = right;
          best = data[right];
        }
        if (compare2(best, item) >= 0)
          break;
        data[pos] = best;
        pos = left;
      }
      data[pos] = item;
    }
  };
  function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function checkWhichEventIsLeft(e1, e22) {
    if (e1.p.x > e22.p.x)
      return 1;
    if (e1.p.x < e22.p.x)
      return -1;
    if (e1.p.y !== e22.p.y)
      return e1.p.y > e22.p.y ? 1 : -1;
    return 1;
  }
  function checkWhichSegmentHasRightEndpointFirst(seg1, seg2) {
    if (seg1.rightSweepEvent.p.x > seg2.rightSweepEvent.p.x)
      return 1;
    if (seg1.rightSweepEvent.p.x < seg2.rightSweepEvent.p.x)
      return -1;
    if (seg1.rightSweepEvent.p.y !== seg2.rightSweepEvent.p.y)
      return seg1.rightSweepEvent.p.y < seg2.rightSweepEvent.p.y ? 1 : -1;
    return 1;
  }
  var Event = class {
    constructor(p, featureId2, ringId2, eventId2) {
      this.p = {
        x: p[0],
        y: p[1]
      };
      this.featureId = featureId2;
      this.ringId = ringId2;
      this.eventId = eventId2;
      this.otherEvent = null;
      this.isLeftEndpoint = null;
    }
    isSamePoint(eventToCheck) {
      return this.p.x === eventToCheck.p.x && this.p.y === eventToCheck.p.y;
    }
  };
  function fillEventQueue(geojson, eventQueue) {
    if (geojson.type === "FeatureCollection") {
      const features = geojson.features;
      for (let i = 0; i < features.length; i++) {
        processFeature(features[i], eventQueue);
      }
    } else {
      processFeature(geojson, eventQueue);
    }
  }
  var featureId = 0;
  var ringId = 0;
  var eventId = 0;
  function processFeature(featureOrGeometry, eventQueue) {
    const geom = featureOrGeometry.type === "Feature" ? featureOrGeometry.geometry : featureOrGeometry;
    let coords = geom.coordinates;
    if (geom.type === "Polygon" || geom.type === "MultiLineString")
      coords = [coords];
    if (geom.type === "LineString")
      coords = [[coords]];
    for (let i = 0; i < coords.length; i++) {
      for (let ii = 0; ii < coords[i].length; ii++) {
        let currentP = coords[i][ii][0];
        let nextP = null;
        ringId = ringId + 1;
        for (let iii = 0; iii < coords[i][ii].length - 1; iii++) {
          nextP = coords[i][ii][iii + 1];
          const e1 = new Event(currentP, featureId, ringId, eventId);
          const e22 = new Event(nextP, featureId, ringId, eventId + 1);
          e1.otherEvent = e22;
          e22.otherEvent = e1;
          if (checkWhichEventIsLeft(e1, e22) > 0) {
            e22.isLeftEndpoint = true;
            e1.isLeftEndpoint = false;
          } else {
            e1.isLeftEndpoint = true;
            e22.isLeftEndpoint = false;
          }
          eventQueue.push(e1);
          eventQueue.push(e22);
          currentP = nextP;
          eventId = eventId + 1;
        }
      }
    }
    featureId = featureId + 1;
  }
  var Segment = class {
    constructor(event) {
      this.leftSweepEvent = event;
      this.rightSweepEvent = event.otherEvent;
    }
  };
  function testSegmentIntersect(seg1, seg2) {
    if (seg1 === null || seg2 === null)
      return false;
    if (seg1.leftSweepEvent.ringId === seg2.leftSweepEvent.ringId && (seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.rightSweepEvent.isSamePoint(seg2.rightSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.leftSweepEvent) || seg1.leftSweepEvent.isSamePoint(seg2.rightSweepEvent)))
      return false;
    const x1 = seg1.leftSweepEvent.p.x;
    const y1 = seg1.leftSweepEvent.p.y;
    const x2 = seg1.rightSweepEvent.p.x;
    const y2 = seg1.rightSweepEvent.p.y;
    const x3 = seg2.leftSweepEvent.p.x;
    const y3 = seg2.leftSweepEvent.p.y;
    const x4 = seg2.rightSweepEvent.p.x;
    const y4 = seg2.rightSweepEvent.p.y;
    const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    const numeA = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    const numeB = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    if (denom === 0) {
      if (numeA === 0 && numeB === 0)
        return false;
      return false;
    }
    const uA = numeA / denom;
    const uB = numeB / denom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
      const x = x1 + uA * (x2 - x1);
      const y = y1 + uA * (y2 - y1);
      return [x, y];
    }
    return false;
  }
  function runCheck(eventQueue, ignoreSelfIntersections) {
    ignoreSelfIntersections = ignoreSelfIntersections ? ignoreSelfIntersections : false;
    const intersectionPoints = [];
    const outQueue = new TinyQueue([], checkWhichSegmentHasRightEndpointFirst);
    while (eventQueue.length) {
      const event = eventQueue.pop();
      if (event.isLeftEndpoint) {
        const segment = new Segment(event);
        for (let i = 0; i < outQueue.data.length; i++) {
          const otherSeg = outQueue.data[i];
          if (ignoreSelfIntersections) {
            if (otherSeg.leftSweepEvent.featureId === event.featureId)
              continue;
          }
          const intersection3 = testSegmentIntersect(segment, otherSeg);
          if (intersection3 !== false)
            intersectionPoints.push(intersection3);
        }
        outQueue.push(segment);
      } else if (event.isLeftEndpoint === false) {
        outQueue.pop();
      }
    }
    return intersectionPoints;
  }
  function sweeplineIntersections(geojson, ignoreSelfIntersections) {
    const eventQueue = new TinyQueue([], checkWhichEventIsLeft);
    fillEventQueue(geojson, eventQueue);
    return runCheck(eventQueue, ignoreSelfIntersections);
  }
  var sweeplineIntersections_esm_default = sweeplineIntersections;
  var sweeplineIntersections2 = sweeplineIntersections_esm_default;
  function lineIntersect(line1, line2, options = {}) {
    const { removeDuplicates = true, ignoreSelfIntersections = true } = options;
    let features = [];
    if (line1.type === "FeatureCollection")
      features = features.concat(line1.features);
    else if (line1.type === "Feature")
      features.push(line1);
    else if (line1.type === "LineString" || line1.type === "Polygon" || line1.type === "MultiLineString" || line1.type === "MultiPolygon") {
      features.push(feature(line1));
    }
    if (line2.type === "FeatureCollection")
      features = features.concat(line2.features);
    else if (line2.type === "Feature")
      features.push(line2);
    else if (line2.type === "LineString" || line2.type === "Polygon" || line2.type === "MultiLineString" || line2.type === "MultiPolygon") {
      features.push(feature(line2));
    }
    const intersections = sweeplineIntersections2(
      featureCollection(features),
      ignoreSelfIntersections
    );
    let results = [];
    if (removeDuplicates) {
      const unique = {};
      intersections.forEach((intersection3) => {
        const key = intersection3.join(",");
        if (!unique[key]) {
          unique[key] = true;
          results.push(intersection3);
        }
      });
    } else {
      results = intersections;
    }
    return featureCollection(results.map((r) => point2(r)));
  }
  function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null)
      return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null)
          continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j = 0; j < coords.length; j++) {
              if (callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint")
                multiFeatureIndex++;
            }
            if (geomType === "LineString")
              multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length - wrapShrink; k++) {
                if (callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString")
                multiFeatureIndex++;
              if (geomType === "Polygon")
                geometryIndex++;
            }
            if (geomType === "Polygon")
              multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j = 0; j < coords.length; j++) {
              geometryIndex = 0;
              for (k = 0; k < coords[j].length; k++) {
                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                  if (callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j = 0; j < geometry.geometries.length; j++)
              if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }
  function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG, geometryMaybeCollection, isGeometryCollection, featureProperties, featureBBox, featureId2, featureIndex = 0, isFeatureCollection = geojson.type === "FeatureCollection", isFeature = geojson.type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (i = 0; i < stop; i++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[i].geometry : isFeature ? geojson.geometry : geojson;
      featureProperties = isFeatureCollection ? geojson.features[i].properties : isFeature ? geojson.properties : {};
      featureBBox = isFeatureCollection ? geojson.features[i].bbox : isFeature ? geojson.bbox : void 0;
      featureId2 = isFeatureCollection ? geojson.features[i].id : isFeature ? geojson.id : void 0;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (g = 0; g < stopG; g++) {
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
        if (geometry === null) {
          if (callback(
            null,
            featureIndex,
            featureProperties,
            featureBBox,
            featureId2
          ) === false)
            return false;
          continue;
        }
        switch (geometry.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon": {
            if (callback(
              geometry,
              featureIndex,
              featureProperties,
              featureBBox,
              featureId2
            ) === false)
              return false;
            break;
          }
          case "GeometryCollection": {
            for (j = 0; j < geometry.geometries.length; j++) {
              if (callback(
                geometry.geometries[j],
                featureIndex,
                featureProperties,
                featureBBox,
                featureId2
              ) === false)
                return false;
            }
            break;
          }
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
      featureIndex++;
    }
  }
  function flattenEach(geojson, callback) {
    geomEach(geojson, function(geometry, featureIndex, properties, bbox2, id5) {
      var type = geometry === null ? null : geometry.type;
      switch (type) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
          if (callback(
            feature(geometry, properties, { bbox: bbox2, id: id5 }),
            featureIndex,
            0
          ) === false)
            return false;
          return;
      }
      var geomType;
      switch (type) {
        case "MultiPoint":
          geomType = "Point";
          break;
        case "MultiLineString":
          geomType = "LineString";
          break;
        case "MultiPolygon":
          geomType = "Polygon";
          break;
      }
      for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
        var coordinate = geometry.coordinates[multiFeatureIndex];
        var geom = {
          type: geomType,
          coordinates: coordinate
        };
        if (callback(feature(geom, properties), featureIndex, multiFeatureIndex) === false)
          return false;
      }
    });
  }
  function polygonToLine(poly, options = {}) {
    const geom = getGeom(poly);
    if (!options.properties && poly.type === "Feature") {
      options.properties = poly.properties;
    }
    switch (geom.type) {
      case "Polygon":
        return singlePolygonToLine(geom, options);
      case "MultiPolygon":
        return multiPolygonToLine(geom, options);
      default:
        throw new Error("invalid poly");
    }
  }
  function singlePolygonToLine(poly, options = {}) {
    const geom = getGeom(poly);
    const coords = geom.coordinates;
    const properties = options.properties ? options.properties : poly.type === "Feature" ? poly.properties : {};
    return coordsToLine(coords, properties);
  }
  function multiPolygonToLine(multiPoly, options = {}) {
    const geom = getGeom(multiPoly);
    const coords = geom.coordinates;
    const properties = options.properties ? options.properties : multiPoly.type === "Feature" ? multiPoly.properties : {};
    const lines = [];
    coords.forEach((coord) => {
      lines.push(coordsToLine(coord, properties));
    });
    return featureCollection(lines);
  }
  function coordsToLine(coords, properties) {
    if (coords.length > 1) {
      return multiLineString(coords, properties);
    }
    return lineString(coords[0], properties);
  }
  function booleanDisjoint(feature1, feature2, {
    ignoreSelfIntersections = true
  } = { ignoreSelfIntersections: true }) {
    let bool = true;
    flattenEach(feature1, (flatten1) => {
      flattenEach(feature2, (flatten2) => {
        if (bool === false) {
          return false;
        }
        bool = disjoint(
          flatten1.geometry,
          flatten2.geometry,
          ignoreSelfIntersections
        );
      });
    });
    return bool;
  }
  function disjoint(geom1, geom2, ignoreSelfIntersections) {
    switch (geom1.type) {
      case "Point":
        switch (geom2.type) {
          case "Point":
            return !compareCoords(geom1.coordinates, geom2.coordinates);
          case "LineString":
            return !isPointOnLine(geom2, geom1);
          case "Polygon":
            return !booleanPointInPolygon(geom1, geom2);
        }
        break;
      case "LineString":
        switch (geom2.type) {
          case "Point":
            return !isPointOnLine(geom1, geom2);
          case "LineString":
            return !isLineOnLine(geom1, geom2, ignoreSelfIntersections);
          case "Polygon":
            return !isLineInPoly(geom2, geom1, ignoreSelfIntersections);
        }
        break;
      case "Polygon":
        switch (geom2.type) {
          case "Point":
            return !booleanPointInPolygon(geom2, geom1);
          case "LineString":
            return !isLineInPoly(geom1, geom2, ignoreSelfIntersections);
          case "Polygon":
            return !isPolyInPoly(geom2, geom1, ignoreSelfIntersections);
        }
    }
    return false;
  }
  function isPointOnLine(lineString2, pt) {
    for (let i = 0; i < lineString2.coordinates.length - 1; i++) {
      if (isPointOnLineSegment(
        lineString2.coordinates[i],
        lineString2.coordinates[i + 1],
        pt.coordinates
      )) {
        return true;
      }
    }
    return false;
  }
  function isLineOnLine(lineString1, lineString2, ignoreSelfIntersections) {
    const doLinesIntersect = lineIntersect(lineString1, lineString2, {
      ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
      return true;
    }
    return false;
  }
  function isLineInPoly(polygon2, lineString2, ignoreSelfIntersections) {
    for (const coord of lineString2.coordinates) {
      if (booleanPointInPolygon(coord, polygon2)) {
        return true;
      }
    }
    const doLinesIntersect = lineIntersect(lineString2, polygonToLine(polygon2), {
      ignoreSelfIntersections
    });
    if (doLinesIntersect.features.length > 0) {
      return true;
    }
    return false;
  }
  function isPolyInPoly(feature1, feature2, ignoreSelfIntersections) {
    for (const coord1 of feature1.coordinates[0]) {
      if (booleanPointInPolygon(coord1, feature2)) {
        return true;
      }
    }
    for (const coord2 of feature2.coordinates[0]) {
      if (booleanPointInPolygon(coord2, feature1)) {
        return true;
      }
    }
    const doLinesIntersect = lineIntersect(
      polygonToLine(feature1),
      polygonToLine(feature2),
      { ignoreSelfIntersections }
    );
    if (doLinesIntersect.features.length > 0) {
      return true;
    }
    return false;
  }
  function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt) {
    const dxc = pt[0] - lineSegmentStart[0];
    const dyc = pt[1] - lineSegmentStart[1];
    const dxl = lineSegmentEnd[0] - lineSegmentStart[0];
    const dyl = lineSegmentEnd[1] - lineSegmentStart[1];
    const cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
      return false;
    }
    if (Math.abs(dxl) >= Math.abs(dyl)) {
      if (dxl > 0) {
        return lineSegmentStart[0] <= pt[0] && pt[0] <= lineSegmentEnd[0];
      } else {
        return lineSegmentEnd[0] <= pt[0] && pt[0] <= lineSegmentStart[0];
      }
    } else if (dyl > 0) {
      return lineSegmentStart[1] <= pt[1] && pt[1] <= lineSegmentEnd[1];
    } else {
      return lineSegmentEnd[1] <= pt[1] && pt[1] <= lineSegmentStart[1];
    }
  }
  function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
  }
  function booleanIntersects(feature1, feature2, {
    ignoreSelfIntersections = true
  } = {}) {
    let bool = false;
    flattenEach(feature1, (flatten1) => {
      flattenEach(feature2, (flatten2) => {
        if (bool === true) {
          return true;
        }
        bool = !booleanDisjoint(flatten1.geometry, flatten2.geometry, {
          ignoreSelfIntersections
        });
      });
    });
    return bool;
  }
  var turf_boolean_intersects_default = booleanIntersects;
  function geojsonFeatures({
    geojson,
    spatialFilter,
    uniqueIdProperty
  }) {
    let uniqueIdx = 0;
    const map2 = /* @__PURE__ */ new Map();
    if (!spatialFilter) {
      return [];
    }
    for (const feature2 of geojson.features) {
      const uniqueId = uniqueIdProperty ? feature2.properties[uniqueIdProperty] : ++uniqueIdx;
      if (!map2.has(uniqueId) && turf_boolean_intersects_default(spatialFilter, feature2)) {
        map2.set(uniqueId, feature2.properties);
      }
    }
    return Array.from(map2.values());
  }
  var RADIANS_TO_DEGREES2 = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS3 = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
  var config = globalThis.mathgl.config;
  function isArray(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function lerp2(a, b, t) {
    if (isArray(a)) {
      return a.map((ai, i) => lerp2(ai, b[i], t));
    }
    return t * b + (1 - t) * a;
  }
  function assert3(condition, message) {
    if (!condition) {
      throw new Error(message || "@math.gl/web-mercator: assertion failed.");
    }
  }
  var PI2 = Math.PI;
  var PI_42 = PI2 / 4;
  var DEGREES_TO_RADIANS22 = PI2 / 180;
  var RADIANS_TO_DEGREES22 = 180 / PI2;
  var TILE_SIZE4 = 512;
  function lngLatToWorld2(lngLat) {
    const [lng, lat] = lngLat;
    assert3(Number.isFinite(lng));
    assert3(Number.isFinite(lat) && lat >= -90 && lat <= 90, "invalid latitude");
    const lambda2 = lng * DEGREES_TO_RADIANS22;
    const phi2 = lat * DEGREES_TO_RADIANS22;
    const x = TILE_SIZE4 * (lambda2 + PI2) / (2 * PI2);
    const y = TILE_SIZE4 * (PI2 + Math.log(Math.tan(PI_42 + phi2 * 0.5))) / (2 * PI2);
    return [x, y];
  }
  function worldToLngLat2(xy) {
    const [x, y] = xy;
    const lambda2 = x / TILE_SIZE4 * (2 * PI2) - PI2;
    const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE4 * (2 * PI2) - PI2)) - PI_42);
    return [lambda2 * RADIANS_TO_DEGREES22, phi2 * RADIANS_TO_DEGREES22];
  }
  var DEGREES_TO_RADIANS32 = Math.PI / 180;
  var TRANSFORM_FN = {
    Point: transformPoint,
    MultiPoint: transformMultiPoint,
    LineString: transformLineString,
    MultiLineString: transformMultiLineString,
    Polygon: transformPolygon,
    MultiPolygon: transformMultiPolygon
  };
  function transformTileCoordsToWGS84(geometry, bbox2) {
    const [west, south, east, north] = bbox2;
    const nw = lngLatToWorld2([west, north]);
    const se = lngLatToWorld2([east, south]);
    const projectedBbox = [nw, se];
    if (geometry.type === "GeometryCollection") {
      throw new Error("Unsupported geometry type GeometryCollection");
    }
    const transformFn = TRANSFORM_FN[geometry.type];
    const coordinates = transformFn(geometry.coordinates, projectedBbox);
    return { ...geometry, coordinates };
  }
  function transformPoint([pointX, pointY], [nw, se]) {
    const x = lerp2(nw[0], se[0], pointX);
    const y = lerp2(nw[1], se[1], pointY);
    return worldToLngLat2([x, y]);
  }
  function getPoints(geometry, bbox2) {
    return geometry.map((g) => transformPoint(g, bbox2));
  }
  function transformMultiPoint(multiPoint, bbox2) {
    return getPoints(multiPoint, bbox2);
  }
  function transformLineString(line, bbox2) {
    return getPoints(line, bbox2);
  }
  function transformMultiLineString(multiLineString2, bbox2) {
    return multiLineString2.map(
      (lineString2) => transformLineString(lineString2, bbox2)
    );
  }
  function transformPolygon(polygon2, bbox2) {
    return polygon2.map((polygonRing) => getPoints(polygonRing, bbox2));
  }
  function transformMultiPolygon(multiPolygon2, bbox2) {
    return multiPolygon2.map((polygon2) => transformPolygon(polygon2, bbox2));
  }
  function bboxPolygon(bbox2, options = {}) {
    const west = Number(bbox2[0]);
    const south = Number(bbox2[1]);
    const east = Number(bbox2[2]);
    const north = Number(bbox2[3]);
    if (bbox2.length === 6) {
      throw new Error(
        "@turf/bbox-polygon does not support BBox with 6 positions"
      );
    }
    const lowLeft = [west, south];
    const topLeft = [west, north];
    const topRight = [east, north];
    const lowRight = [east, south];
    return polygon(
      [[lowLeft, lowRight, topRight, topLeft, lowLeft]],
      options.properties,
      { bbox: bbox2, id: options.id }
    );
  }
  var turf_bbox_polygon_default = bboxPolygon;
  function bbox(geojson, options = {}) {
    if (geojson.bbox != null && true !== options.recompute) {
      return geojson.bbox;
    }
    const result = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, (coord) => {
      if (result[0] > coord[0]) {
        result[0] = coord[0];
      }
      if (result[1] > coord[1]) {
        result[1] = coord[1];
      }
      if (result[2] < coord[0]) {
        result[2] = coord[0];
      }
      if (result[3] < coord[1]) {
        result[3] = coord[1];
      }
    });
    return result;
  }
  function booleanPointOnLine(pt, line, options = {}) {
    const ptCoords = getCoord(pt);
    const lineCoords = getCoords(line);
    for (let i = 0; i < lineCoords.length - 1; i++) {
      let ignoreBoundary = false;
      if (options.ignoreEndVertices) {
        if (i === 0) {
          ignoreBoundary = "start";
        }
        if (i === lineCoords.length - 2) {
          ignoreBoundary = "end";
        }
        if (i === 0 && i + 1 === lineCoords.length - 1) {
          ignoreBoundary = "both";
        }
      }
      if (isPointOnLineSegment2(
        lineCoords[i],
        lineCoords[i + 1],
        ptCoords,
        ignoreBoundary,
        typeof options.epsilon === "undefined" ? null : options.epsilon
      )) {
        return true;
      }
    }
    return false;
  }
  function isPointOnLineSegment2(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary, epsilon2) {
    const x = pt[0];
    const y = pt[1];
    const x1 = lineSegmentStart[0];
    const y1 = lineSegmentStart[1];
    const x2 = lineSegmentEnd[0];
    const y2 = lineSegmentEnd[1];
    const dxc = pt[0] - x1;
    const dyc = pt[1] - y1;
    const dxl = x2 - x1;
    const dyl = y2 - y1;
    const cross = dxc * dyl - dyc * dxl;
    if (epsilon2 !== null) {
      if (Math.abs(cross) > epsilon2) {
        return false;
      }
    } else if (cross !== 0) {
      return false;
    }
    if (Math.abs(dxl) === Math.abs(dyl) && Math.abs(dxl) === 0) {
      if (excludeBoundary) {
        return false;
      }
      if (pt[0] === lineSegmentStart[0] && pt[1] === lineSegmentStart[1]) {
        return true;
      } else {
        return false;
      }
    }
    if (!excludeBoundary) {
      if (Math.abs(dxl) >= Math.abs(dyl)) {
        return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
      }
      return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
    } else if (excludeBoundary === "start") {
      if (Math.abs(dxl) >= Math.abs(dyl)) {
        return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
      }
      return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
    } else if (excludeBoundary === "end") {
      if (Math.abs(dxl) >= Math.abs(dyl)) {
        return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
      }
      return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
    } else if (excludeBoundary === "both") {
      if (Math.abs(dxl) >= Math.abs(dyl)) {
        return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
      }
      return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
    }
    return false;
  }
  function booleanWithin(feature1, feature2) {
    var geom1 = getGeom(feature1);
    var geom2 = getGeom(feature2);
    var type1 = geom1.type;
    var type2 = geom2.type;
    switch (type1) {
      case "Point":
        switch (type2) {
          case "MultiPoint":
            return isPointInMultiPoint(geom1, geom2);
          case "LineString":
            return booleanPointOnLine(geom1, geom2, { ignoreEndVertices: true });
          case "Polygon":
          case "MultiPolygon":
            return booleanPointInPolygon(geom1, geom2, { ignoreBoundary: true });
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      case "MultiPoint":
        switch (type2) {
          case "MultiPoint":
            return isMultiPointInMultiPoint(geom1, geom2);
          case "LineString":
            return isMultiPointOnLine(geom1, geom2);
          case "Polygon":
          case "MultiPolygon":
            return isMultiPointInPoly(geom1, geom2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      case "LineString":
        switch (type2) {
          case "LineString":
            return isLineOnLine2(geom1, geom2);
          case "Polygon":
          case "MultiPolygon":
            return isLineInPoly2(geom1, geom2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      case "Polygon":
        switch (type2) {
          case "Polygon":
          case "MultiPolygon":
            return isPolyInPoly2(geom1, geom2);
          default:
            throw new Error("feature2 " + type2 + " geometry not supported");
        }
      default:
        throw new Error("feature1 " + type1 + " geometry not supported");
    }
  }
  function isPointInMultiPoint(point22, multiPoint) {
    var i;
    var output = false;
    for (i = 0; i < multiPoint.coordinates.length; i++) {
      if (compareCoords2(multiPoint.coordinates[i], point22.coordinates)) {
        output = true;
        break;
      }
    }
    return output;
  }
  function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for (var i = 0; i < multiPoint1.coordinates.length; i++) {
      var anyMatch = false;
      for (var i2 = 0; i2 < multiPoint2.coordinates.length; i2++) {
        if (compareCoords2(multiPoint1.coordinates[i], multiPoint2.coordinates[i2])) {
          anyMatch = true;
        }
      }
      if (!anyMatch) {
        return false;
      }
    }
    return true;
  }
  function isMultiPointOnLine(multiPoint, lineString2) {
    var foundInsidePoint = false;
    for (var i = 0; i < multiPoint.coordinates.length; i++) {
      if (!booleanPointOnLine(multiPoint.coordinates[i], lineString2)) {
        return false;
      }
      if (!foundInsidePoint) {
        foundInsidePoint = booleanPointOnLine(
          multiPoint.coordinates[i],
          lineString2,
          { ignoreEndVertices: true }
        );
      }
    }
    return foundInsidePoint;
  }
  function isMultiPointInPoly(multiPoint, polygon2) {
    var output = true;
    var oneInside = false;
    var isInside = false;
    for (var i = 0; i < multiPoint.coordinates.length; i++) {
      isInside = booleanPointInPolygon(multiPoint.coordinates[i], polygon2);
      if (!isInside) {
        output = false;
        break;
      }
      if (!oneInside) {
        isInside = booleanPointInPolygon(multiPoint.coordinates[i], polygon2, {
          ignoreBoundary: true
        });
      }
    }
    return output && isInside;
  }
  function isLineOnLine2(lineString1, lineString2) {
    for (var i = 0; i < lineString1.coordinates.length; i++) {
      if (!booleanPointOnLine(lineString1.coordinates[i], lineString2)) {
        return false;
      }
    }
    return true;
  }
  function isLineInPoly2(linestring, polygon2) {
    var polyBbox = bbox(polygon2);
    var lineBbox = bbox(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
      return false;
    }
    var foundInsidePoint = false;
    for (var i = 0; i < linestring.coordinates.length; i++) {
      if (!booleanPointInPolygon(linestring.coordinates[i], polygon2)) {
        return false;
      }
      if (!foundInsidePoint) {
        foundInsidePoint = booleanPointInPolygon(
          linestring.coordinates[i],
          polygon2,
          { ignoreBoundary: true }
        );
      }
      if (!foundInsidePoint && i < linestring.coordinates.length - 1) {
        var midpoint = getMidpoint(
          linestring.coordinates[i],
          linestring.coordinates[i + 1]
        );
        foundInsidePoint = booleanPointInPolygon(midpoint, polygon2, {
          ignoreBoundary: true
        });
      }
    }
    return foundInsidePoint;
  }
  function isPolyInPoly2(geometry1, geometry2) {
    var poly1Bbox = bbox(geometry1);
    var poly2Bbox = bbox(geometry2);
    if (!doBBoxOverlap(poly2Bbox, poly1Bbox)) {
      return false;
    }
    for (var i = 0; i < geometry1.coordinates[0].length; i++) {
      if (!booleanPointInPolygon(geometry1.coordinates[0][i], geometry2)) {
        return false;
      }
    }
    return true;
  }
  function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0])
      return false;
    if (bbox1[2] < bbox2[2])
      return false;
    if (bbox1[1] > bbox2[1])
      return false;
    if (bbox1[3] < bbox2[3])
      return false;
    return true;
  }
  function compareCoords2(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
  }
  function getMidpoint(pair1, pair2) {
    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
  }
  var turf_boolean_within_default = booleanWithin;
  var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
  var mathceil = Math.ceil;
  var mathfloor = Math.floor;
  var bignumberError = "[BigNumber Error] ";
  var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
  var BASE = 1e14;
  var LOG_BASE = 14;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
  var SQRT_BASE = 1e7;
  var MAX = 1e9;
  function clone2(configObject) {
    var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
      prefix: "",
      groupSize: 3,
      secondaryGroupSize: 0,
      groupSeparator: ",",
      decimalSeparator: ".",
      fractionGroupSize: 0,
      fractionGroupSeparator: "\xA0",
      // non-breaking space
      suffix: ""
    }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
    function BigNumber2(v2, b) {
      var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
      if (!(x instanceof BigNumber2))
        return new BigNumber2(v2, b);
      if (b == null) {
        if (v2 && v2._isBigNumber === true) {
          x.s = v2.s;
          if (!v2.c || v2.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v2.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v2.e;
            x.c = v2.c.slice();
          }
          return;
        }
        if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
          x.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
          if (v2 === ~~v2) {
            for (e = 0, i = v2; i >= 10; i /= 10, e++)
              ;
            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v2];
            }
            return;
          }
          str = String(v2);
        } else {
          if (!isNumeric.test(str = String(v2)))
            return parseNumeric(x, str, isNum);
          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }
        if ((e = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0)
            e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
      } else {
        intCheck(b, 2, ALPHABET.length, "Base");
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber2(v2);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }
        str = String(v2);
        if (isNum = typeof v2 == "number") {
          if (v2 * 0 != 0)
            return parseNumeric(x, str, isNum, b);
          x.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
          if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
            throw Error(tooManyDigits + v2);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }
        alphabet = ALPHABET.slice(0, b);
        e = i = 0;
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == ".") {
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {
              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }
            return parseNumeric(x, String(v2), isNum, b);
          }
        }
        isNum = false;
        str = convertBase(str, b, 10, x.s);
        if ((e = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        else
          e = str.length;
      }
      for (i = 0; str.charCodeAt(i) === 48; i++)
        ;
      for (len = str.length; str.charCodeAt(--len) === 48; )
        ;
      if (str = str.slice(i, ++len)) {
        len -= i;
        if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
          throw Error(tooManyDigits + x.s * v2);
        }
        if ((e = e - i - 1) > MAX_EXP) {
          x.c = x.e = null;
        } else if (e < MIN_EXP) {
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];
          i = (e + 1) % LOG_BASE;
          if (e < 0)
            i += LOG_BASE;
          if (i < len) {
            if (i)
              x.c.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; ) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }
            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }
          for (; i--; str += "0")
            ;
          x.c.push(+str);
        }
      } else {
        x.c = [x.e = 0];
      }
    }
    BigNumber2.clone = clone2;
    BigNumber2.ROUND_UP = 0;
    BigNumber2.ROUND_DOWN = 1;
    BigNumber2.ROUND_CEIL = 2;
    BigNumber2.ROUND_FLOOR = 3;
    BigNumber2.ROUND_HALF_UP = 4;
    BigNumber2.ROUND_HALF_DOWN = 5;
    BigNumber2.ROUND_HALF_EVEN = 6;
    BigNumber2.ROUND_HALF_CEIL = 7;
    BigNumber2.ROUND_HALF_FLOOR = 8;
    BigNumber2.EUCLID = 9;
    BigNumber2.config = BigNumber2.set = function(obj) {
      var p, v2;
      if (obj != null) {
        if (typeof obj == "object") {
          if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
            v2 = obj[p];
            intCheck(v2, 0, MAX, p);
            DECIMAL_PLACES = v2;
          }
          if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
            v2 = obj[p];
            intCheck(v2, 0, 8, p);
            ROUNDING_MODE = v2;
          }
          if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
            v2 = obj[p];
            if (v2 && v2.pop) {
              intCheck(v2[0], -MAX, 0, p);
              intCheck(v2[1], 0, MAX, p);
              TO_EXP_NEG = v2[0];
              TO_EXP_POS = v2[1];
            } else {
              intCheck(v2, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
            }
          }
          if (obj.hasOwnProperty(p = "RANGE")) {
            v2 = obj[p];
            if (v2 && v2.pop) {
              intCheck(v2[0], -MAX, -1, p);
              intCheck(v2[1], 1, MAX, p);
              MIN_EXP = v2[0];
              MAX_EXP = v2[1];
            } else {
              intCheck(v2, -MAX, MAX, p);
              if (v2) {
                MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
              } else {
                throw Error(bignumberError + p + " cannot be zero: " + v2);
              }
            }
          }
          if (obj.hasOwnProperty(p = "CRYPTO")) {
            v2 = obj[p];
            if (v2 === !!v2) {
              if (v2) {
                if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v2;
                } else {
                  CRYPTO = !v2;
                  throw Error(bignumberError + "crypto unavailable");
                }
              } else {
                CRYPTO = v2;
              }
            } else {
              throw Error(bignumberError + p + " not true or false: " + v2);
            }
          }
          if (obj.hasOwnProperty(p = "MODULO_MODE")) {
            v2 = obj[p];
            intCheck(v2, 0, 9, p);
            MODULO_MODE = v2;
          }
          if (obj.hasOwnProperty(p = "POW_PRECISION")) {
            v2 = obj[p];
            intCheck(v2, 0, MAX, p);
            POW_PRECISION = v2;
          }
          if (obj.hasOwnProperty(p = "FORMAT")) {
            v2 = obj[p];
            if (typeof v2 == "object")
              FORMAT = v2;
            else
              throw Error(bignumberError + p + " not an object: " + v2);
          }
          if (obj.hasOwnProperty(p = "ALPHABET")) {
            v2 = obj[p];
            if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
              alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
              ALPHABET = v2;
            } else {
              throw Error(bignumberError + p + " invalid: " + v2);
            }
          }
        } else {
          throw Error(bignumberError + "Object expected: " + obj);
        }
      }
      return {
        DECIMAL_PLACES,
        ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO,
        MODULO_MODE,
        POW_PRECISION,
        FORMAT,
        ALPHABET
      };
    };
    BigNumber2.isBigNumber = function(v2) {
      if (!v2 || v2._isBigNumber !== true)
        return false;
      if (!BigNumber2.DEBUG)
        return true;
      var i, n, c = v2.c, e = v2.e, s = v2.s;
      out:
        if ({}.toString.call(c) == "[object Array]") {
          if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
            if (c[0] === 0) {
              if (e === 0 && c.length === 1)
                return true;
              break out;
            }
            i = (e + 1) % LOG_BASE;
            if (i < 1)
              i += LOG_BASE;
            if (String(c[0]).length == i) {
              for (i = 0; i < c.length; i++) {
                n = c[i];
                if (n < 0 || n >= BASE || n !== mathfloor(n))
                  break out;
              }
              if (n !== 0)
                return true;
            }
          }
        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
          return true;
        }
      throw Error(bignumberError + "Invalid BigNumber: " + v2);
    };
    BigNumber2.maximum = BigNumber2.max = function() {
      return maxOrMin(arguments, -1);
    };
    BigNumber2.minimum = BigNumber2.min = function() {
      return maxOrMin(arguments, 1);
    };
    BigNumber2.random = function() {
      var pow2_53 = 9007199254740992;
      var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
        return mathfloor(Math.random() * pow2_53);
      } : function() {
        return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
      };
      return function(dp) {
        var a, b, e, k, v2, i = 0, c = [], rand = new BigNumber2(ONE);
        if (dp == null)
          dp = DECIMAL_PLACES;
        else
          intCheck(dp, 0, MAX);
        k = mathceil(dp / LOG_BASE);
        if (CRYPTO) {
          if (crypto.getRandomValues) {
            a = crypto.getRandomValues(new Uint32Array(k *= 2));
            for (; i < k; ) {
              v2 = a[i] * 131072 + (a[i + 1] >>> 11);
              if (v2 >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {
                c.push(v2 % 1e14);
                i += 2;
              }
            }
            i = k / 2;
          } else if (crypto.randomBytes) {
            a = crypto.randomBytes(k *= 7);
            for (; i < k; ) {
              v2 = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
              if (v2 >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {
                c.push(v2 % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error(bignumberError + "crypto unavailable");
          }
        }
        if (!CRYPTO) {
          for (; i < k; ) {
            v2 = random53bitInt();
            if (v2 < 9e15)
              c[i++] = v2 % 1e14;
          }
        }
        k = c[--i];
        dp %= LOG_BASE;
        if (k && dp) {
          v2 = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v2) * v2;
        }
        for (; c[i] === 0; c.pop(), i--)
          ;
        if (i < 0) {
          c = [e = 0];
        } else {
          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
            ;
          for (i = 1, v2 = c[0]; v2 >= 10; v2 /= 10, i++)
            ;
          if (i < LOG_BASE)
            e -= LOG_BASE - i;
        }
        rand.e = e;
        rand.c = c;
        return rand;
      };
    }();
    BigNumber2.sum = function() {
      var i = 1, args = arguments, sum3 = new BigNumber2(args[0]);
      for (; i < args.length; )
        sum3 = sum3.plus(args[i++]);
      return sum3;
    };
    convertBase = /* @__PURE__ */ function() {
      var decimal = "0123456789";
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j, arr = [0], arrL, i = 0, len = str.length;
        for (; i < len; ) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
            ;
          arr[0] += alphabet.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null)
                arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      return function(str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
        if (i >= 0) {
          k = POW_PRECISION;
          POW_PRECISION = 0;
          str = str.replace(".", "");
          y = new BigNumber2(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;
          y.c = toBaseOut(
            toFixedPoint(coeffToString(x.c), x.e, "0"),
            10,
            baseOut,
            decimal
          );
          y.e = y.c.length;
        }
        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
        e = k = xc.length;
        for (; xc[--k] == 0; xc.pop())
          ;
        if (!xc[0])
          return alphabet.charAt(0);
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }
        d = e + dp + 1;
        i = xc[d];
        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;
        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
        if (d < 1 || !xc[0]) {
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {
          xc.length = d;
          if (r) {
            for (--baseOut; ++xc[--d] > baseOut; ) {
              xc[d] = 0;
              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }
          for (k = xc.length; !xc[--k]; )
            ;
          for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
            ;
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }
        return str;
      };
    }();
    div = /* @__PURE__ */ function() {
      function multiply(x, k, base) {
        var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
        for (x = x.slice(); i--; ) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }
        if (carry)
          x = [carry].concat(x);
        return x;
      }
      function compare2(a, b, aL, bL) {
        var i, cmp;
        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {
          for (i = cmp = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return cmp;
      }
      function subtract(a, b, aL, base) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; a.splice(0, 1))
          ;
      }
      return function(x, y, dp, rm, base) {
        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
        if (!xc || !xc[0] || !yc || !yc[0]) {
          return new BigNumber2(
            // Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
              // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
              xc && xc[0] == 0 || !yc ? s * 0 : s / 0
            )
          );
        }
        q = new BigNumber2(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;
        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }
        for (i = 0; yc[i] == (xc[i] || 0); i++)
          ;
        if (yc[i] > (xc[i] || 0))
          e--;
        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;
          n = mathfloor(base / (yc[0] + 1));
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }
          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; rem[remL++] = 0)
            ;
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2)
            yc0++;
          do {
            n = 0;
            cmp = compare2(yc, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL)
                rem0 = rem0 * base + (rem[1] || 0);
              n = mathfloor(rem0 / yc0);
              if (n > 1) {
                if (n >= base)
                  n = base - 1;
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;
                while (compare2(prod, rem, prodL, remL) == 1) {
                  n--;
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {
                if (n == 0) {
                  cmp = n = 1;
                }
                prod = yc.slice();
                prodL = prod.length;
              }
              if (prodL < remL)
                prod = [0].concat(prod);
              subtract(rem, prod, remL, base);
              remL = rem.length;
              if (cmp == -1) {
                while (compare2(yc, rem, yL, remL) < 1) {
                  n++;
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            }
            qc[i++] = n;
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);
          more = rem[0] != null;
          if (!qc[0])
            qc.splice(0, 1);
        }
        if (base == BASE) {
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
            ;
          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
        } else {
          q.e = e;
          q.r = +more;
        }
        return q;
      };
    }();
    function format2(n, i, rm, id5) {
      var c0, e, ne, len, str;
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      if (!n.c)
        return n.toString();
      c0 = n.c[0];
      ne = n.e;
      if (i == null) {
        str = coeffToString(n.c);
        str = id5 == 1 || id5 == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
      } else {
        n = round(new BigNumber2(n), i, rm);
        e = n.e;
        str = coeffToString(n.c);
        len = str.length;
        if (id5 == 1 || id5 == 2 && (i <= e || e <= TO_EXP_NEG)) {
          for (; len < i; str += "0", len++)
            ;
          str = toExponential(str, e);
        } else {
          i -= ne;
          str = toFixedPoint(str, e, "0");
          if (e + 1 > len) {
            if (--i > 0)
              for (str += "."; i--; str += "0")
                ;
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len)
                str += ".";
              for (; i--; str += "0")
                ;
            }
          }
        }
      }
      return n.s < 0 && c0 ? "-" + str : str;
    }
    function maxOrMin(args, n) {
      var k, y, i = 1, x = new BigNumber2(args[0]);
      for (; i < args.length; i++) {
        y = new BigNumber2(args[i]);
        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
          x = y;
        }
      }
      return x;
    }
    function normalise(n, c, e) {
      var i = 1, j = c.length;
      for (; !c[--j]; c.pop())
        ;
      for (j = c[0]; j >= 10; j /= 10, i++)
        ;
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
        n.c = n.e = null;
      } else if (e < MIN_EXP) {
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }
      return n;
    }
    parseNumeric = /* @__PURE__ */ function() {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function(x, str, isNum, b) {
        var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {
            s = s.replace(basePrefix, function(m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
              return !b || b == base ? p1 : m;
            });
            if (b) {
              base = b;
              s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
            }
            if (str != s)
              return new BigNumber2(s, base);
          }
          if (BigNumber2.DEBUG) {
            throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
          }
          x.s = null;
        }
        x.c = x.e = null;
      };
    }();
    function round(x, sd, rm, r) {
      var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
      if (xc) {
        out: {
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
            ;
          i = sd - d;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];
            rd = mathfloor(n / pows10[d - j - 1] % 10);
          } else {
            ni = mathceil((i + 1) / LOG_BASE);
            if (ni >= xc.length) {
              if (r) {
                for (; xc.length <= ni; xc.push(0))
                  ;
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];
              for (d = 1; k >= 10; k /= 10, d++)
                ;
              i %= LOG_BASE;
              j = i - LOG_BASE + d;
              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
            }
          }
          r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
          xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xc[0]) {
            xc.length = 0;
            if (r) {
              sd -= x.e + 1;
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {
              xc[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }
          if (r) {
            for (; ; ) {
              if (ni == 0) {
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                  ;
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++)
                  ;
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE)
                    xc[0] = 1;
                }
                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE)
                  break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }
          for (i = xc.length; xc[--i] === 0; xc.pop())
            ;
        }
        if (x.e > MAX_EXP) {
          x.c = x.e = null;
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }
      return x;
    }
    function valueOf(n) {
      var str, e = n.e;
      if (e === null)
        return n.toString();
      str = coeffToString(n.c);
      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
      return n.s < 0 ? "-" + str : str;
    }
    P.absoluteValue = P.abs = function() {
      var x = new BigNumber2(this);
      if (x.s < 0)
        x.s = 1;
      return x;
    };
    P.comparedTo = function(y, b) {
      return compare(this, new BigNumber2(y, b));
    };
    P.decimalPlaces = P.dp = function(dp, rm) {
      var c, n, v2, x = this;
      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(new BigNumber2(x), dp + x.e + 1, rm);
      }
      if (!(c = x.c))
        return null;
      n = ((v2 = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
      if (v2 = c[v2])
        for (; v2 % 10 == 0; v2 /= 10, n--)
          ;
      if (n < 0)
        n = 0;
      return n;
    };
    P.dividedBy = P.div = function(y, b) {
      return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };
    P.dividedToIntegerBy = P.idiv = function(y, b) {
      return div(this, new BigNumber2(y, b), 0, 1);
    };
    P.exponentiatedBy = P.pow = function(n, m) {
      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
      n = new BigNumber2(n);
      if (n.c && !n.isInteger()) {
        throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
      }
      if (m != null)
        m = new BigNumber2(m);
      nIsBig = n.e > 14;
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
        y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }
      nIsNeg = n.s < 0;
      if (m) {
        if (m.c ? !m.c[0] : !m.s)
          return new BigNumber2(NaN);
        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
        if (isModExp)
          x = x.mod(m);
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
        k = x.s < 0 && isOdd(n) ? -0 : 0;
        if (x.e > -1)
          k = 1 / k;
        return new BigNumber2(nIsNeg ? 1 / k : k);
      } else if (POW_PRECISION) {
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }
      if (nIsBig) {
        half = new BigNumber2(0.5);
        if (nIsNeg)
          n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }
      y = new BigNumber2(ONE);
      for (; ; ) {
        if (nIsOdd) {
          y = y.times(x);
          if (!y.c)
            break;
          if (k) {
            if (y.c.length > k)
              y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m);
          }
        }
        if (i) {
          i = mathfloor(i / 2);
          if (i === 0)
            break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);
          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          }
        }
        x = x.times(x);
        if (k) {
          if (x.c && x.c.length > k)
            x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m);
        }
      }
      if (isModExp)
        return y;
      if (nIsNeg)
        y = ONE.div(y);
      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };
    P.integerValue = function(rm) {
      var n = new BigNumber2(this);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };
    P.isEqualTo = P.eq = function(y, b) {
      return compare(this, new BigNumber2(y, b)) === 0;
    };
    P.isFinite = function() {
      return !!this.c;
    };
    P.isGreaterThan = P.gt = function(y, b) {
      return compare(this, new BigNumber2(y, b)) > 0;
    };
    P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
      return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
    };
    P.isInteger = function() {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };
    P.isLessThan = P.lt = function(y, b) {
      return compare(this, new BigNumber2(y, b)) < 0;
    };
    P.isLessThanOrEqualTo = P.lte = function(y, b) {
      return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
    };
    P.isNaN = function() {
      return !this.s;
    };
    P.isNegative = function() {
      return this.s < 0;
    };
    P.isPositive = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return !!this.c && this.c[0] == 0;
    };
    P.minus = function(y, b) {
      var i, j, t, xLTy, x = this, a = x.s;
      y = new BigNumber2(y, b);
      b = y.s;
      if (!a || !b)
        return new BigNumber2(NaN);
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }
      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
      if (!xe || !ye) {
        if (!xc || !yc)
          return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
        if (!xc[0] || !yc[0]) {
          return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
            // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
            ROUNDING_MODE == 3 ? -0 : 0
          ));
        }
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();
      if (a = xe - ye) {
        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }
        t.reverse();
        for (b = a; b--; t.push(0))
          ;
        t.reverse();
      } else {
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
        for (a = b = 0; b < j; b++) {
          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }
      b = (j = yc.length) - (i = xc.length);
      if (b > 0)
        for (; b--; xc[i++] = 0)
          ;
      b = BASE - 1;
      for (; j > a; ) {
        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b)
            ;
          --xc[i];
          xc[j] += BASE;
        }
        xc[j] -= yc[j];
      }
      for (; xc[0] == 0; xc.splice(0, 1), --ye)
        ;
      if (!xc[0]) {
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }
      return normalise(y, xc, ye);
    };
    P.modulo = P.mod = function(y, b) {
      var q, s, x = this;
      y = new BigNumber2(y, b);
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber2(NaN);
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber2(x);
      }
      if (MODULO_MODE == 9) {
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }
      y = x.minus(q.times(y));
      if (!y.c[0] && MODULO_MODE == 1)
        y.s = x.s;
      return y;
    };
    P.multipliedBy = P.times = function(y, b) {
      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
      if (!xc || !yc || !xc[0] || !yc[0]) {
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;
          if (!xc || !yc) {
            y.c = y.e = null;
          } else {
            y.c = [0];
            y.e = 0;
          }
        }
        return y;
      }
      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }
      for (i = xcL + ycL, zc = []; i--; zc.push(0))
        ;
      base = BASE;
      sqrtBase = SQRT_BASE;
      for (i = ycL; --i >= 0; ) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;
        for (k = xcL, j = i + k; j > i; ) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }
        zc[j] = c;
      }
      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }
      return normalise(y, zc, e);
    };
    P.negated = function() {
      var x = new BigNumber2(this);
      x.s = -x.s || null;
      return x;
    };
    P.plus = function(y, b) {
      var t, x = this, a = x.s;
      y = new BigNumber2(y, b);
      b = y.s;
      if (!a || !b)
        return new BigNumber2(NaN);
      if (a != b) {
        y.s = -b;
        return x.minus(y);
      }
      var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
      if (!xe || !ye) {
        if (!xc || !yc)
          return new BigNumber2(a / 0);
        if (!xc[0] || !yc[0])
          return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }
        t.reverse();
        for (; a--; t.push(0))
          ;
        t.reverse();
      }
      a = xc.length;
      b = yc.length;
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }
      for (a = 0; b; ) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }
      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }
      return normalise(y, xc, ye);
    };
    P.precision = P.sd = function(sd, rm) {
      var c, n, v2, x = this;
      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(new BigNumber2(x), sd, rm);
      }
      if (!(c = x.c))
        return null;
      v2 = c.length - 1;
      n = v2 * LOG_BASE + 1;
      if (v2 = c[v2]) {
        for (; v2 % 10 == 0; v2 /= 10, n--)
          ;
        for (v2 = c[0]; v2 >= 10; v2 /= 10, n++)
          ;
      }
      if (sd && x.e + 1 > n)
        n = x.e + 1;
      return n;
    };
    P.shiftedBy = function(k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times("1e" + k);
    };
    P.squareRoot = P.sqrt = function() {
      var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }
      s = Math.sqrt(+valueOf(x));
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0)
          n += "0";
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = "5e" + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf("e") + 1) + e;
        }
        r = new BigNumber2(n);
      } else {
        r = new BigNumber2(s + "");
      }
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3)
          s = 0;
        for (; ; ) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));
          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
            if (r.e < e)
              --s;
            n = n.slice(s - 3, s + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              dp += 4;
              s += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
      }
      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };
    P.toExponential = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format2(this, dp, rm, 1);
    };
    P.toFixed = function(dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format2(this, dp, rm);
    };
    P.toFormat = function(dp, rm, format22) {
      var str, x = this;
      if (format22 == null) {
        if (dp != null && rm && typeof rm == "object") {
          format22 = rm;
          rm = null;
        } else if (dp && typeof dp == "object") {
          format22 = dp;
          dp = rm = null;
        } else {
          format22 = FORMAT;
        }
      } else if (typeof format22 != "object") {
        throw Error(bignumberError + "Argument not an object: " + format22);
      }
      str = x.toFixed(dp, rm);
      if (x.c) {
        var i, arr = str.split("."), g1 = +format22.groupSize, g2 = +format22.secondaryGroupSize, groupSeparator = format22.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }
        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1)
            intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0)
            intPart += groupSeparator + intDigits.slice(i);
          if (isNeg)
            intPart = "-" + intPart;
        }
        str = fractionPart ? intPart + (format22.decimalSeparator || "") + ((g2 = +format22.fractionGroupSize) ? fractionPart.replace(
          new RegExp("\\d{" + g2 + "}\\B", "g"),
          "$&" + (format22.fractionGroupSeparator || "")
        ) : fractionPart) : intPart;
      }
      return (format22.prefix || "") + str + (format22.suffix || "");
    };
    P.toFraction = function(md) {
      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
      if (md != null) {
        n = new BigNumber2(md);
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
        }
      }
      if (!xc)
        return new BigNumber2(x);
      d = new BigNumber2(ONE);
      n1 = d0 = new BigNumber2(ONE);
      d1 = n0 = new BigNumber2(ONE);
      s = coeffToString(xc);
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber2(s);
      n0.c[0] = 0;
      for (; ; ) {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1)
          break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }
      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
        div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
      ) < 1 ? [n1, d1] : [n0, d0];
      MAX_EXP = exp;
      return r;
    };
    P.toNumber = function() {
      return +valueOf(this);
    };
    P.toPrecision = function(sd, rm) {
      if (sd != null)
        intCheck(sd, 1, MAX);
      return format2(this, sd, rm, 2);
    };
    P.toString = function(b) {
      var str, n = this, s = n.s, e = n.e;
      if (e === null) {
        if (s) {
          str = "Infinity";
          if (s < 0)
            str = "-" + str;
        } else {
          str = "NaN";
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, "0");
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
        }
        if (s < 0 && n.c[0])
          str = "-" + str;
      }
      return str;
    };
    P.valueOf = P.toJSON = function() {
      return valueOf(this);
    };
    P._isBigNumber = true;
    P[Symbol.toStringTag] = "BigNumber";
    P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
    if (configObject != null)
      BigNumber2.set(configObject);
    return BigNumber2;
  }
  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }
  function coeffToString(a) {
    var s, z, i = 1, j = a.length, r = a[0] + "";
    for (; i < j; ) {
      s = a[i++] + "";
      z = LOG_BASE - s.length;
      for (; z--; s = "0" + s)
        ;
      r += s;
    }
    for (j = r.length; r.charCodeAt(--j) === 48; )
      ;
    return r.slice(0, j + 1 || 1);
  }
  function compare(x, y) {
    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
    if (!i || !j)
      return null;
    a = xc && !xc[0];
    b = yc && !yc[0];
    if (a || b)
      return a ? b ? 0 : -j : i;
    if (i != j)
      return i;
    a = i < 0;
    b = k == l;
    if (!xc || !yc)
      return b ? 0 : !xc ^ a ? 1 : -1;
    if (!b)
      return k > l ^ a ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;
    for (i = 0; i < j; i++)
      if (xc[i] != yc[i])
        return xc[i] > yc[i] ^ a ? 1 : -1;
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }
  function intCheck(n, min2, max2, name) {
    if (n < min2 || n > max2 || n !== mathfloor(n)) {
      throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min2 || n > max2 ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
    }
  }
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }
  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
  }
  function toFixedPoint(str, e, z) {
    var len, zs;
    if (e < 0) {
      for (zs = z + "."; ++e; zs += z)
        ;
      str = zs + str;
    } else {
      len = str.length;
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z)
          ;
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + "." + str.slice(e);
      }
    }
    return str;
  }
  var BigNumber = clone2();
  var bignumber_default = BigNumber;
  var SplayTreeNode = class {
    constructor(key) {
      __publicField(this, "key");
      __publicField(this, "left", null);
      __publicField(this, "right", null);
      this.key = key;
    }
  };
  var SplayTreeSetNode = class extends SplayTreeNode {
    constructor(key) {
      super(key);
    }
  };
  var SplayTree = class {
    constructor() {
      __publicField(this, "size", 0);
      __publicField(this, "modificationCount", 0);
      __publicField(this, "splayCount", 0);
    }
    splay(key) {
      const root = this.root;
      if (root == null) {
        this.compare(key, key);
        return -1;
      }
      let right = null;
      let newTreeRight = null;
      let left = null;
      let newTreeLeft = null;
      let current = root;
      const compare2 = this.compare;
      let comp;
      while (true) {
        comp = compare2(current.key, key);
        if (comp > 0) {
          let currentLeft = current.left;
          if (currentLeft == null)
            break;
          comp = compare2(currentLeft.key, key);
          if (comp > 0) {
            current.left = currentLeft.right;
            currentLeft.right = current;
            current = currentLeft;
            currentLeft = current.left;
            if (currentLeft == null)
              break;
          }
          if (right == null) {
            newTreeRight = current;
          } else {
            right.left = current;
          }
          right = current;
          current = currentLeft;
        } else if (comp < 0) {
          let currentRight = current.right;
          if (currentRight == null)
            break;
          comp = compare2(currentRight.key, key);
          if (comp < 0) {
            current.right = currentRight.left;
            currentRight.left = current;
            current = currentRight;
            currentRight = current.right;
            if (currentRight == null)
              break;
          }
          if (left == null) {
            newTreeLeft = current;
          } else {
            left.right = current;
          }
          left = current;
          current = currentRight;
        } else {
          break;
        }
      }
      if (left != null) {
        left.right = current.left;
        current.left = newTreeLeft;
      }
      if (right != null) {
        right.left = current.right;
        current.right = newTreeRight;
      }
      if (this.root !== current) {
        this.root = current;
        this.splayCount++;
      }
      return comp;
    }
    splayMin(node) {
      let current = node;
      let nextLeft = current.left;
      while (nextLeft != null) {
        const left = nextLeft;
        current.left = left.right;
        left.right = current;
        current = left;
        nextLeft = current.left;
      }
      return current;
    }
    splayMax(node) {
      let current = node;
      let nextRight = current.right;
      while (nextRight != null) {
        const right = nextRight;
        current.right = right.left;
        right.left = current;
        current = right;
        nextRight = current.right;
      }
      return current;
    }
    _delete(key) {
      if (this.root == null)
        return null;
      const comp = this.splay(key);
      if (comp != 0)
        return null;
      let root = this.root;
      const result = root;
      const left = root.left;
      this.size--;
      if (left == null) {
        this.root = root.right;
      } else {
        const right = root.right;
        root = this.splayMax(left);
        root.right = right;
        this.root = root;
      }
      this.modificationCount++;
      return result;
    }
    addNewRoot(node, comp) {
      this.size++;
      this.modificationCount++;
      const root = this.root;
      if (root == null) {
        this.root = node;
        return;
      }
      if (comp < 0) {
        node.left = root;
        node.right = root.right;
        root.right = null;
      } else {
        node.right = root;
        node.left = root.left;
        root.left = null;
      }
      this.root = node;
    }
    _first() {
      const root = this.root;
      if (root == null)
        return null;
      this.root = this.splayMin(root);
      return this.root;
    }
    _last() {
      const root = this.root;
      if (root == null)
        return null;
      this.root = this.splayMax(root);
      return this.root;
    }
    clear() {
      this.root = null;
      this.size = 0;
      this.modificationCount++;
    }
    has(key) {
      return this.validKey(key) && this.splay(key) == 0;
    }
    defaultCompare() {
      return (a, b) => a < b ? -1 : a > b ? 1 : 0;
    }
    wrap() {
      return {
        getRoot: () => {
          return this.root;
        },
        setRoot: (root) => {
          this.root = root;
        },
        getSize: () => {
          return this.size;
        },
        getModificationCount: () => {
          return this.modificationCount;
        },
        getSplayCount: () => {
          return this.splayCount;
        },
        setSplayCount: (count) => {
          this.splayCount = count;
        },
        splay: (key) => {
          return this.splay(key);
        },
        has: (key) => {
          return this.has(key);
        }
      };
    }
  };
  var _a;
  var _b;
  var SplayTreeSet = class _SplayTreeSet extends SplayTree {
    constructor(compare2, isValidKey) {
      super();
      __publicField(this, "root", null);
      __publicField(this, "compare");
      __publicField(this, "validKey");
      __publicField(this, _a, "[object Set]");
      this.compare = compare2 ?? this.defaultCompare();
      this.validKey = isValidKey ?? ((v2) => v2 != null && v2 != void 0);
    }
    delete(element) {
      if (!this.validKey(element))
        return false;
      return this._delete(element) != null;
    }
    deleteAll(elements) {
      for (const element of elements) {
        this.delete(element);
      }
    }
    forEach(f) {
      const nodes = this[Symbol.iterator]();
      let result;
      while (result = nodes.next(), !result.done) {
        f(result.value, result.value, this);
      }
    }
    add(element) {
      const compare2 = this.splay(element);
      if (compare2 != 0)
        this.addNewRoot(new SplayTreeSetNode(element), compare2);
      return this;
    }
    addAndReturn(element) {
      const compare2 = this.splay(element);
      if (compare2 != 0)
        this.addNewRoot(new SplayTreeSetNode(element), compare2);
      return this.root.key;
    }
    addAll(elements) {
      for (const element of elements) {
        this.add(element);
      }
    }
    isEmpty() {
      return this.root == null;
    }
    isNotEmpty() {
      return this.root != null;
    }
    single() {
      if (this.size == 0)
        throw "Bad state: No element";
      if (this.size > 1)
        throw "Bad state: Too many element";
      return this.root.key;
    }
    first() {
      if (this.size == 0)
        throw "Bad state: No element";
      return this._first().key;
    }
    last() {
      if (this.size == 0)
        throw "Bad state: No element";
      return this._last().key;
    }
    lastBefore(element) {
      if (element == null)
        throw "Invalid arguments(s)";
      if (this.root == null)
        return null;
      const comp = this.splay(element);
      if (comp < 0)
        return this.root.key;
      let node = this.root.left;
      if (node == null)
        return null;
      let nodeRight = node.right;
      while (nodeRight != null) {
        node = nodeRight;
        nodeRight = node.right;
      }
      return node.key;
    }
    firstAfter(element) {
      if (element == null)
        throw "Invalid arguments(s)";
      if (this.root == null)
        return null;
      const comp = this.splay(element);
      if (comp > 0)
        return this.root.key;
      let node = this.root.right;
      if (node == null)
        return null;
      let nodeLeft = node.left;
      while (nodeLeft != null) {
        node = nodeLeft;
        nodeLeft = node.left;
      }
      return node.key;
    }
    retainAll(elements) {
      const retainSet = new _SplayTreeSet(this.compare, this.validKey);
      const modificationCount = this.modificationCount;
      for (const object of elements) {
        if (modificationCount != this.modificationCount) {
          throw "Concurrent modification during iteration.";
        }
        if (this.validKey(object) && this.splay(object) == 0) {
          retainSet.add(this.root.key);
        }
      }
      if (retainSet.size != this.size) {
        this.root = retainSet.root;
        this.size = retainSet.size;
        this.modificationCount++;
      }
    }
    lookup(object) {
      if (!this.validKey(object))
        return null;
      const comp = this.splay(object);
      if (comp != 0)
        return null;
      return this.root.key;
    }
    intersection(other) {
      const result = new _SplayTreeSet(this.compare, this.validKey);
      for (const element of this) {
        if (other.has(element))
          result.add(element);
      }
      return result;
    }
    difference(other) {
      const result = new _SplayTreeSet(this.compare, this.validKey);
      for (const element of this) {
        if (!other.has(element))
          result.add(element);
      }
      return result;
    }
    union(other) {
      const u4 = this.clone();
      u4.addAll(other);
      return u4;
    }
    clone() {
      const set2 = new _SplayTreeSet(this.compare, this.validKey);
      set2.size = this.size;
      set2.root = this.copyNode(this.root);
      return set2;
    }
    copyNode(node) {
      if (node == null)
        return null;
      function copyChildren(node2, dest) {
        let left;
        let right;
        do {
          left = node2.left;
          right = node2.right;
          if (left != null) {
            const newLeft = new SplayTreeSetNode(left.key);
            dest.left = newLeft;
            copyChildren(left, newLeft);
          }
          if (right != null) {
            const newRight = new SplayTreeSetNode(right.key);
            dest.right = newRight;
            node2 = right;
            dest = newRight;
          }
        } while (right != null);
      }
      const result = new SplayTreeSetNode(node.key);
      copyChildren(node, result);
      return result;
    }
    toSet() {
      return this.clone();
    }
    entries() {
      return new SplayTreeSetEntryIterableIterator(this.wrap());
    }
    keys() {
      return this[Symbol.iterator]();
    }
    values() {
      return this[Symbol.iterator]();
    }
    [(_b = Symbol.iterator, _a = Symbol.toStringTag, _b)]() {
      return new SplayTreeKeyIterableIterator(this.wrap());
    }
  };
  var SplayTreeIterableIterator = class {
    constructor(tree) {
      __publicField(this, "tree");
      __publicField(this, "path", new Array());
      __publicField(this, "modificationCount", null);
      __publicField(this, "splayCount");
      this.tree = tree;
      this.splayCount = tree.getSplayCount();
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      if (this.moveNext())
        return { done: false, value: this.current() };
      return { done: true, value: null };
    }
    current() {
      if (!this.path.length)
        return null;
      const node = this.path[this.path.length - 1];
      return this.getValue(node);
    }
    rebuildPath(key) {
      this.path.splice(0, this.path.length);
      this.tree.splay(key);
      this.path.push(this.tree.getRoot());
      this.splayCount = this.tree.getSplayCount();
    }
    findLeftMostDescendent(node) {
      while (node != null) {
        this.path.push(node);
        node = node.left;
      }
    }
    moveNext() {
      if (this.modificationCount != this.tree.getModificationCount()) {
        if (this.modificationCount == null) {
          this.modificationCount = this.tree.getModificationCount();
          let node2 = this.tree.getRoot();
          while (node2 != null) {
            this.path.push(node2);
            node2 = node2.left;
          }
          return this.path.length > 0;
        }
        throw "Concurrent modification during iteration.";
      }
      if (!this.path.length)
        return false;
      if (this.splayCount != this.tree.getSplayCount()) {
        this.rebuildPath(this.path[this.path.length - 1].key);
      }
      let node = this.path[this.path.length - 1];
      let next = node.right;
      if (next != null) {
        while (next != null) {
          this.path.push(next);
          next = next.left;
        }
        return true;
      }
      this.path.pop();
      while (this.path.length && this.path[this.path.length - 1].right === node) {
        node = this.path.pop();
      }
      return this.path.length > 0;
    }
  };
  var SplayTreeKeyIterableIterator = class extends SplayTreeIterableIterator {
    getValue(node) {
      return node.key;
    }
  };
  var SplayTreeSetEntryIterableIterator = class extends SplayTreeIterableIterator {
    getValue(node) {
      return [node.key, node.key];
    }
  };
  var constant_default2 = (x) => {
    return () => {
      return x;
    };
  };
  var compare_default = (eps) => {
    const almostEqual = eps ? (a, b) => b.minus(a).abs().isLessThanOrEqualTo(eps) : constant_default2(false);
    return (a, b) => {
      if (almostEqual(a, b))
        return 0;
      return a.comparedTo(b);
    };
  };
  function orient_default(eps) {
    const almostCollinear = eps ? (area2, ax, ay, cx, cy) => area2.exponentiatedBy(2).isLessThanOrEqualTo(
      cx.minus(ax).exponentiatedBy(2).plus(cy.minus(ay).exponentiatedBy(2)).times(eps)
    ) : constant_default2(false);
    return (a, b, c) => {
      const ax = a.x, ay = a.y, cx = c.x, cy = c.y;
      const area2 = ay.minus(cy).times(b.x.minus(cx)).minus(ax.minus(cx).times(b.y.minus(cy)));
      if (almostCollinear(area2, ax, ay, cx, cy))
        return 0;
      return area2.comparedTo(0);
    };
  }
  var identity_default2 = (x) => {
    return x;
  };
  var snap_default = (eps) => {
    if (eps) {
      const xTree = new SplayTreeSet(compare_default(eps));
      const yTree = new SplayTreeSet(compare_default(eps));
      const snapCoord = (coord, tree) => {
        return tree.addAndReturn(coord);
      };
      const snap = (v2) => {
        return {
          x: snapCoord(v2.x, xTree),
          y: snapCoord(v2.y, yTree)
        };
      };
      snap({ x: new bignumber_default(0), y: new bignumber_default(0) });
      return snap;
    }
    return identity_default2;
  };
  var set = (eps) => {
    return {
      set: (eps2) => {
        precision = set(eps2);
      },
      reset: () => set(eps),
      compare: compare_default(eps),
      snap: snap_default(eps),
      orient: orient_default(eps)
    };
  };
  var precision = set();
  var isInBbox = (bbox2, point22) => {
    return bbox2.ll.x.isLessThanOrEqualTo(point22.x) && point22.x.isLessThanOrEqualTo(bbox2.ur.x) && bbox2.ll.y.isLessThanOrEqualTo(point22.y) && point22.y.isLessThanOrEqualTo(bbox2.ur.y);
  };
  var getBboxOverlap = (b1, b2) => {
    if (b2.ur.x.isLessThan(b1.ll.x) || b1.ur.x.isLessThan(b2.ll.x) || b2.ur.y.isLessThan(b1.ll.y) || b1.ur.y.isLessThan(b2.ll.y))
      return null;
    const lowerX = b1.ll.x.isLessThan(b2.ll.x) ? b2.ll.x : b1.ll.x;
    const upperX = b1.ur.x.isLessThan(b2.ur.x) ? b1.ur.x : b2.ur.x;
    const lowerY = b1.ll.y.isLessThan(b2.ll.y) ? b2.ll.y : b1.ll.y;
    const upperY = b1.ur.y.isLessThan(b2.ur.y) ? b1.ur.y : b2.ur.y;
    return { ll: { x: lowerX, y: lowerY }, ur: { x: upperX, y: upperY } };
  };
  var crossProduct = (a, b) => a.x.times(b.y).minus(a.y.times(b.x));
  var dotProduct = (a, b) => a.x.times(b.x).plus(a.y.times(b.y));
  var length = (v2) => dotProduct(v2, v2).sqrt();
  var sineOfAngle = (pShared, pBase, pAngle) => {
    const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };
    const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };
    return crossProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));
  };
  var cosineOfAngle = (pShared, pBase, pAngle) => {
    const vBase = { x: pBase.x.minus(pShared.x), y: pBase.y.minus(pShared.y) };
    const vAngle = { x: pAngle.x.minus(pShared.x), y: pAngle.y.minus(pShared.y) };
    return dotProduct(vAngle, vBase).div(length(vAngle)).div(length(vBase));
  };
  var horizontalIntersection = (pt, v2, y) => {
    if (v2.y.isZero())
      return null;
    return { x: pt.x.plus(v2.x.div(v2.y).times(y.minus(pt.y))), y };
  };
  var verticalIntersection = (pt, v2, x) => {
    if (v2.x.isZero())
      return null;
    return { x, y: pt.y.plus(v2.y.div(v2.x).times(x.minus(pt.x))) };
  };
  var intersection = (pt1, v1, pt2, v2) => {
    if (v1.x.isZero())
      return verticalIntersection(pt2, v2, pt1.x);
    if (v2.x.isZero())
      return verticalIntersection(pt1, v1, pt2.x);
    if (v1.y.isZero())
      return horizontalIntersection(pt2, v2, pt1.y);
    if (v2.y.isZero())
      return horizontalIntersection(pt1, v1, pt2.y);
    const kross = crossProduct(v1, v2);
    if (kross.isZero())
      return null;
    const ve = { x: pt2.x.minus(pt1.x), y: pt2.y.minus(pt1.y) };
    const d1 = crossProduct(ve, v1).div(kross);
    const d2 = crossProduct(ve, v2).div(kross);
    const x1 = pt1.x.plus(d2.times(v1.x)), x2 = pt2.x.plus(d1.times(v2.x));
    const y1 = pt1.y.plus(d2.times(v1.y)), y2 = pt2.y.plus(d1.times(v2.y));
    const x = x1.plus(x2).div(2);
    const y = y1.plus(y2).div(2);
    return { x, y };
  };
  var SweepEvent = class _SweepEvent {
    // Warning: 'point' input will be modified and re-used (for performance)
    constructor(point22, isLeft) {
      __publicField(this, "point");
      __publicField(this, "isLeft");
      __publicField(this, "segment");
      __publicField(this, "otherSE");
      __publicField(this, "consumedBy");
      if (point22.events === void 0)
        point22.events = [this];
      else
        point22.events.push(this);
      this.point = point22;
      this.isLeft = isLeft;
    }
    // for ordering sweep events in the sweep event queue
    static compare(a, b) {
      const ptCmp = _SweepEvent.comparePoints(a.point, b.point);
      if (ptCmp !== 0)
        return ptCmp;
      if (a.point !== b.point)
        a.link(b);
      if (a.isLeft !== b.isLeft)
        return a.isLeft ? 1 : -1;
      return Segment2.compare(a.segment, b.segment);
    }
    // for ordering points in sweep line order
    static comparePoints(aPt, bPt) {
      if (aPt.x.isLessThan(bPt.x))
        return -1;
      if (aPt.x.isGreaterThan(bPt.x))
        return 1;
      if (aPt.y.isLessThan(bPt.y))
        return -1;
      if (aPt.y.isGreaterThan(bPt.y))
        return 1;
      return 0;
    }
    link(other) {
      if (other.point === this.point) {
        throw new Error("Tried to link already linked events");
      }
      const otherEvents = other.point.events;
      for (let i = 0, iMax = otherEvents.length; i < iMax; i++) {
        const evt = otherEvents[i];
        this.point.events.push(evt);
        evt.point = this.point;
      }
      this.checkForConsuming();
    }
    /* Do a pass over our linked events and check to see if any pair
     * of segments match, and should be consumed. */
    checkForConsuming() {
      const numEvents = this.point.events.length;
      for (let i = 0; i < numEvents; i++) {
        const evt1 = this.point.events[i];
        if (evt1.segment.consumedBy !== void 0)
          continue;
        for (let j = i + 1; j < numEvents; j++) {
          const evt2 = this.point.events[j];
          if (evt2.consumedBy !== void 0)
            continue;
          if (evt1.otherSE.point.events !== evt2.otherSE.point.events)
            continue;
          evt1.segment.consume(evt2.segment);
        }
      }
    }
    getAvailableLinkedEvents() {
      const events = [];
      for (let i = 0, iMax = this.point.events.length; i < iMax; i++) {
        const evt = this.point.events[i];
        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {
          events.push(evt);
        }
      }
      return events;
    }
    /**
     * Returns a comparator function for sorting linked events that will
     * favor the event that will give us the smallest left-side angle.
     * All ring construction starts as low as possible heading to the right,
     * so by always turning left as sharp as possible we'll get polygons
     * without uncessary loops & holes.
     *
     * The comparator function has a compute cache such that it avoids
     * re-computing already-computed values.
     */
    getLeftmostComparator(baseEvent) {
      const cache = /* @__PURE__ */ new Map();
      const fillCache = (linkedEvent) => {
        const nextEvent = linkedEvent.otherSE;
        cache.set(linkedEvent, {
          sine: sineOfAngle(this.point, baseEvent.point, nextEvent.point),
          cosine: cosineOfAngle(this.point, baseEvent.point, nextEvent.point)
        });
      };
      return (a, b) => {
        if (!cache.has(a))
          fillCache(a);
        if (!cache.has(b))
          fillCache(b);
        const { sine: asine, cosine: acosine } = cache.get(a);
        const { sine: bsine, cosine: bcosine } = cache.get(b);
        if (asine.isGreaterThanOrEqualTo(0) && bsine.isGreaterThanOrEqualTo(0)) {
          if (acosine.isLessThan(bcosine))
            return 1;
          if (acosine.isGreaterThan(bcosine))
            return -1;
          return 0;
        }
        if (asine.isLessThan(0) && bsine.isLessThan(0)) {
          if (acosine.isLessThan(bcosine))
            return -1;
          if (acosine.isGreaterThan(bcosine))
            return 1;
          return 0;
        }
        if (bsine.isLessThan(asine))
          return -1;
        if (bsine.isGreaterThan(asine))
          return 1;
        return 0;
      };
    }
  };
  var RingOut = class _RingOut {
    constructor(events) {
      __publicField(this, "events");
      __publicField(this, "poly");
      __publicField(this, "_isExteriorRing");
      __publicField(this, "_enclosingRing");
      this.events = events;
      for (let i = 0, iMax = events.length; i < iMax; i++) {
        events[i].segment.ringOut = this;
      }
      this.poly = null;
    }
    /* Given the segments from the sweep line pass, compute & return a series
     * of closed rings from all the segments marked to be part of the result */
    static factory(allSegments) {
      const ringsOut = [];
      for (let i = 0, iMax = allSegments.length; i < iMax; i++) {
        const segment = allSegments[i];
        if (!segment.isInResult() || segment.ringOut)
          continue;
        let prevEvent = null;
        let event = segment.leftSE;
        let nextEvent = segment.rightSE;
        const events = [event];
        const startingPoint = event.point;
        const intersectionLEs = [];
        while (true) {
          prevEvent = event;
          event = nextEvent;
          events.push(event);
          if (event.point === startingPoint)
            break;
          while (true) {
            const availableLEs = event.getAvailableLinkedEvents();
            if (availableLEs.length === 0) {
              const firstPt = events[0].point;
              const lastPt = events[events.length - 1].point;
              throw new Error(
                `Unable to complete output ring starting at [${firstPt.x}, ${firstPt.y}]. Last matching segment found ends at [${lastPt.x}, ${lastPt.y}].`
              );
            }
            if (availableLEs.length === 1) {
              nextEvent = availableLEs[0].otherSE;
              break;
            }
            let indexLE = null;
            for (let j = 0, jMax = intersectionLEs.length; j < jMax; j++) {
              if (intersectionLEs[j].point === event.point) {
                indexLE = j;
                break;
              }
            }
            if (indexLE !== null) {
              const intersectionLE = intersectionLEs.splice(indexLE)[0];
              const ringEvents = events.splice(intersectionLE.index);
              ringEvents.unshift(ringEvents[0].otherSE);
              ringsOut.push(new _RingOut(ringEvents.reverse()));
              continue;
            }
            intersectionLEs.push({
              index: events.length,
              point: event.point
            });
            const comparator = event.getLeftmostComparator(prevEvent);
            nextEvent = availableLEs.sort(comparator)[0].otherSE;
            break;
          }
        }
        ringsOut.push(new _RingOut(events));
      }
      return ringsOut;
    }
    getGeom() {
      let prevPt = this.events[0].point;
      const points = [prevPt];
      for (let i = 1, iMax = this.events.length - 1; i < iMax; i++) {
        const pt2 = this.events[i].point;
        const nextPt2 = this.events[i + 1].point;
        if (precision.orient(pt2, prevPt, nextPt2) === 0)
          continue;
        points.push(pt2);
        prevPt = pt2;
      }
      if (points.length === 1)
        return null;
      const pt = points[0];
      const nextPt = points[1];
      if (precision.orient(pt, prevPt, nextPt) === 0)
        points.shift();
      points.push(points[0]);
      const step = this.isExteriorRing() ? 1 : -1;
      const iStart = this.isExteriorRing() ? 0 : points.length - 1;
      const iEnd = this.isExteriorRing() ? points.length : -1;
      const orderedPoints = [];
      for (let i = iStart; i != iEnd; i += step)
        orderedPoints.push([points[i].x.toNumber(), points[i].y.toNumber()]);
      return orderedPoints;
    }
    isExteriorRing() {
      if (this._isExteriorRing === void 0) {
        const enclosing = this.enclosingRing();
        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;
      }
      return this._isExteriorRing;
    }
    enclosingRing() {
      if (this._enclosingRing === void 0) {
        this._enclosingRing = this._calcEnclosingRing();
      }
      return this._enclosingRing;
    }
    /* Returns the ring that encloses this one, if any */
    _calcEnclosingRing() {
      let leftMostEvt = this.events[0];
      for (let i = 1, iMax = this.events.length; i < iMax; i++) {
        const evt = this.events[i];
        if (SweepEvent.compare(leftMostEvt, evt) > 0)
          leftMostEvt = evt;
      }
      let prevSeg = leftMostEvt.segment.prevInResult();
      let prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
      while (true) {
        if (!prevSeg)
          return null;
        if (!prevPrevSeg)
          return prevSeg.ringOut;
        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {
          if (prevPrevSeg.ringOut?.enclosingRing() !== prevSeg.ringOut) {
            return prevSeg.ringOut;
          } else
            return prevSeg.ringOut?.enclosingRing();
        }
        prevSeg = prevPrevSeg.prevInResult();
        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;
      }
    }
  };
  var PolyOut = class {
    constructor(exteriorRing) {
      __publicField(this, "exteriorRing");
      __publicField(this, "interiorRings");
      this.exteriorRing = exteriorRing;
      exteriorRing.poly = this;
      this.interiorRings = [];
    }
    addInterior(ring) {
      this.interiorRings.push(ring);
      ring.poly = this;
    }
    getGeom() {
      const geom0 = this.exteriorRing.getGeom();
      if (geom0 === null)
        return null;
      const geom = [geom0];
      for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
        const ringGeom = this.interiorRings[i].getGeom();
        if (ringGeom === null)
          continue;
        geom.push(ringGeom);
      }
      return geom;
    }
  };
  var MultiPolyOut = class {
    constructor(rings) {
      __publicField(this, "rings");
      __publicField(this, "polys");
      this.rings = rings;
      this.polys = this._composePolys(rings);
    }
    getGeom() {
      const geom = [];
      for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
        const polyGeom = this.polys[i].getGeom();
        if (polyGeom === null)
          continue;
        geom.push(polyGeom);
      }
      return geom;
    }
    _composePolys(rings) {
      const polys = [];
      for (let i = 0, iMax = rings.length; i < iMax; i++) {
        const ring = rings[i];
        if (ring.poly)
          continue;
        if (ring.isExteriorRing())
          polys.push(new PolyOut(ring));
        else {
          const enclosingRing = ring.enclosingRing();
          if (!enclosingRing?.poly)
            polys.push(new PolyOut(enclosingRing));
          enclosingRing?.poly?.addInterior(ring);
        }
      }
      return polys;
    }
  };
  var SweepLine = class {
    constructor(queue, comparator = Segment2.compare) {
      __publicField(this, "queue");
      __publicField(this, "tree");
      __publicField(this, "segments");
      this.queue = queue;
      this.tree = new SplayTreeSet(comparator);
      this.segments = [];
    }
    process(event) {
      const segment = event.segment;
      const newEvents = [];
      if (event.consumedBy) {
        if (event.isLeft)
          this.queue.delete(event.otherSE);
        else
          this.tree.delete(segment);
        return newEvents;
      }
      if (event.isLeft)
        this.tree.add(segment);
      let prevSeg = segment;
      let nextSeg = segment;
      do {
        prevSeg = this.tree.lastBefore(prevSeg);
      } while (prevSeg != null && prevSeg.consumedBy != void 0);
      do {
        nextSeg = this.tree.firstAfter(nextSeg);
      } while (nextSeg != null && nextSeg.consumedBy != void 0);
      if (event.isLeft) {
        let prevMySplitter = null;
        if (prevSeg) {
          const prevInter = prevSeg.getIntersection(segment);
          if (prevInter !== null) {
            if (!segment.isAnEndpoint(prevInter))
              prevMySplitter = prevInter;
            if (!prevSeg.isAnEndpoint(prevInter)) {
              const newEventsFromSplit = this._splitSafely(prevSeg, prevInter);
              for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                newEvents.push(newEventsFromSplit[i]);
              }
            }
          }
        }
        let nextMySplitter = null;
        if (nextSeg) {
          const nextInter = nextSeg.getIntersection(segment);
          if (nextInter !== null) {
            if (!segment.isAnEndpoint(nextInter))
              nextMySplitter = nextInter;
            if (!nextSeg.isAnEndpoint(nextInter)) {
              const newEventsFromSplit = this._splitSafely(nextSeg, nextInter);
              for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                newEvents.push(newEventsFromSplit[i]);
              }
            }
          }
        }
        if (prevMySplitter !== null || nextMySplitter !== null) {
          let mySplitter = null;
          if (prevMySplitter === null)
            mySplitter = nextMySplitter;
          else if (nextMySplitter === null)
            mySplitter = prevMySplitter;
          else {
            const cmpSplitters = SweepEvent.comparePoints(
              prevMySplitter,
              nextMySplitter
            );
            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;
          }
          this.queue.delete(segment.rightSE);
          newEvents.push(segment.rightSE);
          const newEventsFromSplit = segment.split(mySplitter);
          for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
            newEvents.push(newEventsFromSplit[i]);
          }
        }
        if (newEvents.length > 0) {
          this.tree.delete(segment);
          newEvents.push(event);
        } else {
          this.segments.push(segment);
          segment.prev = prevSeg;
        }
      } else {
        if (prevSeg && nextSeg) {
          const inter = prevSeg.getIntersection(nextSeg);
          if (inter !== null) {
            if (!prevSeg.isAnEndpoint(inter)) {
              const newEventsFromSplit = this._splitSafely(prevSeg, inter);
              for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                newEvents.push(newEventsFromSplit[i]);
              }
            }
            if (!nextSeg.isAnEndpoint(inter)) {
              const newEventsFromSplit = this._splitSafely(nextSeg, inter);
              for (let i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {
                newEvents.push(newEventsFromSplit[i]);
              }
            }
          }
        }
        this.tree.delete(segment);
      }
      return newEvents;
    }
    /* Safely split a segment that is currently in the datastructures
     * IE - a segment other than the one that is currently being processed. */
    _splitSafely(seg, pt) {
      this.tree.delete(seg);
      const rightSE = seg.rightSE;
      this.queue.delete(rightSE);
      const newEvents = seg.split(pt);
      newEvents.push(rightSE);
      if (seg.consumedBy === void 0)
        this.tree.add(seg);
      return newEvents;
    }
  };
  var Operation = class {
    constructor() {
      __publicField(this, "type");
      __publicField(this, "numMultiPolys");
    }
    run(type, geom, moreGeoms) {
      operation.type = type;
      const multipolys = [new MultiPolyIn(geom, true)];
      for (let i = 0, iMax = moreGeoms.length; i < iMax; i++) {
        multipolys.push(new MultiPolyIn(moreGeoms[i], false));
      }
      operation.numMultiPolys = multipolys.length;
      if (operation.type === "difference") {
        const subject = multipolys[0];
        let i = 1;
        while (i < multipolys.length) {
          if (getBboxOverlap(multipolys[i].bbox, subject.bbox) !== null)
            i++;
          else
            multipolys.splice(i, 1);
        }
      }
      if (operation.type === "intersection") {
        for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
          const mpA = multipolys[i];
          for (let j = i + 1, jMax = multipolys.length; j < jMax; j++) {
            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null)
              return [];
          }
        }
      }
      const queue = new SplayTreeSet(SweepEvent.compare);
      for (let i = 0, iMax = multipolys.length; i < iMax; i++) {
        const sweepEvents = multipolys[i].getSweepEvents();
        for (let j = 0, jMax = sweepEvents.length; j < jMax; j++) {
          queue.add(sweepEvents[j]);
        }
      }
      const sweepLine = new SweepLine(queue);
      let evt = null;
      if (queue.size != 0) {
        evt = queue.first();
        queue.delete(evt);
      }
      while (evt) {
        const newEvents = sweepLine.process(evt);
        for (let i = 0, iMax = newEvents.length; i < iMax; i++) {
          const evt2 = newEvents[i];
          if (evt2.consumedBy === void 0)
            queue.add(evt2);
        }
        if (queue.size != 0) {
          evt = queue.first();
          queue.delete(evt);
        } else {
          evt = null;
        }
      }
      precision.reset();
      const ringsOut = RingOut.factory(sweepLine.segments);
      const result = new MultiPolyOut(ringsOut);
      return result.getGeom();
    }
  };
  var operation = new Operation();
  var operation_default = operation;
  var segmentId = 0;
  var Segment2 = class _Segment {
    /* Warning: a reference to ringWindings input will be stored,
     *  and possibly will be later modified */
    constructor(leftSE, rightSE, rings, windings) {
      __publicField(this, "id");
      __publicField(this, "leftSE");
      __publicField(this, "rightSE");
      __publicField(this, "rings");
      __publicField(this, "windings");
      __publicField(this, "ringOut");
      __publicField(this, "consumedBy");
      __publicField(this, "prev");
      __publicField(this, "_prevInResult");
      __publicField(this, "_beforeState");
      __publicField(this, "_afterState");
      __publicField(this, "_isInResult");
      this.id = ++segmentId;
      this.leftSE = leftSE;
      leftSE.segment = this;
      leftSE.otherSE = rightSE;
      this.rightSE = rightSE;
      rightSE.segment = this;
      rightSE.otherSE = leftSE;
      this.rings = rings;
      this.windings = windings;
    }
    /* This compare() function is for ordering segments in the sweep
     * line tree, and does so according to the following criteria:
     *
     * Consider the vertical line that lies an infinestimal step to the
     * right of the right-more of the two left endpoints of the input
     * segments. Imagine slowly moving a point up from negative infinity
     * in the increasing y direction. Which of the two segments will that
     * point intersect first? That segment comes 'before' the other one.
     *
     * If neither segment would be intersected by such a line, (if one
     * or more of the segments are vertical) then the line to be considered
     * is directly on the right-more of the two left inputs.
     */
    static compare(a, b) {
      const alx = a.leftSE.point.x;
      const blx = b.leftSE.point.x;
      const arx = a.rightSE.point.x;
      const brx = b.rightSE.point.x;
      if (brx.isLessThan(alx))
        return 1;
      if (arx.isLessThan(blx))
        return -1;
      const aly = a.leftSE.point.y;
      const bly = b.leftSE.point.y;
      const ary = a.rightSE.point.y;
      const bry = b.rightSE.point.y;
      if (alx.isLessThan(blx)) {
        if (bly.isLessThan(aly) && bly.isLessThan(ary))
          return 1;
        if (bly.isGreaterThan(aly) && bly.isGreaterThan(ary))
          return -1;
        const aCmpBLeft = a.comparePoint(b.leftSE.point);
        if (aCmpBLeft < 0)
          return 1;
        if (aCmpBLeft > 0)
          return -1;
        const bCmpARight = b.comparePoint(a.rightSE.point);
        if (bCmpARight !== 0)
          return bCmpARight;
        return -1;
      }
      if (alx.isGreaterThan(blx)) {
        if (aly.isLessThan(bly) && aly.isLessThan(bry))
          return -1;
        if (aly.isGreaterThan(bly) && aly.isGreaterThan(bry))
          return 1;
        const bCmpALeft = b.comparePoint(a.leftSE.point);
        if (bCmpALeft !== 0)
          return bCmpALeft;
        const aCmpBRight = a.comparePoint(b.rightSE.point);
        if (aCmpBRight < 0)
          return 1;
        if (aCmpBRight > 0)
          return -1;
        return 1;
      }
      if (aly.isLessThan(bly))
        return -1;
      if (aly.isGreaterThan(bly))
        return 1;
      if (arx.isLessThan(brx)) {
        const bCmpARight = b.comparePoint(a.rightSE.point);
        if (bCmpARight !== 0)
          return bCmpARight;
      }
      if (arx.isGreaterThan(brx)) {
        const aCmpBRight = a.comparePoint(b.rightSE.point);
        if (aCmpBRight < 0)
          return 1;
        if (aCmpBRight > 0)
          return -1;
      }
      if (!arx.eq(brx)) {
        const ay = ary.minus(aly);
        const ax = arx.minus(alx);
        const by = bry.minus(bly);
        const bx = brx.minus(blx);
        if (ay.isGreaterThan(ax) && by.isLessThan(bx))
          return 1;
        if (ay.isLessThan(ax) && by.isGreaterThan(bx))
          return -1;
      }
      if (arx.isGreaterThan(brx))
        return 1;
      if (arx.isLessThan(brx))
        return -1;
      if (ary.isLessThan(bry))
        return -1;
      if (ary.isGreaterThan(bry))
        return 1;
      if (a.id < b.id)
        return -1;
      if (a.id > b.id)
        return 1;
      return 0;
    }
    static fromRing(pt1, pt2, ring) {
      let leftPt, rightPt, winding;
      const cmpPts = SweepEvent.comparePoints(pt1, pt2);
      if (cmpPts < 0) {
        leftPt = pt1;
        rightPt = pt2;
        winding = 1;
      } else if (cmpPts > 0) {
        leftPt = pt2;
        rightPt = pt1;
        winding = -1;
      } else
        throw new Error(
          `Tried to create degenerate segment at [${pt1.x}, ${pt1.y}]`
        );
      const leftSE = new SweepEvent(leftPt, true);
      const rightSE = new SweepEvent(rightPt, false);
      return new _Segment(leftSE, rightSE, [ring], [winding]);
    }
    /* When a segment is split, the rightSE is replaced with a new sweep event */
    replaceRightSE(newRightSE) {
      this.rightSE = newRightSE;
      this.rightSE.segment = this;
      this.rightSE.otherSE = this.leftSE;
      this.leftSE.otherSE = this.rightSE;
    }
    bbox() {
      const y1 = this.leftSE.point.y;
      const y2 = this.rightSE.point.y;
      return {
        ll: { x: this.leftSE.point.x, y: y1.isLessThan(y2) ? y1 : y2 },
        ur: { x: this.rightSE.point.x, y: y1.isGreaterThan(y2) ? y1 : y2 }
      };
    }
    /* A vector from the left point to the right */
    vector() {
      return {
        x: this.rightSE.point.x.minus(this.leftSE.point.x),
        y: this.rightSE.point.y.minus(this.leftSE.point.y)
      };
    }
    isAnEndpoint(pt) {
      return pt.x.eq(this.leftSE.point.x) && pt.y.eq(this.leftSE.point.y) || pt.x.eq(this.rightSE.point.x) && pt.y.eq(this.rightSE.point.y);
    }
    /* Compare this segment with a point.
     *
     * A point P is considered to be colinear to a segment if there
     * exists a distance D such that if we travel along the segment
     * from one * endpoint towards the other a distance D, we find
     * ourselves at point P.
     *
     * Return value indicates:
     *
     *   1: point lies above the segment (to the left of vertical)
     *   0: point is colinear to segment
     *  -1: point lies below the segment (to the right of vertical)
     */
    comparePoint(point22) {
      return precision.orient(this.leftSE.point, point22, this.rightSE.point);
    }
    /**
     * Given another segment, returns the first non-trivial intersection
     * between the two segments (in terms of sweep line ordering), if it exists.
     *
     * A 'non-trivial' intersection is one that will cause one or both of the
     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:
     *
     *   * endpoint of segA with endpoint of segB --> trivial
     *   * endpoint of segA with point along segB --> non-trivial
     *   * endpoint of segB with point along segA --> non-trivial
     *   * point along segA with point along segB --> non-trivial
     *
     * If no non-trivial intersection exists, return null
     * Else, return null.
     */
    getIntersection(other) {
      const tBbox = this.bbox();
      const oBbox = other.bbox();
      const bboxOverlap = getBboxOverlap(tBbox, oBbox);
      if (bboxOverlap === null)
        return null;
      const tlp = this.leftSE.point;
      const trp = this.rightSE.point;
      const olp = other.leftSE.point;
      const orp = other.rightSE.point;
      const touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;
      const touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;
      const touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;
      const touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0;
      if (touchesThisLSE && touchesOtherLSE) {
        if (touchesThisRSE && !touchesOtherRSE)
          return trp;
        if (!touchesThisRSE && touchesOtherRSE)
          return orp;
        return null;
      }
      if (touchesThisLSE) {
        if (touchesOtherRSE) {
          if (tlp.x.eq(orp.x) && tlp.y.eq(orp.y))
            return null;
        }
        return tlp;
      }
      if (touchesOtherLSE) {
        if (touchesThisRSE) {
          if (trp.x.eq(olp.x) && trp.y.eq(olp.y))
            return null;
        }
        return olp;
      }
      if (touchesThisRSE && touchesOtherRSE)
        return null;
      if (touchesThisRSE)
        return trp;
      if (touchesOtherRSE)
        return orp;
      const pt = intersection(tlp, this.vector(), olp, other.vector());
      if (pt === null)
        return null;
      if (!isInBbox(bboxOverlap, pt))
        return null;
      return precision.snap(pt);
    }
    /**
     * Split the given segment into multiple segments on the given points.
     *  * Each existing segment will retain its leftSE and a new rightSE will be
     *    generated for it.
     *  * A new segment will be generated which will adopt the original segment's
     *    rightSE, and a new leftSE will be generated for it.
     *  * If there are more than two points given to split on, new segments
     *    in the middle will be generated with new leftSE and rightSE's.
     *  * An array of the newly generated SweepEvents will be returned.
     *
     * Warning: input array of points is modified
     */
    split(point22) {
      const newEvents = [];
      const alreadyLinked = point22.events !== void 0;
      const newLeftSE = new SweepEvent(point22, true);
      const newRightSE = new SweepEvent(point22, false);
      const oldRightSE = this.rightSE;
      this.replaceRightSE(newRightSE);
      newEvents.push(newRightSE);
      newEvents.push(newLeftSE);
      const newSeg = new _Segment(
        newLeftSE,
        oldRightSE,
        this.rings.slice(),
        this.windings.slice()
      );
      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {
        newSeg.swapEvents();
      }
      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {
        this.swapEvents();
      }
      if (alreadyLinked) {
        newLeftSE.checkForConsuming();
        newRightSE.checkForConsuming();
      }
      return newEvents;
    }
    /* Swap which event is left and right */
    swapEvents() {
      const tmpEvt = this.rightSE;
      this.rightSE = this.leftSE;
      this.leftSE = tmpEvt;
      this.leftSE.isLeft = true;
      this.rightSE.isLeft = false;
      for (let i = 0, iMax = this.windings.length; i < iMax; i++) {
        this.windings[i] *= -1;
      }
    }
    /* Consume another segment. We take their rings under our wing
     * and mark them as consumed. Use for perfectly overlapping segments */
    consume(other) {
      let consumer = this;
      let consumee = other;
      while (consumer.consumedBy)
        consumer = consumer.consumedBy;
      while (consumee.consumedBy)
        consumee = consumee.consumedBy;
      const cmp = _Segment.compare(consumer, consumee);
      if (cmp === 0)
        return;
      if (cmp > 0) {
        const tmp = consumer;
        consumer = consumee;
        consumee = tmp;
      }
      if (consumer.prev === consumee) {
        const tmp = consumer;
        consumer = consumee;
        consumee = tmp;
      }
      for (let i = 0, iMax = consumee.rings.length; i < iMax; i++) {
        const ring = consumee.rings[i];
        const winding = consumee.windings[i];
        const index2 = consumer.rings.indexOf(ring);
        if (index2 === -1) {
          consumer.rings.push(ring);
          consumer.windings.push(winding);
        } else
          consumer.windings[index2] += winding;
      }
      consumee.rings = null;
      consumee.windings = null;
      consumee.consumedBy = consumer;
      consumee.leftSE.consumedBy = consumer.leftSE;
      consumee.rightSE.consumedBy = consumer.rightSE;
    }
    /* The first segment previous segment chain that is in the result */
    prevInResult() {
      if (this._prevInResult !== void 0)
        return this._prevInResult;
      if (!this.prev)
        this._prevInResult = null;
      else if (this.prev.isInResult())
        this._prevInResult = this.prev;
      else
        this._prevInResult = this.prev.prevInResult();
      return this._prevInResult;
    }
    beforeState() {
      if (this._beforeState !== void 0)
        return this._beforeState;
      if (!this.prev)
        this._beforeState = {
          rings: [],
          windings: [],
          multiPolys: []
        };
      else {
        const seg = this.prev.consumedBy || this.prev;
        this._beforeState = seg.afterState();
      }
      return this._beforeState;
    }
    afterState() {
      if (this._afterState !== void 0)
        return this._afterState;
      const beforeState = this.beforeState();
      this._afterState = {
        rings: beforeState.rings.slice(0),
        windings: beforeState.windings.slice(0),
        multiPolys: []
      };
      const ringsAfter = this._afterState.rings;
      const windingsAfter = this._afterState.windings;
      const mpsAfter = this._afterState.multiPolys;
      for (let i = 0, iMax = this.rings.length; i < iMax; i++) {
        const ring = this.rings[i];
        const winding = this.windings[i];
        const index2 = ringsAfter.indexOf(ring);
        if (index2 === -1) {
          ringsAfter.push(ring);
          windingsAfter.push(winding);
        } else
          windingsAfter[index2] += winding;
      }
      const polysAfter = [];
      const polysExclude = [];
      for (let i = 0, iMax = ringsAfter.length; i < iMax; i++) {
        if (windingsAfter[i] === 0)
          continue;
        const ring = ringsAfter[i];
        const poly = ring.poly;
        if (polysExclude.indexOf(poly) !== -1)
          continue;
        if (ring.isExterior)
          polysAfter.push(poly);
        else {
          if (polysExclude.indexOf(poly) === -1)
            polysExclude.push(poly);
          const index2 = polysAfter.indexOf(ring.poly);
          if (index2 !== -1)
            polysAfter.splice(index2, 1);
        }
      }
      for (let i = 0, iMax = polysAfter.length; i < iMax; i++) {
        const mp = polysAfter[i].multiPoly;
        if (mpsAfter.indexOf(mp) === -1)
          mpsAfter.push(mp);
      }
      return this._afterState;
    }
    /* Is this segment part of the final result? */
    isInResult() {
      if (this.consumedBy)
        return false;
      if (this._isInResult !== void 0)
        return this._isInResult;
      const mpsBefore = this.beforeState().multiPolys;
      const mpsAfter = this.afterState().multiPolys;
      switch (operation_default.type) {
        case "union": {
          const noBefores = mpsBefore.length === 0;
          const noAfters = mpsAfter.length === 0;
          this._isInResult = noBefores !== noAfters;
          break;
        }
        case "intersection": {
          let least;
          let most;
          if (mpsBefore.length < mpsAfter.length) {
            least = mpsBefore.length;
            most = mpsAfter.length;
          } else {
            least = mpsAfter.length;
            most = mpsBefore.length;
          }
          this._isInResult = most === operation_default.numMultiPolys && least < most;
          break;
        }
        case "xor": {
          const diff = Math.abs(mpsBefore.length - mpsAfter.length);
          this._isInResult = diff % 2 === 1;
          break;
        }
        case "difference": {
          const isJustSubject = (mps) => mps.length === 1 && mps[0].isSubject;
          this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);
          break;
        }
      }
      return this._isInResult;
    }
  };
  var RingIn = class {
    constructor(geomRing, poly, isExterior) {
      __publicField(this, "poly");
      __publicField(this, "isExterior");
      __publicField(this, "segments");
      __publicField(this, "bbox");
      if (!Array.isArray(geomRing) || geomRing.length === 0) {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      this.poly = poly;
      this.isExterior = isExterior;
      this.segments = [];
      if (typeof geomRing[0][0] !== "number" || typeof geomRing[0][1] !== "number") {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      const firstPoint = precision.snap({ x: new bignumber_default(geomRing[0][0]), y: new bignumber_default(geomRing[0][1]) });
      this.bbox = {
        ll: { x: firstPoint.x, y: firstPoint.y },
        ur: { x: firstPoint.x, y: firstPoint.y }
      };
      let prevPoint = firstPoint;
      for (let i = 1, iMax = geomRing.length; i < iMax; i++) {
        if (typeof geomRing[i][0] !== "number" || typeof geomRing[i][1] !== "number") {
          throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
        }
        const point22 = precision.snap({ x: new bignumber_default(geomRing[i][0]), y: new bignumber_default(geomRing[i][1]) });
        if (point22.x.eq(prevPoint.x) && point22.y.eq(prevPoint.y))
          continue;
        this.segments.push(Segment2.fromRing(prevPoint, point22, this));
        if (point22.x.isLessThan(this.bbox.ll.x))
          this.bbox.ll.x = point22.x;
        if (point22.y.isLessThan(this.bbox.ll.y))
          this.bbox.ll.y = point22.y;
        if (point22.x.isGreaterThan(this.bbox.ur.x))
          this.bbox.ur.x = point22.x;
        if (point22.y.isGreaterThan(this.bbox.ur.y))
          this.bbox.ur.y = point22.y;
        prevPoint = point22;
      }
      if (!firstPoint.x.eq(prevPoint.x) || !firstPoint.y.eq(prevPoint.y)) {
        this.segments.push(Segment2.fromRing(prevPoint, firstPoint, this));
      }
    }
    getSweepEvents() {
      const sweepEvents = [];
      for (let i = 0, iMax = this.segments.length; i < iMax; i++) {
        const segment = this.segments[i];
        sweepEvents.push(segment.leftSE);
        sweepEvents.push(segment.rightSE);
      }
      return sweepEvents;
    }
  };
  var PolyIn = class {
    constructor(geomPoly, multiPoly) {
      __publicField(this, "multiPoly");
      __publicField(this, "exteriorRing");
      __publicField(this, "interiorRings");
      __publicField(this, "bbox");
      if (!Array.isArray(geomPoly)) {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      this.exteriorRing = new RingIn(geomPoly[0], this, true);
      this.bbox = {
        ll: { x: this.exteriorRing.bbox.ll.x, y: this.exteriorRing.bbox.ll.y },
        ur: { x: this.exteriorRing.bbox.ur.x, y: this.exteriorRing.bbox.ur.y }
      };
      this.interiorRings = [];
      for (let i = 1, iMax = geomPoly.length; i < iMax; i++) {
        const ring = new RingIn(geomPoly[i], this, false);
        if (ring.bbox.ll.x.isLessThan(this.bbox.ll.x))
          this.bbox.ll.x = ring.bbox.ll.x;
        if (ring.bbox.ll.y.isLessThan(this.bbox.ll.y))
          this.bbox.ll.y = ring.bbox.ll.y;
        if (ring.bbox.ur.x.isGreaterThan(this.bbox.ur.x))
          this.bbox.ur.x = ring.bbox.ur.x;
        if (ring.bbox.ur.y.isGreaterThan(this.bbox.ur.y))
          this.bbox.ur.y = ring.bbox.ur.y;
        this.interiorRings.push(ring);
      }
      this.multiPoly = multiPoly;
    }
    getSweepEvents() {
      const sweepEvents = this.exteriorRing.getSweepEvents();
      for (let i = 0, iMax = this.interiorRings.length; i < iMax; i++) {
        const ringSweepEvents = this.interiorRings[i].getSweepEvents();
        for (let j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {
          sweepEvents.push(ringSweepEvents[j]);
        }
      }
      return sweepEvents;
    }
  };
  var MultiPolyIn = class {
    constructor(geom, isSubject) {
      __publicField(this, "isSubject");
      __publicField(this, "polys");
      __publicField(this, "bbox");
      if (!Array.isArray(geom)) {
        throw new Error("Input geometry is not a valid Polygon or MultiPolygon");
      }
      try {
        if (typeof geom[0][0][0] === "number")
          geom = [geom];
      } catch (ex) {
      }
      this.polys = [];
      this.bbox = {
        ll: { x: new bignumber_default(Number.POSITIVE_INFINITY), y: new bignumber_default(Number.POSITIVE_INFINITY) },
        ur: { x: new bignumber_default(Number.NEGATIVE_INFINITY), y: new bignumber_default(Number.NEGATIVE_INFINITY) }
      };
      for (let i = 0, iMax = geom.length; i < iMax; i++) {
        const poly = new PolyIn(geom[i], this);
        if (poly.bbox.ll.x.isLessThan(this.bbox.ll.x))
          this.bbox.ll.x = poly.bbox.ll.x;
        if (poly.bbox.ll.y.isLessThan(this.bbox.ll.y))
          this.bbox.ll.y = poly.bbox.ll.y;
        if (poly.bbox.ur.x.isGreaterThan(this.bbox.ur.x))
          this.bbox.ur.x = poly.bbox.ur.x;
        if (poly.bbox.ur.y.isGreaterThan(this.bbox.ur.y))
          this.bbox.ur.y = poly.bbox.ur.y;
        this.polys.push(poly);
      }
      this.isSubject = isSubject;
    }
    getSweepEvents() {
      const sweepEvents = [];
      for (let i = 0, iMax = this.polys.length; i < iMax; i++) {
        const polySweepEvents = this.polys[i].getSweepEvents();
        for (let j = 0, jMax = polySweepEvents.length; j < jMax; j++) {
          sweepEvents.push(polySweepEvents[j]);
        }
      }
      return sweepEvents;
    }
  };
  var intersection2 = (geom, ...moreGeoms) => operation_default.run("intersection", geom, moreGeoms);
  var setPrecision = precision.set;
  function intersect(features, options = {}) {
    const geoms = [];
    geomEach(features, (geom) => {
      geoms.push(geom.coordinates);
    });
    if (geoms.length < 2) {
      throw new Error("Must specify at least 2 geometries");
    }
    const intersection22 = intersection2(geoms[0], ...geoms.slice(1));
    if (intersection22.length === 0)
      return null;
    if (intersection22.length === 1)
      return polygon(intersection22[0], options.properties);
    return multiPolygon(intersection22, options.properties);
  }
  var turf_intersect_default = intersect;
  var TRANSFORM_FN2 = {
    Point: transformPoint2,
    MultiPoint: transformMultiPoint2,
    LineString: transformLineString2,
    MultiLineString: transformMultiLineString2,
    Polygon: transformPolygon2,
    MultiPolygon: transformMultiPolygon2
  };
  function transformToTileCoords(geometry, bbox2) {
    const [west, south, east, north] = bbox2;
    const nw = projectFlat([west, north]);
    const se = projectFlat([east, south]);
    const projectedBbox = [nw, se];
    if (geometry.type === "GeometryCollection") {
      throw new Error("Unsupported geometry type GeometryCollection");
    }
    const transformFn = TRANSFORM_FN2[geometry.type];
    const coordinates = transformFn(geometry.coordinates, projectedBbox);
    return { ...geometry, coordinates };
  }
  function transformPoint2([pointX, pointY], [nw, se]) {
    const x = inverseLerp(nw[0], se[0], pointX);
    const y = inverseLerp(nw[1], se[1], pointY);
    return [x, y];
  }
  function getPoints2(geometry, bbox2) {
    return geometry.map((g) => transformPoint2(projectFlat(g), bbox2));
  }
  function transformMultiPoint2(multiPoint, bbox2) {
    return getPoints2(multiPoint, bbox2);
  }
  function transformLineString2(line, bbox2) {
    return getPoints2(line, bbox2);
  }
  function transformMultiLineString2(multiLineString2, bbox2) {
    return multiLineString2.map(
      (lineString2) => transformLineString2(lineString2, bbox2)
    );
  }
  function transformPolygon2(polygon2, bbox2) {
    return polygon2.map((polygonRing) => getPoints2(polygonRing, bbox2));
  }
  function transformMultiPolygon2(multiPolygon2, bbox2) {
    return multiPolygon2.map((polygon2) => transformPolygon2(polygon2, bbox2));
  }
  function projectFlat(xyz) {
    return lngLatToWorld2(xyz);
  }
  function inverseLerp(a, b, x) {
    return (x - a) / (b - a);
  }
  function lineclip(points, bbox2, result) {
    var len = points.length, codeA = bitCode(points[0], bbox2), part = [], i, codeB, lastCode;
    let a;
    let b;
    if (!result)
      result = [];
    for (i = 1; i < len; i++) {
      a = points[i - 1];
      b = points[i];
      codeB = lastCode = bitCode(b, bbox2);
      while (true) {
        if (!(codeA | codeB)) {
          part.push(a);
          if (codeB !== lastCode) {
            part.push(b);
            if (i < len - 1) {
              result.push(part);
              part = [];
            }
          } else if (i === len - 1) {
            part.push(b);
          }
          break;
        } else if (codeA & codeB) {
          break;
        } else if (codeA) {
          a = intersect2(a, b, codeA, bbox2);
          codeA = bitCode(a, bbox2);
        } else {
          b = intersect2(a, b, codeB, bbox2);
          codeB = bitCode(b, bbox2);
        }
      }
      codeA = lastCode;
    }
    if (part.length)
      result.push(part);
    return result;
  }
  function polygonclip(points, bbox2) {
    var result, edge, prev, prevInside, i, p, inside;
    for (edge = 1; edge <= 8; edge *= 2) {
      result = [];
      prev = points[points.length - 1];
      prevInside = !(bitCode(prev, bbox2) & edge);
      for (i = 0; i < points.length; i++) {
        p = points[i];
        inside = !(bitCode(p, bbox2) & edge);
        if (inside !== prevInside)
          result.push(intersect2(prev, p, edge, bbox2));
        if (inside)
          result.push(p);
        prev = p;
        prevInside = inside;
      }
      points = result;
      if (!points.length)
        break;
    }
    return result;
  }
  function intersect2(a, b, edge, bbox2) {
    return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox2[3] - a[1]) / (b[1] - a[1]), bbox2[3]] : edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox2[1] - a[1]) / (b[1] - a[1]), bbox2[1]] : edge & 2 ? [bbox2[2], a[1] + (b[1] - a[1]) * (bbox2[2] - a[0]) / (b[0] - a[0])] : edge & 1 ? [bbox2[0], a[1] + (b[1] - a[1]) * (bbox2[0] - a[0]) / (b[0] - a[0])] : null;
  }
  function bitCode(p, bbox2) {
    var code = 0;
    if (p[0] < bbox2[0])
      code |= 1;
    else if (p[0] > bbox2[2])
      code |= 2;
    if (p[1] < bbox2[1])
      code |= 4;
    else if (p[1] > bbox2[3])
      code |= 8;
    return code;
  }
  function bboxClip(feature2, bbox2) {
    const geom = getGeom(feature2);
    const type = geom.type;
    const properties = feature2.type === "Feature" ? feature2.properties : {};
    let coords = geom.coordinates;
    switch (type) {
      case "LineString":
      case "MultiLineString": {
        const lines = [];
        if (type === "LineString") {
          coords = [coords];
        }
        coords.forEach((line) => {
          lineclip(line, bbox2, lines);
        });
        if (lines.length === 1) {
          return lineString(lines[0], properties);
        }
        return multiLineString(lines, properties);
      }
      case "Polygon":
        return polygon(clipPolygon(coords, bbox2), properties);
      case "MultiPolygon":
        return multiPolygon(
          coords.map((poly) => {
            return clipPolygon(poly, bbox2);
          }),
          properties
        );
      default:
        throw new Error("geometry " + type + " not supported");
    }
  }
  function clipPolygon(rings, bbox2) {
    const outRings = [];
    for (const ring of rings) {
      const clipped = polygonclip(ring, bbox2);
      if (clipped.length > 0) {
        if (clipped[0][0] !== clipped[clipped.length - 1][0] || clipped[0][1] !== clipped[clipped.length - 1][1]) {
          clipped.push(clipped[0]);
        }
        if (clipped.length >= 4) {
          outRings.push(clipped);
        }
      }
    }
    return outRings;
  }
  var turf_bbox_clip_default = bboxClip;
  function intersectTileGeometry(tileBbox, tileFormat, spatialFilter) {
    const tilePolygon = turf_bbox_polygon_default(tileBbox);
    if (!spatialFilter || turf_boolean_within_default(tilePolygon, spatialFilter)) {
      return true;
    }
    const clippedSpatialFilter = turf_intersect_default(
      featureCollection([tilePolygon, feature(spatialFilter)])
    );
    if (!clippedSpatialFilter) {
      return false;
    }
    return tileFormat === "mvt" ? transformToTileCoords(clippedSpatialFilter.geometry, tileBbox) : clippedSpatialFilter.geometry;
  }
  function intersectTileRaster(parent, cellResolution, spatialFilter) {
    return intersectTileQuadbin(parent, cellResolution, spatialFilter);
  }
  function intersectTileQuadbin(parent, cellResolution, spatialFilter) {
    const tilePolygon = cellToBoundary2(parent);
    if (!spatialFilter || turf_boolean_within_default(tilePolygon, spatialFilter)) {
      return true;
    }
    const clippedSpatialFilter = turf_intersect_default(
      featureCollection([feature(tilePolygon), feature(spatialFilter)])
    );
    if (!clippedSpatialFilter) {
      return false;
    }
    const cells = geometryToCells(
      clippedSpatialFilter.geometry,
      cellResolution
    );
    return new Set(cells);
  }
  var BBOX_WEST = [-180, -90, 0, 90];
  var BBOX_EAST = [0, -90, 180, 90];
  function intersectTileH3(cellResolution, spatialFilter) {
    if (!spatialFilter) {
      return true;
    }
    const spatialFilterFeature = feature(spatialFilter);
    const cellsWest = (0, import_h3_js5.polygonToCells)(
      turf_bbox_clip_default(spatialFilterFeature, BBOX_WEST).geometry.coordinates,
      cellResolution,
      true
    );
    const cellsEast = (0, import_h3_js5.polygonToCells)(
      turf_bbox_clip_default(spatialFilterFeature, BBOX_EAST).geometry.coordinates,
      cellResolution,
      true
    );
    return new Set(cellsWest.concat(cellsEast));
  }
  var FEATURE_GEOM_PROPERTY = "__geomValue";
  function tileFeaturesGeometries({
    tiles: tiles3,
    tileFormat,
    spatialFilter,
    uniqueIdProperty,
    options
  }) {
    const map2 = /* @__PURE__ */ new Map();
    for (const tile of tiles3) {
      if (tile.isVisible === false || !tile.data) {
        continue;
      }
      const tileBbox = [
        tile.bbox.west,
        tile.bbox.south,
        tile.bbox.east,
        tile.bbox.north
      ];
      const intersection3 = intersectTileGeometry(
        tileBbox,
        tileFormat,
        spatialFilter
      );
      if (intersection3 === false)
        continue;
      const transformedSpatialFilter = intersection3 === true ? void 0 : intersection3;
      calculateFeatures({
        map: map2,
        spatialFilter: transformedSpatialFilter,
        data: tile.data.points,
        type: "Point",
        bbox: tileBbox,
        tileFormat,
        uniqueIdProperty,
        options
      });
      calculateFeatures({
        map: map2,
        spatialFilter: transformedSpatialFilter,
        data: tile.data.lines,
        type: "LineString",
        bbox: tileBbox,
        tileFormat,
        uniqueIdProperty,
        options
      });
      calculateFeatures({
        map: map2,
        spatialFilter: transformedSpatialFilter,
        data: tile.data.polygons,
        type: "Polygon",
        bbox: tileBbox,
        tileFormat,
        uniqueIdProperty,
        options
      });
    }
    return Array.from(map2.values());
  }
  function processTileFeatureProperties({
    map: map2,
    data,
    startIndex,
    endIndex,
    type,
    bbox: bbox2,
    tileFormat,
    uniqueIdProperty,
    storeGeometry,
    spatialFilter
  }) {
    const tileProps = getPropertiesFromTile(data, startIndex);
    const uniquePropertyValue = getUniquePropertyValue(
      tileProps,
      uniqueIdProperty,
      map2
    );
    if (!uniquePropertyValue || map2.has(uniquePropertyValue)) {
      return;
    }
    let geometry = null;
    if (storeGeometry || spatialFilter) {
      const { positions } = data;
      const ringCoordinates = getRingCoordinatesFor(
        startIndex,
        endIndex,
        positions
      );
      geometry = getFeatureByType(ringCoordinates, type);
    }
    if (geometry && spatialFilter && !turf_boolean_intersects_default(geometry, spatialFilter)) {
      return;
    }
    const properties = parseProperties2(tileProps);
    if (storeGeometry && geometry) {
      properties[FEATURE_GEOM_PROPERTY] = tileFormat === "mvt" ? transformTileCoordsToWGS84(geometry, bbox2) : geometry;
    }
    map2.set(uniquePropertyValue, properties);
  }
  function addIntersectedFeaturesInTile({
    map: map2,
    data,
    spatialFilter,
    type,
    bbox: bbox2,
    tileFormat,
    uniqueIdProperty,
    options
  }) {
    const indices = getIndices(data, type);
    const storeGeometry = options?.storeGeometry || false;
    for (let i = 0; i < indices.length - 1; i++) {
      const startIndex = indices[i];
      const endIndex = indices[i + 1];
      processTileFeatureProperties({
        map: map2,
        data,
        startIndex,
        endIndex,
        type,
        bbox: bbox2,
        tileFormat,
        uniqueIdProperty,
        storeGeometry,
        spatialFilter
      });
    }
  }
  function getIndices(data, type) {
    let indices;
    switch (type) {
      case "Polygon":
        indices = data.primitivePolygonIndices;
        break;
      case "LineString":
        indices = data.pathIndices;
        break;
      case "Point":
        indices = createIndicesForPoints(data);
        break;
      default:
        throw new Error(
          `Unsupported geometry type: ${type}`
        );
    }
    return indices.value;
  }
  function getFeatureId(data, startIndex) {
    return data.featureIds.value[startIndex];
  }
  function getPropertiesFromTile(data, startIndex) {
    const featureId2 = getFeatureId(data, startIndex);
    const { properties, numericProps, fields } = data;
    const result = {
      uniqueId: fields?.[featureId2]?.id,
      properties: properties[featureId2],
      numericProps: {}
    };
    for (const key in numericProps) {
      result.numericProps[key] = numericProps[key].value[startIndex];
    }
    return result;
  }
  function parseProperties2(tileProps) {
    const { properties, numericProps } = tileProps;
    return Object.assign({}, properties, numericProps);
  }
  function getUniquePropertyValue(tileProps, uniqueIdProperty, map2) {
    if (uniqueIdProperty) {
      return getValueFromTileProps(tileProps, uniqueIdProperty);
    }
    if (tileProps.uniqueId) {
      return tileProps.uniqueId;
    }
    const artificialId = map2.size + 1;
    return getValueFromTileProps(tileProps, "cartodb_id") || getValueFromTileProps(tileProps, "geoid") || artificialId;
  }
  function getValueFromTileProps(tileProps, propertyName) {
    const { properties, numericProps } = tileProps;
    return numericProps[propertyName] || properties[propertyName];
  }
  function getFeatureByType(coordinates, type) {
    switch (type) {
      case "Polygon":
        return { type: "Polygon", coordinates: [coordinates] };
      case "LineString":
        return { type: "LineString", coordinates };
      case "Point":
        return { type: "Point", coordinates: coordinates[0] };
      default:
        throw new Error("Invalid geometry type");
    }
  }
  function getRingCoordinatesFor(startIndex, endIndex, positions) {
    const ringCoordinates = [];
    for (let j = startIndex; j < endIndex; j++) {
      ringCoordinates.push(
        Array.from(
          positions.value.subarray(j * positions.size, (j + 1) * positions.size)
        )
      );
    }
    return ringCoordinates;
  }
  function calculateFeatures({
    map: map2,
    spatialFilter,
    data,
    type,
    bbox: bbox2,
    tileFormat,
    uniqueIdProperty,
    options
  }) {
    if (!data?.properties.length) {
      return;
    }
    if (!spatialFilter) {
      addAllFeaturesInTile({
        map: map2,
        data,
        type,
        bbox: bbox2,
        tileFormat,
        uniqueIdProperty,
        options
      });
    } else {
      addIntersectedFeaturesInTile({
        map: map2,
        data,
        spatialFilter,
        type,
        bbox: bbox2,
        tileFormat,
        uniqueIdProperty,
        options
      });
    }
  }
  function addAllFeaturesInTile({
    map: map2,
    data,
    type,
    bbox: bbox2,
    tileFormat,
    uniqueIdProperty,
    options
  }) {
    const indices = getIndices(data, type);
    const storeGeometry = options?.storeGeometry || false;
    for (let i = 0; i < indices.length - 1; i++) {
      const startIndex = indices[i];
      const endIndex = indices[i + 1];
      processTileFeatureProperties({
        map: map2,
        data,
        startIndex,
        endIndex,
        type,
        bbox: bbox2,
        tileFormat,
        uniqueIdProperty,
        storeGeometry
      });
    }
  }
  function createIndicesForPoints(data) {
    const featureIds = data.featureIds.value;
    const lastFeatureId = featureIds[featureIds.length - 1];
    const PointIndicesArray = featureIds.constructor;
    const pointIndices = {
      value: new PointIndicesArray(featureIds.length + 1),
      size: 1
    };
    pointIndices.value.set(featureIds);
    pointIndices.value.set([lastFeatureId + 1], featureIds.length);
    return pointIndices;
  }
  function tileFeaturesSpatialIndex({
    tiles: tiles3,
    spatialFilter,
    spatialDataColumn,
    spatialDataType
  }) {
    const map2 = /* @__PURE__ */ new Map();
    const spatialIndex = getSpatialIndex(spatialDataType);
    const cellResolution = getResolution5(tiles3, spatialIndex);
    const spatialIndexIDName = spatialDataColumn ? spatialDataColumn : spatialIndex;
    if (!cellResolution) {
      return [];
    }
    let intersection3;
    if (spatialIndex === "h3") {
      intersection3 = intersectTileH3(cellResolution, spatialFilter);
    }
    for (const tile of tiles3) {
      if (tile.isVisible === false || !tile.data) {
        continue;
      }
      if (spatialIndex === "quadbin") {
        const parent = getTileIndex(tile, spatialIndex);
        intersection3 = intersectTileQuadbin(
          parent,
          cellResolution,
          spatialFilter
        );
      }
      if (!intersection3)
        continue;
      tile.data.forEach((d) => {
        if (intersection3 === true || intersection3.has(d.id)) {
          map2.set(d.id, { ...d.properties, [spatialIndexIDName]: d.id });
        }
      });
    }
    return Array.from(map2.values());
  }
  function getTileIndex(tile, spatialIndex) {
    if (spatialIndex === "quadbin") {
      return tile.index.q;
    }
    return tile.id;
  }
  function getResolution5(tiles3, spatialIndex) {
    const data = tiles3.find((tile) => tile.data?.length)?.data;
    if (!data) {
      return;
    }
    if (spatialIndex === "quadbin") {
      return Number(getResolution4(data[0].id));
    }
    if (spatialIndex === "h3") {
      return (0, import_h3_js6.getResolution)(data[0].id);
    }
  }
  function getSpatialIndex(spatialDataType) {
    switch (spatialDataType) {
      case "h3":
        return "h3";
      case "quadbin":
        return "quadbin";
      default:
        throw new Error("Unexpected spatial data type");
    }
  }
  var V3_MINOR_VERSION = "3.4";
  var DEFAULT_GEO_COLUMN = "geom";
  var DEFAULT_MAX_LENGTH_URL = 7e3;
  var DEFAULT_TILE_RESOLUTION = 0.5;
  var REDUCED_QUERIES_TILE_RESOLUTION = 1;
  var DEFAULT_AGGREGATION_RES_LEVEL_H3 = 4;
  var DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN = 6;
  var DEFAULT_AGGREGATION_EXP_ALIAS = "__aggregationValue";
  var DEFAULT_AGGREGATION_EXP = `1 AS ${DEFAULT_AGGREGATION_EXP_ALIAS}`;
  function tileFeaturesRaster({
    tiles: tiles3,
    ...options
  }) {
    const metadataByBand = {};
    for (const band2 of options.rasterMetadata.bands) {
      metadataByBand[band2.name] = { ...band2, nodata: Number(band2.nodata) };
    }
    tiles3 = tiles3.filter(isRasterTileVisible);
    if (tiles3.length === 0)
      return [];
    const tileResolution = getResolution4(tiles3[0].index.q);
    const tileBlockSize = tiles3[0].data.blockSize;
    const cellResolution = tileResolution + BigInt(Math.log2(tileBlockSize));
    const data = /* @__PURE__ */ new Map();
    for (const tile of tiles3) {
      const parent = tile.index.q;
      const intersection3 = intersectTileRaster(
        parent,
        cellResolution,
        options.spatialFilter
      );
      if (intersection3 === false)
        continue;
      const tileSortedCells = cellToChildrenRaster(parent, cellResolution);
      for (let i = 0; i < tileSortedCells.length; i++) {
        if (intersection3 !== true && !intersection3.has(tileSortedCells[i])) {
          continue;
        }
        const cellData = {};
        let cellDataExists = false;
        for (const band2 in tile.data.cells.numericProps) {
          const value = tile.data.cells.numericProps[band2].value[i];
          const bandMetadata = metadataByBand[band2];
          if (isValidBandValue(value, bandMetadata.nodata)) {
            cellData[band2] = tile.data.cells.numericProps[band2].value[i];
            cellDataExists = true;
          }
        }
        if (cellDataExists) {
          data.set(tileSortedCells[i], cellData);
        }
      }
    }
    return Array.from(data.values());
  }
  function isRasterTile(tile) {
    return !!tile.data?.cells;
  }
  function isRasterTileVisible(tile) {
    return !!(tile.isVisible && tile.data?.cells?.numericProps);
  }
  function cellToChildrenRaster(parent, resolution) {
    const parentTile = cellToTile2(parent);
    const childZ = Number(resolution);
    const blockSize = 2 ** (childZ - parentTile.z);
    const childBaseX = parentTile.x * blockSize;
    const childBaseY = parentTile.y * blockSize;
    const cells = [];
    for (let i = 0, il = blockSize ** 2; i < il; i++) {
      const x = childBaseX + i % blockSize;
      const y = childBaseY + Math.floor(i / blockSize);
      cells.push(tileToCell2({ x, y, z: childZ }));
    }
    return cells;
  }
  function isValidBandValue(value, nodata) {
    return Number.isNaN(value) ? false : nodata !== value;
  }
  var FILTER_TYPES = new Set(Object.values(FilterType));
  function normalizeObjectKeys(el) {
    if (Array.isArray(el)) {
      return el.map((value) => normalizeObjectKeys(value));
    } else if (typeof el !== "object") {
      return el;
    }
    return Object.entries(el).reduce(
      (acc, [key, value]) => {
        acc[key.toLowerCase()] = typeof value === "object" && value ? normalizeObjectKeys(value) : value;
        return acc;
      },
      {}
    );
  }
  function assert22(condition, message) {
    if (!condition) {
      throw new Error(message);
    }
  }
  var _InvalidColumnError = class _InvalidColumnError2 extends Error {
    constructor(message) {
      super(`${_InvalidColumnError2.NAME}: ${message}`);
      this.name = _InvalidColumnError2.NAME;
    }
    static is(error) {
      return error instanceof _InvalidColumnError2 || error.message?.includes(_InvalidColumnError2.NAME);
    }
  };
  __publicField(_InvalidColumnError, "NAME", "InvalidColumnError");
  var InvalidColumnError = _InvalidColumnError;
  function isEmptyObject(object) {
    for (const _ in object) {
      return false;
    }
    return true;
  }
  var isObject2 = (x) => x !== null && typeof x === "object";
  var isPureObject = (x) => isObject2(x) && x.constructor === {}.constructor;
  function assignOptional(target, ...sources) {
    for (const source of sources) {
      for (const key in source) {
        if (source[key] !== void 0) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
  function getWidgetSpatialDataType(spatialDataType, spatialDataColumn, schema) {
    const field = schema.find((field2) => field2.name === spatialDataColumn);
    if (field && field.type === "geometry") {
      return "geo";
    }
    return spatialDataType;
  }
  function tileFeatures({
    tiles: tiles3,
    spatialFilter,
    uniqueIdProperty,
    tileFormat,
    spatialDataColumn = DEFAULT_GEO_COLUMN,
    spatialDataType,
    rasterMetadata,
    storeGeometry = false
  }) {
    if (spatialDataType === "geo") {
      return tileFeaturesGeometries({
        tiles: tiles3,
        tileFormat,
        spatialFilter,
        uniqueIdProperty,
        options: { storeGeometry }
      });
    }
    if (tiles3.some(isRasterTile)) {
      assert22(rasterMetadata, "Missing raster metadata");
      return tileFeaturesRaster({
        tiles: tiles3,
        spatialFilter,
        spatialDataColumn,
        spatialDataType,
        rasterMetadata
      });
    }
    return tileFeaturesSpatialIndex({
      tiles: tiles3,
      spatialFilter,
      spatialDataColumn,
      spatialDataType
    });
  }
  var CartoAPIError = class extends Error {
    constructor(error, errorContext, response, responseJson) {
      let responseString = "Failed to connect";
      if (response) {
        responseString = "Server returned: ";
        if (response.status === 400) {
          responseString += "Bad request";
        } else if (response.status === 401 || response.status === 403) {
          responseString += "Unauthorized access";
        } else if (response.status === 404) {
          responseString += "Not found";
        } else {
          responseString += "Error";
        }
        responseString += ` (${response.status}):`;
      }
      responseString += ` ${error.message || error}`;
      let message = `${errorContext.requestType} API request failed`;
      message += `
${responseString}`;
      for (const key of Object.keys(errorContext)) {
        if (key === "requestType")
          continue;
        message += `
${formatErrorKey(key)}: ${errorContext[key]}`;
      }
      message += "\n";
      super(message);
      __publicField(this, "error");
      __publicField(this, "errorContext");
      __publicField(this, "response");
      __publicField(this, "responseJson");
      this.name = "CartoAPIError";
      this.response = response;
      this.responseJson = responseJson;
      this.error = error;
      this.errorContext = errorContext;
    }
  };
  function formatErrorKey(key) {
    return key.replace(/([A-Z])/g, " $1").replace(/^./, (s) => s.toUpperCase());
  }
  function joinPath(...args) {
    return args.map((part) => part.endsWith("/") ? part.slice(0, -1) : part).join("/");
  }
  function buildV3Path(apiBaseUrl, version, endpoint, ...rest) {
    return joinPath(apiBaseUrl, version, endpoint, ...rest);
  }
  function buildPublicMapUrl({
    apiBaseUrl,
    cartoMapId
  }) {
    return buildV3Path(apiBaseUrl, "v3", "maps", "public", cartoMapId);
  }
  function buildStatsUrl({
    attribute,
    apiBaseUrl,
    connectionName,
    source,
    type
  }) {
    if (type === "query") {
      return buildV3Path(apiBaseUrl, "v3", "stats", connectionName, attribute);
    }
    return buildV3Path(
      apiBaseUrl,
      "v3",
      "stats",
      connectionName,
      source,
      attribute
    );
  }
  function buildSourceUrl({
    apiBaseUrl,
    connectionName,
    endpoint
  }) {
    return buildV3Path(apiBaseUrl, "v3", "maps", connectionName, endpoint);
  }
  function buildQueryUrl({
    apiBaseUrl,
    connectionName
  }) {
    return buildV3Path(apiBaseUrl, "v3", "sql", connectionName, "query");
  }
  var DEFAULT_HEADERS = {
    Accept: "application/json",
    "Content-Type": "application/json"
  };
  var DEFAULT_REQUEST_CACHE = /* @__PURE__ */ new Map();
  async function requestWithParameters({
    baseUrl,
    parameters = {},
    headers: customHeaders = {},
    errorContext,
    maxLengthURL = DEFAULT_MAX_LENGTH_URL,
    localCache,
    signal
  }) {
    parameters = {
      v: V3_MINOR_VERSION,
      client: getClient(),
      ...typeof deck !== "undefined" && deck.VERSION && { deckglVersion: deck.VERSION },
      ...parameters
    };
    baseUrl = excludeURLParameters(baseUrl, Object.keys(parameters));
    const key = createCacheKey(baseUrl, parameters, customHeaders);
    const {
      cache: REQUEST_CACHE,
      canReadCache,
      canStoreInCache
    } = getCacheSettings(localCache);
    if (canReadCache && REQUEST_CACHE.has(key)) {
      return REQUEST_CACHE.get(key);
    }
    const url = createURLWithParameters(baseUrl, parameters);
    const headers = { ...DEFAULT_HEADERS, ...customHeaders };
    const fetchPromise = url.length > maxLengthURL ? fetch(baseUrl, {
      method: "POST",
      body: JSON.stringify(parameters),
      headers,
      signal
    }) : fetch(url, { headers, signal });
    let response;
    let responseJson;
    const jsonPromise = fetchPromise.then((_response) => {
      response = _response;
      return response.json();
    }).then((json) => {
      responseJson = json;
      if (!response || !response.ok) {
        throw new Error(json.error);
      }
      return json;
    }).catch((error) => {
      if (canStoreInCache) {
        REQUEST_CACHE.delete(key);
      }
      throw new CartoAPIError(error, errorContext, response, responseJson);
    });
    if (canStoreInCache) {
      REQUEST_CACHE.set(key, jsonPromise);
    }
    return jsonPromise;
  }
  function getCacheSettings(localCache) {
    const canReadCache = localCache?.cacheControl?.includes("no-cache") ? false : true;
    const canStoreInCache = localCache?.cacheControl?.includes("no-store") ? false : true;
    const cache = localCache?.cache || DEFAULT_REQUEST_CACHE;
    return {
      cache,
      canReadCache,
      canStoreInCache
    };
  }
  function createCacheKey(baseUrl, parameters, headers) {
    const parameterEntries = Object.entries(parameters).sort(
      ([a], [b]) => a > b ? 1 : -1
    );
    const headerEntries = Object.entries(headers).sort(
      ([a], [b]) => a > b ? 1 : -1
    );
    return JSON.stringify({
      baseUrl,
      parameters: parameterEntries,
      headers: headerEntries
    });
  }
  function createURLWithParameters(baseUrlString, parameters) {
    const baseUrl = new URL(baseUrlString);
    for (const [key, value] of Object.entries(parameters)) {
      if (isPureObject(value) || Array.isArray(value)) {
        baseUrl.searchParams.set(key, JSON.stringify(value));
      } else {
        if (value !== null && value !== void 0) {
          baseUrl.searchParams.set(
            key,
            value.toString()
          );
        }
      }
    }
    return baseUrl.toString();
  }
  function excludeURLParameters(baseUrlString, parameters) {
    const baseUrl = new URL(baseUrlString);
    for (const param of parameters) {
      if (baseUrl.searchParams.has(param)) {
        baseUrl.searchParams.delete(param);
      }
    }
    return baseUrl.toString();
  }
  var SOURCE_DEFAULTS = {
    apiBaseUrl: DEFAULT_API_BASE_URL,
    headers: {},
    maxLengthURL: DEFAULT_MAX_LENGTH_URL
  };
  async function baseSource(endpoint, options, urlParameters) {
    const { accessToken, connectionName, cache, ...optionalOptions } = options;
    const mergedOptions = {
      ...SOURCE_DEFAULTS,
      clientId: getClient(),
      accessToken,
      connectionName,
      endpoint
    };
    for (const key in optionalOptions) {
      if (optionalOptions[key]) {
        mergedOptions[key] = optionalOptions[key];
      }
    }
    const baseUrl = buildSourceUrl(mergedOptions);
    const { clientId, maxLengthURL, localCache } = mergedOptions;
    const headers = {
      Authorization: `Bearer ${options.accessToken}`,
      ...options.headers
    };
    const parameters = { client: clientId, ...options.tags, ...urlParameters };
    const errorContext = {
      requestType: "Map instantiation",
      connection: options.connectionName,
      type: endpoint,
      source: JSON.stringify(parameters, void 0, 2)
    };
    const { tilejson, schema } = await requestWithParameters({
      baseUrl,
      parameters,
      headers,
      errorContext,
      maxLengthURL,
      localCache
    });
    const dataUrl = tilejson.url[0];
    if (cache) {
      cache.value = parseInt(
        new URL(dataUrl).searchParams.get("cache") || "",
        10
      );
    }
    errorContext.requestType = "Map data";
    const json = await requestWithParameters({
      baseUrl: dataUrl,
      parameters: { client: clientId },
      headers,
      errorContext,
      maxLengthURL,
      localCache
    });
    if (accessToken) {
      json.accessToken = accessToken;
    }
    if (schema) {
      json.schema = schema;
    }
    return json;
  }
  var boundaryQuerySource = async function(options) {
    const {
      columns,
      filters,
      tilesetTableName,
      propertiesSqlQuery,
      queryParameters
    } = options;
    const urlParameters = {
      tilesetTableName,
      propertiesSqlQuery
    };
    if (columns) {
      urlParameters.columns = columns.join(",");
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    if (queryParameters) {
      urlParameters.queryParameters = queryParameters;
    }
    return baseSource("boundary", options, urlParameters);
  };
  var boundaryTableSource = async function(options) {
    const { filters, tilesetTableName, columns, propertiesTableName } = options;
    const urlParameters = {
      tilesetTableName,
      propertiesTableName
    };
    if (columns) {
      urlParameters.columns = columns.join(",");
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return baseSource("boundary", options, urlParameters);
  };
  var _WidgetSource = class _WidgetSource2 {
    constructor(props) {
      __publicField(this, "props");
      this.props = {
        ..._WidgetSource2.defaultProps,
        clientId: getClient(),
        // Refresh clientId, default may have changed.
        ...props
      };
    }
    /**
     * Destroys the widget source and releases allocated resources.
     *
     * For remote sources (tables, queries) this has no effect, but for local
     * sources (tilesets, rasters) these resources will affect performance
     * and stability if many (10+) sources are created and not released.
     */
    destroy() {
    }
  };
  __publicField(_WidgetSource, "defaultProps", {
    apiVersion: "v3",
    apiBaseUrl: DEFAULT_API_BASE_URL,
    clientId: getClient(),
    filters: {},
    filtersLogicalOperator: "and"
  });
  var WidgetSource = _WidgetSource;
  function dealWithApiError({
    response,
    data
  }) {
    if (data.error === "Column not found") {
      throw new InvalidColumnError(`${data.error} ${data.column_name}`);
    }
    if (typeof data.error === "string" && data.error?.includes("Missing columns")) {
      throw new InvalidColumnError(data.error);
    }
    switch (response.status) {
      case 401:
        throw new Error("Unauthorized access. Invalid credentials");
      case 403:
        throw new Error("Forbidden access to the requested data");
      default:
        throw new Error(
          data && data.error && typeof data.error === "string" ? data.error : JSON.stringify(data?.hint || data.error?.[0])
        );
    }
  }
  async function makeCall({
    url,
    accessToken,
    opts
  }) {
    let response;
    let data;
    const isPost = opts?.method === "POST";
    try {
      response = await fetch(url.toString(), {
        headers: {
          Authorization: `Bearer ${accessToken}`,
          ...isPost && { "Content-Type": "application/json" },
          ...opts.headers
        },
        ...isPost && {
          method: opts?.method,
          body: opts?.body
        },
        signal: opts?.signal,
        ...opts?.otherOptions
      });
      data = await response.json();
    } catch (error) {
      if (error.name === "AbortError")
        throw error;
      throw new Error(`Failed request: ${error}`);
    }
    if (!response.ok) {
      dealWithApiError({ response, data });
    }
    return data;
  }
  var AVAILABLE_MODELS = [
    "category",
    "histogram",
    "formula",
    "pick",
    "timeseries",
    "range",
    "scatterplot",
    "table",
    "aggregations"
  ];
  var { V3 } = ApiVersion;
  var REQUEST_GET_MAX_URL_LENGTH = 2048;
  function executeModel(props) {
    assert22(props.source, "executeModel: missing source");
    assert22(props.model, "executeModel: missing model");
    assert22(props.params, "executeModel: missing params");
    assert22(
      AVAILABLE_MODELS.includes(props.model),
      `executeModel: model provided isn't valid. Available models: ${AVAILABLE_MODELS.join(
        ", "
      )}`
    );
    const { model, source, params, opts } = props;
    const { type, apiVersion, apiBaseUrl, accessToken, connectionName, clientId } = source;
    assert22(apiBaseUrl, "executeModel: missing apiBaseUrl");
    assert22(accessToken, "executeModel: missing accessToken");
    assert22(apiVersion === V3, "executeModel: SQL Model API requires CARTO 3+");
    assert22(type !== "tileset", "executeModel: Tilesets not supported");
    let url = `${apiBaseUrl}/v3/sql/${connectionName}/model/${model}`;
    const {
      data,
      filters,
      filtersLogicalOperator = "and",
      spatialDataType = "geo",
      spatialDataColumn = DEFAULT_GEO_COLUMN,
      spatialFiltersMode = "intersects",
      tags
    } = source;
    const queryParams = {
      type,
      client: clientId,
      source: data,
      params,
      queryParameters: source.queryParameters || "",
      filters,
      filtersLogicalOperator,
      ...tags ?? {}
    };
    queryParams.spatialDataType = spatialDataType;
    queryParams.spatialDataColumn = spatialDataColumn;
    if (source.spatialFilter) {
      queryParams.spatialFilters = { [spatialDataColumn]: source.spatialFilter };
      if (spatialDataType !== "geo") {
        queryParams.spatialFiltersMode = spatialFiltersMode;
      }
    }
    const urlWithSearchParams = url + "?" + objectToURLSearchParams(queryParams).toString();
    const isGet = urlWithSearchParams.length <= REQUEST_GET_MAX_URL_LENGTH;
    if (isGet) {
      url = urlWithSearchParams;
    }
    return makeCall({
      url,
      accessToken: source.accessToken,
      opts: {
        ...opts,
        method: isGet ? "GET" : "POST",
        ...!isGet && { body: JSON.stringify(queryParams) }
      }
    });
  }
  function objectToURLSearchParams(object) {
    const params = new URLSearchParams();
    for (const key in object) {
      if (isPureObject(object[key])) {
        params.append(key, JSON.stringify(object[key]));
      } else if (Array.isArray(object[key])) {
        params.append(key, JSON.stringify(object[key]));
      } else if (object[key] === null) {
        params.append(key, "null");
      } else if (object[key] !== void 0) {
        params.append(key, String(object[key]));
      }
    }
    return params;
  }
  var FILTER_TYPES2 = new Set(Object.values(FilterType));
  var isFilterType = (type) => FILTER_TYPES2.has(type);
  function getApplicableFilters(owner, filters) {
    if (!filters)
      return {};
    const applicableFilters = {};
    for (const column in filters) {
      for (const type in filters[column]) {
        if (!isFilterType(type))
          continue;
        const filter = filters[column][type];
        const isApplicable = !owner || !filter?.owner || filter?.owner !== owner;
        if (filter && isApplicable) {
          applicableFilters[column] || (applicableFilters[column] = {});
          applicableFilters[column][type] = filter;
        }
      }
    }
    return applicableFilters;
  }
  var OTHERS_CATEGORY_NAME = "_carto_others";
  var WidgetRemoteSource = class extends WidgetSource {
    _getModelSource(filters, filterOwner) {
      const props = this.props;
      return {
        apiVersion: props.apiVersion,
        apiBaseUrl: props.apiBaseUrl,
        clientId: props.clientId,
        accessToken: props.accessToken,
        connectionName: props.connectionName,
        filters: getApplicableFilters(filterOwner, filters || props.filters),
        filtersLogicalOperator: props.filtersLogicalOperator,
        spatialDataType: props.spatialDataType,
        spatialDataColumn: props.spatialDataColumn,
        tags: props.tags
      };
    }
    async getCategories(options) {
      const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        rawResult,
        ...params
      } = options;
      const {
        column,
        operation: operation2,
        operationColumn,
        operationExp,
        othersThreshold,
        orderBy
      } = params;
      if (operation2 === AggregationTypes.Custom) {
        assert22(operationExp, "operationExp is required for custom operation");
      }
      const result = await executeModel({
        model: "category",
        source: {
          ...this.getModelSource(filters, filterOwner),
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column,
          operation: operation2,
          operationExp,
          operationColumn: operationColumn || column,
          othersThreshold,
          orderBy
        },
        opts: { signal, headers: this.props.headers }
      });
      const normalizedRows = normalizeObjectKeys(result.rows || []);
      if (rawResult) {
        return result;
      }
      if (!othersThreshold) {
        return normalizedRows;
      }
      return [
        ...normalizedRows,
        { name: OTHERS_CATEGORY_NAME, value: result?.metadata?.others }
      ];
    }
    async getFeatures(options) {
      const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        ...params
      } = options;
      const { columns, dataType, featureIds, z, limit, tileResolution } = params;
      return executeModel({
        model: "pick",
        source: {
          ...this.getModelSource(filters, filterOwner),
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          columns,
          dataType,
          featureIds,
          z,
          limit: limit || 1e3,
          tileResolution: tileResolution || DEFAULT_TILE_RESOLUTION
        },
        opts: { signal, headers: this.props.headers }
        // Avoid `normalizeObjectKeys()`, which changes column names.
      }).then(({ rows }) => ({ rows }));
    }
    async getFormula(options) {
      const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        operationExp,
        ...params
      } = options;
      const { column, operation: operation2 } = params;
      if (operation2 === AggregationTypes.Custom) {
        assert22(operationExp, "operationExp is required for custom operation");
      }
      return executeModel({
        model: "formula",
        source: {
          ...this.getModelSource(filters, filterOwner),
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column: column ?? "*",
          operation: operation2 ?? AggregationTypes.Count,
          operationExp
        },
        opts: { signal, headers: this.props.headers }
      }).then((res) => normalizeObjectKeys(res.rows[0]));
    }
    async getHistogram(options) {
      const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        ...params
      } = options;
      const { column, operation: operation2, ticks: ticks2 } = params;
      const data = await executeModel({
        model: "histogram",
        source: {
          ...this.getModelSource(filters, filterOwner),
          spatialFiltersMode,
          spatialFilter
        },
        params: { column, operation: operation2, ticks: ticks2 },
        opts: { signal, headers: this.props.headers }
      }).then((res) => normalizeObjectKeys(res.rows));
      if (data.length) {
        const result = Array(ticks2.length + 1).fill(0);
        data.forEach(
          ({ tick, value }) => result[tick] = value
        );
        return result;
      }
      return [];
    }
    async getRange(options) {
      const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        ...params
      } = options;
      const { column } = params;
      return executeModel({
        model: "range",
        source: {
          ...this.getModelSource(filters, filterOwner),
          spatialFiltersMode,
          spatialFilter
        },
        params: { column },
        opts: { signal, headers: this.props.headers }
      }).then((res) => normalizeObjectKeys(res.rows[0]));
    }
    async getScatter(options) {
      const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        ...params
      } = options;
      const { xAxisColumn, xAxisJoinOperation, yAxisColumn, yAxisJoinOperation } = params;
      const HARD_LIMIT = 500;
      return executeModel({
        model: "scatterplot",
        source: {
          ...this.getModelSource(filters, filterOwner),
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          xAxisColumn,
          xAxisJoinOperation,
          yAxisColumn,
          yAxisJoinOperation,
          limit: HARD_LIMIT
        },
        opts: { signal, headers: this.props.headers }
      }).then((res) => normalizeObjectKeys(res.rows)).then((res) => res.map(({ x, y }) => [x, y]));
    }
    async getTable(options) {
      const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        ...params
      } = options;
      const { columns, sortBy, sortDirection, offset = 0, limit = 10 } = params;
      return executeModel({
        model: "table",
        source: {
          ...this.getModelSource(filters, filterOwner),
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column: columns,
          sortBy,
          sortDirection,
          limit,
          offset
        },
        opts: { signal, headers: this.props.headers }
      }).then((res) => ({
        // Avoid `normalizeObjectKeys()`, which changes column names.
        rows: res.rows ?? res.ROWS,
        totalCount: res.metadata?.total ?? res.METADATA?.TOTAL
      }));
    }
    async getTimeSeries(options) {
      const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        ...params
      } = options;
      const {
        column,
        operationColumn,
        joinOperation,
        operation: operation2,
        operationExp,
        stepSize,
        stepMultiplier,
        splitByCategory,
        splitByCategoryLimit,
        splitByCategoryValues
      } = params;
      if (operation2 === AggregationTypes.Custom) {
        assert22(operationExp, "operationExp is required for custom operation");
      }
      return executeModel({
        model: "timeseries",
        source: {
          ...this.getModelSource(filters, filterOwner),
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          column,
          stepSize,
          stepMultiplier,
          operationColumn: operationColumn || column,
          joinOperation,
          operation: operation2,
          operationExp,
          splitByCategory,
          splitByCategoryLimit,
          splitByCategoryValues
        },
        opts: { signal, headers: this.props.headers }
      }).then((res) => ({
        rows: normalizeObjectKeys(res.rows),
        categories: res.metadata?.categories
      }));
    }
    async getAggregations(options) {
      const {
        signal,
        filters = this.props.filters,
        filterOwner,
        spatialFilter,
        spatialFiltersMode,
        aggregations
      } = options;
      return executeModel({
        model: "aggregations",
        source: {
          ...this.getModelSource(filters, filterOwner),
          spatialFiltersMode,
          spatialFilter
        },
        params: {
          aggregations
        },
        opts: { signal, headers: this.props.headers }
      }).then((res) => ({
        rows: res.rows.map((row) => normalizeObjectKeys(row))
      }));
    }
    /** @experimental */
    async getExtent(options = {}) {
      const { signal, filters = this.props.filters, filterOwner } = options;
      const {
        type,
        data,
        apiBaseUrl,
        apiVersion,
        connectionName,
        spatialDataColumn,
        spatialDataType,
        queryParameters
      } = this.getModelSource(filters, filterOwner);
      assert22(apiVersion === "v3", "Stats API requires CARTO 3+");
      let url;
      const parameters = { filters, spatialDataType };
      if (type === "query") {
        url = `${apiBaseUrl}/${apiVersion}/stats/${connectionName}/${spatialDataColumn}`;
        parameters.q = data;
        parameters.queryParameters = queryParameters;
      } else {
        url = `${apiBaseUrl}/${apiVersion}/stats/${connectionName}/${data}/${spatialDataColumn}`;
      }
      const headers = {
        Authorization: `Bearer ${this.props.accessToken}`,
        ...this.props.headers
      };
      const errorContext = {
        requestType: "Tile stats",
        connection: connectionName,
        type
      };
      return requestWithParameters({
        baseUrl: url,
        headers,
        signal,
        errorContext,
        parameters
      }).then(({ extent: { xmin, ymin, xmax, ymax } }) => ({
        bbox: [xmin, ymin, xmax, ymax]
      }));
    }
  };
  var WidgetQuerySource = class extends WidgetRemoteSource {
    getModelSource(filters, filterOwner) {
      return {
        ...super._getModelSource(filters, filterOwner),
        type: "query",
        data: this.props.sqlQuery,
        queryParameters: this.props.queryParameters
      };
    }
  };
  var aggregationFunctions = {
    count: (values) => values.length,
    min: (...args) => applyAggregationFunction(min, ...args),
    max: (...args) => applyAggregationFunction(max, ...args),
    sum: (...args) => applyAggregationFunction(sum2, ...args),
    avg: (...args) => applyAggregationFunction(avg, ...args)
  };
  function aggregate(feature2, keys, operation2) {
    if (!keys?.length) {
      throw new Error("Cannot aggregate a feature without having keys");
    } else if (keys.length === 1) {
      const value = feature2[keys[0]];
      return isPotentiallyValidNumber(value) ? Number(value) : value;
    }
    const aggregationFn = aggregationFunctions[operation2];
    if (!aggregationFn) {
      throw new Error(`${operation2} isn't a valid aggregation function`);
    }
    return aggregationFn(
      keys.map((column) => {
        const value = feature2[column];
        return isPotentiallyValidNumber(value) ? Number(value) : value;
      })
    );
  }
  function isPotentiallyValidNumber(value) {
    return typeof value === "string" && value.trim().length > 0;
  }
  var applyAggregationFunction = (aggFn, values, keys, operation2) => {
    const normalizedKeys = normalizeKeys(keys);
    const elements = (normalizedKeys?.length || 0) <= 1 ? filterFalsyElements(values, normalizedKeys || []) : values;
    return aggFn(elements, keys, operation2);
  };
  function filterFalsyElements(values, keys) {
    const filterFn = (value) => value !== null && value !== void 0;
    if (!keys?.length) {
      return values.filter(filterFn);
    }
    return values.filter((v2) => filterFn(v2[keys[0]]));
  }
  function avg(values, keys, joinOperation) {
    return sum2(values, keys, joinOperation) / (values.length || 1);
  }
  function sum2(values, keys, joinOperation) {
    const normalizedKeys = normalizeKeys(keys);
    if (normalizedKeys) {
      return values.reduce(
        (a, b) => a + aggregate(b, normalizedKeys, joinOperation),
        0
      );
    }
    return values.reduce((a, b) => a + b, 0);
  }
  function min(values, keys, joinOperation) {
    const normalizedKeys = normalizeKeys(keys);
    if (normalizedKeys) {
      return values.reduce(
        (a, b) => Math.min(a, aggregate(b, normalizedKeys, joinOperation)),
        Infinity
      );
    }
    let min2 = Number.POSITIVE_INFINITY;
    for (const value of values) {
      min2 = Math.min(min2, value);
    }
    return min2;
  }
  function max(values, keys, joinOperation) {
    const normalizedKeys = normalizeKeys(keys);
    if (normalizedKeys) {
      return values.reduce(
        (a, b) => Math.max(a, aggregate(b, normalizedKeys, joinOperation)),
        -Infinity
      );
    }
    let max2 = Number.NEGATIVE_INFINITY;
    for (const value of values) {
      max2 = Math.max(max2, value);
    }
    return max2;
  }
  function normalizeKeys(keys) {
    return Array.isArray(keys) ? keys : typeof keys === "string" ? [keys] : void 0;
  }
  var import_thenby = __toESM2(require_thenBy_module(), 1);
  function applySorting(features, {
    sortBy,
    sortByDirection = "asc",
    sortByColumnType = "string"
  } = {}) {
    if (sortBy === void 0) {
      return features;
    }
    const isValidSortBy = Array.isArray(sortBy) && sortBy.length || // sortBy can be an array of columns
    typeof sortBy === "string";
    if (!isValidSortBy) {
      throw new Error("Sorting options are bad formatted");
    }
    const sortFn = createSortFn({
      sortBy,
      sortByDirection,
      sortByColumnType: sortByColumnType || "string"
    });
    return features.sort(sortFn);
  }
  function createSortFn({
    sortBy,
    sortByDirection,
    sortByColumnType
  }) {
    const [firstSortOption, ...othersSortOptions] = normalizeSortByOptions({
      sortBy,
      sortByDirection,
      sortByColumnType
    });
    let sortFn = (0, import_thenby.firstBy)(...firstSortOption);
    for (const sortOptions of othersSortOptions) {
      sortFn = sortFn.thenBy(...sortOptions);
    }
    return sortFn;
  }
  function normalizeSortByOptions({
    sortBy,
    sortByDirection,
    sortByColumnType
  }) {
    const numberFormat = sortByColumnType === "number" && {
      cmp: (a, b) => a - b
    };
    if (!Array.isArray(sortBy)) {
      sortBy = [sortBy];
    }
    return sortBy.map((sortByEl) => {
      if (typeof sortByEl === "string") {
        return [sortByEl, { direction: sortByDirection, ...numberFormat }];
      }
      if (Array.isArray(sortByEl)) {
        if (sortByEl[1] === void 0) {
          return [sortByEl, { direction: sortByDirection, ...numberFormat }];
        }
        if (typeof sortByEl[1] === "object") {
          const othersSortOptions = numberFormat ? { ...numberFormat, ...sortByEl[1] } : sortByEl[1];
          return [
            sortByEl[0],
            { direction: sortByDirection, ...othersSortOptions }
          ];
        }
      }
      return sortByEl;
    });
  }
  function groupValuesByColumn({
    data,
    valuesColumns,
    joinOperation,
    keysColumn,
    operation: operation2,
    othersThreshold,
    orderBy = "frequency_desc"
  }) {
    if (Array.isArray(data) && data.length === 0) {
      return { rows: null };
    }
    const groups = data.reduce((accumulator, item) => {
      const group2 = item[keysColumn];
      const values = accumulator.get(group2) || [];
      accumulator.set(group2, values);
      const aggregatedValue = aggregate(item, valuesColumns, joinOperation);
      const isValid = (operation2 === "count" ? true : aggregatedValue !== null) && aggregatedValue !== void 0;
      if (isValid) {
        values.push(aggregatedValue);
        accumulator.set(group2, values);
      }
      return accumulator;
    }, /* @__PURE__ */ new Map());
    const targetOperation = aggregationFunctions[operation2];
    if (!targetOperation) {
      return { rows: [] };
    }
    const allCategories = Array.from(groups).map(([name, value]) => ({
      name,
      value: targetOperation(value)
    })).sort(getSorter(orderBy));
    if (othersThreshold && allCategories.length > othersThreshold) {
      const otherValue = allCategories.slice(othersThreshold).flatMap(({ name }) => groups.get(name));
      return {
        rows: allCategories,
        metadata: {
          others: targetOperation(otherValue)
        }
      };
    }
    return {
      rows: allCategories
    };
  }
  function getSorter(orderBy) {
    switch (orderBy) {
      case "frequency_asc":
        return (a, b) => a.value - b.value || nameCompare(a.name, b.name);
      case "frequency_desc":
        return (a, b) => b.value - a.value || nameCompare(a.name, b.name);
      case "alphabetical_asc":
        return (a, b) => nameCompare(a.name, b.name) || b.value - a.value;
      case "alphabetical_desc":
        return (a, b) => nameCompare(b.name, a.name) || b.value - a.value;
    }
  }
  function nameCompare(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      return a - b;
    }
    return String(a ?? "null").localeCompare(String(b ?? "null"));
  }
  function getUTCMonday(date) {
    const dateCp = new Date(date);
    const day = dateCp.getUTCDay();
    const diff = dateCp.getUTCDate() - day + (day ? 1 : -6);
    dateCp.setUTCDate(diff);
    return Date.UTC(
      dateCp.getUTCFullYear(),
      dateCp.getUTCMonth(),
      dateCp.getUTCDate()
    );
  }
  var GROUP_KEY_FN_MAPPING = {
    year: (date) => Date.UTC(date.getUTCFullYear()),
    month: (date) => Date.UTC(date.getUTCFullYear(), date.getUTCMonth()),
    week: (date) => getUTCMonday(date),
    day: (date) => Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()),
    hour: (date) => Date.UTC(
      date.getUTCFullYear(),
      date.getUTCMonth(),
      date.getUTCDate(),
      date.getUTCHours()
    ),
    minute: (date) => Date.UTC(
      date.getUTCFullYear(),
      date.getUTCMonth(),
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes()
    ),
    second: (date) => Date.UTC(
      date.getUTCFullYear(),
      date.getUTCMonth(),
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds()
    )
  };
  function groupValuesByDateColumn({
    data,
    valuesColumns,
    joinOperation,
    keysColumn,
    groupType,
    operation: operation2
  }) {
    if (Array.isArray(data) && data.length === 0) {
      return null;
    }
    const groupKeyFn = GROUP_KEY_FN_MAPPING[groupType];
    if (!groupKeyFn) {
      return null;
    }
    const groups = data.reduce((acc, item) => {
      const value = item[keysColumn];
      const formattedValue = new Date(value);
      const groupKey = groupKeyFn(formattedValue);
      if (!isNaN(groupKey)) {
        let groupedValues = acc.get(groupKey);
        if (!groupedValues) {
          groupedValues = [];
          acc.set(groupKey, groupedValues);
        }
        const aggregatedValue = aggregate(item, valuesColumns, joinOperation);
        const isValid = aggregatedValue !== null && aggregatedValue !== void 0;
        if (isValid) {
          groupedValues.push(aggregatedValue);
          acc.set(groupKey, groupedValues);
        }
      }
      return acc;
    }, /* @__PURE__ */ new Map());
    const targetOperation = aggregationFunctions[operation2];
    return [...groups.entries()].map(([name, value]) => ({
      name,
      value: targetOperation(value)
    })).sort((a, b) => a.name - b.name);
  }
  function histogram({
    data,
    valuesColumns,
    joinOperation,
    ticks: ticks2,
    operation: operation2
  }) {
    if (Array.isArray(data) && data.length === 0) {
      return [];
    }
    const binsContainer = [Number.MIN_SAFE_INTEGER, ...ticks2].map(
      (tick, index2, arr) => ({
        bin: index2,
        start: tick,
        end: index2 === arr.length - 1 ? Number.MAX_SAFE_INTEGER : arr[index2 + 1],
        values: []
      })
    );
    data.forEach((feature2) => {
      const featureValue = aggregate(
        feature2,
        valuesColumns,
        joinOperation
      );
      const isValid = featureValue !== null && featureValue !== void 0;
      if (!isValid) {
        return;
      }
      const binContainer = binsContainer.find(
        (bin) => bin.start <= featureValue && bin.end > featureValue
      );
      if (!binContainer) {
        return;
      }
      binContainer.values.push(featureValue);
    });
    const targetOperation = aggregationFunctions[operation2];
    const transformedBins = binsContainer.map(
      (binContainer) => binContainer.values
    );
    return transformedBins.map(
      (values) => values.length ? targetOperation(values) : 0
    );
  }
  function scatterPlot({
    data,
    xAxisColumns,
    xAxisJoinOperation,
    yAxisColumns,
    yAxisJoinOperation
  }) {
    return data.reduce(
      (acc, feature2) => {
        const xValue = aggregate(
          feature2,
          xAxisColumns,
          xAxisJoinOperation
        );
        const xIsValid = xValue !== null && xValue !== void 0;
        const yValue = aggregate(
          feature2,
          yAxisColumns,
          yAxisJoinOperation
        );
        const yIsValid = yValue !== null && yValue !== void 0;
        if (xIsValid && yIsValid) {
          acc.push([xValue, yValue]);
        }
        return acc;
      },
      []
    );
  }
  var __defProp22 = Object.defineProperty;
  var __name = (target, value) => __defProp22(target, "name", { value, configurable: true });
  var _GeojsonEquality = class _GeojsonEquality2 {
    constructor(opts) {
      this.direction = false;
      this.compareProperties = true;
      var _a2, _b2, _c;
      this.precision = 10 ** -((_a2 = opts == null ? void 0 : opts.precision) != null ? _a2 : 17);
      this.direction = (_b2 = opts == null ? void 0 : opts.direction) != null ? _b2 : false;
      this.compareProperties = (_c = opts == null ? void 0 : opts.compareProperties) != null ? _c : true;
    }
    compare(g1, g2) {
      if (g1.type !== g2.type) {
        return false;
      }
      if (!sameLength(g1, g2)) {
        return false;
      }
      switch (g1.type) {
        case "Point":
          return this.compareCoord(g1.coordinates, g2.coordinates);
        case "LineString":
          return this.compareLine(g1.coordinates, g2.coordinates);
        case "Polygon":
          return this.comparePolygon(g1, g2);
        case "GeometryCollection":
          return this.compareGeometryCollection(g1, g2);
        case "Feature":
          return this.compareFeature(g1, g2);
        case "FeatureCollection":
          return this.compareFeatureCollection(g1, g2);
        default:
          if (g1.type.startsWith("Multi")) {
            const g1s = explode(g1);
            const g2s = explode(
              g2
            );
            return g1s.every(
              (g1part) => g2s.some((g2part) => this.compare(g1part, g2part))
            );
          }
      }
      return false;
    }
    compareCoord(c1, c2) {
      return c1.length === c2.length && c1.every((c, i) => Math.abs(c - c2[i]) < this.precision);
    }
    compareLine(path1, path2, ind = 0, isPoly = false) {
      if (!sameLength(path1, path2)) {
        return false;
      }
      const p1 = path1;
      let p2 = path2;
      if (isPoly && !this.compareCoord(p1[0], p2[0])) {
        const startIndex = this.fixStartIndex(p2, p1);
        if (!startIndex) {
          return false;
        } else {
          p2 = startIndex;
        }
      }
      const sameDirection = this.compareCoord(p1[ind], p2[ind]);
      if (this.direction || sameDirection) {
        return this.comparePath(p1, p2);
      } else {
        if (this.compareCoord(p1[ind], p2[p2.length - (1 + ind)])) {
          return this.comparePath(p1.slice().reverse(), p2);
        }
        return false;
      }
    }
    fixStartIndex(sourcePath, targetPath) {
      let correctPath, ind = -1;
      for (let i = 0; i < sourcePath.length; i++) {
        if (this.compareCoord(sourcePath[i], targetPath[0])) {
          ind = i;
          break;
        }
      }
      if (ind >= 0) {
        correctPath = [].concat(
          sourcePath.slice(ind, sourcePath.length),
          sourcePath.slice(1, ind + 1)
        );
      }
      return correctPath;
    }
    comparePath(p1, p2) {
      return p1.every((c, i) => this.compareCoord(c, p2[i]));
    }
    comparePolygon(g1, g2) {
      if (this.compareLine(g1.coordinates[0], g2.coordinates[0], 1, true)) {
        const holes1 = g1.coordinates.slice(1, g1.coordinates.length);
        const holes2 = g2.coordinates.slice(1, g2.coordinates.length);
        return holes1.every(
          (h1) => holes2.some((h2) => this.compareLine(h1, h2, 1, true))
        );
      }
      return false;
    }
    compareGeometryCollection(g1, g2) {
      return sameLength(g1.geometries, g2.geometries) && this.compareBBox(g1, g2) && g1.geometries.every((g, i) => this.compare(g, g2.geometries[i]));
    }
    compareFeature(g1, g2) {
      return g1.id === g2.id && (this.compareProperties ? equal(g1.properties, g2.properties) : true) && this.compareBBox(g1, g2) && this.compare(g1.geometry, g2.geometry);
    }
    compareFeatureCollection(g1, g2) {
      return sameLength(g1.features, g2.features) && this.compareBBox(g1, g2) && g1.features.every((f, i) => this.compare(f, g2.features[i]));
    }
    compareBBox(g1, g2) {
      return Boolean(!g1.bbox && !g2.bbox) || (g1.bbox && g2.bbox ? this.compareCoord(g1.bbox, g2.bbox) : false);
    }
  };
  __name(_GeojsonEquality, "GeojsonEquality");
  var GeojsonEquality = _GeojsonEquality;
  function sameLength(g1, g2) {
    return g1.coordinates ? g1.coordinates.length === g2.coordinates.length : g1.length === g2.length;
  }
  __name(sameLength, "sameLength");
  function explode(g) {
    return g.coordinates.map((part) => ({
      type: g.type.replace("Multi", ""),
      coordinates: part
    }));
  }
  __name(explode, "explode");
  function geojsonEquality(g1, g2, opts) {
    const eq = new GeojsonEquality(opts);
    return eq.compare(g1, g2);
  }
  __name(geojsonEquality, "geojsonEquality");
  function equal(object1, object2) {
    if (object1 === null && object2 === null) {
      return true;
    }
    if (object1 === null || object2 === null) {
      return false;
    }
    const objKeys1 = Object.keys(object1);
    const objKeys2 = Object.keys(object2);
    if (objKeys1.length !== objKeys2.length)
      return false;
    for (var key of objKeys1) {
      const value1 = object1[key];
      const value2 = object2[key];
      const isObjects = isObject3(value1) && isObject3(value2);
      if (isObjects && !equal(value1, value2) || !isObjects && value1 !== value2) {
        return false;
      }
    }
    return true;
  }
  __name(equal, "equal");
  var isObject3 = /* @__PURE__ */ __name((object) => {
    return object != null && typeof object === "object";
  }, "isObject");
  function cleanCoords(geojson, options = {}) {
    var mutate = typeof options === "object" ? options.mutate : options;
    if (!geojson)
      throw new Error("geojson is required");
    var type = getType(geojson);
    var newCoords = [];
    switch (type) {
      case "LineString":
        newCoords = cleanLine(geojson, type);
        break;
      case "MultiLineString":
      case "Polygon":
        getCoords(geojson).forEach(function(line) {
          newCoords.push(cleanLine(line, type));
        });
        break;
      case "MultiPolygon":
        getCoords(geojson).forEach(function(polygons) {
          var polyPoints = [];
          polygons.forEach(function(ring) {
            polyPoints.push(cleanLine(ring, type));
          });
          newCoords.push(polyPoints);
        });
        break;
      case "Point":
        return geojson;
      case "MultiPoint":
        var existing = {};
        getCoords(geojson).forEach(function(coord) {
          var key = coord.join("-");
          if (!Object.prototype.hasOwnProperty.call(existing, key)) {
            newCoords.push(coord);
            existing[key] = true;
          }
        });
        break;
      default:
        throw new Error(type + " geometry not supported");
    }
    if (geojson.coordinates) {
      if (mutate === true) {
        geojson.coordinates = newCoords;
        return geojson;
      }
      return { type, coordinates: newCoords };
    } else {
      if (mutate === true) {
        geojson.geometry.coordinates = newCoords;
        return geojson;
      }
      return feature({ type, coordinates: newCoords }, geojson.properties, {
        bbox: geojson.bbox,
        id: geojson.id
      });
    }
  }
  function cleanLine(line, type) {
    var points = getCoords(line);
    if (points.length === 2 && !equals2(points[0], points[1]))
      return points;
    var newPoints = [];
    var secondToLast = points.length - 1;
    var newPointsLength = newPoints.length;
    newPoints.push(points[0]);
    for (var i = 1; i < secondToLast; i++) {
      var prevAddedPoint = newPoints[newPoints.length - 1];
      if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1])
        continue;
      else {
        newPoints.push(points[i]);
        newPointsLength = newPoints.length;
        if (newPointsLength > 2) {
          if (isPointOnLineSegment3(
            newPoints[newPointsLength - 3],
            newPoints[newPointsLength - 1],
            newPoints[newPointsLength - 2]
          ))
            newPoints.splice(newPoints.length - 2, 1);
        }
      }
    }
    newPoints.push(points[points.length - 1]);
    newPointsLength = newPoints.length;
    if ((type === "Polygon" || type === "MultiPolygon") && equals2(points[0], points[points.length - 1]) && newPointsLength < 4) {
      throw new Error("invalid polygon");
    }
    if (type === "LineString" && newPointsLength < 3) {
      return newPoints;
    }
    if (isPointOnLineSegment3(
      newPoints[newPointsLength - 3],
      newPoints[newPointsLength - 1],
      newPoints[newPointsLength - 2]
    ))
      newPoints.splice(newPoints.length - 2, 1);
    return newPoints;
  }
  function equals2(pt1, pt2) {
    return pt1[0] === pt2[0] && pt1[1] === pt2[1];
  }
  function isPointOnLineSegment3(start, end, point22) {
    var x = point22[0], y = point22[1];
    var startX = start[0], startY = start[1];
    var endX = end[0], endY = end[1];
    var dxc = x - startX;
    var dyc = y - startY;
    var dxl = endX - startX;
    var dyl = endY - startY;
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0)
      return false;
    else if (Math.abs(dxl) >= Math.abs(dyl))
      return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;
    else
      return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;
  }
  function booleanEqual(feature1, feature2, options = {}) {
    let precision2 = options.precision;
    precision2 = precision2 === void 0 || precision2 === null || isNaN(precision2) ? 6 : precision2;
    if (typeof precision2 !== "number" || !(precision2 >= 0)) {
      throw new Error("precision must be a positive number");
    }
    const type1 = getGeom(feature1).type;
    const type2 = getGeom(feature2).type;
    if (type1 !== type2)
      return false;
    return geojsonEquality(cleanCoords(feature1), cleanCoords(feature2), {
      precision: precision2
    });
  }
  var WidgetTilesetSourceImpl = class extends WidgetSource {
    constructor() {
      super(...arguments);
      __publicField(this, "_tiles", []);
      __publicField(this, "_features", []);
      __publicField(this, "_tileFeatureExtractOptions", {});
      __publicField(this, "_tileFeatureExtractPreviousInputs", {});
    }
    /**
     * Loads features as a list of tiles (typically provided by deck.gl).
     * After tiles are loaded, {@link extractTileFeatures} must be called
     * before computing statistics on the tiles.
     */
    loadTiles(tiles3) {
      this._tiles = tiles3;
      this._features.length = 0;
    }
    /** Configures options used to extract features from tiles. */
    setTileFeatureExtractOptions(options) {
      this._tileFeatureExtractOptions = options;
      this._features.length = 0;
    }
    _extractTileFeatures(spatialFilter) {
      const prevInputs = this._tileFeatureExtractPreviousInputs;
      if (this._features.length && spatialFilterEquals(prevInputs.spatialFilter, spatialFilter)) {
        return;
      }
      this._features = tileFeatures({
        ...assignOptional({}, this.props, this._tileFeatureExtractOptions),
        tiles: this._tiles,
        spatialFilter
      });
      prevInputs.spatialFilter = spatialFilter;
    }
    /**
     * Loads features as GeoJSON (used for testing).
     * @experimental
     * @internal Not for public use. Spatial filters in other method calls will be ignored.
     */
    loadGeoJSON({
      geojson,
      spatialFilter
    }) {
      this._features = geojsonFeatures({
        geojson,
        spatialFilter,
        ...this._tileFeatureExtractOptions
      });
      this._tileFeatureExtractPreviousInputs.spatialFilter = spatialFilter;
    }
    async getFeatures() {
      throw new Error("getFeatures not supported for tilesets");
    }
    async getFormula({
      column = "*",
      operation: operation2 = AggregationTypes.Count,
      joinOperation,
      filters,
      filterOwner,
      spatialFilter
    }) {
      const filteredFeatures = this._getFilteredFeatures(
        spatialFilter,
        filters,
        filterOwner
      );
      if (filteredFeatures.length === 0 && operation2 !== AggregationTypes.Count) {
        return { value: null };
      }
      if (operation2 === AggregationTypes.Custom) {
        throw new Error("Custom aggregation not supported for tilesets");
      }
      if (column && column !== "*" || operation2 !== AggregationTypes.Count) {
        assertColumn(this._features, column);
      }
      const targetOperation = aggregationFunctions[operation2];
      assert22(targetOperation, `Unsupported aggregation operation: ${operation2}`);
      return {
        value: targetOperation(filteredFeatures, column, joinOperation)
      };
    }
    async getHistogram({
      operation: operation2 = AggregationTypes.Count,
      ticks: ticks2,
      column,
      joinOperation,
      filters,
      filterOwner,
      spatialFilter
    }) {
      const filteredFeatures = this._getFilteredFeatures(
        spatialFilter,
        filters,
        filterOwner
      );
      if (!this._features.length) {
        return [];
      }
      assertColumn(this._features, column);
      return histogram({
        data: filteredFeatures,
        valuesColumns: normalizeColumns(column),
        joinOperation,
        ticks: ticks2,
        operation: operation2
      });
    }
    async getCategories({
      column,
      operation: operation2 = AggregationTypes.Count,
      operationColumn,
      joinOperation,
      filters,
      filterOwner,
      spatialFilter,
      othersThreshold,
      orderBy = "frequency_desc",
      rawResult
    }) {
      const filteredFeatures = this._getFilteredFeatures(
        spatialFilter,
        filters,
        filterOwner
      );
      if (!filteredFeatures.length) {
        return [];
      }
      assertColumn(this._features, column, operationColumn);
      const result = groupValuesByColumn({
        data: filteredFeatures,
        valuesColumns: normalizeColumns(operationColumn || column),
        joinOperation,
        keysColumn: column,
        operation: operation2,
        othersThreshold,
        orderBy
      });
      if (rawResult) {
        return result;
      }
      if (!othersThreshold) {
        return result?.rows || [];
      }
      return [
        ...result?.rows || [],
        { name: OTHERS_CATEGORY_NAME, value: result?.metadata?.others }
      ];
    }
    async getScatter({
      xAxisColumn,
      yAxisColumn,
      xAxisJoinOperation,
      yAxisJoinOperation,
      filters,
      filterOwner,
      spatialFilter
    }) {
      const filteredFeatures = this._getFilteredFeatures(
        spatialFilter,
        filters,
        filterOwner
      );
      if (!filteredFeatures.length) {
        return [];
      }
      assertColumn(this._features, xAxisColumn, yAxisColumn);
      return scatterPlot({
        data: filteredFeatures,
        xAxisColumns: normalizeColumns(xAxisColumn),
        xAxisJoinOperation,
        yAxisColumns: normalizeColumns(yAxisColumn),
        yAxisJoinOperation
      });
    }
    async getTable({
      columns,
      searchFilterColumn,
      searchFilterText,
      sortBy,
      sortDirection,
      sortByColumnType,
      offset = 0,
      limit = 10,
      filters,
      filterOwner,
      spatialFilter
    }) {
      let filteredFeatures = this._getFilteredFeatures(
        spatialFilter,
        filters,
        filterOwner
      );
      if (!filteredFeatures.length) {
        return { rows: [], totalCount: 0 };
      }
      if (searchFilterColumn && searchFilterText) {
        console.warn(
          'WidgetTilesetSource: "searchFilterText" is deprecated, use "filters" and FilterType.STRING_SEARCH instead.'
        );
        filteredFeatures = filteredFeatures.filter(
          (row) => row[searchFilterColumn] && String(row[searchFilterColumn]).toLowerCase().includes(String(searchFilterText).toLowerCase())
        );
      }
      let rows = applySorting(filteredFeatures, {
        sortBy,
        sortByDirection: sortDirection,
        sortByColumnType
      });
      const totalCount = rows.length;
      rows = rows.slice(
        Math.min(offset, totalCount),
        Math.min(offset + limit, totalCount)
      );
      rows = rows.map((srcRow) => {
        const dstRow = {};
        for (const column of columns) {
          dstRow[column] = srcRow[column];
        }
        return dstRow;
      });
      return { rows, totalCount };
    }
    async getTimeSeries({
      column,
      stepSize,
      operation: operation2,
      operationColumn,
      joinOperation,
      filters,
      filterOwner,
      spatialFilter
    }) {
      const filteredFeatures = this._getFilteredFeatures(
        spatialFilter,
        filters,
        filterOwner
      );
      if (!filteredFeatures.length) {
        return { rows: [] };
      }
      assertColumn(this._features, column, operationColumn);
      assert22(
        operation2 !== "custom",
        "Custom operation not supported for tilesets"
      );
      const rows = groupValuesByDateColumn({
        data: filteredFeatures,
        valuesColumns: normalizeColumns(operationColumn || column),
        keysColumn: column,
        groupType: stepSize,
        operation: operation2,
        joinOperation
      }) || [];
      return { rows };
    }
    async getRange({
      column,
      filters,
      filterOwner,
      spatialFilter
    }) {
      const filteredFeatures = this._getFilteredFeatures(
        spatialFilter,
        filters,
        filterOwner
      );
      if (!this._features.length) {
        return null;
      }
      assertColumn(this._features, column);
      return {
        min: aggregationFunctions.min(filteredFeatures, column),
        max: aggregationFunctions.max(filteredFeatures, column)
      };
    }
    async getAggregations({
      aggregations,
      filters,
      filterOwner,
      spatialFilter
    }) {
      const filteredFeatures = this._getFilteredFeatures(
        spatialFilter,
        filters,
        filterOwner
      );
      if (!this._features.length) {
        return { rows: [] };
      }
      assert22(
        typeof aggregations !== "string",
        "Unsupported tileset SQL aggregation"
      );
      const result = {};
      const usedAliases = /* @__PURE__ */ new Set();
      for (const { column, operation: operation2, alias } of aggregations) {
        if (column && column !== "*" || operation2 !== AggregationTypes.Count) {
          assertColumn(this._features, column);
        }
        const aliasKey = alias.toLowerCase();
        assert22(!usedAliases.has(aliasKey), `Duplicate alias: ${aliasKey}`);
        usedAliases.add(aliasKey);
        const targetOperation = aggregationFunctions[operation2];
        assert22(targetOperation, `Unsupported operation: ${operation2}`);
        result[alias] = targetOperation(filteredFeatures, column);
      }
      return { rows: [result] };
    }
    /** @experimental */
    async getExtent() {
      return Promise.reject(new Error("not implemented"));
    }
    /****************************************************************************
     * INTERNAL
     */
    _getFilteredFeatures(spatialFilter, filters, filterOwner) {
      this._extractTileFeatures(spatialFilter);
      return applyFilters(
        this._features,
        getApplicableFilters(filterOwner, filters || this.props.filters),
        this.props.filtersLogicalOperator || "and"
      );
    }
  };
  function assertColumn(features, ...columnArgs) {
    const columns = Array.from(new Set(columnArgs.map(normalizeColumns).flat()));
    const featureKeys = Object.keys(features[0]);
    const invalidColumns = columns.filter(
      (column) => column && !featureKeys.includes(column)
    );
    if (invalidColumns.length) {
      throw new InvalidColumnError(
        `Missing column(s): ${invalidColumns.join(", ")}`
      );
    }
  }
  function normalizeColumns(columns) {
    return Array.isArray(columns) ? columns : typeof columns === "string" ? [columns] : [];
  }
  function spatialFilterEquals(a, b) {
    if (a === b)
      return true;
    if (!a || !b)
      return false;
    return booleanEqual(a, b);
  }
  var WidgetTilesetSource = class extends WidgetSource {
    constructor(props) {
      super(props);
      __publicField(this, "_localImpl", null);
      __publicField(this, "_workerImpl", null);
      __publicField(this, "_workerEnabled");
      __publicField(this, "_workerNextRequestId", 1);
      this._workerEnabled = (props.widgetWorker ?? true) && true && typeof Worker !== "undefined";
      if (!this._workerEnabled) {
        this._localImpl = new WidgetTilesetSourceImpl(this.props);
      }
    }
    destroy() {
      this._localImpl?.destroy();
      this._localImpl = null;
      this._workerImpl?.terminate();
      this._workerImpl = null;
      super.destroy();
    }
    /////////////////////////////////////////////////////////////////////////////
    // WEB WORKER MANAGEMENT
    /**
     * Returns an initialized Worker, to be reused for the lifecycle of this
     * source instance.
     */
    _getWorker() {
      if (this._workerImpl) {
        return this._workerImpl;
      }
      if (this.props.widgetWorkerUrl) {
        this._workerImpl = new Worker(this.props.widgetWorkerUrl, {
          name: "cartowidgettileset"
        });
      } else {
        this._workerImpl = new Worker(
          new URL("@carto/api-client/worker", import_meta.url),
          {
            type: "module",
            name: "cartowidgettileset"
          }
        );
      }
      this._workerImpl.addEventListener("error", (e) => {
        console.error("widget-tileset-source worker error", e);
      });
      this._workerImpl.postMessage({
        method: "init",
        params: [this.props]
      });
      return this._workerImpl;
    }
    /** Executes a given method on the worker. */
    _executeWorkerMethod(method, params, signal) {
      if (!this._workerEnabled) {
        return this._localImpl[method](...params);
      }
      const worker = this._getWorker();
      const requestId = this._workerNextRequestId++;
      let resolve = null;
      let reject = null;
      function onMessage(e) {
        const response = e.data;
        if (response.requestId !== requestId)
          return;
        if (signal?.aborted)
          return;
        if (response.ok) {
          resolve(response.result);
        } else {
          reject(new Error(response.error));
        }
      }
      function onAbort() {
        reject(new Error(signal.reason));
      }
      worker.addEventListener("message", onMessage);
      signal?.addEventListener("abort", onAbort);
      const promise = new Promise((_resolve, _reject) => {
        resolve = _resolve;
        reject = _reject;
        worker.postMessage({
          requestId,
          method,
          params
        });
      });
      void promise.finally(() => {
        worker.removeEventListener("message", onMessage);
        signal?.removeEventListener("abort", onAbort);
      });
      return promise;
    }
    /////////////////////////////////////////////////////////////////////////////
    // DATA LOADING
    /**
     * Loads features as a list of tiles (typically provided by deck.gl).
     * After tiles are loaded, {@link extractTileFeatures} must be called
     * before computing statistics on the tiles.
     */
    loadTiles(tiles3) {
      if (!this._workerEnabled) {
        return this._localImpl.loadTiles(tiles3);
      }
      const worker = this._getWorker();
      tiles3 = tiles3.map(
        ({ id: id5, index: index2, bbox: bbox2, isVisible, data }) => {
          const tile = {
            id: id5,
            index: index2,
            isVisible,
            data,
            bbox: bbox2
          };
          return tile;
        }
      );
      worker.postMessage({
        method: "loadTiles",
        params: [tiles3]
      });
    }
    /** Configures options used to extract features from tiles. */
    setTileFeatureExtractOptions(options) {
      if (!this._workerEnabled) {
        return this._localImpl?.setTileFeatureExtractOptions(options);
      }
      const worker = this._getWorker();
      worker.postMessage({
        method: "setTileFeatureExtractOptions",
        params: [options]
      });
    }
    /**
     * Loads features as GeoJSON (used for testing).
     * @experimental
     * @internal Not for public use. Spatial filters in other method calls will be ignored.
     */
    loadGeoJSON({
      geojson,
      spatialFilter
    }) {
      if (!this._workerEnabled) {
        return this._localImpl.loadGeoJSON({ geojson, spatialFilter });
      }
      const worker = this._getWorker();
      worker.postMessage({
        method: "loadGeoJSON",
        params: [{ geojson, spatialFilter }]
      });
    }
    /////////////////////////////////////////////////////////////////////////////
    // WIDGETS API
    // eslint-disable-next-line @typescript-eslint/require-await
    async getFeatures() {
      throw new Error("getFeatures not supported for tilesets");
    }
    async getFormula({
      signal,
      ...options
    }) {
      return this._executeWorkerMethod("getFormula", [options], signal);
    }
    async getHistogram({
      signal,
      ...options
    }) {
      return this._executeWorkerMethod("getHistogram", [options], signal);
    }
    async getCategories({
      signal,
      ...options
    }) {
      return this._executeWorkerMethod("getCategories", [options], signal);
    }
    async getScatter({
      signal,
      ...options
    }) {
      return this._executeWorkerMethod("getScatter", [options], signal);
    }
    async getTable({
      signal,
      ...options
    }) {
      return this._executeWorkerMethod("getTable", [options], signal);
    }
    async getTimeSeries({
      signal,
      ...options
    }) {
      return this._executeWorkerMethod("getTimeSeries", [options], signal);
    }
    async getRange({
      signal,
      ...options
    }) {
      return this._executeWorkerMethod("getRange", [options], signal);
    }
    async getAggregations({
      signal,
      ...options
    }) {
      return this._executeWorkerMethod(
        "getAggregations",
        [options],
        signal
      );
    }
    /** @experimental */
    async getExtent() {
      return Promise.resolve({
        bbox: this.props.spatialDataBounds
      });
    }
  };
  var WidgetRasterSource = class extends WidgetTilesetSource {
  };
  var WidgetTableSource = class extends WidgetRemoteSource {
    getModelSource(filters, filterOwner) {
      return {
        ...super._getModelSource(filters, filterOwner),
        type: "table",
        data: this.props.tableName
      };
    }
  };
  var h3QuerySource = async function(options) {
    const {
      aggregationExp,
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_H3,
      sqlQuery,
      spatialDataColumn = "h3",
      queryParameters,
      filters
    } = options;
    const spatialDataType = "h3";
    const urlParameters = {
      aggregationExp,
      spatialDataColumn,
      spatialDataType,
      q: sqlQuery
    };
    if (aggregationResLevel) {
      urlParameters.aggregationResLevel = String(aggregationResLevel);
    }
    if (queryParameters) {
      urlParameters.queryParameters = queryParameters;
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return baseSource("query", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetQuerySource({
          ...options,
          // NOTE: Parameters with default values above must be explicitly passed here.
          spatialDataColumn,
          spatialDataType: getWidgetSpatialDataType(
            spatialDataType,
            spatialDataColumn,
            result.schema
          )
        })
      })
    );
  };
  var h3TableSource = async function(options) {
    const {
      aggregationExp,
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_H3,
      spatialDataColumn = "h3",
      tableName,
      filters
    } = options;
    const spatialDataType = "h3";
    const urlParameters = {
      aggregationExp,
      name: tableName,
      spatialDataColumn,
      spatialDataType
    };
    if (aggregationResLevel) {
      urlParameters.aggregationResLevel = String(aggregationResLevel);
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return baseSource("table", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetTableSource({
          ...options,
          // NOTE: Parameters with default values above must be explicitly passed here.
          spatialDataColumn,
          spatialDataType: getWidgetSpatialDataType(
            spatialDataType,
            spatialDataColumn,
            result.schema
          )
        })
      })
    );
  };
  function getTileFormat(tilejson) {
    const tileParams = new URL(tilejson.tiles[0]).searchParams;
    return tileParams.get("formatTiles") === "mvt" ? "mvt" : "binary";
  }
  var h3TilesetSource = async function(options) {
    const { tableName, spatialDataColumn = "h3" } = options;
    const urlParameters = { name: tableName };
    return baseSource("tileset", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetTilesetSource({
          ...options,
          tileFormat: getTileFormat(result),
          spatialDataColumn,
          spatialDataType: "h3",
          spatialDataBounds: result.bounds
        })
      })
    );
  };
  var quadbinQuerySource = async function(options) {
    const {
      aggregationExp,
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN,
      sqlQuery,
      spatialDataColumn = "quadbin",
      queryParameters,
      filters
    } = options;
    const spatialDataType = "quadbin";
    const urlParameters = {
      aggregationExp,
      q: sqlQuery,
      spatialDataColumn,
      spatialDataType
    };
    if (aggregationResLevel) {
      urlParameters.aggregationResLevel = String(aggregationResLevel);
    }
    if (queryParameters) {
      urlParameters.queryParameters = queryParameters;
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return baseSource("query", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetQuerySource({
          ...options,
          // NOTE: Parameters with default values above must be explicitly passed here.
          spatialDataColumn,
          spatialDataType: getWidgetSpatialDataType(
            spatialDataType,
            spatialDataColumn,
            result.schema
          )
        })
      })
    );
  };
  var quadbinTableSource = async function(options) {
    const {
      aggregationExp,
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN,
      spatialDataColumn = "quadbin",
      tableName,
      filters
    } = options;
    const spatialDataType = "quadbin";
    const urlParameters = {
      aggregationExp,
      name: tableName,
      spatialDataColumn,
      spatialDataType
    };
    if (aggregationResLevel) {
      urlParameters.aggregationResLevel = String(aggregationResLevel);
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    return baseSource("table", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetTableSource({
          ...options,
          // NOTE: Parameters with default values above must be explicitly passed here.
          spatialDataColumn,
          spatialDataType: getWidgetSpatialDataType(
            spatialDataType,
            spatialDataColumn,
            result.schema
          )
        })
      })
    );
  };
  var quadbinTilesetSource = async function(options) {
    const { tableName, spatialDataColumn = "quadbin" } = options;
    const urlParameters = { name: tableName };
    return baseSource("tileset", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetTilesetSource({
          ...options,
          tileFormat: getTileFormat(result),
          spatialDataColumn,
          spatialDataType: "quadbin",
          spatialDataBounds: result.bounds
        })
      })
    );
  };
  var rasterSource = async function(options) {
    const { tableName, filters } = options;
    const urlParameters = { name: tableName };
    if (filters) {
      urlParameters.filters = filters;
    }
    return baseSource("raster", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetRasterSource({
          ...options,
          tileFormat: getTileFormat(result),
          spatialDataColumn: "quadbin",
          spatialDataType: "quadbin",
          spatialDataBounds: result.bounds,
          rasterMetadata: result.raster_metadata
        })
      })
    );
  };
  var trajectoryQuerySource = async function(options) {
    const {
      columns,
      spatialDataColumn = DEFAULT_GEO_COLUMN,
      sqlQuery,
      tileResolution = DEFAULT_TILE_RESOLUTION,
      queryParameters,
      aggregationExp,
      trajectoryIdColumn,
      timestampColumn
    } = options;
    const spatialDataType = "trajectory";
    const urlParameters = {
      spatialDataColumn,
      spatialDataType,
      tileResolution: tileResolution.toString(),
      q: sqlQuery,
      trajectoryIdColumn,
      timestampColumn
    };
    if (columns) {
      urlParameters.columns = columns.join(",");
    }
    if (queryParameters) {
      urlParameters.queryParameters = queryParameters;
    }
    if (aggregationExp) {
      urlParameters.aggregationExp = aggregationExp;
    }
    const result = await baseSource(
      "query",
      options,
      urlParameters
    );
    const widgetSource = new WidgetQuerySource({
      ...options,
      // NOTE: Parameters with default values above must be explicitly passed here.
      spatialDataColumn,
      spatialDataType,
      tileResolution
    });
    const timestampRange = await widgetSource.getRange({ column: timestampColumn });
    return {
      ...result,
      widgetSource,
      timestampRange
    };
  };
  var trajectoryTableSource = async function(options) {
    const {
      columns,
      spatialDataColumn = DEFAULT_GEO_COLUMN,
      tableName,
      tileResolution = DEFAULT_TILE_RESOLUTION,
      aggregationExp,
      trajectoryIdColumn,
      timestampColumn
    } = options;
    const spatialDataType = "trajectory";
    const urlParameters = {
      name: tableName,
      spatialDataColumn,
      spatialDataType,
      tileResolution: tileResolution.toString(),
      trajectoryIdColumn,
      timestampColumn
    };
    if (columns) {
      urlParameters.columns = columns.join(",");
    }
    if (aggregationExp) {
      urlParameters.aggregationExp = aggregationExp;
    }
    const result = await baseSource(
      "table",
      options,
      urlParameters
    );
    const widgetSource = new WidgetTableSource({
      ...options,
      // NOTE: Parameters with default values above must be explicitly passed here.
      spatialDataColumn,
      spatialDataType,
      tileResolution
    });
    const timestampRange = await widgetSource.getRange({ column: timestampColumn });
    return {
      ...result,
      widgetSource,
      timestampRange
    };
  };
  var vectorQuerySource = async function(options) {
    const {
      columns,
      filters,
      spatialDataColumn = DEFAULT_GEO_COLUMN,
      sqlQuery,
      tileResolution = DEFAULT_TILE_RESOLUTION,
      queryParameters,
      aggregationExp
    } = options;
    const spatialDataType = "geo";
    const urlParameters = {
      spatialDataColumn,
      spatialDataType,
      tileResolution: tileResolution.toString(),
      q: sqlQuery
    };
    if (columns) {
      urlParameters.columns = columns.join(",");
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    if (queryParameters) {
      urlParameters.queryParameters = queryParameters;
    }
    if (aggregationExp) {
      urlParameters.aggregationExp = aggregationExp;
    }
    return baseSource("query", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetQuerySource({
          ...options,
          // NOTE: Parameters with default values above must be explicitly passed here.
          spatialDataColumn,
          spatialDataType,
          tileResolution
        })
      })
    );
  };
  var vectorTableSource = async function(options) {
    const {
      columns,
      filters,
      spatialDataColumn = DEFAULT_GEO_COLUMN,
      tableName,
      tileResolution = DEFAULT_TILE_RESOLUTION,
      aggregationExp
    } = options;
    const spatialDataType = "geo";
    const urlParameters = {
      name: tableName,
      spatialDataColumn,
      spatialDataType,
      tileResolution: tileResolution.toString()
    };
    if (columns) {
      urlParameters.columns = columns.join(",");
    }
    if (filters) {
      urlParameters.filters = filters;
    }
    if (aggregationExp) {
      urlParameters.aggregationExp = aggregationExp;
    }
    return baseSource("table", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetTableSource({
          ...options,
          // NOTE: Parameters with default values above must be explicitly passed here.
          spatialDataColumn,
          spatialDataType,
          tileResolution
        })
      })
    );
  };
  var vectorTilesetSource = async function(options) {
    const { tableName, spatialDataColumn = DEFAULT_GEO_COLUMN } = options;
    const urlParameters = { name: tableName };
    return baseSource("tileset", options, urlParameters).then(
      (result) => ({
        ...result,
        widgetSource: new WidgetTilesetSource({
          ...options,
          tileFormat: getTileFormat(result),
          spatialDataColumn,
          spatialDataType: "geo",
          spatialDataBounds: result.bounds
        })
      })
    );
  };
  var CARTO_SOURCES = {
    boundaryQuerySource,
    boundaryTableSource,
    h3QuerySource,
    h3TableSource,
    h3TilesetSource,
    quadbinQuerySource,
    quadbinTableSource,
    quadbinTilesetSource,
    rasterSource,
    trajectoryQuerySource,
    trajectoryTableSource,
    vectorQuerySource,
    vectorTableSource,
    vectorTilesetSource
  };
  var query = async function(options) {
    const {
      apiBaseUrl = SOURCE_DEFAULTS.apiBaseUrl,
      maxLengthURL = SOURCE_DEFAULTS.maxLengthURL,
      clientId = getClient(),
      localCache,
      connectionName,
      sqlQuery,
      queryParameters,
      internalParameters
    } = options;
    const urlParameters = { q: sqlQuery };
    if (queryParameters) {
      urlParameters.queryParameters = JSON.stringify(queryParameters);
    }
    const baseUrl = buildQueryUrl({ apiBaseUrl, connectionName });
    const headers = {
      Authorization: `Bearer ${options.accessToken}`,
      ...options.headers
    };
    const parameters = {
      client: clientId,
      ...options.tags,
      ...internalParameters,
      ...urlParameters
    };
    const errorContext = {
      requestType: "SQL",
      connection: options.connectionName,
      type: "query",
      source: JSON.stringify(parameters, void 0, 2)
    };
    return await requestWithParameters({
      baseUrl,
      parameters,
      headers,
      errorContext,
      maxLengthURL,
      localCache,
      signal: options.signal
    });
  };
  var cartoStyleUrlTemplate = "https://basemaps.cartocdn.com/gl/{basemap}-gl-style/style.json";
  var CARTO_MAP_STYLES = ["positron", "dark-matter", "voyager"];
  var GOOGLE_BASEMAPS = {
    roadmap: {
      mapTypeId: "roadmap",
      mapId: "3754c817b510f791"
    },
    "google-positron": {
      mapTypeId: "roadmap",
      mapId: "ea84ae4203ef21cd"
    },
    "google-dark-matter": {
      mapTypeId: "roadmap",
      mapId: "2fccc3b36c22a0e2"
    },
    "google-voyager": {
      mapTypeId: "roadmap",
      mapId: "885caf1e15bb9ef2"
    },
    satellite: {
      mapTypeId: "satellite"
    },
    hybrid: {
      mapTypeId: "hybrid"
    },
    terrain: {
      mapTypeId: "terrain"
    }
  };
  var STYLE_LAYER_GROUPS = [
    {
      slug: "label",
      filter: ({ id: id5 }) => Boolean(
        id5.match(
          /(?=(label|_label|place-|place_|poi-|poi_|watername_|roadname_|housenumber))/
        )
      ),
      defaultVisibility: true
    },
    {
      slug: "road",
      filter: ({ id: id5 }) => Boolean(id5.match(/(?=(road|railway|tunnel|street|bridge))(?!.*label)/)),
      defaultVisibility: true
    },
    {
      slug: "border",
      filter: ({ id: id5 }) => Boolean(id5.match(/border|boundaries|boundary_/)),
      defaultVisibility: false
    },
    {
      slug: "building",
      filter: ({ id: id5 }) => Boolean(id5.match(/building/)),
      defaultVisibility: true
    },
    {
      slug: "water",
      filter: ({ id: id5 }) => Boolean(id5.match(/(?=(water|stream|ferry))/)),
      defaultVisibility: true
    },
    {
      slug: "land",
      filter: ({ id: id5 }) => Boolean(
        id5.match(/(?=(parks|landcover|industrial|sand|hillshade|park_))/)
      ),
      defaultVisibility: true
    }
  ];
  function applyLayerGroupFilters(style, visibleLayerGroups) {
    if (!Array.isArray(style?.layers)) {
      return style;
    }
    const removedLayerFilters = STYLE_LAYER_GROUPS.filter(
      (lg) => !visibleLayerGroups[lg.slug]
    ).map((lg) => lg.filter);
    const visibleLayers = style.layers.filter(
      (layer) => removedLayerFilters.every((match) => !match(layer))
    );
    return {
      ...style,
      layers: visibleLayers
    };
  }
  function someLayerGroupsDisabled(visibleLayerGroups) {
    return visibleLayerGroups && Object.values(visibleLayerGroups).every(Boolean) === false;
  }
  function getStyleUrl(styleType) {
    return cartoStyleUrlTemplate.replace("{basemap}", styleType);
  }
  async function fetchStyle({
    styleUrl,
    errorContext
  }) {
    let response;
    return await fetch(styleUrl, { mode: "cors" }).then((res) => {
      response = res;
      return res.json();
    }).catch((error) => {
      throw new CartoAPIError(
        error,
        { ...errorContext, requestType: "Basemap style" },
        response
      );
    });
  }
  var basemap_styles_default = {
    VOYAGER: getStyleUrl("voyager"),
    POSITRON: getStyleUrl("positron"),
    DARK_MATTER: getStyleUrl("dark-matter"),
    VOYAGER_NOLABELS: getStyleUrl("voyager-nolabels"),
    POSITRON_NOLABELS: getStyleUrl("positron-nolabels"),
    DARK_MATTER_NOLABELS: getStyleUrl("dark-matter-nolabels")
  };
  function createVecExprEvaluator(expression) {
    try {
      const parsed = compile(expression);
      const evalFun = (context) => evaluate(parsed, context);
      evalFun.symbols = getSymbols(parsed);
      return evalFun;
    } catch {
      return null;
    }
  }
  function createResultArray(typeTemplate, length2 = typeTemplate.length) {
    return new Array(length2);
  }
  function isVecLike(a) {
    return Array.isArray(a) || ArrayBuffer.isView(a);
  }
  var createBinopVec = (scalarBinOp) => (left, right) => {
    const length2 = Math.min(left.length, right.length);
    const r = createResultArray(left, length2);
    for (let i = 0; i < length2; i++) {
      r[i] = scalarBinOp(left[i], right[i]);
    }
    return r;
  };
  var createBinopVecNum = (scalarBinOp) => (left, right) => {
    const length2 = left.length;
    const r = createResultArray(left, length2);
    for (let i = 0; i < length2; i++) {
      r[i] = scalarBinOp(left[i], right);
    }
    return r;
  };
  var createBinopNumVec = (scalarBinOp) => (left, right) => {
    const length2 = right.length;
    const r = createResultArray(right, length2);
    for (let i = 0; i < length2; i++) {
      r[i] = scalarBinOp(left, right[i]);
    }
    return r;
  };
  var createUnopVec = (scalarUnop) => (a) => {
    const length2 = a.length;
    const r = createResultArray(a, length2);
    for (let i = 0; i < length2; i++) {
      r[i] = scalarUnop(a[i]);
    }
    return r;
  };
  function mapDictValues(dict, fun) {
    return Object.keys(dict).reduce(
      (acc, key) => {
        acc[key] = fun(dict[key]);
        return acc;
      },
      {}
    );
  }
  var binopsNum = {
    "||": (a, b) => a || b,
    "&&": (a, b) => a && b,
    "|": (a, b) => a | b,
    "^": (a, b) => a ^ b,
    "&": (a, b) => a & b,
    "==": (a, b) => Number(a == b),
    "!=": (a, b) => Number(a != b),
    "===": (a, b) => Number(a === b),
    "!==": (a, b) => Number(a !== b),
    "<": (a, b) => Number(a < b),
    ">": (a, b) => Number(a > b),
    "<=": (a, b) => Number(a <= b),
    ">=": (a, b) => Number(a >= b),
    "<<": (a, b) => a << b,
    ">>": (a, b) => a >> b,
    ">>>": (a, b) => a >>> b,
    "+": (a, b) => a + b,
    "-": (a, b) => a - b,
    "*": (a, b) => a * b,
    "/": (a, b) => a / b,
    "%": (a, b) => a % b
  };
  var unopsNum = {
    "-": (a) => -a,
    "+": (a) => +a,
    "~": (a) => ~a,
    "!": (a) => Number(!a)
  };
  var binopsVector = mapDictValues(binopsNum, createBinopVec);
  var binopsNumVec = mapDictValues(binopsNum, createBinopNumVec);
  var binopsVecNum = mapDictValues(binopsNum, createBinopVecNum);
  var unopsVector = mapDictValues(unopsNum, createUnopVec);
  function getBinop(operator, left, right) {
    const isLeftVec = isVecLike(left);
    const isRightVec = isVecLike(right);
    if (isLeftVec && isRightVec) {
      return binopsVector[operator];
    } else if (isLeftVec) {
      return binopsVecNum[operator];
    } else if (isRightVec) {
      return binopsNumVec[operator];
    } else {
      return binopsNum[operator];
    }
  }
  function evaluate(_node, context) {
    const node = _node;
    switch (node.type) {
      case "BinaryExpression": {
        const left = evaluate(node.left, context);
        const right = evaluate(node.right, context);
        const binopFun = getBinop(node.operator, left, right);
        return binopFun(left, right);
      }
      case "ConditionalExpression": {
        const val = evaluate(node.test, context);
        if (isVecLike(val)) {
          const length2 = val.length;
          const consequentVal = evaluate(node.consequent, context);
          const alternateVal = evaluate(node.alternate, context);
          const r = createResultArray(val);
          for (let i = 0; i < length2; i++) {
            const entryVal = val[i] ? consequentVal : alternateVal;
            r[i] = isVecLike(entryVal) ? entryVal[i] ?? NaN : entryVal;
          }
          return r;
        } else {
          return val ? evaluate(node.consequent, context) : evaluate(node.alternate, context);
        }
      }
      case "Identifier":
        return context[node.name];
      case "Literal":
        return node.value;
      case "UnaryExpression": {
        const val = evaluate(node.argument, context);
        const unopFun = isVecLike(val) ? unopsVector[node.operator] : unopsNum[node.operator];
        return unopFun(val);
      }
      default:
        return void 0;
    }
  }
  function visit(_node, visitor) {
    const node = _node;
    visitor(node);
    switch (node.type) {
      case "BinaryExpression": {
        visit(node.left, visitor);
        visit(node.right, visitor);
        break;
      }
      case "ConditionalExpression": {
        visit(node.test, visitor);
        visit(node.consequent, visitor);
        visit(node.alternate, visitor);
        break;
      }
      case "UnaryExpression": {
        visit(node.argument, visitor);
        break;
      }
    }
  }
  function getSymbols(node) {
    const symbols = /* @__PURE__ */ new Set();
    visit(node, (node2) => {
      if (node2.type === "Identifier") {
        symbols.add(node2.name);
      }
    });
    return Array.from(symbols);
  }
  function compile(expression) {
    return jsep(expression);
  }
  function define_default2(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend2(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition)
      prototype[key] = definition[key];
    return prototype;
  }
  function Color4() {
  }
  var darker2 = 0.7;
  var brighter2 = 1 / darker2;
  var reI2 = "\\s*([+-]?\\d+)\\s*";
  var reN2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP2 = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex2 = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger2 = new RegExp(`^rgb\\(${reI2},${reI2},${reI2}\\)$`);
  var reRgbPercent2 = new RegExp(`^rgb\\(${reP2},${reP2},${reP2}\\)$`);
  var reRgbaInteger2 = new RegExp(`^rgba\\(${reI2},${reI2},${reI2},${reN2}\\)$`);
  var reRgbaPercent2 = new RegExp(`^rgba\\(${reP2},${reP2},${reP2},${reN2}\\)$`);
  var reHslPercent2 = new RegExp(`^hsl\\(${reN2},${reP2},${reP2}\\)$`);
  var reHslaPercent2 = new RegExp(`^hsla\\(${reN2},${reP2},${reP2},${reN2}\\)$`);
  var named2 = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default2(Color4, color2, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex2,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex2,
    formatHex8: color_formatHex82,
    formatHsl: color_formatHsl2,
    formatRgb: color_formatRgb2,
    toString: color_formatRgb2
  });
  function color_formatHex2() {
    return this.rgb().formatHex();
  }
  function color_formatHex82() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl2() {
    return hslConvert2(this).formatHsl();
  }
  function color_formatRgb2() {
    return this.rgb().formatRgb();
  }
  function color2(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex2.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn2(m) : l === 3 ? new Rgb2(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba2(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba2(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger2.exec(format2)) ? new Rgb2(m[1], m[2], m[3], 1) : (m = reRgbPercent2.exec(format2)) ? new Rgb2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger2.exec(format2)) ? rgba2(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent2.exec(format2)) ? rgba2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent2.exec(format2)) ? hsla2(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent2.exec(format2)) ? hsla2(m[1], m[2] / 100, m[3] / 100, m[4]) : named2.hasOwnProperty(format2) ? rgbn2(named2[format2]) : format2 === "transparent" ? new Rgb2(NaN, NaN, NaN, 0) : null;
  }
  function rgbn2(n) {
    return new Rgb2(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba2(r, g, b, a) {
    if (a <= 0)
      r = g = b = NaN;
    return new Rgb2(r, g, b, a);
  }
  function rgbConvert2(o) {
    if (!(o instanceof Color4))
      o = color2(o);
    if (!o)
      return new Rgb2();
    o = o.rgb();
    return new Rgb2(o.r, o.g, o.b, o.opacity);
  }
  function rgb2(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert2(r) : new Rgb2(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb2(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default2(Rgb2, rgb2, extend2(Color4, {
    brighter(k) {
      k = k == null ? brighter2 : Math.pow(brighter2, k);
      return new Rgb2(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker2 : Math.pow(darker2, k);
      return new Rgb2(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb2(clampi2(this.r), clampi2(this.g), clampi2(this.b), clampa2(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex2,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex2,
    formatHex8: rgb_formatHex82,
    formatRgb: rgb_formatRgb2,
    toString: rgb_formatRgb2
  }));
  function rgb_formatHex2() {
    return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}`;
  }
  function rgb_formatHex82() {
    return `#${hex2(this.r)}${hex2(this.g)}${hex2(this.b)}${hex2((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb2() {
    const a = clampa2(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi2(this.r)}, ${clampi2(this.g)}, ${clampi2(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa2(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi2(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex2(value) {
    value = clampi2(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla2(h, s, l, a) {
    if (a <= 0)
      h = s = l = NaN;
    else if (l <= 0 || l >= 1)
      h = s = NaN;
    else if (s <= 0)
      h = NaN;
    return new Hsl2(h, s, l, a);
  }
  function hslConvert2(o) {
    if (o instanceof Hsl2)
      return new Hsl2(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color4))
      o = color2(o);
    if (!o)
      return new Hsl2();
    if (o instanceof Hsl2)
      return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
    if (s) {
      if (r === max2)
        h = (g - b) / s + (g < b) * 6;
      else if (g === max2)
        h = (b - r) / s + 2;
      else
        h = (r - g) / s + 4;
      s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl2(h, s, l, o.opacity);
  }
  function hsl2(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert2(h) : new Hsl2(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl2(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default2(Hsl2, hsl2, extend2(Color4, {
    brighter(k) {
      k = k == null ? brighter2 : Math.pow(brighter2, k);
      return new Hsl2(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker2 : Math.pow(darker2, k);
      return new Hsl2(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb2(
        hsl2rgb2(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb2(h, m1, m2),
        hsl2rgb2(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl2(clamph2(this.h), clampt2(this.s), clampt2(this.l), clampa2(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa2(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph2(this.h)}, ${clampt2(this.s) * 100}%, ${clampt2(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph2(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt2(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb2(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }
  function createBinaryProxy2(data, index2) {
    const { properties, numericProps } = data;
    return new Proxy(properties[index2] || {}, {
      get(target, property) {
        if (property in numericProps) {
          return numericProps[property].value[index2];
        }
        return target[property];
      },
      has(target, property) {
        return property in numericProps || property in target;
      },
      ownKeys(target) {
        return [...Object.keys(numericProps), ...Reflect.ownKeys(target)];
      },
      getOwnPropertyDescriptor() {
        return { enumerable: true, configurable: true };
      }
    });
  }
  function scaleIdentity() {
    let unknown;
    function scale2(x) {
      return x === null ? unknown : x;
    }
    scale2.invert = scale2;
    scale2.domain = scale2.range = (d) => d;
    scale2.unknown = (u4) => {
      if (u4) {
        unknown = u4;
      }
      return unknown;
    };
    scale2.copy = () => {
      const scaleCopy = scaleIdentity();
      scaleCopy.unknown(unknown);
      return scaleCopy;
    };
    return scale2;
  }
  function isRemoteCalculationSupported(dataset) {
    if (dataset?.type === "tileset" || dataset.providerId === "databricks") {
      return false;
    }
    return true;
  }
  var DATE_FORMATTER = new Intl.DateTimeFormat("en-US", {
    year: "2-digit",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric",
    timeZone: "UTC"
  });
  function formatDate(value) {
    return DATE_FORMATTER.format(new Date(value));
  }
  function formatTimestamp(value) {
    return String(Math.floor(new Date(value).getTime() / 1e3));
  }
  function roundedPow10(exp) {
    const raw = Math.pow(10, exp);
    if (exp < 0) {
      const shift = Math.pow(10, -exp);
      return Math.round(raw * shift) / shift;
    }
    return raw;
  }
  function getLog10ScaleSteps({
    min: min2,
    max: max2,
    steps
  }) {
    if (min2 === 0) {
      if (max2 === Infinity) {
        return [...Array(steps - 1)].map((_v, i) => roundedPow10(i + 1));
      }
      const maxLog = Math.log10(max2);
      const endExponent = Math.ceil(maxLog);
      const startExponent = endExponent - steps + 1;
      return [...Array(steps - 1)].map(
        (_v, i) => roundedPow10(startExponent + i)
      );
    } else {
      const minLog = Math.log10(min2);
      const startExponent = Math.ceil(minLog) === minLog ? minLog + 1 : Math.ceil(minLog);
      return [...Array(steps - 1)].map(
        (_v, i) => roundedPow10(startExponent + i)
      );
    }
  }
  var SCALE_FUNCS = {
    linear: linear2,
    ordinal,
    log: log6,
    point,
    quantile: quantile2,
    quantize,
    sqrt,
    custom: threshold,
    identity: scaleIdentity
  };
  function identity2(v2) {
    return v2;
  }
  var hexToRGB = (c) => {
    const { r, g, b } = rgb2(c);
    return [r, g, b];
  };
  var rgbToHex = (c) => {
    const [r, g, b] = c;
    const rStr = r.toString(16).padStart(2, "0");
    const gStr = g.toString(16).padStart(2, "0");
    const bStr = b.toString(16).padStart(2, "0");
    return `#${rStr}${gStr}${bStr}`.toUpperCase();
  };
  var UNKNOWN_COLOR = "#868d91";
  var UNKNOWN_COLOR_RGB = hexToRGB(UNKNOWN_COLOR);
  var OPACITY_MAP = {
    getFillColor: "opacity",
    getLineColor: "strokeOpacity",
    getTextColor: "opacity"
  };
  var hexToRGBA = (c) => {
    const { r, g, b, opacity } = rgb2(c);
    return [r, g, b, 255 * opacity];
  };
  var sharedPropMap = {
    // Apply the value of Kepler `color` prop to the deck `getFillColor` prop
    color: "getFillColor",
    isVisible: "visible",
    label: "cartoLabel",
    textLabel: {
      alignment: "getTextAlignmentBaseline",
      anchor: "getTextAnchor",
      // Apply the value of Kepler `textLabel.color` prop to the deck `getTextColor` prop
      color: "getTextColor",
      size: "getTextSize"
    },
    visConfig: {
      enable3d: "extruded",
      elevationScale: "elevationScale",
      filled: "filled",
      strokeColor: "getLineColor",
      stroked: "stroked",
      thickness: "getLineWidth",
      radius: "getPointRadius",
      wireframe: "wireframe"
    }
  };
  var rasterPropsMap = {
    isVisible: "visible",
    visConfig: {
      opacity: "opacity"
    }
  };
  var customMarkersPropsMap = {
    color: "getIconColor",
    visConfig: {
      radius: "getIconSize"
    }
  };
  var heatmapTilePropsMap = {
    visConfig: {
      colorRange: (x) => ({ colorRange: x.colors.map(hexToRGBA) }),
      radius: (radius) => ({ radiusPixels: 20 + radius }),
      opacity: "opacity"
    }
  };
  var defaultProps11 = {
    lineMiterLimit: 2,
    lineWidthUnits: "pixels",
    pointRadiusUnits: "pixels",
    rounded: true,
    wrapLongitude: false
  };
  function mergePropMaps(a = {}, b = {}) {
    return { ...a, ...b, visConfig: { ...a.visConfig, ...b.visConfig } };
  }
  var deprecatedLayerTypes = [
    "geojson",
    "grid",
    "heatmap",
    "hexagon",
    "hexagonId",
    "point"
  ];
  var TEXT_LABEL_INDEX = 0;
  var TEXT_OUTLINE_OPACITY = 64;
  var TEXT_NUMBER_FORMATTER = new Intl.NumberFormat("en-US", {
    maximumFractionDigits: 2,
    notation: "compact"
  });
  function getLayerProps(type, config2, dataset) {
    if (deprecatedLayerTypes.includes(type)) {
      throw new Error(
        `Outdated layer type: ${type}. Please open map in CARTO Builder to automatically migrate.`
      );
    }
    if (type === "raster") {
      return {
        propMap: rasterPropsMap,
        defaultProps: {}
      };
    }
    let basePropMap = sharedPropMap;
    if (config2.visConfig?.customMarkers) {
      basePropMap = mergePropMaps(basePropMap, customMarkersPropsMap);
    }
    if (type === "heatmapTile") {
      basePropMap = mergePropMaps(basePropMap, heatmapTilePropsMap);
    }
    const { aggregationExp, aggregationResLevel } = dataset;
    return {
      propMap: basePropMap,
      defaultProps: {
        ...defaultProps11,
        ...aggregationExp && { aggregationExp },
        ...aggregationResLevel && { aggregationResLevel },
        uniqueIdProperty: "geoid"
      }
    };
  }
  function domainFromAttribute(attribute, scaleType, scaleLength) {
    if (scaleType === "ordinal" || scaleType === "point") {
      if (!attribute.categories) {
        return [0, 1];
      }
      return attribute.categories.map((c) => c.category).filter((c) => c !== void 0 && c !== null);
    }
    if (scaleType === "quantile" && attribute.quantiles) {
      return "global" in attribute.quantiles ? attribute.quantiles.global[scaleLength] : attribute.quantiles[scaleLength];
    }
    let { min: min2 } = attribute;
    if (scaleType === "log" && min2 === 0) {
      min2 = 1e-5;
    }
    return [min2 ?? 0, attribute.max ?? 1];
  }
  function calculateDomain(data, name, scaleType, scaleLength) {
    if (data.tilestats) {
      const { attributes } = data.tilestats.layers[0];
      const attribute = attributes.find((a) => a.attribute === name);
      if (attribute) {
        return domainFromAttribute(attribute, scaleType, scaleLength);
      }
    }
    return [0, 1];
  }
  function normalizeAccessor(accessor, data) {
    if (data.features || data.tilestats || data.raster_metadata) {
      return (object, info) => {
        if (object) {
          return accessor(object.properties || object.__source.object.properties);
        }
        const { data: data2, index: index2 } = info;
        const proxy = createBinaryProxy2(data2, index2);
        return accessor(proxy);
      };
    }
    return accessor;
  }
  function opacityToAlpha(opacity) {
    return opacity !== void 0 ? Math.round(255 * Math.pow(opacity, 1 / 2.2)) : 255;
  }
  function getAccessorKeys(name, aggregation) {
    let keys = [name];
    if (aggregation) {
      keys = keys.concat(
        [aggregation, aggregation.toUpperCase()].map((a) => `${name}_${a}`)
      );
    }
    return keys;
  }
  function findAccessorKey(keys, properties) {
    for (const key of keys) {
      if (key in properties) {
        return [key];
      }
    }
    return keys;
  }
  function getColorAccessor({ name, colorColumn }, scaleType, { aggregation, range: range2 }, opacity, data) {
    const { scale: scale2, domain } = calculateLayerScale(
      colorColumn || name,
      colorColumn ? "identity" : scaleType,
      range2,
      data
    );
    const alpha = opacityToAlpha(opacity);
    let accessorKeys = getAccessorKeys(colorColumn || name, aggregation);
    const accessor = (properties) => {
      if (!(accessorKeys[0] in properties)) {
        accessorKeys = findAccessorKey(accessorKeys, properties);
      }
      const propertyValue = properties[accessorKeys[0]];
      const scaled = scale2(propertyValue);
      const rgb22 = typeof scaled === "string" ? hexToRGB(scaled) : scaled;
      return [...rgb22, propertyValue === null ? 0 : alpha];
    };
    return {
      accessor: normalizeAccessor(accessor, data),
      scaleDomain: scale2.domain(),
      domain,
      range: (scale2.range() || []).map(rgbToHex)
    };
  }
  function calculateLayerScale(name, scaleType, range2, data) {
    let scaleDomain;
    let scaleColors = [];
    const { colors } = range2;
    const domain = calculateDomain(data, name, scaleType, colors.length);
    if (scaleType !== "identity") {
      if (range2.colorMap) {
        const { colorMap } = range2;
        scaleDomain = [];
        colorMap.forEach(([value, color22]) => {
          scaleDomain.push(value);
          scaleColors.push(color22);
        });
      } else {
        if (scaleType === "custom" && range2.uiCustomScaleType === "logarithmic") {
          const [min2, max2] = domain;
          scaleDomain = getLog10ScaleSteps({
            min: min2,
            max: max2,
            steps: colors.length
          });
          scaleColors = colors;
        } else {
          scaleColors = colors;
        }
      }
    }
    return {
      scale: createColorScale(
        scaleType,
        scaleDomain || domain,
        scaleColors.map(hexToRGB),
        UNKNOWN_COLOR_RGB
      ),
      domain
    };
  }
  function createColorScale(scaleType, domain, range2, unknown) {
    const scale2 = SCALE_FUNCS[scaleType]();
    scale2.domain(domain);
    scale2.range(range2);
    scale2.unknown(unknown);
    return scale2;
  }
  var FALLBACK_ICON = "data:image/svg+xml;charset=utf-8;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMTAwIDEwMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4NCiAgPGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNTAiLz4NCjwvc3ZnPg==";
  function getIconUrlAccessor(field, range2, {
    fallbackUrl,
    maxIconSize,
    useMaskedIcons
  }, data) {
    const urlToUnpackedIcon = (url) => ({
      id: `${url}@@${maxIconSize}`,
      url,
      width: maxIconSize,
      height: maxIconSize,
      mask: useMaskedIcons
    });
    let unknownValue = fallbackUrl || FALLBACK_ICON;
    if (range2?.othersMarker) {
      unknownValue = range2.othersMarker;
    }
    const unknownIcon = urlToUnpackedIcon(unknownValue);
    if (!range2 || !field) {
      return () => unknownIcon;
    }
    const mapping = {};
    for (const { value, markerUrl } of range2.markerMap) {
      if (markerUrl) {
        mapping[value] = urlToUnpackedIcon(markerUrl);
      }
    }
    const accessor = (properties) => {
      const propertyValue = properties[field.name];
      return mapping[propertyValue] || unknownIcon;
    };
    return normalizeAccessor(accessor, data);
  }
  function getMaxMarkerSize(visConfig, visualChannels) {
    const { radiusRange, radius } = visConfig;
    const { radiusField, sizeField } = visualChannels;
    const field = radiusField || sizeField;
    return Math.ceil(radiusRange && field ? radiusRange[1] : radius);
  }
  function negateAccessor(accessor) {
    if (typeof accessor === "function") {
      return (d, i) => -accessor(d, i);
    }
    return -accessor;
  }
  function getSizeAccessor({ name }, scaleType, aggregation, range2, data) {
    const scale2 = scaleType ? SCALE_FUNCS[scaleType]() : identity2;
    let domain = [];
    if (scaleType && range2) {
      if (aggregation !== AggregationTypes.Count) {
        domain = calculateDomain(data, name, scaleType);
        scale2.domain(domain);
      } else {
        domain = scale2.domain();
      }
      scale2.range(range2);
    }
    let accessorKeys = getAccessorKeys(name, aggregation);
    const accessor = (properties) => {
      if (!(accessorKeys[0] in properties)) {
        accessorKeys = findAccessorKey(accessorKeys, properties);
      }
      const propertyValue = properties[accessorKeys[0]];
      return scale2(propertyValue);
    };
    return {
      accessor: normalizeAccessor(accessor, data),
      domain,
      scaleDomain: domain,
      range: range2
    };
  }
  var FORMATS = {
    date: formatDate,
    integer: format("i"),
    float: format(".5f"),
    timestamp: formatTimestamp,
    default: String
  };
  function getTextAccessor({ name, type }, data) {
    const format2 = FORMATS[type] || FORMATS.default;
    const accessor = (properties) => {
      return format2(properties[name]);
    };
    return normalizeAccessor(accessor, data);
  }
  function calculateClusterRadius(properties, stats, radiusRange, column) {
    const { min: min2, max: max2 } = stats[column];
    const value = properties[column];
    if (min2 === max2)
      return radiusRange[1];
    const normalizedValue = (value - min2) / (max2 - min2);
    return radiusRange[0] + normalizedValue * (radiusRange[1] - radiusRange[0]);
  }
  function getDefaultAggregationExpColumnAliasForLayerType(layerType, provider, schema) {
    if (schema && layerType === "clusterTile") {
      return getColumnAliasForAggregationExp(
        getDefaultColumnFromSchemaForAggregationExp(schema),
        "count",
        provider
      );
    } else {
      return DEFAULT_AGGREGATION_EXP_ALIAS;
    }
  }
  function getColumnAliasForAggregationExp(name, aggregation, provider) {
    const columnAlias = `${name}_${aggregation}`;
    return provider === "snowflake" ? columnAlias.toUpperCase() : columnAlias;
  }
  function getDefaultColumnFromSchemaForAggregationExp(schema) {
    return schema ? schema[0].name : "";
  }
  function calculateClusterTextFontSize(radius) {
    if (radius >= 80)
      return 24;
    if (radius >= 72)
      return 24;
    if (radius >= 56)
      return 20;
    if (radius >= 40)
      return 16;
    if (radius >= 24)
      return 13;
    if (radius >= 8)
      return 11;
    return 11;
  }
  var UNKNOWN_COLOR2 = [134, 141, 145];
  var RASTER_COLOR_BANDS = ["red", "green", "blue"];
  function getHasDataPredicate(noData) {
    if (noData === "nan") {
      return (v2) => !isNaN(v2);
    }
    if (typeof noData === "string") {
      noData = parseFloat(noData);
    }
    if (typeof noData === "number") {
      return (v2) => v2 !== noData && !isNaN(v2);
    }
    return () => true;
  }
  function createRasterColumnLayerDataTransform(transform) {
    return (data) => {
      if (!data || !("data" in data) || !data?.data?.cells?.numericProps) {
        return data;
      }
      return transform(data);
    };
  }
  function createEvaluationContext(numericProps, noData) {
    const hasData = getHasDataPredicate(noData);
    const bands = Object.entries(numericProps).map(([bandName, { value }]) => ({
      bandName,
      values: value,
      copied: false
    }));
    const length2 = bands[0].values.length;
    for (let i = 0; i < length2; i++) {
      let hasSomeData = false;
      for (let j = 0; j < bands.length; j++) {
        hasSomeData = hasSomeData || hasData(bands[j].values[i]);
      }
      if (!hasSomeData) {
        for (let j = 0; j < bands.length; j++) {
          if (!bands[j].copied) {
            bands[j].copied = true;
            bands[j].values = Array.from(bands[j].values);
          }
          bands[j].values[i] = NaN;
        }
      }
    }
    const context = bands.reduce(
      (agg, { bandName, values }) => {
        agg[bandName] = values;
        return agg;
      },
      {}
    );
    return context;
  }
  function createExprDataTransform({
    colorBand,
    rasterMetadata,
    usedSymbols
  }) {
    if (!colorBand || !colorBand.type || colorBand.type === "none") {
      return void 0;
    }
    const expr = colorBand?.type === "expression" ? colorBand.value : void 0;
    const vecExprEvaluator = expr ? createVecExprEvaluator(expr) : void 0;
    const dataTransform = createRasterColumnLayerDataTransform(
      (dataWrapped) => {
        const data = dataWrapped.data;
        if (expr) {
          const cachedResult = dataWrapped.customExpressionResults?.[expr];
          if (cachedResult) {
            return dataWrapped;
          }
        }
        let context = dataWrapped.expressionEvalContext;
        if (!context) {
          const usedNumericProps = usedSymbols.reduce(
            (acc, symbol) => {
              acc[symbol] = data.cells.numericProps[symbol];
              return acc;
            },
            {}
          );
          context = createEvaluationContext(
            usedNumericProps,
            rasterMetadata.nodata
          );
          dataWrapped = {
            ...dataWrapped,
            expressionEvalContext: context
          };
        }
        if (!vecExprEvaluator || !expr)
          return dataWrapped;
        const evalResult = vecExprEvaluator(context);
        return {
          ...dataWrapped,
          customExpressionResults: {
            ...dataWrapped.customExpressionResults,
            [expr]: evalResult
          }
        };
      }
    );
    return dataTransform;
  }
  function combineDataTransforms(dataTransforms) {
    const actualTransforms = dataTransforms.filter((v2) => v2);
    if (actualTransforms.length === 0)
      return void 0;
    if (actualTransforms.length === 1)
      return actualTransforms[0];
    return (data) => actualTransforms.reduce(
      (aggData, transformFun) => transformFun(aggData),
      data
    );
  }
  function createRgbToColorBufferDataTransform({
    bandDefs,
    attribute
  }) {
    return createRasterColumnLayerDataTransform(
      (dataWrapped) => {
        const length2 = dataWrapped.length;
        const getBandBufferOrValue = (colorBand) => {
          if (colorBand?.type === "expression") {
            return dataWrapped.customExpressionResults?.[colorBand.value];
          }
          if (colorBand?.type === "band") {
            return dataWrapped.expressionEvalContext?.[colorBand.value];
          }
          return 0;
        };
        const red = getBandBufferOrValue(bandDefs.red);
        const green = getBandBufferOrValue(bandDefs.green);
        const blue = getBandBufferOrValue(bandDefs.blue);
        const colorBuffer = new Uint8Array(length2 * 4);
        for (let inputIndex = 0, outputIndex = 0; inputIndex < length2; inputIndex++, outputIndex += 4) {
          const redRaw = typeof red === "number" ? red : red ? red[inputIndex] : NaN;
          const greenRaw = typeof green === "number" ? green : green ? green[inputIndex] : NaN;
          const blueRaw = typeof blue === "number" ? blue : blue ? blue[inputIndex] : NaN;
          if (isNaN(redRaw) && isNaN(greenRaw) && isNaN(blueRaw)) {
            bufferSetRgba(colorBuffer, outputIndex, 0, 0, 0, 0);
          } else {
            bufferSetRgba(
              colorBuffer,
              outputIndex,
              redRaw,
              greenRaw,
              blueRaw,
              255
            );
          }
        }
        dataWrapped.customExpressionResults = void 0;
        dataWrapped.expressionEvalContext = void 0;
        return {
          ...dataWrapped,
          attributes: {
            [attribute]: colorBuffer
          }
        };
      }
    );
  }
  function getUsedSymbols(colorBands) {
    return Array.from(
      colorBands.reduce((symbols, band2) => {
        if (band2.type === "expression") {
          const expressionSymbols = createVecExprEvaluator(band2.value)?.symbols || [];
          expressionSymbols.forEach((symbol) => symbols.add(symbol));
        }
        if (band2.type === "band") {
          symbols.add(band2.value);
        }
        return symbols;
      }, /* @__PURE__ */ new Set())
    );
  }
  function getRasterTileLayerStylePropsRgb({
    layerConfig,
    rasterMetadata,
    visualChannels
  }) {
    const { visConfig } = layerConfig;
    const { colorBands } = visConfig;
    const bandDefs = {
      red: colorBands?.find((band2) => band2.band === "red"),
      green: colorBands?.find((band2) => band2.band === "green"),
      blue: colorBands?.find((band2) => band2.band === "blue")
    };
    const rgbToInstanceFillColorsDataTransform = createRgbToColorBufferDataTransform({
      bandDefs,
      attribute: "instanceFillColors"
    });
    const usedSymbols = colorBands ? getUsedSymbols(colorBands) : [];
    const bandTransforms = RASTER_COLOR_BANDS.map(
      (band2) => createExprDataTransform({
        colorBand: bandDefs[band2],
        rasterMetadata,
        usedSymbols
      })
    );
    const combinedDataTransform = combineDataTransforms([
      ...bandTransforms,
      rgbToInstanceFillColorsDataTransform
    ]);
    return {
      dataTransform: combinedDataTransform,
      updateTriggers: getRasterTileLayerUpdateTriggers({
        layerConfig,
        visualChannels
      })
    };
  }
  function createBandColorScaleDataTransform({
    bandName,
    scaleFun,
    nodata,
    attribute
  }) {
    const hasData = getHasDataPredicate(nodata);
    return createRasterColumnLayerDataTransform(
      (dataWrapped) => {
        const length2 = dataWrapped.length;
        const bandBuffer = dataWrapped.data.cells.numericProps[bandName].value;
        const colorBuffer = new Uint8Array(length2 * 4);
        for (let i = 0; i < length2; i++) {
          const rawValue = bandBuffer[i];
          if (!hasData(rawValue)) {
            bufferSetRgba(colorBuffer, i * 4, 0, 0, 0, 0);
          } else {
            const colorRgb = scaleFun(rawValue);
            bufferSetRgba(
              colorBuffer,
              i * 4,
              colorRgb[0],
              colorRgb[1],
              colorRgb[2],
              255
            );
          }
        }
        return {
          ...dataWrapped,
          attributes: {
            [attribute]: colorBuffer
          }
        };
      }
    );
  }
  function domainFromRasterMetadataBand(band2, scaleType, colorRange) {
    if (scaleType === "ordinal") {
      return colorRange.colorMap?.map(([value]) => value) || [];
    }
    if (scaleType === "custom") {
      if (colorRange.uiCustomScaleType === "logarithmic") {
        return getLog10ScaleSteps({
          min: band2.stats.min,
          max: band2.stats.max,
          steps: colorRange.colors.length
        });
      } else {
        return colorRange.colorMap?.map(([value]) => value) || [];
      }
    }
    const scaleLength = colorRange.colors.length;
    if (scaleType === "quantile") {
      const quantiles = band2.stats.quantiles?.[scaleLength];
      if (!quantiles) {
        return [0, 1];
      }
      return [band2.stats.min, ...quantiles, band2.stats.max];
    }
    return [band2.stats.min, band2.stats.max];
  }
  function getRasterTileLayerStylePropsScaledBand({
    layerConfig,
    rasterMetadata,
    visualChannels
  }) {
    const { visConfig } = layerConfig;
    const { colorField } = visualChannels;
    const { rasterStyleType } = visConfig;
    const colorRange = rasterStyleType === "ColorRange" ? visConfig.colorRange : visConfig.uniqueValuesColorRange;
    const scaleType = rasterStyleType === "ColorRange" ? visualChannels.colorScale : "ordinal";
    const bandInfo = rasterMetadata.bands.find(
      (band2) => band2.name === colorField?.name
    );
    if (!colorField?.name || !scaleType || !colorRange || !bandInfo) {
      return {};
    }
    const domain = domainFromRasterMetadataBand(bandInfo, scaleType, colorRange);
    const scaleFun = createColorScale(
      scaleType,
      domain,
      colorRange.colors.map(hexToRGB2),
      UNKNOWN_COLOR2
    );
    const bandColorScaleDataTransform = createBandColorScaleDataTransform({
      bandName: bandInfo.name,
      scaleFun,
      nodata: bandInfo?.nodata ?? rasterMetadata.nodata,
      attribute: "instanceFillColors"
    });
    return {
      dataTransform: bandColorScaleDataTransform,
      updateTriggers: getRasterTileLayerUpdateTriggers({
        layerConfig,
        visualChannels
      })
    };
  }
  function getRasterTileLayerUpdateTriggers({
    layerConfig,
    visualChannels
  }) {
    const { visConfig } = layerConfig;
    const { rasterStyleType } = visConfig;
    const getFillColorUpdateTriggers = {
      rasterStyleType
    };
    if (rasterStyleType === "ColorRange") {
      getFillColorUpdateTriggers.colorRange = visConfig.colorRange?.colors;
      getFillColorUpdateTriggers.colorMap = visConfig.colorRange?.colorMap;
      getFillColorUpdateTriggers.colorScale = visualChannels.colorScale;
      getFillColorUpdateTriggers.colorFieldId = visualChannels.colorField?.name;
    } else if (rasterStyleType === "UniqueValues") {
      getFillColorUpdateTriggers.colorMap = visConfig.uniqueValuesColorRange?.colorMap;
      getFillColorUpdateTriggers.colorFieldId = visualChannels.colorField?.name;
    } else if (rasterStyleType === "Rgb") {
      getFillColorUpdateTriggers.colorBands = visConfig.colorBands;
    }
    return {
      getFillColor: getFillColorUpdateTriggers
    };
  }
  function bufferSetRgba(target, index2, r, g, b, a) {
    target[index2 + 0] = r;
    target[index2 + 1] = g;
    target[index2 + 2] = b;
    target[index2 + 3] = a;
  }
  function hexToRGB2(hexColor) {
    const r = parseInt(hexColor.slice(1, 3), 16);
    const g = parseInt(hexColor.slice(3, 5), 16);
    const b = parseInt(hexColor.slice(5, 7), 16);
    return [r, g, b];
  }
  function getLayerDescriptor({
    mapConfig,
    layer,
    dataset
  }) {
    const { filters, visState } = mapConfig;
    const { layerBlending, interactionConfig } = visState;
    const { id: id5, type, config: config2, visualChannels } = layer;
    const { data, id: datasetId } = dataset;
    const { propMap, defaultProps: defaultProps22 } = getLayerProps(type, config2, dataset);
    const styleProps = createStyleProps(config2, propMap);
    const { channelProps, scales } = createChannelProps(
      id5,
      type,
      config2,
      visualChannels,
      data,
      dataset
    );
    const layerDescriptor = {
      type,
      filters: isEmptyObject(filters) || isRemoteCalculationSupported(dataset) ? void 0 : filters[datasetId],
      props: {
        id: id5,
        data,
        ...defaultProps22,
        ...createInteractionProps(interactionConfig),
        ...styleProps,
        ...channelProps,
        ...createParametersProp(layerBlending, styleProps.parameters || {}),
        // Must come after style
        ...createLoadOptions(data.accessToken)
      },
      scales
    };
    return layerDescriptor;
  }
  function parseMap(json) {
    const { keplerMapConfig, datasets, token } = json;
    assert22(keplerMapConfig.version === "v1", "Only support Kepler v1");
    const mapConfig = keplerMapConfig.config;
    const { mapState, mapStyle, popupSettings, legendSettings, visState } = mapConfig;
    const { layers } = visState;
    const layersReverse = [...layers].reverse();
    return {
      id: json.id,
      title: json.title,
      description: json.description,
      createdAt: json.createdAt,
      updatedAt: json.updatedAt,
      initialViewState: mapState,
      /** @deprecated Use `basemap`. */
      mapStyle,
      popupSettings,
      legendSettings,
      token,
      layers: layersReverse.map((layer) => {
        try {
          const { dataId } = layer.config;
          const dataset = datasets.find(
            (d) => d.id === dataId
          );
          assert22(dataset, `No dataset matching dataId: ${dataId}`);
          const layerDescriptor = getLayerDescriptor({
            mapConfig,
            layer,
            dataset
          });
          return layerDescriptor;
        } catch (e) {
          console.error(e.message);
          return void 0;
        }
      })
    };
  }
  function createParametersProp(layerBlending, parameters) {
    if (layerBlending === "additive") {
      parameters.blendColorSrcFactor = parameters.blendAlphaSrcFactor = "src-alpha";
      parameters.blendColorDstFactor = parameters.blendAlphaDstFactor = "dst-alpha";
      parameters.blendColorOperation = parameters.blendAlphaOperation = "add";
    } else if (layerBlending === "subtractive") {
      parameters.blendColorSrcFactor = "one";
      parameters.blendColorDstFactor = "one-minus-dst-color";
      parameters.blendAlphaSrcFactor = "src-alpha";
      parameters.blendAlphaDstFactor = "dst-alpha";
      parameters.blendColorOperation = "subtract";
      parameters.blendAlphaOperation = "add";
    }
    return Object.keys(parameters).length ? { parameters } : {};
  }
  function createInteractionProps(interactionConfig) {
    const pickable = interactionConfig && interactionConfig.tooltip.enabled;
    return {
      autoHighlight: pickable,
      pickable
    };
  }
  function mapProps(source, target, mapping) {
    for (const sourceKey in mapping) {
      const sourceValue = source[sourceKey];
      const targetKey = mapping[sourceKey];
      if (sourceValue === void 0) {
        continue;
      }
      if (typeof targetKey === "string") {
        target[targetKey] = sourceValue;
      } else if (typeof targetKey === "function") {
        const [key, value] = Object.entries(targetKey(sourceValue))[0];
        target[key] = value;
      } else if (typeof targetKey === "object") {
        mapProps(sourceValue, target, targetKey);
      }
    }
  }
  function createStyleProps(config2, mapping) {
    const result = {};
    mapProps(config2, result, mapping);
    if (result.stroked && !result.getLineColor) {
      result.getLineColor = result.getFillColor;
    }
    for (const colorAccessor in OPACITY_MAP) {
      if (Array.isArray(result[colorAccessor])) {
        const color22 = [...result[colorAccessor]];
        const opacityKey = OPACITY_MAP[colorAccessor];
        const opacity = config2.visConfig[opacityKey];
        color22[3] = opacityToAlpha(opacity);
        result[colorAccessor] = color22;
      }
    }
    result.highlightColor = config2.visConfig.enable3d ? [255, 255, 255, 60] : [252, 242, 26, 255];
    return result;
  }
  function createChannelProps(id5, layerType, config2, visualChannels, data, dataset) {
    if (layerType === "raster") {
      const rasterMetadata = data.raster_metadata;
      if (!rasterMetadata) {
        return {
          channelProps: {},
          scales: {}
        };
      }
      const rasterStyleType = config2.visConfig.rasterStyleType;
      if (rasterStyleType === "Rgb") {
        return {
          channelProps: getRasterTileLayerStylePropsRgb({
            layerConfig: config2,
            rasterMetadata,
            visualChannels
          }),
          scales: {}
          // TODO
        };
      } else {
        return {
          channelProps: getRasterTileLayerStylePropsScaledBand({
            layerConfig: config2,
            visualChannels,
            rasterMetadata
          }),
          scales: {
            // TODO
          }
        };
      }
    }
    const { textLabel, visConfig } = config2;
    const result = {};
    const updateTriggers = {};
    const scales = {};
    {
      const { colorField, colorScale } = visualChannels;
      const { colorRange, colorAggregation } = visConfig;
      if (colorField && colorScale && colorRange) {
        const { accessor, ...scaleProps } = getColorAccessor(
          colorField,
          colorScale,
          { aggregation: colorAggregation, range: colorRange },
          visConfig.opacity,
          data
        );
        result.getFillColor = accessor;
        scales.fillColor = updateTriggers.getFillColor = {
          field: colorField,
          type: colorScale,
          ...scaleProps
        };
      } else {
        scales.fillColor = {};
      }
    }
    if (layerType === "clusterTile") {
      const aggregationExpAlias = getDefaultAggregationExpColumnAliasForLayerType(
        layerType,
        dataset.providerId,
        data.schema
      );
      result.pointType = visConfig.isTextVisible ? "circle+text" : "circle";
      result.clusterLevel = visConfig.clusterLevel;
      result.getWeight = (d) => {
        return d.properties[aggregationExpAlias];
      };
      updateTriggers.getWeight = aggregationExpAlias;
      result.getPointRadius = (d, info) => {
        return calculateClusterRadius(
          d.properties,
          info.data.attributes.stats,
          visConfig.radiusRange,
          aggregationExpAlias
        );
      };
      updateTriggers.getPointRadius = {
        aggregationExpAlias,
        radiusRange: visConfig.radiusRange
      };
      result.textCharacterSet = "auto";
      result.textFontFamily = "Inter, sans";
      result.textFontSettings = { sdf: true };
      result.textFontWeight = 600;
      result.getText = (d) => TEXT_NUMBER_FORMATTER.format(d.properties[aggregationExpAlias]);
      updateTriggers.getText = aggregationExpAlias;
      result.getTextColor = config2.textLabel[TEXT_LABEL_INDEX].color;
      result.textOutlineColor = [
        ...config2.textLabel[TEXT_LABEL_INDEX].outlineColor,
        TEXT_OUTLINE_OPACITY
      ];
      result.textOutlineWidth = 5;
      result.textSizeUnits = "pixels";
      result.getTextSize = (d, info) => {
        const radius = calculateClusterRadius(
          d.properties,
          info.data.attributes.stats,
          visConfig.radiusRange,
          aggregationExpAlias
        );
        return calculateClusterTextFontSize(radius);
      };
      updateTriggers.getTextSize = {
        aggregationExpAlias,
        radiusRange: visConfig.radiusRange
      };
    }
    {
      const radiusRange = visConfig.radiusRange;
      const { radiusField, radiusScale } = visualChannels;
      if (radiusField && radiusRange && radiusScale) {
        const { accessor, ...scaleProps } = getSizeAccessor(
          radiusField,
          radiusScale,
          visConfig.radiusAggregation,
          radiusRange,
          data
        );
        result.getPointRadius = accessor;
        scales.pointRadius = updateTriggers.getPointRadius = {
          field: radiusField,
          type: radiusScale,
          ...scaleProps
        };
      }
    }
    {
      const strokeColorRange = visConfig.strokeColorRange;
      const { strokeColorScale, strokeColorField } = visualChannels;
      if (strokeColorField && strokeColorRange && strokeColorScale) {
        const { strokeColorAggregation: aggregation } = visConfig;
        const opacity = visConfig.strokeOpacity !== void 0 ? visConfig.strokeOpacity : 1;
        const { accessor, ...scaleProps } = getColorAccessor(
          strokeColorField,
          strokeColorScale,
          { aggregation, range: strokeColorRange },
          opacity,
          data
        );
        result.getLineColor = accessor;
        scales.lineColor = updateTriggers.getLineColor = {
          field: strokeColorField,
          type: strokeColorScale,
          ...scaleProps
        };
      }
    }
    {
      const { sizeField: strokeWidthField, sizeScale: strokeWidthScale } = visualChannels;
      const { sizeRange, sizeAggregation } = visConfig;
      if (strokeWidthField && sizeRange) {
        const { accessor, ...scaleProps } = getSizeAccessor(
          strokeWidthField,
          strokeWidthScale,
          sizeAggregation,
          sizeRange,
          data
        );
        result.getLineWidth = accessor;
        scales.lineWidth = updateTriggers.getLineWidth = {
          field: strokeWidthField,
          type: strokeWidthScale || "identity",
          ...scaleProps
        };
      }
    }
    {
      const { enable3d, heightRange } = visConfig;
      const { heightField, heightScale } = visualChannels;
      if (heightField && heightRange && enable3d) {
        const { accessor, ...scaleProps } = getSizeAccessor(
          heightField,
          heightScale,
          visConfig.heightAggregation,
          heightRange,
          data
        );
        result.getElevation = accessor;
        scales.elevation = updateTriggers.getElevation = {
          field: heightField,
          type: heightScale || "identity",
          ...scaleProps
        };
      }
    }
    {
      const { weightField } = visualChannels;
      const { weightAggregation } = visConfig;
      if (weightField && weightAggregation) {
        const { accessor, ...scaleProps } = getSizeAccessor(
          weightField,
          void 0,
          weightAggregation,
          void 0,
          data
        );
        result.getWeight = accessor;
        scales.weight = updateTriggers.getWeight = {
          field: weightField,
          type: "identity",
          ...scaleProps
        };
      }
    }
    if (visConfig.customMarkers) {
      const maxIconSize = getMaxMarkerSize(visConfig, visualChannels);
      const { getPointRadius, getFillColor } = result;
      const {
        customMarkersUrl,
        customMarkersRange,
        filled: useMaskedIcons
      } = visConfig;
      result.pointType = "icon";
      result.getIcon = getIconUrlAccessor(
        visualChannels.customMarkersField,
        customMarkersRange,
        { fallbackUrl: customMarkersUrl, maxIconSize, useMaskedIcons },
        data
      );
      updateTriggers.getIcon = {
        customMarkersUrl,
        customMarkersRange,
        maxIconSize,
        useMaskedIcons
      };
      result._subLayerProps = {
        "points-icon": {
          loadOptions: {
            image: {
              type: "imagebitmap"
            },
            imagebitmap: {
              resizeWidth: maxIconSize,
              resizeHeight: maxIconSize,
              resizeQuality: "high"
            }
          }
        }
      };
      if (getFillColor && useMaskedIcons) {
        result.getIconColor = getFillColor;
        updateTriggers.getIconColor = updateTriggers.getFillColor;
      }
      if (getPointRadius) {
        result.getIconSize = getPointRadius;
        updateTriggers.getIconSize = updateTriggers.getPointRadius;
      }
      if (visualChannels.rotationField) {
        const { accessor } = getSizeAccessor(
          visualChannels.rotationField,
          void 0,
          null,
          void 0,
          data
        );
        result.getIconAngle = negateAccessor(accessor);
        updateTriggers.getIconAngle = updateTriggers.getRotationField;
      }
    } else if (layerType === "tileset") {
      result.pointType = "circle";
    }
    if (textLabel && textLabel.length && textLabel[0].field) {
      const [mainLabel, secondaryLabel] = textLabel;
      const collisionGroup = id5;
      ({
        alignment: result.getTextAlignmentBaseline,
        anchor: result.getTextAnchor,
        color: result.getTextColor,
        outlineColor: result.textOutlineColor,
        size: result.textSizeScale
      } = mainLabel);
      const {
        color: getSecondaryColor,
        field: secondaryField,
        outlineColor: secondaryOutlineColor,
        size: secondarySizeScale
      } = secondaryLabel || {};
      result.getText = mainLabel.field && getTextAccessor(mainLabel.field, data);
      const getSecondaryText = secondaryField && getTextAccessor(secondaryField, data);
      result.pointType = `${result.pointType}+text`;
      result.textCharacterSet = "auto";
      result.textFontFamily = "Inter, sans";
      result.textFontSettings = { sdf: true };
      result.textFontWeight = 600;
      result.textOutlineWidth = 3;
      result._subLayerProps = {
        ...result._subLayerProps,
        "points-text": {
          collisionEnabled: true,
          collisionGroup,
          // getPointRadius already has radiusScale baked in, so only pass one or the other
          ...result.getPointRadius ? { getRadius: result.getPointRadius } : { radiusScale: visConfig.radius },
          ...secondaryField && {
            getSecondaryText,
            getSecondaryColor,
            secondarySizeScale,
            secondaryOutlineColor
          }
        }
      };
    }
    return {
      channelProps: {
        ...result,
        updateTriggers
      },
      scales
    };
  }
  function createLoadOptions(accessToken) {
    return {
      loadOptions: { fetch: { headers: { Authorization: `Bearer ${accessToken}` } } }
    };
  }
  var CUSTOM_STYLE_ID_PREFIX = "custom:";
  var DEFAULT_CARTO_STYLE = "positron";
  function mapLibreViewpros(config2) {
    const { longitude, latitude, ...rest } = config2.mapState;
    return {
      center: [longitude, latitude],
      ...rest
    };
  }
  async function fetchBasemapProps({
    config: config2,
    errorContext,
    applyLayerFilters = true
  }) {
    const { mapStyle } = config2;
    const styleType = mapStyle.styleType || DEFAULT_CARTO_STYLE;
    if (styleType.startsWith(CUSTOM_STYLE_ID_PREFIX)) {
      const currentCustomStyle = config2.customBaseMaps?.customStyle;
      if (currentCustomStyle) {
        return {
          type: "maplibre",
          props: {
            style: currentCustomStyle.style || currentCustomStyle.url,
            ...mapLibreViewpros(config2)
          },
          attribution: currentCustomStyle.customAttribution
        };
      }
    }
    if (CARTO_MAP_STYLES.includes(styleType)) {
      const { visibleLayerGroups } = mapStyle;
      const styleUrl = getStyleUrl(styleType);
      let style = styleUrl;
      let rawStyle = styleUrl;
      if (applyLayerFilters && visibleLayerGroups && someLayerGroupsDisabled(visibleLayerGroups)) {
        rawStyle = await fetchStyle({ styleUrl, errorContext });
        style = applyLayerGroupFilters(rawStyle, visibleLayerGroups);
      }
      return {
        type: "maplibre",
        props: {
          style,
          ...mapLibreViewpros(config2)
        },
        visibleLayerGroups,
        rawStyle
      };
    }
    const googleBasemapDef = GOOGLE_BASEMAPS[styleType];
    if (googleBasemapDef) {
      const { mapState } = config2;
      return {
        type: "google-maps",
        props: {
          ...googleBasemapDef,
          center: { lat: mapState.latitude, lng: mapState.longitude },
          zoom: mapState.zoom + 1,
          tilt: mapState.pitch,
          heading: mapState.bearing
        }
      };
    }
    return {
      type: "maplibre",
      props: {
        style: getStyleUrl(DEFAULT_CARTO_STYLE),
        ...mapLibreViewpros(config2)
      }
    };
  }
  function configureSource({
    dataset,
    filters,
    options
  }) {
    const {
      geoColumn,
      columns,
      type,
      source,
      queryParameters,
      aggregationExp,
      aggregationResLevel: originalAggregationResLevel
    } = dataset;
    const sourceOptions = getSourceOptions(options);
    const spatialDataColumn = getColumnNameFromGeoColumn(geoColumn) || void 0;
    const spatialIndex = geoColumn ? getSpatialIndexFromGeoColumn(geoColumn) : void 0;
    const tileResolution = getDynamicTileResolution(spatialIndex);
    const isH3 = spatialIndex === "h3";
    const isQuadbin = spatialIndex === "quadbin";
    let aggregationResLevel = originalAggregationResLevel;
    if (typeof originalAggregationResLevel !== "number" && isH3) {
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_H3;
    } else if (typeof originalAggregationResLevel !== "number" && isQuadbin) {
      aggregationResLevel = DEFAULT_AGGREGATION_RES_LEVEL_QUADBIN;
    }
    const spatialIndexOptions = {
      aggregationExp: !aggregationExp ? DEFAULT_AGGREGATION_EXP : aggregationExp,
      aggregationResLevel: scaleAggregationResLevel(
        aggregationResLevel,
        tileResolution
      ),
      spatialDataColumn,
      ...filters && { filters }
    };
    const tilesetOptions = {
      ...sourceOptions,
      tableName: source
    };
    const tableOptions = {
      ...sourceOptions,
      tableName: source,
      tileResolution
    };
    const queryOptions = {
      ...sourceOptions,
      sqlQuery: source,
      tileResolution,
      ...queryParameters && { queryParameters }
    };
    const vectorOptions = {
      spatialDataColumn,
      ...columns && { columns },
      ...filters && { filters },
      ...aggregationExp && { aggregationExp }
    };
    if (type === "raster") {
      return rasterSource({
        ...sourceOptions,
        tableName: source,
        ...filters && { filters }
      });
    }
    if (type === "tileset") {
      return vectorTilesetSource({ ...tilesetOptions });
    }
    if (type === "table") {
      if (isH3) {
        return h3TableSource({
          ...tableOptions,
          ...spatialIndexOptions
        });
      } else if (isQuadbin) {
        return quadbinTableSource({
          ...tableOptions,
          ...spatialIndexOptions
        });
      } else {
        return vectorTableSource({
          ...tableOptions,
          ...vectorOptions
        });
      }
    }
    if (type === "query") {
      if (isH3) {
        return h3QuerySource({
          ...queryOptions,
          ...spatialIndexOptions
        });
      } else if (isQuadbin) {
        return quadbinQuerySource({
          ...queryOptions,
          ...spatialIndexOptions
        });
      } else {
        return vectorQuerySource({
          ...queryOptions,
          ...vectorOptions
        });
      }
    }
    throw new Error(`Invalid source type: ${type}`);
  }
  function getSourceOptions({
    accessToken,
    apiBaseUrl,
    connection,
    headers,
    maxLengthURL
  }) {
    return {
      accessToken,
      connectionName: connection,
      apiBaseUrl,
      headers,
      maxLengthURL,
      ...headers?.["Cache-Control"]?.includes("no-cache") && {
        localCache: {
          cacheControl: ["no-cache"]
        }
      }
    };
  }
  function getDynamicTileResolution(spatialIndex) {
    if (spatialIndex !== "h3") {
      return REDUCED_QUERIES_TILE_RESOLUTION;
    }
    return DEFAULT_TILE_RESOLUTION;
  }
  function scaleAggregationResLevel(aggregationResLevel, tileResolution) {
    if (typeof aggregationResLevel !== "number")
      return;
    return aggregationResLevel - Math.log2(0.5 / tileResolution);
  }
  function getColumnNameFromGeoColumn(geoColumn) {
    if (!geoColumn) {
      return geoColumn;
    }
    const parts = geoColumn.split(":");
    return parts.length === 1 ? parts[0] : parts.length === 2 ? parts[1] : null;
  }
  function getSpatialIndexFromGeoColumn(geoColumn) {
    const spatialIndexToSearch = geoColumn.split(":")[0];
    for (const index2 of Object.values(SpatialIndex)) {
      if (SpatialIndexColumn[index2].includes(spatialIndexToSearch)) {
        return index2;
      }
    }
    return null;
  }
  async function _fetchMapDataset(dataset, filters, context) {
    const { connectionName } = dataset;
    const cache = {};
    const configuredSource = configureSource({
      dataset,
      filters: isRemoteCalculationSupported(dataset) ? filters : void 0,
      options: {
        ...context,
        connection: connectionName,
        headers: context.headers,
        accessToken: context.accessToken,
        apiBaseUrl: context.apiBaseUrl,
        maxLengthURL: context.maxLengthURL
      }
    });
    dataset.data = await configuredSource;
    let cacheChanged = true;
    if (cache.value) {
      cacheChanged = dataset.cache !== cache.value;
      dataset.cache = cache.value;
    }
    return cacheChanged;
  }
  async function _fetchTilestats(attribute, dataset, context) {
    const { connectionName, data, id: id5, source, type, queryParameters } = dataset;
    const { apiBaseUrl } = context;
    const errorContext = {
      requestType: "Tile stats",
      connection: connectionName,
      type,
      source
    };
    if (!("tilestats" in data)) {
      throw new CartoAPIError(
        new Error(`Invalid dataset for tilestats: ${id5}`),
        errorContext
      );
    }
    const baseUrl = buildStatsUrl({ attribute, apiBaseUrl, ...dataset });
    const client2 = new URLSearchParams(data.tiles[0]).get("client");
    const headers = { Authorization: `Bearer ${context.accessToken}` };
    const parameters = {};
    if (client2) {
      parameters.client = client2;
    }
    if (type === "query") {
      parameters.q = source;
      if (queryParameters) {
        parameters.queryParameters = JSON.stringify(queryParameters);
      }
    }
    const stats = await requestWithParameters({
      baseUrl,
      headers,
      parameters,
      errorContext,
      maxLengthURL: context.maxLengthURL
    });
    const { attributes } = data.tilestats.layers[0];
    const index2 = attributes.findIndex((d) => d.attribute === attribute);
    attributes[index2] = stats;
    return true;
  }
  async function fillInMapDatasets({ datasets, keplerMapConfig }, context) {
    const { filters } = keplerMapConfig.config;
    const promises = datasets.map(
      (dataset) => _fetchMapDataset(dataset, filters[dataset.id], context)
    );
    return await Promise.all(promises);
  }
  async function fillInTileStats({ datasets, keplerMapConfig }, context) {
    const attributes = [];
    const { layers } = keplerMapConfig.config.visState;
    for (const layer of layers) {
      for (const channel of Object.keys(layer.visualChannels)) {
        const attribute = layer.visualChannels[channel]?.name;
        if (attribute) {
          const dataset = datasets.find((d) => d.id === layer.config.dataId);
          if (dataset && dataset.type !== "tileset" && dataset.data.tilestats) {
            attributes.push({ attribute, dataset });
          }
        }
      }
    }
    const filteredAttributes = [];
    for (const a of attributes) {
      if (!filteredAttributes.find(
        ({ attribute, dataset }) => attribute === a.attribute && dataset === a.dataset
      )) {
        filteredAttributes.push(a);
      }
    }
    const promises = filteredAttributes.map(
      ({ attribute, dataset }) => _fetchTilestats(attribute, dataset, context)
    );
    return await Promise.all(promises);
  }
  async function fetchMap({
    accessToken,
    apiBaseUrl = DEFAULT_API_BASE_URL,
    cartoMapId,
    clientId,
    headers,
    autoRefresh,
    onNewData,
    maxLengthURL
  }) {
    assert22(
      cartoMapId,
      'Must define CARTO map id: fetchMap({cartoMapId: "XXXX-XXXX-XXXX"})'
    );
    if (accessToken) {
      headers = { Authorization: `Bearer ${accessToken}`, ...headers };
    }
    if (autoRefresh || onNewData) {
      assert22(onNewData, "Must define `onNewData` when using autoRefresh");
      assert22(typeof onNewData === "function", "`onNewData` must be a function");
      assert22(
        typeof autoRefresh === "number" && autoRefresh > 0,
        "`autoRefresh` must be a positive number"
      );
    }
    const baseUrl = buildPublicMapUrl({ apiBaseUrl, cartoMapId });
    const errorContext = {
      requestType: "Public map",
      mapId: cartoMapId
    };
    const map2 = await requestWithParameters({
      baseUrl,
      headers,
      errorContext,
      maxLengthURL
    });
    const context = {
      accessToken: map2.token || accessToken,
      apiBaseUrl,
      clientId,
      headers,
      maxLengthURL
    };
    let stopAutoRefresh;
    if (autoRefresh) {
      const intervalId = setInterval(async () => {
        const changed = await fillInMapDatasets(map2, {
          ...context,
          headers: {
            ...headers,
            "If-Modified-Since": (/* @__PURE__ */ new Date()).toUTCString()
          }
        });
        if (onNewData && changed.some((v2) => v2 === true)) {
          onNewData(parseMap(map2));
        }
      }, autoRefresh * 1e3);
      stopAutoRefresh = () => {
        clearInterval(intervalId);
      };
    }
    const geojsonLayers = map2.keplerMapConfig.config.visState.layers.filter(
      ({ type }) => type === "geojson" || type === "point"
    );
    const geojsonDatasetIds = geojsonLayers.map(
      ({ config: config2 }) => config2.dataId
    );
    map2.datasets.forEach((dataset) => {
      if (geojsonDatasetIds.includes(dataset.id)) {
        const { config: config2 } = geojsonLayers.find(
          ({ config: config3 }) => config3.dataId === dataset.id
        );
        dataset.format = "geojson";
        if (!dataset.geoColumn && config2.columns.geojson) {
          dataset.geoColumn = config2.columns.geojson;
        }
      }
    });
    const [basemap] = await Promise.all([
      fetchBasemapProps({ config: map2.keplerMapConfig.config, errorContext }),
      // Mutates map.datasets so that dataset.data contains data
      fillInMapDatasets(map2, context)
    ]);
    await fillInTileStats(map2, context);
    const out = { ...parseMap(map2), basemap, ...{ stopAutoRefresh } };
    const textLayers = out.layers.filter((layer) => {
      const pointType = layer.props?.pointType || "";
      return pointType.includes("text");
    });
    if (textLayers.length && window.FontFace && !document.fonts.check("12px Inter")) {
      const font = new FontFace(
        "Inter",
        "url(https://fonts.gstatic.com/s/inter/v12/UcC73FwrK3iLTeHuS_fvQtMwCp50KnMa1ZL7W0Q5nw.woff2)"
      );
      await font.load().then((f) => document.fonts.add(f));
    }
    return out;
  }
  var EMPTY_U32 = 2 ** 32 - 1;

  // src/basemap.ts
  var cartoStyleUrlTemplate2 = "https://basemaps.cartocdn.com/gl/{basemap}-gl-style/style.json";
  var CARTO_MAP_STYLES2 = ["positron", "dark-matter", "voyager"];
  var GOOGLE_BASEMAPS2 = {
    roadmap: {
      mapTypeId: "roadmap",
      mapId: "3754c817b510f791"
    },
    "google-positron": {
      mapTypeId: "roadmap",
      mapId: "ea84ae4203ef21cd"
    },
    "google-dark-matter": {
      mapTypeId: "roadmap",
      mapId: "2fccc3b36c22a0e2"
    },
    "google-voyager": {
      mapTypeId: "roadmap",
      mapId: "885caf1e15bb9ef2"
    },
    satellite: {
      mapTypeId: "satellite"
    },
    hybrid: {
      mapTypeId: "hybrid"
    },
    terrain: {
      mapTypeId: "terrain"
    }
  };
  var STYLE_LAYER_GROUPS2 = [
    {
      slug: "label",
      filter: ({ id: id5 }) => Boolean(
        id5.match(/(?=(label|_label|place-|place_|poi-|poi_|watername_|roadname_|housenumber))/)
      ),
      defaultVisibility: true
    },
    {
      slug: "road",
      filter: ({ id: id5 }) => Boolean(id5.match(/(?=(road|railway|tunnel|street|bridge))(?!.*label)/)),
      defaultVisibility: true
    },
    {
      slug: "border",
      filter: ({ id: id5 }) => Boolean(id5.match(/border|boundaries|boundary_/)),
      defaultVisibility: false
    },
    {
      slug: "building",
      filter: ({ id: id5 }) => Boolean(id5.match(/building/)),
      defaultVisibility: true
    },
    {
      slug: "water",
      filter: ({ id: id5 }) => Boolean(id5.match(/(?=(water|stream|ferry))/)),
      defaultVisibility: true
    },
    {
      slug: "land",
      filter: ({ id: id5 }) => Boolean(id5.match(/(?=(parks|landcover|industrial|sand|hillshade|park_))/)),
      defaultVisibility: true
    }
  ];
  function applyLayerGroupFilters2(style, visibleLayerGroups) {
    if (!Array.isArray(style?.layers)) {
      return style;
    }
    const removedLayerFilters = STYLE_LAYER_GROUPS2.filter((lg) => !visibleLayerGroups[lg.slug]).map(
      (lg) => lg.filter
    );
    const visibleLayers = style.layers.filter(
      (layer) => removedLayerFilters.every((match) => !match(layer))
    );
    return {
      ...style,
      layers: visibleLayers
    };
  }
  function someLayerGroupsDisabled2(visibleLayerGroups) {
    return visibleLayerGroups && Object.values(visibleLayerGroups).every(Boolean) === false;
  }
  function getStyleUrl2(styleType) {
    return cartoStyleUrlTemplate2.replace("{basemap}", styleType);
  }
  async function fetchStyle2({
    styleUrl,
    errorContext
  }) {
    let response;
    return await fetch(styleUrl, { mode: "cors" }).then((res) => {
      response = res;
      return res.json();
    }).catch((error) => {
      throw new CartoAPIError(error, { ...errorContext, requestType: "Basemap style" }, response);
    });
  }
  var basemap_default = {
    VOYAGER: getStyleUrl2("voyager"),
    POSITRON: getStyleUrl2("positron"),
    DARK_MATTER: getStyleUrl2("dark-matter"),
    VOYAGER_NOLABELS: getStyleUrl2("voyager-nolabels"),
    POSITRON_NOLABELS: getStyleUrl2("positron-nolabels"),
    DARK_MATTER_NOLABELS: getStyleUrl2("dark-matter-nolabels")
  };

  // ../../node_modules/cartocolor/dist/cartocolor.js
  var cartocolor_exports = {};
  __export(cartocolor_exports, {
    Antique: () => Antique,
    ArmyRose: () => ArmyRose,
    BluGrn: () => BluGrn,
    BluYl: () => BluYl,
    Bold: () => Bold,
    BrwnYl: () => BrwnYl,
    Burg: () => Burg,
    BurgYl: () => BurgYl,
    DarkMint: () => DarkMint,
    Earth: () => Earth,
    Emrld: () => Emrld,
    Fall: () => Fall,
    Geyser: () => Geyser,
    Magenta: () => Magenta,
    Mint: () => Mint,
    OrYel: () => OrYel,
    Pastel: () => Pastel,
    Peach: () => Peach,
    PinkYl: () => PinkYl,
    Prism: () => Prism,
    Purp: () => Purp,
    PurpOr: () => PurpOr,
    RedOr: () => RedOr,
    Safe: () => Safe,
    Sunset: () => Sunset,
    SunsetDark: () => SunsetDark,
    Teal: () => Teal,
    TealGrn: () => TealGrn,
    TealRose: () => TealRose,
    Temps: () => Temps,
    Tropic: () => Tropic,
    Vivid: () => Vivid,
    ag_GrnYl: () => ag_GrnYl,
    ag_Sunset: () => ag_Sunset,
    cb_Accent: () => cb_Accent,
    cb_Blues: () => cb_Blues,
    cb_BrBG: () => cb_BrBG,
    cb_BuGn: () => cb_BuGn,
    cb_BuPu: () => cb_BuPu,
    cb_Dark2: () => cb_Dark2,
    cb_GnBu: () => cb_GnBu,
    cb_Greens: () => cb_Greens,
    cb_Greys: () => cb_Greys,
    cb_OrRd: () => cb_OrRd,
    cb_Oranges: () => cb_Oranges,
    cb_PRGn: () => cb_PRGn,
    cb_Paired: () => cb_Paired,
    cb_Pastel1: () => cb_Pastel1,
    cb_Pastel2: () => cb_Pastel2,
    cb_PiYG: () => cb_PiYG,
    cb_PuBu: () => cb_PuBu,
    cb_PuBuGn: () => cb_PuBuGn,
    cb_PuOr: () => cb_PuOr,
    cb_PuRd: () => cb_PuRd,
    cb_Purples: () => cb_Purples,
    cb_RdBu: () => cb_RdBu,
    cb_RdGy: () => cb_RdGy,
    cb_RdPu: () => cb_RdPu,
    cb_RdYlBu: () => cb_RdYlBu,
    cb_RdYlGn: () => cb_RdYlGn,
    cb_Reds: () => cb_Reds,
    cb_Set1: () => cb_Set1,
    cb_Set2: () => cb_Set2,
    cb_Set3: () => cb_Set3,
    cb_Spectral: () => cb_Spectral,
    cb_YlGn: () => cb_YlGn,
    cb_YlGnBu: () => cb_YlGnBu,
    cb_YlOrBr: () => cb_YlOrBr,
    cb_YlOrRd: () => cb_YlOrRd
  });

  // ../../node_modules/colorbrewer/index.es.js
  var index = {
    schemeGroups: {
      sequential: ["BuGn", "BuPu", "GnBu", "OrRd", "PuBu", "PuBuGn", "PuRd", "RdPu", "YlGn", "YlGnBu", "YlOrBr", "YlOrRd"],
      singlehue: ["Blues", "Greens", "Greys", "Oranges", "Purples", "Reds"],
      diverging: ["BrBG", "PiYG", "PRGn", "PuOr", "RdBu", "RdGy", "RdYlBu", "RdYlGn", "Spectral"],
      qualitative: ["Accent", "Dark2", "Paired", "Pastel1", "Pastel2", "Set1", "Set2", "Set3"]
    },
    YlGn: {
      3: ["#f7fcb9", "#addd8e", "#31a354"],
      4: ["#ffffcc", "#c2e699", "#78c679", "#238443"],
      5: ["#ffffcc", "#c2e699", "#78c679", "#31a354", "#006837"],
      6: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#31a354", "#006837"],
      7: ["#ffffcc", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
      8: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#005a32"],
      9: ["#ffffe5", "#f7fcb9", "#d9f0a3", "#addd8e", "#78c679", "#41ab5d", "#238443", "#006837", "#004529"]
    },
    YlGnBu: {
      3: ["#edf8b1", "#7fcdbb", "#2c7fb8"],
      4: ["#ffffcc", "#a1dab4", "#41b6c4", "#225ea8"],
      5: ["#ffffcc", "#a1dab4", "#41b6c4", "#2c7fb8", "#253494"],
      6: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#2c7fb8", "#253494"],
      7: ["#ffffcc", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
      8: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#0c2c84"],
      9: ["#ffffd9", "#edf8b1", "#c7e9b4", "#7fcdbb", "#41b6c4", "#1d91c0", "#225ea8", "#253494", "#081d58"]
    },
    GnBu: {
      3: ["#e0f3db", "#a8ddb5", "#43a2ca"],
      4: ["#f0f9e8", "#bae4bc", "#7bccc4", "#2b8cbe"],
      5: ["#f0f9e8", "#bae4bc", "#7bccc4", "#43a2ca", "#0868ac"],
      6: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#43a2ca", "#0868ac"],
      7: ["#f0f9e8", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
      8: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#08589e"],
      9: ["#f7fcf0", "#e0f3db", "#ccebc5", "#a8ddb5", "#7bccc4", "#4eb3d3", "#2b8cbe", "#0868ac", "#084081"]
    },
    BuGn: {
      3: ["#e5f5f9", "#99d8c9", "#2ca25f"],
      4: ["#edf8fb", "#b2e2e2", "#66c2a4", "#238b45"],
      5: ["#edf8fb", "#b2e2e2", "#66c2a4", "#2ca25f", "#006d2c"],
      6: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#2ca25f", "#006d2c"],
      7: ["#edf8fb", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
      8: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#005824"],
      9: ["#f7fcfd", "#e5f5f9", "#ccece6", "#99d8c9", "#66c2a4", "#41ae76", "#238b45", "#006d2c", "#00441b"]
    },
    PuBuGn: {
      3: ["#ece2f0", "#a6bddb", "#1c9099"],
      4: ["#f6eff7", "#bdc9e1", "#67a9cf", "#02818a"],
      5: ["#f6eff7", "#bdc9e1", "#67a9cf", "#1c9099", "#016c59"],
      6: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#1c9099", "#016c59"],
      7: ["#f6eff7", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
      8: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016450"],
      9: ["#fff7fb", "#ece2f0", "#d0d1e6", "#a6bddb", "#67a9cf", "#3690c0", "#02818a", "#016c59", "#014636"]
    },
    PuBu: {
      3: ["#ece7f2", "#a6bddb", "#2b8cbe"],
      4: ["#f1eef6", "#bdc9e1", "#74a9cf", "#0570b0"],
      5: ["#f1eef6", "#bdc9e1", "#74a9cf", "#2b8cbe", "#045a8d"],
      6: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#2b8cbe", "#045a8d"],
      7: ["#f1eef6", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
      8: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#034e7b"],
      9: ["#fff7fb", "#ece7f2", "#d0d1e6", "#a6bddb", "#74a9cf", "#3690c0", "#0570b0", "#045a8d", "#023858"]
    },
    BuPu: {
      3: ["#e0ecf4", "#9ebcda", "#8856a7"],
      4: ["#edf8fb", "#b3cde3", "#8c96c6", "#88419d"],
      5: ["#edf8fb", "#b3cde3", "#8c96c6", "#8856a7", "#810f7c"],
      6: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8856a7", "#810f7c"],
      7: ["#edf8fb", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
      8: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#6e016b"],
      9: ["#f7fcfd", "#e0ecf4", "#bfd3e6", "#9ebcda", "#8c96c6", "#8c6bb1", "#88419d", "#810f7c", "#4d004b"]
    },
    RdPu: {
      3: ["#fde0dd", "#fa9fb5", "#c51b8a"],
      4: ["#feebe2", "#fbb4b9", "#f768a1", "#ae017e"],
      5: ["#feebe2", "#fbb4b9", "#f768a1", "#c51b8a", "#7a0177"],
      6: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#c51b8a", "#7a0177"],
      7: ["#feebe2", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
      8: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177"],
      9: ["#fff7f3", "#fde0dd", "#fcc5c0", "#fa9fb5", "#f768a1", "#dd3497", "#ae017e", "#7a0177", "#49006a"]
    },
    PuRd: {
      3: ["#e7e1ef", "#c994c7", "#dd1c77"],
      4: ["#f1eef6", "#d7b5d8", "#df65b0", "#ce1256"],
      5: ["#f1eef6", "#d7b5d8", "#df65b0", "#dd1c77", "#980043"],
      6: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#dd1c77", "#980043"],
      7: ["#f1eef6", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
      8: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#91003f"],
      9: ["#f7f4f9", "#e7e1ef", "#d4b9da", "#c994c7", "#df65b0", "#e7298a", "#ce1256", "#980043", "#67001f"]
    },
    OrRd: {
      3: ["#fee8c8", "#fdbb84", "#e34a33"],
      4: ["#fef0d9", "#fdcc8a", "#fc8d59", "#d7301f"],
      5: ["#fef0d9", "#fdcc8a", "#fc8d59", "#e34a33", "#b30000"],
      6: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#e34a33", "#b30000"],
      7: ["#fef0d9", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
      8: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#990000"],
      9: ["#fff7ec", "#fee8c8", "#fdd49e", "#fdbb84", "#fc8d59", "#ef6548", "#d7301f", "#b30000", "#7f0000"]
    },
    YlOrRd: {
      3: ["#ffeda0", "#feb24c", "#f03b20"],
      4: ["#ffffb2", "#fecc5c", "#fd8d3c", "#e31a1c"],
      5: ["#ffffb2", "#fecc5c", "#fd8d3c", "#f03b20", "#bd0026"],
      6: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#f03b20", "#bd0026"],
      7: ["#ffffb2", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
      8: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#b10026"],
      9: ["#ffffcc", "#ffeda0", "#fed976", "#feb24c", "#fd8d3c", "#fc4e2a", "#e31a1c", "#bd0026", "#800026"]
    },
    YlOrBr: {
      3: ["#fff7bc", "#fec44f", "#d95f0e"],
      4: ["#ffffd4", "#fed98e", "#fe9929", "#cc4c02"],
      5: ["#ffffd4", "#fed98e", "#fe9929", "#d95f0e", "#993404"],
      6: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#d95f0e", "#993404"],
      7: ["#ffffd4", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
      8: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#8c2d04"],
      9: ["#ffffe5", "#fff7bc", "#fee391", "#fec44f", "#fe9929", "#ec7014", "#cc4c02", "#993404", "#662506"]
    },
    Purples: {
      3: ["#efedf5", "#bcbddc", "#756bb1"],
      4: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#6a51a3"],
      5: ["#f2f0f7", "#cbc9e2", "#9e9ac8", "#756bb1", "#54278f"],
      6: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#756bb1", "#54278f"],
      7: ["#f2f0f7", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
      8: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#4a1486"],
      9: ["#fcfbfd", "#efedf5", "#dadaeb", "#bcbddc", "#9e9ac8", "#807dba", "#6a51a3", "#54278f", "#3f007d"]
    },
    Blues: {
      3: ["#deebf7", "#9ecae1", "#3182bd"],
      4: ["#eff3ff", "#bdd7e7", "#6baed6", "#2171b5"],
      5: ["#eff3ff", "#bdd7e7", "#6baed6", "#3182bd", "#08519c"],
      6: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#3182bd", "#08519c"],
      7: ["#eff3ff", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
      8: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#084594"],
      9: ["#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b"]
    },
    Greens: {
      3: ["#e5f5e0", "#a1d99b", "#31a354"],
      4: ["#edf8e9", "#bae4b3", "#74c476", "#238b45"],
      5: ["#edf8e9", "#bae4b3", "#74c476", "#31a354", "#006d2c"],
      6: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#31a354", "#006d2c"],
      7: ["#edf8e9", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
      8: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#005a32"],
      9: ["#f7fcf5", "#e5f5e0", "#c7e9c0", "#a1d99b", "#74c476", "#41ab5d", "#238b45", "#006d2c", "#00441b"]
    },
    Oranges: {
      3: ["#fee6ce", "#fdae6b", "#e6550d"],
      4: ["#feedde", "#fdbe85", "#fd8d3c", "#d94701"],
      5: ["#feedde", "#fdbe85", "#fd8d3c", "#e6550d", "#a63603"],
      6: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#e6550d", "#a63603"],
      7: ["#feedde", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
      8: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#8c2d04"],
      9: ["#fff5eb", "#fee6ce", "#fdd0a2", "#fdae6b", "#fd8d3c", "#f16913", "#d94801", "#a63603", "#7f2704"]
    },
    Reds: {
      3: ["#fee0d2", "#fc9272", "#de2d26"],
      4: ["#fee5d9", "#fcae91", "#fb6a4a", "#cb181d"],
      5: ["#fee5d9", "#fcae91", "#fb6a4a", "#de2d26", "#a50f15"],
      6: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#de2d26", "#a50f15"],
      7: ["#fee5d9", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
      8: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#99000d"],
      9: ["#fff5f0", "#fee0d2", "#fcbba1", "#fc9272", "#fb6a4a", "#ef3b2c", "#cb181d", "#a50f15", "#67000d"]
    },
    Greys: {
      3: ["#f0f0f0", "#bdbdbd", "#636363"],
      4: ["#f7f7f7", "#cccccc", "#969696", "#525252"],
      5: ["#f7f7f7", "#cccccc", "#969696", "#636363", "#252525"],
      6: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#636363", "#252525"],
      7: ["#f7f7f7", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
      8: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525"],
      9: ["#ffffff", "#f0f0f0", "#d9d9d9", "#bdbdbd", "#969696", "#737373", "#525252", "#252525", "#000000"]
    },
    PuOr: {
      3: ["#f1a340", "#f7f7f7", "#998ec3"],
      4: ["#e66101", "#fdb863", "#b2abd2", "#5e3c99"],
      5: ["#e66101", "#fdb863", "#f7f7f7", "#b2abd2", "#5e3c99"],
      6: ["#b35806", "#f1a340", "#fee0b6", "#d8daeb", "#998ec3", "#542788"],
      7: ["#b35806", "#f1a340", "#fee0b6", "#f7f7f7", "#d8daeb", "#998ec3", "#542788"],
      8: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
      9: ["#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788"],
      10: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"],
      11: ["#7f3b08", "#b35806", "#e08214", "#fdb863", "#fee0b6", "#f7f7f7", "#d8daeb", "#b2abd2", "#8073ac", "#542788", "#2d004b"]
    },
    BrBG: {
      3: ["#d8b365", "#f5f5f5", "#5ab4ac"],
      4: ["#a6611a", "#dfc27d", "#80cdc1", "#018571"],
      5: ["#a6611a", "#dfc27d", "#f5f5f5", "#80cdc1", "#018571"],
      6: ["#8c510a", "#d8b365", "#f6e8c3", "#c7eae5", "#5ab4ac", "#01665e"],
      7: ["#8c510a", "#d8b365", "#f6e8c3", "#f5f5f5", "#c7eae5", "#5ab4ac", "#01665e"],
      8: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
      9: ["#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e"],
      10: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"],
      11: ["#543005", "#8c510a", "#bf812d", "#dfc27d", "#f6e8c3", "#f5f5f5", "#c7eae5", "#80cdc1", "#35978f", "#01665e", "#003c30"]
    },
    PRGn: {
      3: ["#af8dc3", "#f7f7f7", "#7fbf7b"],
      4: ["#7b3294", "#c2a5cf", "#a6dba0", "#008837"],
      5: ["#7b3294", "#c2a5cf", "#f7f7f7", "#a6dba0", "#008837"],
      6: ["#762a83", "#af8dc3", "#e7d4e8", "#d9f0d3", "#7fbf7b", "#1b7837"],
      7: ["#762a83", "#af8dc3", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#7fbf7b", "#1b7837"],
      8: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
      9: ["#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837"],
      10: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"],
      11: ["#40004b", "#762a83", "#9970ab", "#c2a5cf", "#e7d4e8", "#f7f7f7", "#d9f0d3", "#a6dba0", "#5aae61", "#1b7837", "#00441b"]
    },
    PiYG: {
      3: ["#e9a3c9", "#f7f7f7", "#a1d76a"],
      4: ["#d01c8b", "#f1b6da", "#b8e186", "#4dac26"],
      5: ["#d01c8b", "#f1b6da", "#f7f7f7", "#b8e186", "#4dac26"],
      6: ["#c51b7d", "#e9a3c9", "#fde0ef", "#e6f5d0", "#a1d76a", "#4d9221"],
      7: ["#c51b7d", "#e9a3c9", "#fde0ef", "#f7f7f7", "#e6f5d0", "#a1d76a", "#4d9221"],
      8: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
      9: ["#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221"],
      10: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"],
      11: ["#8e0152", "#c51b7d", "#de77ae", "#f1b6da", "#fde0ef", "#f7f7f7", "#e6f5d0", "#b8e186", "#7fbc41", "#4d9221", "#276419"]
    },
    RdBu: {
      3: ["#ef8a62", "#f7f7f7", "#67a9cf"],
      4: ["#ca0020", "#f4a582", "#92c5de", "#0571b0"],
      5: ["#ca0020", "#f4a582", "#f7f7f7", "#92c5de", "#0571b0"],
      6: ["#b2182b", "#ef8a62", "#fddbc7", "#d1e5f0", "#67a9cf", "#2166ac"],
      7: ["#b2182b", "#ef8a62", "#fddbc7", "#f7f7f7", "#d1e5f0", "#67a9cf", "#2166ac"],
      8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
      9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac"],
      10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"],
      11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#f7f7f7", "#d1e5f0", "#92c5de", "#4393c3", "#2166ac", "#053061"]
    },
    RdGy: {
      3: ["#ef8a62", "#ffffff", "#999999"],
      4: ["#ca0020", "#f4a582", "#bababa", "#404040"],
      5: ["#ca0020", "#f4a582", "#ffffff", "#bababa", "#404040"],
      6: ["#b2182b", "#ef8a62", "#fddbc7", "#e0e0e0", "#999999", "#4d4d4d"],
      7: ["#b2182b", "#ef8a62", "#fddbc7", "#ffffff", "#e0e0e0", "#999999", "#4d4d4d"],
      8: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
      9: ["#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d"],
      10: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"],
      11: ["#67001f", "#b2182b", "#d6604d", "#f4a582", "#fddbc7", "#ffffff", "#e0e0e0", "#bababa", "#878787", "#4d4d4d", "#1a1a1a"]
    },
    RdYlBu: {
      3: ["#fc8d59", "#ffffbf", "#91bfdb"],
      4: ["#d7191c", "#fdae61", "#abd9e9", "#2c7bb6"],
      5: ["#d7191c", "#fdae61", "#ffffbf", "#abd9e9", "#2c7bb6"],
      6: ["#d73027", "#fc8d59", "#fee090", "#e0f3f8", "#91bfdb", "#4575b4"],
      7: ["#d73027", "#fc8d59", "#fee090", "#ffffbf", "#e0f3f8", "#91bfdb", "#4575b4"],
      8: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
      9: ["#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4"],
      10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"],
      11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee090", "#ffffbf", "#e0f3f8", "#abd9e9", "#74add1", "#4575b4", "#313695"]
    },
    Spectral: {
      3: ["#fc8d59", "#ffffbf", "#99d594"],
      4: ["#d7191c", "#fdae61", "#abdda4", "#2b83ba"],
      5: ["#d7191c", "#fdae61", "#ffffbf", "#abdda4", "#2b83ba"],
      6: ["#d53e4f", "#fc8d59", "#fee08b", "#e6f598", "#99d594", "#3288bd"],
      7: ["#d53e4f", "#fc8d59", "#fee08b", "#ffffbf", "#e6f598", "#99d594", "#3288bd"],
      8: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
      9: ["#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd"],
      10: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"],
      11: ["#9e0142", "#d53e4f", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#e6f598", "#abdda4", "#66c2a5", "#3288bd", "#5e4fa2"]
    },
    RdYlGn: {
      3: ["#fc8d59", "#ffffbf", "#91cf60"],
      4: ["#d7191c", "#fdae61", "#a6d96a", "#1a9641"],
      5: ["#d7191c", "#fdae61", "#ffffbf", "#a6d96a", "#1a9641"],
      6: ["#d73027", "#fc8d59", "#fee08b", "#d9ef8b", "#91cf60", "#1a9850"],
      7: ["#d73027", "#fc8d59", "#fee08b", "#ffffbf", "#d9ef8b", "#91cf60", "#1a9850"],
      8: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
      9: ["#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850"],
      10: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"],
      11: ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#006837"]
    },
    Accent: {
      3: ["#7fc97f", "#beaed4", "#fdc086"],
      4: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99"],
      5: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0"],
      6: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f"],
      7: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17"],
      8: ["#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666"]
    },
    Dark2: {
      3: ["#1b9e77", "#d95f02", "#7570b3"],
      4: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a"],
      5: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"],
      6: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"],
      7: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d"],
      8: ["#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02", "#a6761d", "#666666"]
    },
    Paired: {
      3: ["#a6cee3", "#1f78b4", "#b2df8a"],
      4: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c"],
      5: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99"],
      6: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c"],
      7: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f"],
      8: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00"],
      9: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6"],
      10: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a"],
      11: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99"],
      12: ["#a6cee3", "#1f78b4", "#b2df8a", "#33a02c", "#fb9a99", "#e31a1c", "#fdbf6f", "#ff7f00", "#cab2d6", "#6a3d9a", "#ffff99", "#b15928"]
    },
    Pastel1: {
      3: ["#fbb4ae", "#b3cde3", "#ccebc5"],
      4: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4"],
      5: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6"],
      6: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc"],
      7: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd"],
      8: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec"],
      9: ["#fbb4ae", "#b3cde3", "#ccebc5", "#decbe4", "#fed9a6", "#ffffcc", "#e5d8bd", "#fddaec", "#f2f2f2"]
    },
    Pastel2: {
      3: ["#b3e2cd", "#fdcdac", "#cbd5e8"],
      4: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4"],
      5: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9"],
      6: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae"],
      7: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc"],
      8: ["#b3e2cd", "#fdcdac", "#cbd5e8", "#f4cae4", "#e6f5c9", "#fff2ae", "#f1e2cc", "#cccccc"]
    },
    Set1: {
      3: ["#e41a1c", "#377eb8", "#4daf4a"],
      4: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3"],
      5: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00"],
      6: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33"],
      7: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628"],
      8: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf"],
      9: ["#e41a1c", "#377eb8", "#4daf4a", "#984ea3", "#ff7f00", "#ffff33", "#a65628", "#f781bf", "#999999"]
    },
    Set2: {
      3: ["#66c2a5", "#fc8d62", "#8da0cb"],
      4: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3"],
      5: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854"],
      6: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f"],
      7: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494"],
      8: ["#66c2a5", "#fc8d62", "#8da0cb", "#e78ac3", "#a6d854", "#ffd92f", "#e5c494", "#b3b3b3"]
    },
    Set3: {
      3: ["#8dd3c7", "#ffffb3", "#bebada"],
      4: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072"],
      5: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3"],
      6: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462"],
      7: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69"],
      8: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5"],
      9: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9"],
      10: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd"],
      11: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5"],
      12: ["#8dd3c7", "#ffffb3", "#bebada", "#fb8072", "#80b1d3", "#fdb462", "#b3de69", "#fccde5", "#d9d9d9", "#bc80bd", "#ccebc5", "#ffed6f"]
    }
  };
  var index_es_default = index;

  // ../../node_modules/cartocolor/dist/cartocolor.js
  var Burg = {
    2: ["#ffc6c4", "#672044"],
    3: ["#ffc6c4", "#cc607d", "#672044"],
    4: ["#ffc6c4", "#e38191", "#ad466c", "#672044"],
    5: ["#ffc6c4", "#ee919b", "#cc607d", "#9e3963", "#672044"],
    6: ["#ffc6c4", "#f29ca3", "#da7489", "#b95073", "#93345d", "#672044"],
    7: [
      "#ffc6c4",
      "#f4a3a8",
      "#e38191",
      "#cc607d",
      "#ad466c",
      "#8b3058",
      "#672044"
    ],
    tags: ["quantitative"]
  };
  var BurgYl = {
    2: ["#fbe6c5", "#70284a"],
    3: ["#fbe6c5", "#dc7176", "#70284a"],
    4: ["#fbe6c5", "#ee8a82", "#c8586c", "#70284a"],
    5: ["#fbe6c5", "#f2a28a", "#dc7176", "#b24b65", "#70284a"],
    6: ["#fbe6c5", "#f4b191", "#e7807d", "#d06270", "#a44360", "#70284a"],
    7: [
      "#fbe6c5",
      "#f5ba98",
      "#ee8a82",
      "#dc7176",
      "#c8586c",
      "#9c3f5d",
      "#70284a"
    ],
    tags: ["quantitative"]
  };
  var RedOr = {
    2: ["#f6d2a9", "#b13f64"],
    3: ["#f6d2a9", "#ea8171", "#b13f64"],
    4: ["#f6d2a9", "#f19c7c", "#dd686c", "#b13f64"],
    5: ["#f6d2a9", "#f3aa84", "#ea8171", "#d55d6a", "#b13f64"],
    6: ["#f6d2a9", "#f4b28a", "#ef9177", "#e3726d", "#cf5669", "#b13f64"],
    7: [
      "#f6d2a9",
      "#f5b78e",
      "#f19c7c",
      "#ea8171",
      "#dd686c",
      "#ca5268",
      "#b13f64"
    ],
    tags: ["quantitative"]
  };
  var OrYel = {
    2: ["#ecda9a", "#ee4d5a"],
    3: ["#ecda9a", "#f7945d", "#ee4d5a"],
    4: ["#ecda9a", "#f3ad6a", "#f97b57", "#ee4d5a"],
    5: ["#ecda9a", "#f1b973", "#f7945d", "#f86f56", "#ee4d5a"],
    6: ["#ecda9a", "#f0c079", "#f5a363", "#f98558", "#f76856", "#ee4d5a"],
    7: [
      "#ecda9a",
      "#efc47e",
      "#f3ad6a",
      "#f7945d",
      "#f97b57",
      "#f66356",
      "#ee4d5a"
    ],
    tags: ["quantitative"]
  };
  var Peach = {
    2: ["#fde0c5", "#eb4a40"],
    3: ["#fde0c5", "#f59e72", "#eb4a40"],
    4: ["#fde0c5", "#f8b58b", "#f2855d", "#eb4a40"],
    5: ["#fde0c5", "#f9c098", "#f59e72", "#f17854", "#eb4a40"],
    6: ["#fde0c5", "#fac7a1", "#f7ac80", "#f38f65", "#f0704f", "#eb4a40"],
    7: [
      "#fde0c5",
      "#facba6",
      "#f8b58b",
      "#f59e72",
      "#f2855d",
      "#ef6a4c",
      "#eb4a40"
    ],
    tags: ["quantitative"]
  };
  var PinkYl = {
    2: ["#fef6b5", "#e15383"],
    3: ["#fef6b5", "#ffa679", "#e15383"],
    4: ["#fef6b5", "#ffc285", "#fa8a76", "#e15383"],
    5: ["#fef6b5", "#ffd08e", "#ffa679", "#f67b77", "#e15383"],
    6: ["#fef6b5", "#ffd795", "#ffb77f", "#fd9576", "#f37378", "#e15383"],
    7: [
      "#fef6b5",
      "#ffdd9a",
      "#ffc285",
      "#ffa679",
      "#fa8a76",
      "#f16d7a",
      "#e15383"
    ],
    tags: ["quantitative"]
  };
  var Mint = {
    2: ["#e4f1e1", "#0d585f"],
    3: ["#e4f1e1", "#63a6a0", "#0d585f"],
    4: ["#e4f1e1", "#89c0b6", "#448c8a", "#0d585f"],
    5: ["#E4F1E1", "#9CCDC1", "#63A6A0", "#337F7F", "#0D585F"],
    6: ["#e4f1e1", "#abd4c7", "#7ab5ad", "#509693", "#2c7778", "#0d585f"],
    7: [
      "#e4f1e1",
      "#b4d9cc",
      "#89c0b6",
      "#63a6a0",
      "#448c8a",
      "#287274",
      "#0d585f"
    ],
    tags: ["quantitative"]
  };
  var BluGrn = {
    2: ["#c4e6c3", "#1d4f60"],
    3: ["#c4e6c3", "#4da284", "#1d4f60"],
    4: ["#c4e6c3", "#6dbc90", "#36877a", "#1d4f60"],
    5: ["#c4e6c3", "#80c799", "#4da284", "#2d7974", "#1d4f60"],
    6: ["#c4e6c3", "#8dce9f", "#5fb28b", "#3e927e", "#297071", "#1d4f60"],
    7: [
      "#c4e6c3",
      "#96d2a4",
      "#6dbc90",
      "#4da284",
      "#36877a",
      "#266b6e",
      "#1d4f60"
    ],
    tags: ["quantitative"]
  };
  var DarkMint = {
    2: ["#d2fbd4", "#123f5a"],
    3: ["#d2fbd4", "#559c9e", "#123f5a"],
    4: ["#d2fbd4", "#7bbcb0", "#3a7c89", "#123f5a"],
    5: ["#d2fbd4", "#8eccb9", "#559c9e", "#2b6c7f", "#123f5a"],
    6: ["#d2fbd4", "#9cd5be", "#6cafa9", "#458892", "#266377", "#123f5a"],
    7: [
      "#d2fbd4",
      "#a5dbc2",
      "#7bbcb0",
      "#559c9e",
      "#3a7c89",
      "#235d72",
      "#123f5a"
    ],
    tags: ["quantitative"]
  };
  var Emrld = {
    2: ["#d3f2a3", "#074050"],
    3: ["#d3f2a3", "#4c9b82", "#074050"],
    4: ["#d3f2a3", "#6cc08b", "#217a79", "#074050"],
    5: ["#d3f2a3", "#82d091", "#4c9b82", "#19696f", "#074050"],
    6: ["#d3f2a3", "#8fda94", "#60b187", "#35877d", "#145f69", "#074050"],
    7: [
      "#d3f2a3",
      "#97e196",
      "#6cc08b",
      "#4c9b82",
      "#217a79",
      "#105965",
      "#074050"
    ],
    tags: ["quantitative"]
  };
  var ag_GrnYl = {
    2: ["#245668", "#EDEF5D"],
    3: ["#245668", "#39AB7E", "#EDEF5D"],
    4: ["#245668", "#0D8F81", "#6EC574", "#EDEF5D"],
    5: ["#245668", "#04817E", "#39AB7E", "#8BD16D", "#EDEF5D"],
    6: ["#245668", "#09787C", "#1D9A81", "#58BB79", "#9DD869", "#EDEF5D"],
    7: [
      "#245668",
      "#0F7279",
      "#0D8F81",
      "#39AB7E",
      "#6EC574",
      "#A9DC67",
      "#EDEF5D"
    ],
    tags: ["aggregation"]
  };
  var BluYl = {
    2: ["#f7feae", "#045275"],
    3: ["#f7feae", "#46aea0", "#045275"],
    4: ["#f7feae", "#7ccba2", "#089099", "#045275"],
    5: ["#f7feae", "#9bd8a4", "#46aea0", "#058092", "#045275"],
    6: ["#f7feae", "#ace1a4", "#68bfa1", "#2a9c9c", "#02778e", "#045275"],
    7: [
      "#f7feae",
      "#b7e6a5",
      "#7ccba2",
      "#46aea0",
      "#089099",
      "#00718b",
      "#045275"
    ],
    tags: ["quantitative"]
  };
  var Teal = {
    2: ["#d1eeea", "#2a5674"],
    3: ["#d1eeea", "#68abb8", "#2a5674"],
    4: ["#d1eeea", "#85c4c9", "#4f90a6", "#2a5674"],
    5: ["#d1eeea", "#96d0d1", "#68abb8", "#45829b", "#2a5674"],
    6: ["#d1eeea", "#a1d7d6", "#79bbc3", "#599bae", "#3f7994", "#2a5674"],
    7: [
      "#d1eeea",
      "#a8dbd9",
      "#85c4c9",
      "#68abb8",
      "#4f90a6",
      "#3b738f",
      "#2a5674"
    ],
    tags: ["quantitative"]
  };
  var TealGrn = {
    2: ["#b0f2bc", "#257d98"],
    3: ["#b0f2bc", "#4cc8a3", "#257d98"],
    4: ["#b0f2bc", "#67dba5", "#38b2a3", "#257d98"],
    5: ["#b0f2bc", "#77e2a8", "#4cc8a3", "#31a6a2", "#257d98"],
    6: ["#b0f2bc", "#82e6aa", "#5bd4a4", "#3fbba3", "#2e9ea1", "#257d98"],
    7: [
      "#b0f2bc",
      "#89e8ac",
      "#67dba5",
      "#4cc8a3",
      "#38b2a3",
      "#2c98a0",
      "#257d98"
    ],
    tags: ["quantitative"]
  };
  var Purp = {
    2: ["#f3e0f7", "#63589f"],
    3: ["#f3e0f7", "#b998dd", "#63589f"],
    4: ["#f3e0f7", "#d1afe8", "#9f82ce", "#63589f"],
    5: ["#f3e0f7", "#dbbaed", "#b998dd", "#9178c4", "#63589f"],
    6: ["#f3e0f7", "#e0c2ef", "#c8a5e4", "#aa8bd4", "#8871be", "#63589f"],
    7: [
      "#f3e0f7",
      "#e4c7f1",
      "#d1afe8",
      "#b998dd",
      "#9f82ce",
      "#826dba",
      "#63589f"
    ],
    tags: ["quantitative"]
  };
  var PurpOr = {
    2: ["#f9ddda", "#573b88"],
    3: ["#f9ddda", "#ce78b3", "#573b88"],
    4: ["#f9ddda", "#e597b9", "#ad5fad", "#573b88"],
    5: ["#f9ddda", "#eda8bd", "#ce78b3", "#9955a8", "#573b88"],
    6: ["#f9ddda", "#f0b2c1", "#dd8ab6", "#bb69b0", "#8c4fa4", "#573b88"],
    7: [
      "#f9ddda",
      "#f2b9c4",
      "#e597b9",
      "#ce78b3",
      "#ad5fad",
      "#834ba0",
      "#573b88"
    ],
    tags: ["quantitative"]
  };
  var Sunset = {
    2: ["#f3e79b", "#5c53a5"],
    3: ["#f3e79b", "#eb7f86", "#5c53a5"],
    4: ["#f3e79b", "#f8a07e", "#ce6693", "#5c53a5"],
    5: ["#f3e79b", "#fab27f", "#eb7f86", "#b95e9a", "#5c53a5"],
    6: ["#f3e79b", "#fabc82", "#f59280", "#dc6f8e", "#ab5b9e", "#5c53a5"],
    7: [
      "#f3e79b",
      "#fac484",
      "#f8a07e",
      "#eb7f86",
      "#ce6693",
      "#a059a0",
      "#5c53a5"
    ],
    tags: ["quantitative"]
  };
  var Magenta = {
    2: ["#f3cbd3", "#6c2167"],
    3: ["#f3cbd3", "#ca699d", "#6c2167"],
    4: ["#f3cbd3", "#dd88ac", "#b14d8e", "#6c2167"],
    5: ["#f3cbd3", "#e498b4", "#ca699d", "#a24186", "#6c2167"],
    6: ["#f3cbd3", "#e7a2b9", "#d67ba5", "#bc5894", "#983a81", "#6c2167"],
    7: [
      "#f3cbd3",
      "#eaa9bd",
      "#dd88ac",
      "#ca699d",
      "#b14d8e",
      "#91357d",
      "#6c2167"
    ],
    tags: ["quantitative"]
  };
  var SunsetDark = {
    2: ["#fcde9c", "#7c1d6f"],
    3: ["#fcde9c", "#e34f6f", "#7c1d6f"],
    4: ["#fcde9c", "#f0746e", "#dc3977", "#7c1d6f"],
    5: ["#fcde9c", "#f58670", "#e34f6f", "#d72d7c", "#7c1d6f"],
    6: ["#fcde9c", "#f89872", "#ec666d", "#df4273", "#c5287b", "#7c1d6f"],
    7: [
      "#fcde9c",
      "#faa476",
      "#f0746e",
      "#e34f6f",
      "#dc3977",
      "#b9257a",
      "#7c1d6f"
    ],
    tags: ["quantitative"]
  };
  var ag_Sunset = {
    2: ["#4b2991", "#edd9a3"],
    3: ["#4b2991", "#ea4f88", "#edd9a3"],
    4: ["#4b2991", "#c0369d", "#fa7876", "#edd9a3"],
    5: ["#4b2991", "#a52fa2", "#ea4f88", "#fa9074", "#edd9a3"],
    6: ["#4b2991", "#932da3", "#d43f96", "#f7667c", "#f89f77", "#edd9a3"],
    7: [
      "#4b2991",
      "#872ca2",
      "#c0369d",
      "#ea4f88",
      "#fa7876",
      "#f6a97a",
      "#edd9a3"
    ],
    tags: ["aggregation"]
  };
  var BrwnYl = {
    2: ["#ede5cf", "#541f3f"],
    3: ["#ede5cf", "#c1766f", "#541f3f"],
    4: ["#ede5cf", "#d39c83", "#a65461", "#541f3f"],
    5: ["#ede5cf", "#daaf91", "#c1766f", "#95455a", "#541f3f"],
    6: ["#ede5cf", "#ddba9b", "#cd8c7a", "#b26166", "#8a3c56", "#541f3f"],
    7: [
      "#ede5cf",
      "#e0c2a2",
      "#d39c83",
      "#c1766f",
      "#a65461",
      "#813753",
      "#541f3f"
    ],
    tags: ["quantitative"]
  };
  var ArmyRose = {
    2: ["#929b4f", "#db8195"],
    3: ["#a3ad62", "#fdfbe4", "#df91a3"],
    4: ["#929b4f", "#d9dbaf", "#f3d1ca", "#db8195"],
    5: ["#879043", "#c1c68c", "#fdfbe4", "#ebb4b8", "#d8758b"],
    6: ["#7f883b", "#b0b874", "#e3e4be", "#f6ddd1", "#e4a0ac", "#d66d85"],
    7: [
      "#798234",
      "#a3ad62",
      "#d0d3a2",
      "#fdfbe4",
      "#f0c6c3",
      "#df91a3",
      "#d46780"
    ],
    tags: ["diverging"]
  };
  var Fall = {
    2: ["#3d5941", "#ca562c"],
    3: ["#3d5941", "#f6edbd", "#ca562c"],
    4: ["#3d5941", "#b5b991", "#edbb8a", "#ca562c"],
    5: ["#3d5941", "#96a07c", "#f6edbd", "#e6a272", "#ca562c"],
    6: ["#3d5941", "#839170", "#cecea2", "#f1cf9e", "#e19464", "#ca562c"],
    7: [
      "#3d5941",
      "#778868",
      "#b5b991",
      "#f6edbd",
      "#edbb8a",
      "#de8a5a",
      "#ca562c"
    ],
    tags: ["diverging"]
  };
  var Geyser = {
    2: ["#008080", "#ca562c"],
    3: ["#008080", "#f6edbd", "#ca562c"],
    4: ["#008080", "#b4c8a8", "#edbb8a", "#ca562c"],
    5: ["#008080", "#92b69e", "#f6edbd", "#e6a272", "#ca562c"],
    6: ["#008080", "#7eab98", "#ced7b1", "#f1cf9e", "#e19464", "#ca562c"],
    7: [
      "#008080",
      "#70a494",
      "#b4c8a8",
      "#f6edbd",
      "#edbb8a",
      "#de8a5a",
      "#ca562c"
    ],
    tags: ["diverging"]
  };
  var Temps = {
    2: ["#009392", "#cf597e"],
    3: ["#009392", "#e9e29c", "#cf597e"],
    4: ["#009392", "#9ccb86", "#eeb479", "#cf597e"],
    5: ["#009392", "#71be83", "#e9e29c", "#ed9c72", "#cf597e"],
    6: ["#009392", "#52b684", "#bcd48c", "#edc783", "#eb8d71", "#cf597e"],
    7: [
      "#009392",
      "#39b185",
      "#9ccb86",
      "#e9e29c",
      "#eeb479",
      "#e88471",
      "#cf597e"
    ],
    tags: ["diverging"]
  };
  var TealRose = {
    2: ["#009392", "#d0587e"],
    3: ["#009392", "#f1eac8", "#d0587e"],
    4: ["#009392", "#91b8aa", "#f1eac8", "#dfa0a0", "#d0587e"],
    5: ["#009392", "#91b8aa", "#f1eac8", "#dfa0a0", "#d0587e"],
    6: ["#009392", "#72aaa1", "#b1c7b3", "#e5b9ad", "#d98994", "#d0587e"],
    7: [
      "#009392",
      "#72aaa1",
      "#b1c7b3",
      "#f1eac8",
      "#e5b9ad",
      "#d98994",
      "#d0587e"
    ],
    tags: ["diverging"]
  };
  var Tropic = {
    2: ["#009B9E", "#C75DAB"],
    3: ["#009B9E", "#F1F1F1", "#C75DAB"],
    4: ["#009B9E", "#A7D3D4", "#E4C1D9", "#C75DAB"],
    5: ["#009B9E", "#7CC5C6", "#F1F1F1", "#DDA9CD", "#C75DAB"],
    6: ["#009B9E", "#5DBCBE", "#C6DFDF", "#E9D4E2", "#D99BC6", "#C75DAB"],
    7: [
      "#009B9E",
      "#42B7B9",
      "#A7D3D4",
      "#F1F1F1",
      "#E4C1D9",
      "#D691C1",
      "#C75DAB"
    ],
    tags: ["diverging"]
  };
  var Earth = {
    2: ["#A16928", "#2887a1"],
    3: ["#A16928", "#edeac2", "#2887a1"],
    4: ["#A16928", "#d6bd8d", "#b5c8b8", "#2887a1"],
    5: ["#A16928", "#caa873", "#edeac2", "#98b7b2", "#2887a1"],
    6: ["#A16928", "#c29b64", "#e0cfa2", "#cbd5bc", "#85adaf", "#2887a1"],
    7: [
      "#A16928",
      "#bd925a",
      "#d6bd8d",
      "#edeac2",
      "#b5c8b8",
      "#79a7ac",
      "#2887a1"
    ],
    tags: ["diverging"]
  };
  var Antique = {
    2: ["#855C75", "#D9AF6B", "#7C7C7C"],
    3: ["#855C75", "#D9AF6B", "#AF6458", "#7C7C7C"],
    4: ["#855C75", "#D9AF6B", "#AF6458", "#736F4C", "#7C7C7C"],
    5: ["#855C75", "#D9AF6B", "#AF6458", "#736F4C", "#526A83", "#7C7C7C"],
    6: [
      "#855C75",
      "#D9AF6B",
      "#AF6458",
      "#736F4C",
      "#526A83",
      "#625377",
      "#7C7C7C"
    ],
    7: [
      "#855C75",
      "#D9AF6B",
      "#AF6458",
      "#736F4C",
      "#526A83",
      "#625377",
      "#68855C",
      "#7C7C7C"
    ],
    8: [
      "#855C75",
      "#D9AF6B",
      "#AF6458",
      "#736F4C",
      "#526A83",
      "#625377",
      "#68855C",
      "#9C9C5E",
      "#7C7C7C"
    ],
    9: [
      "#855C75",
      "#D9AF6B",
      "#AF6458",
      "#736F4C",
      "#526A83",
      "#625377",
      "#68855C",
      "#9C9C5E",
      "#A06177",
      "#7C7C7C"
    ],
    10: [
      "#855C75",
      "#D9AF6B",
      "#AF6458",
      "#736F4C",
      "#526A83",
      "#625377",
      "#68855C",
      "#9C9C5E",
      "#A06177",
      "#8C785D",
      "#7C7C7C"
    ],
    11: [
      "#855C75",
      "#D9AF6B",
      "#AF6458",
      "#736F4C",
      "#526A83",
      "#625377",
      "#68855C",
      "#9C9C5E",
      "#A06177",
      "#8C785D",
      "#467378",
      "#7C7C7C"
    ],
    tags: ["qualitative"]
  };
  var Bold = {
    2: ["#7F3C8D", "#11A579", "#A5AA99"],
    3: ["#7F3C8D", "#11A579", "#3969AC", "#A5AA99"],
    4: ["#7F3C8D", "#11A579", "#3969AC", "#F2B701", "#A5AA99"],
    5: ["#7F3C8D", "#11A579", "#3969AC", "#F2B701", "#E73F74", "#A5AA99"],
    6: [
      "#7F3C8D",
      "#11A579",
      "#3969AC",
      "#F2B701",
      "#E73F74",
      "#80BA5A",
      "#A5AA99"
    ],
    7: [
      "#7F3C8D",
      "#11A579",
      "#3969AC",
      "#F2B701",
      "#E73F74",
      "#80BA5A",
      "#E68310",
      "#A5AA99"
    ],
    8: [
      "#7F3C8D",
      "#11A579",
      "#3969AC",
      "#F2B701",
      "#E73F74",
      "#80BA5A",
      "#E68310",
      "#008695",
      "#A5AA99"
    ],
    9: [
      "#7F3C8D",
      "#11A579",
      "#3969AC",
      "#F2B701",
      "#E73F74",
      "#80BA5A",
      "#E68310",
      "#008695",
      "#CF1C90",
      "#A5AA99"
    ],
    10: [
      "#7F3C8D",
      "#11A579",
      "#3969AC",
      "#F2B701",
      "#E73F74",
      "#80BA5A",
      "#E68310",
      "#008695",
      "#CF1C90",
      "#f97b72",
      "#A5AA99"
    ],
    11: [
      "#7F3C8D",
      "#11A579",
      "#3969AC",
      "#F2B701",
      "#E73F74",
      "#80BA5A",
      "#E68310",
      "#008695",
      "#CF1C90",
      "#f97b72",
      "#4b4b8f",
      "#A5AA99"
    ],
    tags: ["qualitative"]
  };
  var Pastel = {
    2: ["#66C5CC", "#F6CF71", "#B3B3B3"],
    3: ["#66C5CC", "#F6CF71", "#F89C74", "#B3B3B3"],
    4: ["#66C5CC", "#F6CF71", "#F89C74", "#DCB0F2", "#B3B3B3"],
    5: ["#66C5CC", "#F6CF71", "#F89C74", "#DCB0F2", "#87C55F", "#B3B3B3"],
    6: [
      "#66C5CC",
      "#F6CF71",
      "#F89C74",
      "#DCB0F2",
      "#87C55F",
      "#9EB9F3",
      "#B3B3B3"
    ],
    7: [
      "#66C5CC",
      "#F6CF71",
      "#F89C74",
      "#DCB0F2",
      "#87C55F",
      "#9EB9F3",
      "#FE88B1",
      "#B3B3B3"
    ],
    8: [
      "#66C5CC",
      "#F6CF71",
      "#F89C74",
      "#DCB0F2",
      "#87C55F",
      "#9EB9F3",
      "#FE88B1",
      "#C9DB74",
      "#B3B3B3"
    ],
    9: [
      "#66C5CC",
      "#F6CF71",
      "#F89C74",
      "#DCB0F2",
      "#87C55F",
      "#9EB9F3",
      "#FE88B1",
      "#C9DB74",
      "#8BE0A4",
      "#B3B3B3"
    ],
    10: [
      "#66C5CC",
      "#F6CF71",
      "#F89C74",
      "#DCB0F2",
      "#87C55F",
      "#9EB9F3",
      "#FE88B1",
      "#C9DB74",
      "#8BE0A4",
      "#B497E7",
      "#B3B3B3"
    ],
    11: [
      "#66C5CC",
      "#F6CF71",
      "#F89C74",
      "#DCB0F2",
      "#87C55F",
      "#9EB9F3",
      "#FE88B1",
      "#C9DB74",
      "#8BE0A4",
      "#B497E7",
      "#D3B484",
      "#B3B3B3"
    ],
    tags: ["qualitative"]
  };
  var Prism = {
    2: ["#5F4690", "#1D6996", "#666666"],
    3: ["#5F4690", "#1D6996", "#38A6A5", "#666666"],
    4: ["#5F4690", "#1D6996", "#38A6A5", "#0F8554", "#666666"],
    5: ["#5F4690", "#1D6996", "#38A6A5", "#0F8554", "#73AF48", "#666666"],
    6: [
      "#5F4690",
      "#1D6996",
      "#38A6A5",
      "#0F8554",
      "#73AF48",
      "#EDAD08",
      "#666666"
    ],
    7: [
      "#5F4690",
      "#1D6996",
      "#38A6A5",
      "#0F8554",
      "#73AF48",
      "#EDAD08",
      "#E17C05",
      "#666666"
    ],
    8: [
      "#5F4690",
      "#1D6996",
      "#38A6A5",
      "#0F8554",
      "#73AF48",
      "#EDAD08",
      "#E17C05",
      "#CC503E",
      "#666666"
    ],
    9: [
      "#5F4690",
      "#1D6996",
      "#38A6A5",
      "#0F8554",
      "#73AF48",
      "#EDAD08",
      "#E17C05",
      "#CC503E",
      "#94346E",
      "#666666"
    ],
    10: [
      "#5F4690",
      "#1D6996",
      "#38A6A5",
      "#0F8554",
      "#73AF48",
      "#EDAD08",
      "#E17C05",
      "#CC503E",
      "#94346E",
      "#6F4070",
      "#666666"
    ],
    11: [
      "#5F4690",
      "#1D6996",
      "#38A6A5",
      "#0F8554",
      "#73AF48",
      "#EDAD08",
      "#E17C05",
      "#CC503E",
      "#94346E",
      "#6F4070",
      "#994E95",
      "#666666"
    ],
    tags: ["qualitative"]
  };
  var Safe = {
    2: ["#88CCEE", "#CC6677", "#888888"],
    3: ["#88CCEE", "#CC6677", "#DDCC77", "#888888"],
    4: ["#88CCEE", "#CC6677", "#DDCC77", "#117733", "#888888"],
    5: ["#88CCEE", "#CC6677", "#DDCC77", "#117733", "#332288", "#888888"],
    6: [
      "#88CCEE",
      "#CC6677",
      "#DDCC77",
      "#117733",
      "#332288",
      "#AA4499",
      "#888888"
    ],
    7: [
      "#88CCEE",
      "#CC6677",
      "#DDCC77",
      "#117733",
      "#332288",
      "#AA4499",
      "#44AA99",
      "#888888"
    ],
    8: [
      "#88CCEE",
      "#CC6677",
      "#DDCC77",
      "#117733",
      "#332288",
      "#AA4499",
      "#44AA99",
      "#999933",
      "#888888"
    ],
    9: [
      "#88CCEE",
      "#CC6677",
      "#DDCC77",
      "#117733",
      "#332288",
      "#AA4499",
      "#44AA99",
      "#999933",
      "#882255",
      "#888888"
    ],
    10: [
      "#88CCEE",
      "#CC6677",
      "#DDCC77",
      "#117733",
      "#332288",
      "#AA4499",
      "#44AA99",
      "#999933",
      "#882255",
      "#661100",
      "#888888"
    ],
    11: [
      "#88CCEE",
      "#CC6677",
      "#DDCC77",
      "#117733",
      "#332288",
      "#AA4499",
      "#44AA99",
      "#999933",
      "#882255",
      "#661100",
      "#6699CC",
      "#888888"
    ],
    tags: ["qualitative", "colorblind"]
  };
  var Vivid = {
    2: ["#E58606", "#5D69B1", "#A5AA99"],
    3: ["#E58606", "#5D69B1", "#52BCA3", "#A5AA99"],
    4: ["#E58606", "#5D69B1", "#52BCA3", "#99C945", "#A5AA99"],
    5: ["#E58606", "#5D69B1", "#52BCA3", "#99C945", "#CC61B0", "#A5AA99"],
    6: [
      "#E58606",
      "#5D69B1",
      "#52BCA3",
      "#99C945",
      "#CC61B0",
      "#24796C",
      "#A5AA99"
    ],
    7: [
      "#E58606",
      "#5D69B1",
      "#52BCA3",
      "#99C945",
      "#CC61B0",
      "#24796C",
      "#DAA51B",
      "#A5AA99"
    ],
    8: [
      "#E58606",
      "#5D69B1",
      "#52BCA3",
      "#99C945",
      "#CC61B0",
      "#24796C",
      "#DAA51B",
      "#2F8AC4",
      "#A5AA99"
    ],
    9: [
      "#E58606",
      "#5D69B1",
      "#52BCA3",
      "#99C945",
      "#CC61B0",
      "#24796C",
      "#DAA51B",
      "#2F8AC4",
      "#764E9F",
      "#A5AA99"
    ],
    10: [
      "#E58606",
      "#5D69B1",
      "#52BCA3",
      "#99C945",
      "#CC61B0",
      "#24796C",
      "#DAA51B",
      "#2F8AC4",
      "#764E9F",
      "#ED645A",
      "#A5AA99"
    ],
    11: [
      "#E58606",
      "#5D69B1",
      "#52BCA3",
      "#99C945",
      "#CC61B0",
      "#24796C",
      "#DAA51B",
      "#2F8AC4",
      "#764E9F",
      "#ED645A",
      "#CC3A8E",
      "#A5AA99"
    ],
    tags: ["qualitative"]
  };
  var cb_BuGn = { ...index_es_default.BuGn, tags: ["quantitative"] };
  var cb_BuPu = { ...index_es_default.BuPu, tags: ["quantitative"] };
  var cb_GnBu = { ...index_es_default.GnBu, tags: ["quantitative"] };
  var cb_OrRd = { ...index_es_default.OrRd, tags: ["quantitative"] };
  var cb_PuBu = { ...index_es_default.PuBu, tags: ["quantitative"] };
  var cb_PuBuGn = { ...index_es_default.PuBuGn, tags: ["quantitative"] };
  var cb_PuRd = { ...index_es_default.PuRd, tags: ["quantitative"] };
  var cb_RdPu = { ...index_es_default.RdPu, tags: ["quantitative"] };
  var cb_YlGn = { ...index_es_default.YlGn, tags: ["quantitative"] };
  var cb_YlGnBu = { ...index_es_default.YlGnBu, tags: ["quantitative"] };
  var cb_YlOrBr = { ...index_es_default.YlOrBr, tags: ["quantitative"] };
  var cb_YlOrRd = { ...index_es_default.YlOrRd, tags: ["quantitative"] };
  var cb_Accent = { ...index_es_default.Accent, tags: ["qualitative"] };
  var cb_Dark2 = { ...index_es_default.Dark2, tags: ["qualitative"] };
  var cb_Paired = { ...index_es_default.Paired, tags: ["qualitative"] };
  var cb_Pastel1 = { ...index_es_default.Pastel1, tags: ["qualitative"] };
  var cb_Pastel2 = { ...index_es_default.Pastel2, tags: ["qualitative"] };
  var cb_Set1 = { ...index_es_default.Set1, tags: ["qualitative"] };
  var cb_Set2 = { ...index_es_default.Set2, tags: ["qualitative"] };
  var cb_Set3 = { ...index_es_default.Set3, tags: ["qualitative"] };
  var cb_Blues = { ...index_es_default.Blues, tags: ["quantitative"] };
  var cb_Greens = { ...index_es_default.Greens, tags: ["quantitative"] };
  var cb_Greys = { ...index_es_default.Greys, tags: ["quantitative"] };
  var cb_Oranges = { ...index_es_default.Oranges, tags: ["quantitative"] };
  var cb_Purples = { ...index_es_default.Purples, tags: ["quantitative"] };
  var cb_Reds = { ...index_es_default.Reds, tags: ["quantitative"] };
  var cb_BrBG = { ...index_es_default.BrBG, tags: ["diverging"] };
  var cb_PiYG = { ...index_es_default.PiYG, tags: ["diverging"] };
  var cb_PRGn = { ...index_es_default.PRGn, tags: ["diverging"] };
  var cb_PuOr = { ...index_es_default.PuOr, tags: ["diverging"] };
  var cb_RdBu = { ...index_es_default.RdBu, tags: ["diverging"] };
  var cb_RdGy = { ...index_es_default.RdGy, tags: ["diverging"] };
  var cb_RdYlBu = { ...index_es_default.RdYlBu, tags: ["diverging"] };
  var cb_RdYlGn = { ...index_es_default.RdYlGn, tags: ["diverging"] };
  var cb_Spectral = { ...index_es_default.Spectral, tags: ["diverging"] };

  // src/style/palette.ts
  var DEFAULT_PALETTE = "PurpOr";
  var NULL_COLOR = [204, 204, 204];
  var OTHERS_COLOR = [119, 119, 119];
  function getPalette(name, numCategories) {
    const palette = cartocolor_exports[name];
    let paletteIndex = numCategories;
    assert2(palette, `Palette "${name}" not found. Expected a CARTOColors string`);
    const palettesColorVariants = Object.keys(palette).filter((p) => p !== "tags").map(Number);
    const longestPaletteIndex = Math.max(...palettesColorVariants);
    const smallestPaletteIndex = Math.min(...palettesColorVariants);
    if (!Number.isInteger(numCategories) || numCategories > longestPaletteIndex) {
      paletteIndex = longestPaletteIndex;
    } else if (numCategories < smallestPaletteIndex) {
      paletteIndex = smallestPaletteIndex;
    }
    let colors = palette[paletteIndex];
    if (palette.tags && palette.tags.includes("qualitative")) {
      colors = colors.slice(0, -1);
    }
    return colors.map((c) => hexToRgb(c));
  }
  function hexToRgb(hex3) {
    let result = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(hex3);
    if (result) {
      return [
        parseInt(result[1] + result[1], 16),
        parseInt(result[2] + result[2], 16),
        parseInt(result[3] + result[3], 16),
        255
      ];
    }
    result = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(hex3);
    if (result) {
      return [
        parseInt(result[1] + result[1], 16),
        parseInt(result[2] + result[2], 16),
        parseInt(result[3] + result[3], 16),
        parseInt(result[4] + result[4], 16)
      ];
    }
    result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex3);
    if (result) {
      return [parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16), 255];
    }
    result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex3);
    assert2(result, `Hexadecimal color "${hex3}" was not parsed correctly`);
    return [
      parseInt(result[1], 16),
      parseInt(result[2], 16),
      parseInt(result[3], 16),
      parseInt(result[4], 16)
    ];
  }

  // src/style/utils.ts
  var ALLOWED_ATTR_TYPES = Object.freeze(["function", "string"]);
  function getAttrValue(attr, d, info) {
    assert2(typeof d === "object", 'Expected "data" to be an object');
    assert2(ALLOWED_ATTR_TYPES.includes(typeof attr), 'Expected "attr" to be a function or string');
    if (typeof attr === "function") {
      return attr(d, info);
    }
    return d?.properties?.[attr];
  }

  // src/style/color-bins-style.ts
  function colorBins({
    attr,
    domain,
    colors = DEFAULT_PALETTE,
    nullColor = NULL_COLOR
  }) {
    assert2(Array.isArray(domain), 'Expected "domain" to be an array of numbers');
    const palette = typeof colors === "string" ? getPalette(colors, domain.length + 1) : colors;
    const color3 = threshold().domain(domain).range(palette);
    return (d, info) => {
      const value = getAttrValue(attr, d, info);
      return typeof value === "number" && Number.isFinite(value) ? color3(value) : nullColor;
    };
  }

  // src/style/color-categories-style.ts
  function colorCategories({
    attr,
    domain,
    colors = DEFAULT_PALETTE,
    nullColor = NULL_COLOR,
    othersColor = OTHERS_COLOR
  }) {
    assert2(Array.isArray(domain), 'Expected "domain" to be an array of numbers or strings');
    const colorsByCategory = {};
    const palette = typeof colors === "string" ? getPalette(colors, domain.length) : colors;
    for (const [i, c] of domain.entries()) {
      colorsByCategory[c] = palette[i];
    }
    return (d, info) => {
      const value = getAttrValue(attr, d, info);
      return typeof value === "number" && Number.isFinite(value) || typeof value === "string" ? colorsByCategory[value] || othersColor : nullColor;
    };
  }

  // src/style/color-continuous-style.ts
  function colorContinuous({
    attr,
    domain,
    colors = DEFAULT_PALETTE,
    nullColor = NULL_COLOR
  }) {
    assert2(Array.isArray(domain), 'Expected "domain" to be an array of numbers');
    const palette = typeof colors === "string" ? getPalette(colors, domain.length) : colors;
    const color3 = linear2().domain(domain).range(palette);
    return (d, info) => {
      const value = getAttrValue(attr, d, info);
      return typeof value === "number" && Number.isFinite(value) ? color3(value) : nullColor;
    };
  }

  // src/api/fetch-map.ts
  var layerClasses = {
    clusterTile: ClusterTileLayer,
    h3: H3TileLayer,
    heatmapTile: heatmap_tile_layer_default,
    mvt: VectorTileLayer,
    quadbin: QuadbinTileLayer,
    raster: RasterTileLayer,
    tileset: VectorTileLayer
  };
  function LayerFactory(descriptor) {
    const LayerClass = layerClasses[descriptor.type];
    if (!LayerClass) {
      throw new Error(`No layer class found for type: ${descriptor.type}`);
    }
    return new LayerClass(descriptor.props);
  }
  function createResult(result) {
    return {
      ...result,
      layers: result.layers.map((descriptor) => LayerFactory(descriptor))
    };
  }
  async function fetchMap2(options) {
    const { onNewData, ...rest } = options;
    const _options = {
      ...rest,
      onNewData: typeof onNewData === "function" ? (result2) => {
        onNewData(createResult(result2));
      } : void 0
    };
    const _result = await fetchMap(_options);
    const result = createResult(_result);
    return result;
  }

  // src/api/basemap.ts
  var CUSTOM_STYLE_ID_PREFIX2 = "custom:";
  var DEFAULT_CARTO_STYLE2 = "positron";
  function mapLibreViewpros2(config2) {
    const { longitude, latitude, ...rest } = config2.mapState;
    return {
      center: [longitude, latitude],
      ...rest
    };
  }
  async function fetchBasemapProps2({
    config: config2,
    errorContext,
    applyLayerFilters = true
  }) {
    const { mapStyle } = config2;
    const styleType = mapStyle.styleType || DEFAULT_CARTO_STYLE2;
    if (styleType.startsWith(CUSTOM_STYLE_ID_PREFIX2)) {
      const currentCustomStyle = config2.customBaseMaps?.customStyle;
      if (currentCustomStyle) {
        return {
          type: "maplibre",
          props: {
            style: currentCustomStyle.style || currentCustomStyle.url,
            ...mapLibreViewpros2(config2)
          },
          attribution: currentCustomStyle.customAttribution
        };
      }
    }
    if (CARTO_MAP_STYLES2.includes(styleType)) {
      const { visibleLayerGroups } = mapStyle;
      const styleUrl = getStyleUrl2(styleType);
      let style = styleUrl;
      let rawStyle = styleUrl;
      if (applyLayerFilters && visibleLayerGroups && someLayerGroupsDisabled2(visibleLayerGroups)) {
        rawStyle = await fetchStyle2({ styleUrl, errorContext });
        style = applyLayerGroupFilters2(rawStyle, visibleLayerGroups);
      }
      return {
        type: "maplibre",
        props: {
          style,
          ...mapLibreViewpros2(config2)
        },
        visibleLayerGroups,
        rawStyle
      };
    }
    const googleBasemapDef = GOOGLE_BASEMAPS2[styleType];
    if (googleBasemapDef) {
      const { mapState } = config2;
      return {
        type: "google-maps",
        props: {
          ...googleBasemapDef,
          center: { lat: mapState.latitude, lng: mapState.longitude },
          zoom: mapState.zoom + 1,
          tilt: mapState.pitch,
          heading: mapState.bearing
        }
      };
    }
    return {
      type: "maplibre",
      props: {
        style: getStyleUrl2(DEFAULT_CARTO_STYLE2),
        ...mapLibreViewpros2(config2)
      }
    };
  }

  // src/index.ts
  var CARTO_LAYERS = {
    ClusterTileLayer,
    H3TileLayer,
    HeatmapTileLayer: heatmap_tile_layer_default,
    PointLabelLayer,
    QuadbinTileLayer,
    RasterTileLayer,
    VectorTileLayer
  };

  // ../layers/bundle/peer-dependency.ts
  var peer_dependency_exports = {};
  var import_layers6 = __toESM(require_layers(), 1);
  __reExport(peer_dependency_exports, __toESM(require_layers(), 1));
  if (!import_layers6.GeoJsonLayer) {
    throw new Error("@deck.gl/layers is not found");
  }

  // bundle.ts
  __reExport(bundle_exports, peer_dependency_exports);
  var carto = src_exports;
  globalThis.CartoLibrary = src_exports;
  return __toCommonJS(bundle_exports);
})();
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
      return __exports__;
      });
