{
  "version": 3,
  "sources": ["../src/index.ts", "../src/simple-mesh-layer/simple-mesh-layer.ts", "../src/utils/matrix.ts", "../src/simple-mesh-layer/simple-mesh-layer-uniforms.ts", "../src/simple-mesh-layer/simple-mesh-layer-vertex.glsl.ts", "../src/simple-mesh-layer/simple-mesh-layer-fragment.glsl.ts", "../src/scenegraph-layer/scenegraph-layer.ts", "../src/scenegraph-layer/gltf-utils.ts", "../src/scenegraph-layer/scenegraph-layer-uniforms.ts", "../src/scenegraph-layer/scenegraph-layer-vertex.glsl.ts", "../src/scenegraph-layer/scenegraph-layer-fragment.glsl.ts"],
  "sourcesContent": ["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* eslint-disable max-len */\n\n// TODO - v9 - restore when luma.gl/gltf module is available again\n\nexport {default as SimpleMeshLayer} from './simple-mesh-layer/simple-mesh-layer';\nexport type {SimpleMeshLayerProps} from './simple-mesh-layer/simple-mesh-layer';\n\nexport type {ScenegraphLayerProps} from './scenegraph-layer/scenegraph-layer';\nexport {default as ScenegraphLayer} from './scenegraph-layer/scenegraph-layer';\n", "// Note: This file will either be moved back to deck.gl or reformatted to web-monorepo standards\n// Disabling lint temporarily to facilitate copying code in and out of this repo\n/* eslint-disable */\n\n// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Layer, project32, picking, DefaultProps, log, LayerContext, Material} from '@deck.gl/core';\nimport {SamplerProps, Texture} from '@luma.gl/core';\nimport {Model, Geometry} from '@luma.gl/engine';\nimport {ParsedPBRMaterial} from '@luma.gl/gltf';\nimport {phongMaterial} from '@luma.gl/shadertools';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport {simpleMeshUniforms, SimpleMeshProps} from './simple-mesh-layer-uniforms';\nimport vs from './simple-mesh-layer-vertex.glsl';\nimport fs from './simple-mesh-layer-fragment.glsl';\n\nimport type {\n  LayerProps,\n  LayerDataSource,\n  UpdateParameters,\n  Accessor,\n  Position,\n  Color,\n  TextureSource\n} from '@deck.gl/core';\nimport type {MeshAttribute, MeshAttributes} from '@loaders.gl/schema';\nimport type {Geometry as GeometryType} from '@luma.gl/engine';\nimport {getMeshBoundingBox} from '@loaders.gl/schema';\n\nfunction normalizeGeometryAttributes(attributes: MeshAttributes): MeshAttributes {\n  const positionAttribute = attributes.positions || attributes.POSITION;\n  log.assert(positionAttribute, 'no \"postions\" or \"POSITION\" attribute in mesh');\n\n  const vertexCount = positionAttribute.value.length / positionAttribute.size;\n  let colorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!colorAttribute) {\n    colorAttribute = {size: 3, value: new Float32Array(vertexCount * 3).fill(1)};\n  }\n  let normalAttribute = attributes.NORMAL || attributes.normals;\n  if (!normalAttribute) {\n    normalAttribute = {size: 3, value: new Float32Array(vertexCount * 3).fill(0)};\n  }\n  let texCoordAttribute = attributes.TEXCOORD_0 || attributes.texCoords;\n  if (!texCoordAttribute) {\n    texCoordAttribute = {size: 2, value: new Float32Array(vertexCount * 2).fill(0)};\n  }\n\n  return {\n    positions: positionAttribute,\n    colors: colorAttribute,\n    normals: normalAttribute,\n    texCoords: texCoordAttribute\n  };\n}\n\n/*\n * Convert mesh data into geometry\n * @returns {Geometry} geometry\n */\nfunction getGeometry(data: Mesh): Geometry {\n  if (data instanceof Geometry) {\n    // @ts-expect-error data.attributes is readonly\n    data.attributes = normalizeGeometryAttributes(data.attributes);\n    return data;\n  } else if ((data as any).attributes) {\n    return new Geometry({\n      ...data,\n      topology: 'triangle-list',\n      attributes: normalizeGeometryAttributes((data as any).attributes)\n    });\n  } else {\n    return new Geometry({\n      topology: 'triangle-list',\n      attributes: normalizeGeometryAttributes(data as MeshAttributes)\n    });\n  }\n}\n\nconst DEFAULT_COLOR: [number, number, number, number] = [0, 0, 0, 255];\n\ntype Mesh =\n  | GeometryType\n  | {\n      attributes: MeshAttributes;\n      indices?: MeshAttribute;\n    }\n  | MeshAttributes;\n\ntype _SimpleMeshLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  mesh: string | Mesh | Promise<Mesh> | null;\n  texture?: string | TextureSource | Promise<TextureSource>;\n  /** Customize the [texture parameters](https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texParameter). */\n  textureParameters?: SamplerProps | null;\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * If `mesh` does not contain vertex colors, use this color to render each object.\n   * If `mesh` contains vertex colors, then the two colors are mixed together.\n   * Use `[255, 255, 255]` to use the original mesh colors.\n   * If `texture` is assigned, then both colors will be ignored.\n   * @default [0, 0, 0, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n\n  /**\n   * (Experimental) If rendering only one instance of the mesh, set this to false to treat mesh positions\n   * as deltas of the world coordinates of the anchor.\n   * E.g. in LNGLAT coordinates, mesh positions are interpreted as meter offsets by default.\n   * setting _instanced to false interpreted mesh positions as lnglat deltas.\n   * @default true\n   */\n  _instanced?: boolean; // TODO - formalize API\n  /**\n   * Whether to render the mesh in wireframe mode.\n   * @default false\n   */\n  wireframe?: boolean;\n  /**\n   * Material props for lighting effect.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting#constructing-a-material-instance\n   */\n  material?: Material;\n};\n\nexport type SimpleMeshLayerProps<DataT = unknown> = _SimpleMeshLayerProps<DataT> & LayerProps;\n\nconst defaultProps: DefaultProps<SimpleMeshLayerProps> = {\n  mesh: {type: 'object', value: null, async: true},\n  texture: {type: 'image', value: null, async: true},\n  sizeScale: {type: 'number', value: 1, min: 0},\n\n  // _instanced is a hack to use world position instead of meter offsets in mesh\n  // TODO - formalize API\n  _instanced: true,\n  // NOTE(Tarek): Quick and dirty wireframe. Just draws\n  // the same mesh with LINE_STRIPS. Won't follow edges\n  // of the original mesh.\n  wireframe: false,\n  // Optional material for 'lighting' shader module\n  material: true,\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  textureParameters: {type: 'object', ignore: true, value: null}\n};\n\n/** Render a number of instances of an arbitrary 3D geometry. */\nexport default class SimpleMeshLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_SimpleMeshLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'SimpleMeshLayer';\n\n  state!: {\n    parsedPBRMaterial?: ParsedPBRMaterial;\n    model?: Model;\n    emptyTexture: Texture;\n    hasNormals?: boolean;\n    positionBounds?: [number[], number[]] | null;\n  };\n\n  getShaders() {\n    return super.getShaders({\n      vs,\n      fs,\n      modules: [project32, phongMaterial, picking, simpleMeshUniforms]\n    });\n  }\n\n  getBounds(): [number[], number[]] | null {\n    if (this.props._instanced) {\n      return super.getBounds();\n    }\n    let result = this.state.positionBounds;\n    if (result) {\n      return result;\n    }\n    const {mesh} = this.props;\n    if (!mesh) {\n      return null;\n    }\n    // @ts-ignore Detect if mesh is generated by loaders.gl\n    result = mesh.header?.boundingBox;\n\n    if (!result) {\n      // Otherwise, calculate bounding box from positions\n      const {attributes} = getGeometry(mesh as Mesh);\n      attributes.POSITION = attributes.POSITION || attributes.positions;\n\n      //@ts-expect-error\n      result = getMeshBoundingBox(attributes);\n    }\n\n    this.state.positionBounds = result;\n    return result;\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined in a primitive layer\n    attributeManager!.addInstanced({\n      instancePositions: {\n        transition: true,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        size: 3,\n        accessor: 'getPosition'\n      },\n      instanceColors: {\n        type: 'unorm8',\n        transition: true,\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: [0, 0, 0, 255]\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n\n    this.setState({\n      // Avoid luma.gl's missing uniform warning\n      // TODO - add feature to luma.gl to specify ignored uniforms?\n      emptyTexture: this.context.device.createTexture({\n        data: new Uint8Array(4),\n        width: 1,\n        height: 1\n      })\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    if (props.mesh !== oldProps.mesh || changeFlags.extensionsChanged) {\n      this.state.positionBounds = null;\n      this.state.model?.destroy();\n      if (props.mesh) {\n        this.state.model = this.getModel(props.mesh as Mesh);\n\n        const attributes = (props.mesh as any).attributes || props.mesh;\n        this.setState({\n          hasNormals: Boolean(attributes.NORMAL || attributes.normals)\n        });\n      }\n      // attributeManager is always defined in a primitive layer\n      this.getAttributeManager()!.invalidateAll();\n    }\n\n    if (props.texture !== oldProps.texture && props.texture instanceof Texture) {\n      this.setTexture(props.texture);\n    }\n\n    if (this.state.model) {\n      this.state.model.setTopology(this.props.wireframe ? 'line-strip' : 'triangle-list');\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n\n    this.state.emptyTexture.delete();\n  }\n\n  draw({uniforms}) {\n    const {model} = this.state;\n    if (!model) {\n      return;\n    }\n\n    const {viewport, renderPass} = this.context;\n    const {sizeScale, coordinateSystem, _instanced} = this.props;\n\n    const simpleMeshProps: SimpleMeshProps = {\n      sizeScale,\n      composeModelMatrix: !_instanced || shouldComposeModelMatrix(viewport, coordinateSystem),\n      flatShading: !this.state.hasNormals\n    };\n    model.shaderInputs.setProps({simpleMesh: simpleMeshProps});\n    model.draw(renderPass);\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(this.state?.model && super.isLoaded);\n  }\n\n  protected getModel(mesh: Mesh): Model {\n    const model = new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n      geometry: getGeometry(mesh),\n      isInstanced: true\n    });\n\n    const {texture} = this.props;\n    const {emptyTexture} = this.state;\n    const simpleMeshProps: SimpleMeshProps = {\n      sampler: (texture as Texture) || emptyTexture,\n      hasTexture: Boolean(texture)\n    };\n    model.shaderInputs.setProps({simpleMesh: simpleMeshProps});\n    return model;\n  }\n\n  private setTexture(texture: Texture): void {\n    const {emptyTexture, model} = this.state;\n\n    // props.mesh may not be ready at this time.\n    // The sampler will be set when `getModel` is called\n    if (model) {\n      const simpleMeshProps: SimpleMeshProps = {\n        sampler: texture || emptyTexture,\n        hasTexture: Boolean(texture)\n      };\n      model.shaderInputs.setProps({simpleMesh: simpleMeshProps});\n    }\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {COORDINATE_SYSTEM, createIterable} from '@deck.gl/core';\n\n/* eslint-disable max-statements, complexity, camelcase */\nconst RADIAN_PER_DEGREE = Math.PI / 180;\nconst modelMatrix = new Float32Array(16);\nconst valueArray = new Float32Array(12);\n\nfunction calculateTransformMatrix(targetMatrix, orientation, scale) {\n  const pitch = orientation[0] * RADIAN_PER_DEGREE;\n  const yaw = orientation[1] * RADIAN_PER_DEGREE;\n  const roll = orientation[2] * RADIAN_PER_DEGREE;\n\n  const sr = Math.sin(roll);\n  const sp = Math.sin(pitch);\n  const sw = Math.sin(yaw);\n\n  const cr = Math.cos(roll);\n  const cp = Math.cos(pitch);\n  const cw = Math.cos(yaw);\n\n  const scx = scale[0];\n  const scy = scale[1];\n  const scz = scale[2];\n\n  targetMatrix[0] = scx * cw * cp; // 0,0\n  targetMatrix[1] = scx * sw * cp; // 1,0\n  targetMatrix[2] = scx * -sp; // 2,0\n  targetMatrix[3] = scy * (-sw * cr + cw * sp * sr); // 0,1\n  targetMatrix[4] = scy * (cw * cr + sw * sp * sr); // 1,1\n  targetMatrix[5] = scy * cp * sr; // 2,1\n  targetMatrix[6] = scz * (sw * sr + cw * sp * cr); // 0,2\n  targetMatrix[7] = scz * (-cw * sr + sw * sp * cr); // 1,2\n  targetMatrix[8] = scz * cp * cr; // 2,2\n}\n\nfunction getExtendedMat3FromMat4(mat4) {\n  mat4[0] = mat4[0];\n  mat4[1] = mat4[1];\n  mat4[2] = mat4[2];\n  mat4[3] = mat4[4];\n  mat4[4] = mat4[5];\n  mat4[5] = mat4[6];\n  mat4[6] = mat4[8];\n  mat4[7] = mat4[9];\n  mat4[8] = mat4[10];\n  mat4[9] = mat4[12];\n  mat4[10] = mat4[13];\n  mat4[11] = mat4[14];\n\n  return mat4.subarray(0, 12);\n}\n\nexport const MATRIX_ATTRIBUTES = {\n  size: 12,\n  accessor: ['getOrientation', 'getScale', 'getTranslation', 'getTransformMatrix'],\n  shaderAttributes: {\n    instanceModelMatrixCol0: {\n      size: 3,\n      elementOffset: 0\n    },\n    instanceModelMatrixCol1: {\n      size: 3,\n      elementOffset: 3\n    },\n    instanceModelMatrixCol2: {\n      size: 3,\n      elementOffset: 6\n    },\n    instanceTranslation: {\n      size: 3,\n      elementOffset: 9\n    }\n  } as const,\n\n  update(attribute, {startRow, endRow}) {\n    // @ts-expect-error: \"this\" will be bound to a layer when this  function is called\n    const {data, getOrientation, getScale, getTranslation, getTransformMatrix} = this.props;\n\n    const arrayMatrix = Array.isArray(getTransformMatrix);\n    const constantMatrix = arrayMatrix && getTransformMatrix.length === 16;\n    const constantScale = Array.isArray(getScale);\n    const constantOrientation = Array.isArray(getOrientation);\n    const constantTranslation = Array.isArray(getTranslation);\n\n    const hasMatrix = constantMatrix || (!arrayMatrix && Boolean(getTransformMatrix(data[0])));\n\n    if (hasMatrix) {\n      attribute.constant = constantMatrix;\n    } else {\n      attribute.constant = constantOrientation && constantScale && constantTranslation;\n    }\n\n    const instanceModelMatrixData = attribute.value;\n\n    if (attribute.constant) {\n      let matrix;\n\n      if (hasMatrix) {\n        modelMatrix.set(getTransformMatrix);\n        matrix = getExtendedMat3FromMat4(modelMatrix);\n      } else {\n        matrix = valueArray;\n\n        const orientation = getOrientation;\n        const scale = getScale;\n\n        calculateTransformMatrix(matrix, orientation, scale);\n        matrix.set(getTranslation, 9);\n      }\n\n      attribute.value = new Float32Array(matrix);\n    } else {\n      let i = startRow * attribute.size;\n      const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n      for (const object of iterable) {\n        objectInfo.index++;\n        let matrix;\n\n        if (hasMatrix) {\n          modelMatrix.set(\n            constantMatrix ? getTransformMatrix : getTransformMatrix(object, objectInfo)\n          );\n          matrix = getExtendedMat3FromMat4(modelMatrix);\n        } else {\n          matrix = valueArray;\n\n          const orientation = constantOrientation\n            ? getOrientation\n            : getOrientation(object, objectInfo);\n          const scale = constantScale ? getScale : getScale(object, objectInfo);\n\n          calculateTransformMatrix(matrix, orientation, scale);\n          matrix.set(constantTranslation ? getTranslation : getTranslation(object, objectInfo), 9);\n        }\n\n        instanceModelMatrixData[i++] = matrix[0];\n        instanceModelMatrixData[i++] = matrix[1];\n        instanceModelMatrixData[i++] = matrix[2];\n        instanceModelMatrixData[i++] = matrix[3];\n        instanceModelMatrixData[i++] = matrix[4];\n        instanceModelMatrixData[i++] = matrix[5];\n        instanceModelMatrixData[i++] = matrix[6];\n        instanceModelMatrixData[i++] = matrix[7];\n        instanceModelMatrixData[i++] = matrix[8];\n        instanceModelMatrixData[i++] = matrix[9];\n        instanceModelMatrixData[i++] = matrix[10];\n        instanceModelMatrixData[i++] = matrix[11];\n      }\n    }\n  }\n};\n\n// only apply composeModelMatrix when in cartesian or meter_offsets coordinate system\n// with `composeModelMatrix` enabled, the rotation part of the layer's modelMatrix will be composed to instance's transformations\n// since rotating latitude and longitude can not provide meaningful results, hence `composeModelMatrix` is disabled\n// when in LNGLAT and LNGLAT_OFFSET coordinates.\nexport function shouldComposeModelMatrix(viewport, coordinateSystem) {\n  return (\n    coordinateSystem === COORDINATE_SYSTEM.CARTESIAN ||\n    coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS ||\n    (coordinateSystem === COORDINATE_SYSTEM.DEFAULT && !viewport.isGeospatial)\n  );\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Texture} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = `\\\nuniform simpleMeshUniforms {\n  float sizeScale;\n  bool composeModelMatrix;\n  bool hasTexture;\n  bool flatShading;\n} simpleMesh;\n`;\n\nexport type SimpleMeshProps = {\n  sizeScale?: number;\n  composeModelMatrix?: boolean;\n  hasTexture?: boolean;\n  flatShading?: boolean;\n  sampler?: Texture;\n};\n\nexport const simpleMeshUniforms = {\n  name: 'simpleMesh',\n  vs: uniformBlock,\n  fs: uniformBlock,\n  uniformTypes: {\n    sizeScale: 'f32',\n    composeModelMatrix: 'f32',\n    hasTexture: 'f32',\n    flatShading: 'f32'\n  }\n} as const satisfies ShaderModule<SimpleMeshProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-vs\n\n// Primitive attributes\nin vec3 positions;\nin vec3 normals;\nin vec3 colors;\nin vec2 texCoords;\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\n\n// Outputs to fragment shader\nout vec2 vTexCoord;\nout vec3 cameraPosition;\nout vec3 normals_commonspace;\nout vec4 position_commonspace;\nout vec4 vColor;\n\nvoid main(void) {\n  geometry.worldPosition = instancePositions;\n  geometry.uv = texCoords;\n  geometry.pickingColor = instancePickingColors;\n\n  vTexCoord = texCoords;\n  cameraPosition = project.cameraPosition;\n  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);\n\n  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\n  vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;\n\n  if (simpleMesh.composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);\n    geometry.position = position_commonspace;\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);\n    geometry.position = position_commonspace;\n    normals_commonspace = project_normal(instanceModelMatrix * normals);\n  }\n\n  geometry.normal = normals_commonspace;\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `#version 300 es\n#define SHADER_NAME simple-mesh-layer-fs\n\nprecision highp float;\n\nuniform sampler2D sampler;\n\nin vec2 vTexCoord;\nin vec3 cameraPosition;\nin vec3 normals_commonspace;\nin vec4 position_commonspace;\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  geometry.uv = vTexCoord;\n\n  vec3 normal;\n  if (simpleMesh.flatShading) {\n\n  normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\n  } else {\n    normal = normals_commonspace;\n  }\n\n  vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;\n  DECKGL_FILTER_COLOR(color, geometry);\n\n  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);\n  fragColor = vec4(lightColor, color.a * layer.opacity);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Layer, project32, picking, log} from '@deck.gl/core';\nimport type {Device} from '@luma.gl/core';\nimport {pbrMaterial} from '@luma.gl/shadertools';\nimport {ScenegraphNode, GroupNode, ModelNode, Model} from '@luma.gl/engine';\nimport {GLTFAnimator, PBREnvironment, createScenegraphsFromGLTF} from '@luma.gl/gltf';\nimport {GLTFLoader, postProcessGLTF} from '@loaders.gl/gltf';\nimport {waitForGLTFAssets} from './gltf-utils';\n\nimport {MATRIX_ATTRIBUTES, shouldComposeModelMatrix} from '../utils/matrix';\n\nimport {scenegraphUniforms, ScenegraphProps} from './scenegraph-layer-uniforms';\nimport vs from './scenegraph-layer-vertex.glsl';\nimport fs from './scenegraph-layer-fragment.glsl';\n\nimport {\n  UpdateParameters,\n  LayerContext,\n  LayerProps,\n  LayerDataSource,\n  Position,\n  Color,\n  Accessor,\n  DefaultProps\n} from '@deck.gl/core';\n\ntype GLTFInstantiatorOptions = Parameters<typeof createScenegraphsFromGLTF>[2];\n\nconst DEFAULT_COLOR: [number, number, number, number] = [255, 255, 255, 255];\n\nexport type ScenegraphLayerProps<DataT = unknown> = _ScenegraphLayerProps<DataT> & LayerProps;\n\ntype _ScenegraphLayerProps<DataT> = {\n  data: LayerDataSource<DataT>;\n  // TODO - define in luma.gl\n  /**\n   * A url for a glTF model or scenegraph loaded via a [scenegraph loader](https://loaders.gl/docs/specifications/category-scenegraph)\n   */\n  scenegraph: any;\n  /**\n   * Create a luma.gl GroupNode from the resolved scenegraph prop\n   */\n  getScene?: (\n    scenegraph: any,\n    context: {device?: Device; layer: ScenegraphLayer<DataT>}\n  ) => GroupNode;\n  /**\n   * Create a luma.gl GLTFAnimator from the resolved scenegraph prop\n   */\n  getAnimator?: (\n    scenegraph: any,\n    context: {device?: Device; layer: ScenegraphLayer<DataT>}\n  ) => GLTFAnimator;\n  /**\n   * (Experimental) animation configurations. Requires `_animate` on deck object.\n   */\n  _animations?: {\n    [name: number | string | '*']: {\n      /** If the animation is playing */\n      playing?: boolean;\n      /** Start time of the animation, default `0` */\n      startTime?: number;\n      /** Speed multiplier of the animation, default `1` */\n      speed?: number;\n    };\n  } | null;\n  /**\n   * (Experimental) lighting mode\n   * @default 'flat'\n   */\n  _lighting?: 'flat' | 'pbr';\n  /**\n   * (Experimental) lighting environment. Requires `_lighting` to be `'pbr'`.\n   */\n  _imageBasedLightingEnvironment?:\n    | PBREnvironment\n    | ((context: {gl: WebGL2RenderingContext; layer: ScenegraphLayer<DataT>}) => PBREnvironment);\n\n  /** Anchor position accessor. */\n  getPosition?: Accessor<DataT, Position>;\n  /** Color value or accessor.\n   * @default [255, 255, 255, 255]\n   */\n  getColor?: Accessor<DataT, Color>;\n  /**\n   * Orientation in [pitch, yaw, roll] in degrees.\n   * @see https://en.wikipedia.org/wiki/Euler_angles\n   * @default [0, 0, 0]\n   */\n  getOrientation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Scaling factor of the model along each axis.\n   * @default [1, 1, 1]\n   */\n  getScale?: Accessor<DataT, [number, number, number]>;\n  /**\n   * Translation from the anchor point, [x, y, z] in meters.\n   * @default [0, 0, 0]\n   */\n  getTranslation?: Accessor<DataT, [number, number, number]>;\n  /**\n   * TransformMatrix. If specified, `getOrientation`, `getScale` and `getTranslation` are ignored.\n   */\n  getTransformMatrix?: Accessor<DataT, number[]>;\n  /**\n   * Multiplier to scale each geometry by.\n   * @default 1\n   */\n  sizeScale?: number;\n  /**\n   * The minimum size in pixels for one unit of the scene.\n   * @default 0\n   */\n  sizeMinPixels?: number;\n  /**\n   * The maximum size in pixels for one unit of the scene.\n   * @default Number.MAX_SAFE_INTEGER\n   */\n  sizeMaxPixels?: number;\n};\n\nconst defaultProps: DefaultProps<ScenegraphLayerProps> = {\n  scenegraph: {type: 'object', value: null, async: true},\n  getScene: gltf => {\n    if (gltf && gltf.scenes) {\n      // gltf post processor replaces `gltf.scene` number with the scene `object`\n      return typeof gltf.scene === 'object' ? gltf.scene : gltf.scenes[gltf.scene || 0];\n    }\n    return gltf;\n  },\n  getAnimator: scenegraph => scenegraph && scenegraph.animator,\n  _animations: null,\n\n  sizeScale: {type: 'number', value: 1, min: 0},\n  sizeMinPixels: {type: 'number', min: 0, value: 0},\n  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},\n\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getColor: {type: 'accessor', value: DEFAULT_COLOR},\n\n  // flat or pbr\n  _lighting: 'flat',\n  // _lighting must be pbr for this to work\n  _imageBasedLightingEnvironment: undefined,\n\n  // yaw, pitch and roll are in degrees\n  // https://en.wikipedia.org/wiki/Euler_angles\n  // [pitch, yaw, roll]\n  getOrientation: {type: 'accessor', value: [0, 0, 0]},\n  getScale: {type: 'accessor', value: [1, 1, 1]},\n  getTranslation: {type: 'accessor', value: [0, 0, 0]},\n  // 4x4 matrix\n  getTransformMatrix: {type: 'accessor', value: []},\n\n  loaders: [GLTFLoader]\n};\n\n/** Render a number of instances of a complete glTF scenegraph. */\nexport default class ScenegraphLayer<DataT = any, ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ScenegraphLayerProps<DataT>>\n> {\n  static defaultProps = defaultProps;\n  static layerName = 'ScenegraphLayer';\n\n  state!: {\n    scenegraph: GroupNode;\n    animator: GLTFAnimator;\n    models: Model[];\n  };\n\n  getShaders() {\n    const defines: {LIGHTING_PBR?: 1} = {};\n    let pbr;\n\n    if (this.props._lighting === 'pbr') {\n      pbr = pbrMaterial;\n      defines.LIGHTING_PBR = 1;\n    } else {\n      // Dummy shader module needed to handle\n      // pbrMaterial.pbr_baseColorSampler binding\n      pbr = {name: 'pbrMaterial'};\n    }\n\n    const modules = [project32, picking, scenegraphUniforms, pbr];\n    return super.getShaders({defines, vs, fs, modules});\n  }\n\n  initializeState() {\n    const attributeManager = this.getAttributeManager();\n    // attributeManager is always defined for primitive layers\n    attributeManager!.addInstanced({\n      instancePositions: {\n        size: 3,\n        type: 'float64',\n        fp64: this.use64bitPositions(),\n        accessor: 'getPosition',\n        transition: true\n      },\n      instanceColors: {\n        type: 'unorm8',\n        size: this.props.colorFormat.length,\n        accessor: 'getColor',\n        defaultValue: DEFAULT_COLOR,\n        transition: true\n      },\n      instanceModelMatrix: MATRIX_ATTRIBUTES\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n    const {props, oldProps} = params;\n\n    if (props.scenegraph !== oldProps.scenegraph) {\n      this._updateScenegraph();\n    } else if (props._animations !== oldProps._animations) {\n      this._applyAnimationsProp(this.state.animator, props._animations);\n    }\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    this.state.scenegraph?.destroy();\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(this.state?.scenegraph && super.isLoaded);\n  }\n\n  private _updateScenegraph(): void {\n    const props = this.props;\n    const {device} = this.context;\n    let scenegraphData: any = null;\n    if (props.scenegraph instanceof ScenegraphNode) {\n      // Signature 1: props.scenegraph is a proper luma.gl Scenegraph\n      scenegraphData = {scenes: [props.scenegraph]};\n    } else if (props.scenegraph && typeof props.scenegraph === 'object') {\n      // Converts loaders.gl gltf to luma.gl scenegraph using the undocumented @luma.gl/experimental function\n      const gltf = props.scenegraph;\n\n      // Tiles3DLoader already processes GLTF\n      const processedGLTF = gltf.json ? postProcessGLTF(gltf) : gltf;\n\n      const gltfObjects = createScenegraphsFromGLTF(device, processedGLTF, this._getModelOptions());\n      scenegraphData = {gltf: processedGLTF, ...gltfObjects};\n\n      waitForGLTFAssets(gltfObjects)\n        .then(() => {\n          this.setNeedsRedraw();\n        })\n        .catch(ex => {\n          this.raiseError(ex, 'loading glTF');\n        });\n    }\n\n    const options = {layer: this, device: this.context.device};\n    const scenegraph = props.getScene(scenegraphData, options);\n    const animator = props.getAnimator(scenegraphData, options);\n\n    if (scenegraph instanceof GroupNode) {\n      this.state.scenegraph?.destroy();\n\n      this._applyAnimationsProp(animator, props._animations);\n\n      const models: Model[] = [];\n      scenegraph.traverse(node => {\n        if (node instanceof ModelNode) {\n          models.push(node.model);\n        }\n      });\n\n      this.setState({scenegraph, animator, models});\n      this.getAttributeManager()!.invalidateAll();\n    } else if (scenegraph !== null) {\n      log.warn('invalid scenegraph:', scenegraph)();\n    }\n  }\n\n  private _applyAnimationsProp(animator: GLTFAnimator, animationsProp: any): void {\n    if (!animator || !animationsProp) {\n      return;\n    }\n\n    const animations = animator.getAnimations();\n\n    // sort() to ensure '*' comes first so that other values can override\n    Object.keys(animationsProp)\n      .sort()\n      .forEach(key => {\n        // Key can be:\n        //  - number for index number\n        //  - name for animation name\n        //  - * to affect all animations\n        const value = animationsProp[key];\n\n        if (key === '*') {\n          animations.forEach(animation => {\n            Object.assign(animation, value);\n          });\n        } else if (Number.isFinite(Number(key))) {\n          const number = Number(key);\n          if (number >= 0 && number < animations.length) {\n            Object.assign(animations[number], value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        } else {\n          const findResult = animations.find(({animation}) => animation.name === key);\n          if (findResult) {\n            Object.assign(findResult, value);\n          } else {\n            log.warn(`animation ${key} not found`)();\n          }\n        }\n      });\n  }\n\n  private _getModelOptions(): GLTFInstantiatorOptions {\n    const {_imageBasedLightingEnvironment} = this.props;\n\n    let env: PBREnvironment | undefined;\n    if (_imageBasedLightingEnvironment) {\n      if (typeof _imageBasedLightingEnvironment === 'function') {\n        env = _imageBasedLightingEnvironment({gl: this.context.gl, layer: this});\n      } else {\n        env = _imageBasedLightingEnvironment;\n      }\n    }\n\n    return {\n      imageBasedLightingEnvironment: env,\n      modelOptions: {\n        id: this.props.id,\n        isInstanced: true,\n        bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n        ...this.getShaders()\n      },\n      // tangents are not supported\n      useTangents: false\n    };\n  }\n\n  draw({context}) {\n    if (!this.state.scenegraph) return;\n\n    if (this.props._animations && this.state.animator) {\n      this.state.animator.animate(context.timeline.getTime());\n      this.setNeedsRedraw();\n    }\n\n    const {viewport, renderPass} = this.context;\n    const {sizeScale, sizeMinPixels, sizeMaxPixels, coordinateSystem} = this.props;\n    const pbrProjectionProps = {\n      camera: viewport.cameraPosition as [number, number, number]\n    };\n\n    const numInstances = this.getNumInstances();\n    this.state.scenegraph.traverse((node, {worldMatrix}) => {\n      if (node instanceof ModelNode) {\n        const {model} = node;\n        model.setInstanceCount(numInstances);\n\n        const scenegraphProps: ScenegraphProps = {\n          sizeScale,\n          sizeMinPixels,\n          sizeMaxPixels,\n          composeModelMatrix: shouldComposeModelMatrix(viewport, coordinateSystem),\n          sceneModelMatrix: worldMatrix\n        };\n\n        model.shaderInputs.setProps({\n          pbrProjection: pbrProjectionProps,\n          scenegraph: scenegraphProps\n        });\n        model.draw(renderPass);\n      }\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global requestAnimationFrame */\nimport type {GroupNode, ScenegraphNode, ModelNode} from '@luma.gl/engine';\n\nexport async function waitForGLTFAssets(gltfObjects: {scenes: GroupNode[]}): Promise<void> {\n  const remaining: any[] = [];\n\n  gltfObjects.scenes.forEach(scene => {\n    scene.traverse((modelNode: ScenegraphNode) => {\n      // Not really clear how we can access the uniforms?\n      // TODO v9 getUnforms() was removed, hack it with props.uniforms\n      // Object.values((modelNode as ModelNode).model.uniforms).forEach((uniform: any) => {\n      //   if (uniform.loaded === false) {\n      //     remaining.push(uniform);\n      //   }\n      // });\n    });\n  });\n\n  return await waitWhileCondition(() => remaining.some(uniform => !uniform.loaded));\n}\n\nasync function waitWhileCondition(condition: () => boolean): Promise<void> {\n  while (condition()) {\n    await new Promise(resolve => requestAnimationFrame(resolve));\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Matrix4} from '@math.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = `\\\nuniform scenegraphUniforms {\n  float sizeScale;\n  float sizeMinPixels;\n  float sizeMaxPixels;\n  mat4 sceneModelMatrix;\n  bool composeModelMatrix;\n} scenegraph;\n`;\n\nexport type ScenegraphProps = {\n  sizeScale: number;\n  sizeMinPixels: number;\n  sizeMaxPixels: number;\n  sceneModelMatrix: Matrix4;\n  composeModelMatrix: boolean;\n};\n\nexport const scenegraphUniforms = {\n  name: 'scenegraph',\n  vs: uniformBlock,\n  fs: uniformBlock,\n  uniformTypes: {\n    sizeScale: 'f32',\n    sizeMinPixels: 'f32',\n    sizeMaxPixels: 'f32',\n    sceneModelMatrix: 'mat4x4<f32>',\n    composeModelMatrix: 'f32'\n  }\n} as const satisfies ShaderModule<ScenegraphProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\n\n#define SHADER_NAME scenegraph-layer-vertex-shader\n\n// Instance attributes\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin vec4 instanceColors;\nin vec3 instancePickingColors;\nin vec3 instanceModelMatrixCol0;\nin vec3 instanceModelMatrixCol1;\nin vec3 instanceModelMatrixCol2;\nin vec3 instanceTranslation;\n\n// Primitive attributes\nin vec3 positions;\n#ifdef HAS_UV\n  in vec2 texCoords;\n#endif\n#ifdef LIGHTING_PBR\n  #ifdef HAS_NORMALS\n    in vec3 normals;\n  #endif\n#endif\n\n// Varying\nout vec4 vColor;\n\n// pbrMaterial contains all the varying definitions needed\n#ifndef LIGHTING_PBR\n  #ifdef HAS_UV\n    out vec2 vTEXCOORD_0;\n  #endif\n#endif\n\n// Main\nvoid main(void) {\n  #if defined(HAS_UV) && !defined(LIGHTING_PBR)\n    vTEXCOORD_0 = texCoords;\n    geometry.uv = texCoords;\n  #endif\n\n  geometry.worldPosition = instancePositions;\n  geometry.pickingColor = instancePickingColors;\n\n  mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);\n\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n  #ifdef LIGHTING_PBR\n    #ifdef HAS_NORMALS\n      normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;\n    #endif\n  #endif\n\n  float originalSize = project_size_to_pixel(scenegraph.sizeScale);\n  float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);\n\n  vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;\n  if(scenegraph.composeModelMatrix) {\n    DECKGL_FILTER_SIZE(pos, geometry);\n    // using instancePositions as world coordinates\n    // when using globe mode, this branch does not re-orient the model to align with the surface of the earth\n    // call project_normal before setting position to avoid rotation\n    geometry.normal = project_normal(normal);\n    geometry.worldPosition += pos;\n    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\n  }\n  else {\n    pos = project_size(pos);\n    DECKGL_FILTER_SIZE(pos, geometry);\n    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);\n    geometry.normal = project_normal(normal);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  #ifdef LIGHTING_PBR\n    // set PBR data\n    pbr_vPosition = geometry.position.xyz;\n    #ifdef HAS_NORMALS\n      pbr_vNormal = geometry.normal;\n    #endif\n\n    #ifdef HAS_UV\n      pbr_vUV = texCoords;\n    #else\n      pbr_vUV = vec2(0., 0.);\n    #endif\n    geometry.uv = pbr_vUV;\n  #endif\n\n  vColor = instanceColors;\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\n\n#define SHADER_NAME scenegraph-layer-fragment-shader\n\n// Varying\nin vec4 vColor;\n\nout vec4 fragColor;\n\n// pbrMaterial contains all the varying definitions needed\n#ifndef LIGHTING_PBR\n  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n    in vec2 vTEXCOORD_0;\n    uniform sampler2D pbr_baseColorSampler;\n  #endif\n#endif\n\nvoid main(void) {\n  #ifdef LIGHTING_PBR\n    fragColor = vColor * pbr_filterColor(vec4(0));\n    geometry.uv = pbr_vUV;\n  #else\n    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)\n      fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);\n      geometry.uv = vTEXCOORD_0;\n    #else\n      fragColor = vColor;\n    #endif\n  #endif\n\n  fragColor.a *= layer.opacity;\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n"],
  "mappings": "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",
  "names": ["import_core", "import_core", "import_shadertools", "import_engine", "import_gltf", "uniformBlock", "DEFAULT_COLOR", "defaultProps"]
}
