(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target2, all) => {
    for (var name in all)
      __defProp(target2, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target2, mod, secondTarget) => (__copyProps(target2, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target2) => (target2 = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target2, "default", { value: mod, enumerable: true }) : target2,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // external-global-plugin:@deck.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@deck.gl/core"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // ../../node_modules/@luma.gl/constants/dist/webgl-constants.js
  var GLEnum;
  var init_webgl_constants = __esm({
    "../../node_modules/@luma.gl/constants/dist/webgl-constants.js"() {
      (function(GLEnum2) {
        GLEnum2[GLEnum2["DEPTH_BUFFER_BIT"] = 256] = "DEPTH_BUFFER_BIT";
        GLEnum2[GLEnum2["STENCIL_BUFFER_BIT"] = 1024] = "STENCIL_BUFFER_BIT";
        GLEnum2[GLEnum2["COLOR_BUFFER_BIT"] = 16384] = "COLOR_BUFFER_BIT";
        GLEnum2[GLEnum2["POINTS"] = 0] = "POINTS";
        GLEnum2[GLEnum2["LINES"] = 1] = "LINES";
        GLEnum2[GLEnum2["LINE_LOOP"] = 2] = "LINE_LOOP";
        GLEnum2[GLEnum2["LINE_STRIP"] = 3] = "LINE_STRIP";
        GLEnum2[GLEnum2["TRIANGLES"] = 4] = "TRIANGLES";
        GLEnum2[GLEnum2["TRIANGLE_STRIP"] = 5] = "TRIANGLE_STRIP";
        GLEnum2[GLEnum2["TRIANGLE_FAN"] = 6] = "TRIANGLE_FAN";
        GLEnum2[GLEnum2["ZERO"] = 0] = "ZERO";
        GLEnum2[GLEnum2["ONE"] = 1] = "ONE";
        GLEnum2[GLEnum2["SRC_COLOR"] = 768] = "SRC_COLOR";
        GLEnum2[GLEnum2["ONE_MINUS_SRC_COLOR"] = 769] = "ONE_MINUS_SRC_COLOR";
        GLEnum2[GLEnum2["SRC_ALPHA"] = 770] = "SRC_ALPHA";
        GLEnum2[GLEnum2["ONE_MINUS_SRC_ALPHA"] = 771] = "ONE_MINUS_SRC_ALPHA";
        GLEnum2[GLEnum2["DST_ALPHA"] = 772] = "DST_ALPHA";
        GLEnum2[GLEnum2["ONE_MINUS_DST_ALPHA"] = 773] = "ONE_MINUS_DST_ALPHA";
        GLEnum2[GLEnum2["DST_COLOR"] = 774] = "DST_COLOR";
        GLEnum2[GLEnum2["ONE_MINUS_DST_COLOR"] = 775] = "ONE_MINUS_DST_COLOR";
        GLEnum2[GLEnum2["SRC_ALPHA_SATURATE"] = 776] = "SRC_ALPHA_SATURATE";
        GLEnum2[GLEnum2["CONSTANT_COLOR"] = 32769] = "CONSTANT_COLOR";
        GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_COLOR"] = 32770] = "ONE_MINUS_CONSTANT_COLOR";
        GLEnum2[GLEnum2["CONSTANT_ALPHA"] = 32771] = "CONSTANT_ALPHA";
        GLEnum2[GLEnum2["ONE_MINUS_CONSTANT_ALPHA"] = 32772] = "ONE_MINUS_CONSTANT_ALPHA";
        GLEnum2[GLEnum2["FUNC_ADD"] = 32774] = "FUNC_ADD";
        GLEnum2[GLEnum2["FUNC_SUBTRACT"] = 32778] = "FUNC_SUBTRACT";
        GLEnum2[GLEnum2["FUNC_REVERSE_SUBTRACT"] = 32779] = "FUNC_REVERSE_SUBTRACT";
        GLEnum2[GLEnum2["BLEND_EQUATION"] = 32777] = "BLEND_EQUATION";
        GLEnum2[GLEnum2["BLEND_EQUATION_RGB"] = 32777] = "BLEND_EQUATION_RGB";
        GLEnum2[GLEnum2["BLEND_EQUATION_ALPHA"] = 34877] = "BLEND_EQUATION_ALPHA";
        GLEnum2[GLEnum2["BLEND_DST_RGB"] = 32968] = "BLEND_DST_RGB";
        GLEnum2[GLEnum2["BLEND_SRC_RGB"] = 32969] = "BLEND_SRC_RGB";
        GLEnum2[GLEnum2["BLEND_DST_ALPHA"] = 32970] = "BLEND_DST_ALPHA";
        GLEnum2[GLEnum2["BLEND_SRC_ALPHA"] = 32971] = "BLEND_SRC_ALPHA";
        GLEnum2[GLEnum2["BLEND_COLOR"] = 32773] = "BLEND_COLOR";
        GLEnum2[GLEnum2["ARRAY_BUFFER_BINDING"] = 34964] = "ARRAY_BUFFER_BINDING";
        GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER_BINDING"] = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING";
        GLEnum2[GLEnum2["LINE_WIDTH"] = 2849] = "LINE_WIDTH";
        GLEnum2[GLEnum2["ALIASED_POINT_SIZE_RANGE"] = 33901] = "ALIASED_POINT_SIZE_RANGE";
        GLEnum2[GLEnum2["ALIASED_LINE_WIDTH_RANGE"] = 33902] = "ALIASED_LINE_WIDTH_RANGE";
        GLEnum2[GLEnum2["CULL_FACE_MODE"] = 2885] = "CULL_FACE_MODE";
        GLEnum2[GLEnum2["FRONT_FACE"] = 2886] = "FRONT_FACE";
        GLEnum2[GLEnum2["DEPTH_RANGE"] = 2928] = "DEPTH_RANGE";
        GLEnum2[GLEnum2["DEPTH_WRITEMASK"] = 2930] = "DEPTH_WRITEMASK";
        GLEnum2[GLEnum2["DEPTH_CLEAR_VALUE"] = 2931] = "DEPTH_CLEAR_VALUE";
        GLEnum2[GLEnum2["DEPTH_FUNC"] = 2932] = "DEPTH_FUNC";
        GLEnum2[GLEnum2["STENCIL_CLEAR_VALUE"] = 2961] = "STENCIL_CLEAR_VALUE";
        GLEnum2[GLEnum2["STENCIL_FUNC"] = 2962] = "STENCIL_FUNC";
        GLEnum2[GLEnum2["STENCIL_FAIL"] = 2964] = "STENCIL_FAIL";
        GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_FAIL"] = 2965] = "STENCIL_PASS_DEPTH_FAIL";
        GLEnum2[GLEnum2["STENCIL_PASS_DEPTH_PASS"] = 2966] = "STENCIL_PASS_DEPTH_PASS";
        GLEnum2[GLEnum2["STENCIL_REF"] = 2967] = "STENCIL_REF";
        GLEnum2[GLEnum2["STENCIL_VALUE_MASK"] = 2963] = "STENCIL_VALUE_MASK";
        GLEnum2[GLEnum2["STENCIL_WRITEMASK"] = 2968] = "STENCIL_WRITEMASK";
        GLEnum2[GLEnum2["STENCIL_BACK_FUNC"] = 34816] = "STENCIL_BACK_FUNC";
        GLEnum2[GLEnum2["STENCIL_BACK_FAIL"] = 34817] = "STENCIL_BACK_FAIL";
        GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_FAIL"] = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL";
        GLEnum2[GLEnum2["STENCIL_BACK_PASS_DEPTH_PASS"] = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS";
        GLEnum2[GLEnum2["STENCIL_BACK_REF"] = 36003] = "STENCIL_BACK_REF";
        GLEnum2[GLEnum2["STENCIL_BACK_VALUE_MASK"] = 36004] = "STENCIL_BACK_VALUE_MASK";
        GLEnum2[GLEnum2["STENCIL_BACK_WRITEMASK"] = 36005] = "STENCIL_BACK_WRITEMASK";
        GLEnum2[GLEnum2["VIEWPORT"] = 2978] = "VIEWPORT";
        GLEnum2[GLEnum2["SCISSOR_BOX"] = 3088] = "SCISSOR_BOX";
        GLEnum2[GLEnum2["COLOR_CLEAR_VALUE"] = 3106] = "COLOR_CLEAR_VALUE";
        GLEnum2[GLEnum2["COLOR_WRITEMASK"] = 3107] = "COLOR_WRITEMASK";
        GLEnum2[GLEnum2["UNPACK_ALIGNMENT"] = 3317] = "UNPACK_ALIGNMENT";
        GLEnum2[GLEnum2["PACK_ALIGNMENT"] = 3333] = "PACK_ALIGNMENT";
        GLEnum2[GLEnum2["MAX_TEXTURE_SIZE"] = 3379] = "MAX_TEXTURE_SIZE";
        GLEnum2[GLEnum2["MAX_VIEWPORT_DIMS"] = 3386] = "MAX_VIEWPORT_DIMS";
        GLEnum2[GLEnum2["SUBPIXEL_BITS"] = 3408] = "SUBPIXEL_BITS";
        GLEnum2[GLEnum2["RED_BITS"] = 3410] = "RED_BITS";
        GLEnum2[GLEnum2["GREEN_BITS"] = 3411] = "GREEN_BITS";
        GLEnum2[GLEnum2["BLUE_BITS"] = 3412] = "BLUE_BITS";
        GLEnum2[GLEnum2["ALPHA_BITS"] = 3413] = "ALPHA_BITS";
        GLEnum2[GLEnum2["DEPTH_BITS"] = 3414] = "DEPTH_BITS";
        GLEnum2[GLEnum2["STENCIL_BITS"] = 3415] = "STENCIL_BITS";
        GLEnum2[GLEnum2["POLYGON_OFFSET_UNITS"] = 10752] = "POLYGON_OFFSET_UNITS";
        GLEnum2[GLEnum2["POLYGON_OFFSET_FACTOR"] = 32824] = "POLYGON_OFFSET_FACTOR";
        GLEnum2[GLEnum2["TEXTURE_BINDING_2D"] = 32873] = "TEXTURE_BINDING_2D";
        GLEnum2[GLEnum2["SAMPLE_BUFFERS"] = 32936] = "SAMPLE_BUFFERS";
        GLEnum2[GLEnum2["SAMPLES"] = 32937] = "SAMPLES";
        GLEnum2[GLEnum2["SAMPLE_COVERAGE_VALUE"] = 32938] = "SAMPLE_COVERAGE_VALUE";
        GLEnum2[GLEnum2["SAMPLE_COVERAGE_INVERT"] = 32939] = "SAMPLE_COVERAGE_INVERT";
        GLEnum2[GLEnum2["COMPRESSED_TEXTURE_FORMATS"] = 34467] = "COMPRESSED_TEXTURE_FORMATS";
        GLEnum2[GLEnum2["VENDOR"] = 7936] = "VENDOR";
        GLEnum2[GLEnum2["RENDERER"] = 7937] = "RENDERER";
        GLEnum2[GLEnum2["VERSION"] = 7938] = "VERSION";
        GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_TYPE"] = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE";
        GLEnum2[GLEnum2["IMPLEMENTATION_COLOR_READ_FORMAT"] = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT";
        GLEnum2[GLEnum2["BROWSER_DEFAULT_WEBGL"] = 37444] = "BROWSER_DEFAULT_WEBGL";
        GLEnum2[GLEnum2["STATIC_DRAW"] = 35044] = "STATIC_DRAW";
        GLEnum2[GLEnum2["STREAM_DRAW"] = 35040] = "STREAM_DRAW";
        GLEnum2[GLEnum2["DYNAMIC_DRAW"] = 35048] = "DYNAMIC_DRAW";
        GLEnum2[GLEnum2["ARRAY_BUFFER"] = 34962] = "ARRAY_BUFFER";
        GLEnum2[GLEnum2["ELEMENT_ARRAY_BUFFER"] = 34963] = "ELEMENT_ARRAY_BUFFER";
        GLEnum2[GLEnum2["BUFFER_SIZE"] = 34660] = "BUFFER_SIZE";
        GLEnum2[GLEnum2["BUFFER_USAGE"] = 34661] = "BUFFER_USAGE";
        GLEnum2[GLEnum2["CURRENT_VERTEX_ATTRIB"] = 34342] = "CURRENT_VERTEX_ATTRIB";
        GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_ENABLED"] = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED";
        GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_SIZE"] = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE";
        GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_STRIDE"] = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE";
        GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_TYPE"] = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE";
        GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_NORMALIZED"] = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED";
        GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_POINTER"] = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER";
        GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_BUFFER_BINDING"] = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING";
        GLEnum2[GLEnum2["CULL_FACE"] = 2884] = "CULL_FACE";
        GLEnum2[GLEnum2["FRONT"] = 1028] = "FRONT";
        GLEnum2[GLEnum2["BACK"] = 1029] = "BACK";
        GLEnum2[GLEnum2["FRONT_AND_BACK"] = 1032] = "FRONT_AND_BACK";
        GLEnum2[GLEnum2["BLEND"] = 3042] = "BLEND";
        GLEnum2[GLEnum2["DEPTH_TEST"] = 2929] = "DEPTH_TEST";
        GLEnum2[GLEnum2["DITHER"] = 3024] = "DITHER";
        GLEnum2[GLEnum2["POLYGON_OFFSET_FILL"] = 32823] = "POLYGON_OFFSET_FILL";
        GLEnum2[GLEnum2["SAMPLE_ALPHA_TO_COVERAGE"] = 32926] = "SAMPLE_ALPHA_TO_COVERAGE";
        GLEnum2[GLEnum2["SAMPLE_COVERAGE"] = 32928] = "SAMPLE_COVERAGE";
        GLEnum2[GLEnum2["SCISSOR_TEST"] = 3089] = "SCISSOR_TEST";
        GLEnum2[GLEnum2["STENCIL_TEST"] = 2960] = "STENCIL_TEST";
        GLEnum2[GLEnum2["NO_ERROR"] = 0] = "NO_ERROR";
        GLEnum2[GLEnum2["INVALID_ENUM"] = 1280] = "INVALID_ENUM";
        GLEnum2[GLEnum2["INVALID_VALUE"] = 1281] = "INVALID_VALUE";
        GLEnum2[GLEnum2["INVALID_OPERATION"] = 1282] = "INVALID_OPERATION";
        GLEnum2[GLEnum2["OUT_OF_MEMORY"] = 1285] = "OUT_OF_MEMORY";
        GLEnum2[GLEnum2["CONTEXT_LOST_WEBGL"] = 37442] = "CONTEXT_LOST_WEBGL";
        GLEnum2[GLEnum2["CW"] = 2304] = "CW";
        GLEnum2[GLEnum2["CCW"] = 2305] = "CCW";
        GLEnum2[GLEnum2["DONT_CARE"] = 4352] = "DONT_CARE";
        GLEnum2[GLEnum2["FASTEST"] = 4353] = "FASTEST";
        GLEnum2[GLEnum2["NICEST"] = 4354] = "NICEST";
        GLEnum2[GLEnum2["GENERATE_MIPMAP_HINT"] = 33170] = "GENERATE_MIPMAP_HINT";
        GLEnum2[GLEnum2["BYTE"] = 5120] = "BYTE";
        GLEnum2[GLEnum2["UNSIGNED_BYTE"] = 5121] = "UNSIGNED_BYTE";
        GLEnum2[GLEnum2["SHORT"] = 5122] = "SHORT";
        GLEnum2[GLEnum2["UNSIGNED_SHORT"] = 5123] = "UNSIGNED_SHORT";
        GLEnum2[GLEnum2["INT"] = 5124] = "INT";
        GLEnum2[GLEnum2["UNSIGNED_INT"] = 5125] = "UNSIGNED_INT";
        GLEnum2[GLEnum2["FLOAT"] = 5126] = "FLOAT";
        GLEnum2[GLEnum2["DOUBLE"] = 5130] = "DOUBLE";
        GLEnum2[GLEnum2["DEPTH_COMPONENT"] = 6402] = "DEPTH_COMPONENT";
        GLEnum2[GLEnum2["ALPHA"] = 6406] = "ALPHA";
        GLEnum2[GLEnum2["RGB"] = 6407] = "RGB";
        GLEnum2[GLEnum2["RGBA"] = 6408] = "RGBA";
        GLEnum2[GLEnum2["LUMINANCE"] = 6409] = "LUMINANCE";
        GLEnum2[GLEnum2["LUMINANCE_ALPHA"] = 6410] = "LUMINANCE_ALPHA";
        GLEnum2[GLEnum2["UNSIGNED_SHORT_4_4_4_4"] = 32819] = "UNSIGNED_SHORT_4_4_4_4";
        GLEnum2[GLEnum2["UNSIGNED_SHORT_5_5_5_1"] = 32820] = "UNSIGNED_SHORT_5_5_5_1";
        GLEnum2[GLEnum2["UNSIGNED_SHORT_5_6_5"] = 33635] = "UNSIGNED_SHORT_5_6_5";
        GLEnum2[GLEnum2["FRAGMENT_SHADER"] = 35632] = "FRAGMENT_SHADER";
        GLEnum2[GLEnum2["VERTEX_SHADER"] = 35633] = "VERTEX_SHADER";
        GLEnum2[GLEnum2["COMPILE_STATUS"] = 35713] = "COMPILE_STATUS";
        GLEnum2[GLEnum2["DELETE_STATUS"] = 35712] = "DELETE_STATUS";
        GLEnum2[GLEnum2["LINK_STATUS"] = 35714] = "LINK_STATUS";
        GLEnum2[GLEnum2["VALIDATE_STATUS"] = 35715] = "VALIDATE_STATUS";
        GLEnum2[GLEnum2["ATTACHED_SHADERS"] = 35717] = "ATTACHED_SHADERS";
        GLEnum2[GLEnum2["ACTIVE_ATTRIBUTES"] = 35721] = "ACTIVE_ATTRIBUTES";
        GLEnum2[GLEnum2["ACTIVE_UNIFORMS"] = 35718] = "ACTIVE_UNIFORMS";
        GLEnum2[GLEnum2["MAX_VERTEX_ATTRIBS"] = 34921] = "MAX_VERTEX_ATTRIBS";
        GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_VECTORS"] = 36347] = "MAX_VERTEX_UNIFORM_VECTORS";
        GLEnum2[GLEnum2["MAX_VARYING_VECTORS"] = 36348] = "MAX_VARYING_VECTORS";
        GLEnum2[GLEnum2["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS";
        GLEnum2[GLEnum2["MAX_VERTEX_TEXTURE_IMAGE_UNITS"] = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS";
        GLEnum2[GLEnum2["MAX_TEXTURE_IMAGE_UNITS"] = 34930] = "MAX_TEXTURE_IMAGE_UNITS";
        GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_VECTORS"] = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS";
        GLEnum2[GLEnum2["SHADER_TYPE"] = 35663] = "SHADER_TYPE";
        GLEnum2[GLEnum2["SHADING_LANGUAGE_VERSION"] = 35724] = "SHADING_LANGUAGE_VERSION";
        GLEnum2[GLEnum2["CURRENT_PROGRAM"] = 35725] = "CURRENT_PROGRAM";
        GLEnum2[GLEnum2["NEVER"] = 512] = "NEVER";
        GLEnum2[GLEnum2["LESS"] = 513] = "LESS";
        GLEnum2[GLEnum2["EQUAL"] = 514] = "EQUAL";
        GLEnum2[GLEnum2["LEQUAL"] = 515] = "LEQUAL";
        GLEnum2[GLEnum2["GREATER"] = 516] = "GREATER";
        GLEnum2[GLEnum2["NOTEQUAL"] = 517] = "NOTEQUAL";
        GLEnum2[GLEnum2["GEQUAL"] = 518] = "GEQUAL";
        GLEnum2[GLEnum2["ALWAYS"] = 519] = "ALWAYS";
        GLEnum2[GLEnum2["KEEP"] = 7680] = "KEEP";
        GLEnum2[GLEnum2["REPLACE"] = 7681] = "REPLACE";
        GLEnum2[GLEnum2["INCR"] = 7682] = "INCR";
        GLEnum2[GLEnum2["DECR"] = 7683] = "DECR";
        GLEnum2[GLEnum2["INVERT"] = 5386] = "INVERT";
        GLEnum2[GLEnum2["INCR_WRAP"] = 34055] = "INCR_WRAP";
        GLEnum2[GLEnum2["DECR_WRAP"] = 34056] = "DECR_WRAP";
        GLEnum2[GLEnum2["NEAREST"] = 9728] = "NEAREST";
        GLEnum2[GLEnum2["LINEAR"] = 9729] = "LINEAR";
        GLEnum2[GLEnum2["NEAREST_MIPMAP_NEAREST"] = 9984] = "NEAREST_MIPMAP_NEAREST";
        GLEnum2[GLEnum2["LINEAR_MIPMAP_NEAREST"] = 9985] = "LINEAR_MIPMAP_NEAREST";
        GLEnum2[GLEnum2["NEAREST_MIPMAP_LINEAR"] = 9986] = "NEAREST_MIPMAP_LINEAR";
        GLEnum2[GLEnum2["LINEAR_MIPMAP_LINEAR"] = 9987] = "LINEAR_MIPMAP_LINEAR";
        GLEnum2[GLEnum2["TEXTURE_MAG_FILTER"] = 10240] = "TEXTURE_MAG_FILTER";
        GLEnum2[GLEnum2["TEXTURE_MIN_FILTER"] = 10241] = "TEXTURE_MIN_FILTER";
        GLEnum2[GLEnum2["TEXTURE_WRAP_S"] = 10242] = "TEXTURE_WRAP_S";
        GLEnum2[GLEnum2["TEXTURE_WRAP_T"] = 10243] = "TEXTURE_WRAP_T";
        GLEnum2[GLEnum2["TEXTURE_2D"] = 3553] = "TEXTURE_2D";
        GLEnum2[GLEnum2["TEXTURE"] = 5890] = "TEXTURE";
        GLEnum2[GLEnum2["TEXTURE_CUBE_MAP"] = 34067] = "TEXTURE_CUBE_MAP";
        GLEnum2[GLEnum2["TEXTURE_BINDING_CUBE_MAP"] = 34068] = "TEXTURE_BINDING_CUBE_MAP";
        GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_X"] = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X";
        GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_X"] = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X";
        GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Y"] = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y";
        GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Y"] = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y";
        GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_POSITIVE_Z"] = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z";
        GLEnum2[GLEnum2["TEXTURE_CUBE_MAP_NEGATIVE_Z"] = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z";
        GLEnum2[GLEnum2["MAX_CUBE_MAP_TEXTURE_SIZE"] = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE";
        GLEnum2[GLEnum2["TEXTURE0"] = 33984] = "TEXTURE0";
        GLEnum2[GLEnum2["ACTIVE_TEXTURE"] = 34016] = "ACTIVE_TEXTURE";
        GLEnum2[GLEnum2["REPEAT"] = 10497] = "REPEAT";
        GLEnum2[GLEnum2["CLAMP_TO_EDGE"] = 33071] = "CLAMP_TO_EDGE";
        GLEnum2[GLEnum2["MIRRORED_REPEAT"] = 33648] = "MIRRORED_REPEAT";
        GLEnum2[GLEnum2["TEXTURE_WIDTH"] = 4096] = "TEXTURE_WIDTH";
        GLEnum2[GLEnum2["TEXTURE_HEIGHT"] = 4097] = "TEXTURE_HEIGHT";
        GLEnum2[GLEnum2["FLOAT_VEC2"] = 35664] = "FLOAT_VEC2";
        GLEnum2[GLEnum2["FLOAT_VEC3"] = 35665] = "FLOAT_VEC3";
        GLEnum2[GLEnum2["FLOAT_VEC4"] = 35666] = "FLOAT_VEC4";
        GLEnum2[GLEnum2["INT_VEC2"] = 35667] = "INT_VEC2";
        GLEnum2[GLEnum2["INT_VEC3"] = 35668] = "INT_VEC3";
        GLEnum2[GLEnum2["INT_VEC4"] = 35669] = "INT_VEC4";
        GLEnum2[GLEnum2["BOOL"] = 35670] = "BOOL";
        GLEnum2[GLEnum2["BOOL_VEC2"] = 35671] = "BOOL_VEC2";
        GLEnum2[GLEnum2["BOOL_VEC3"] = 35672] = "BOOL_VEC3";
        GLEnum2[GLEnum2["BOOL_VEC4"] = 35673] = "BOOL_VEC4";
        GLEnum2[GLEnum2["FLOAT_MAT2"] = 35674] = "FLOAT_MAT2";
        GLEnum2[GLEnum2["FLOAT_MAT3"] = 35675] = "FLOAT_MAT3";
        GLEnum2[GLEnum2["FLOAT_MAT4"] = 35676] = "FLOAT_MAT4";
        GLEnum2[GLEnum2["SAMPLER_2D"] = 35678] = "SAMPLER_2D";
        GLEnum2[GLEnum2["SAMPLER_CUBE"] = 35680] = "SAMPLER_CUBE";
        GLEnum2[GLEnum2["LOW_FLOAT"] = 36336] = "LOW_FLOAT";
        GLEnum2[GLEnum2["MEDIUM_FLOAT"] = 36337] = "MEDIUM_FLOAT";
        GLEnum2[GLEnum2["HIGH_FLOAT"] = 36338] = "HIGH_FLOAT";
        GLEnum2[GLEnum2["LOW_INT"] = 36339] = "LOW_INT";
        GLEnum2[GLEnum2["MEDIUM_INT"] = 36340] = "MEDIUM_INT";
        GLEnum2[GLEnum2["HIGH_INT"] = 36341] = "HIGH_INT";
        GLEnum2[GLEnum2["FRAMEBUFFER"] = 36160] = "FRAMEBUFFER";
        GLEnum2[GLEnum2["RENDERBUFFER"] = 36161] = "RENDERBUFFER";
        GLEnum2[GLEnum2["RGBA4"] = 32854] = "RGBA4";
        GLEnum2[GLEnum2["RGB5_A1"] = 32855] = "RGB5_A1";
        GLEnum2[GLEnum2["RGB565"] = 36194] = "RGB565";
        GLEnum2[GLEnum2["DEPTH_COMPONENT16"] = 33189] = "DEPTH_COMPONENT16";
        GLEnum2[GLEnum2["STENCIL_INDEX"] = 6401] = "STENCIL_INDEX";
        GLEnum2[GLEnum2["STENCIL_INDEX8"] = 36168] = "STENCIL_INDEX8";
        GLEnum2[GLEnum2["DEPTH_STENCIL"] = 34041] = "DEPTH_STENCIL";
        GLEnum2[GLEnum2["RENDERBUFFER_WIDTH"] = 36162] = "RENDERBUFFER_WIDTH";
        GLEnum2[GLEnum2["RENDERBUFFER_HEIGHT"] = 36163] = "RENDERBUFFER_HEIGHT";
        GLEnum2[GLEnum2["RENDERBUFFER_INTERNAL_FORMAT"] = 36164] = "RENDERBUFFER_INTERNAL_FORMAT";
        GLEnum2[GLEnum2["RENDERBUFFER_RED_SIZE"] = 36176] = "RENDERBUFFER_RED_SIZE";
        GLEnum2[GLEnum2["RENDERBUFFER_GREEN_SIZE"] = 36177] = "RENDERBUFFER_GREEN_SIZE";
        GLEnum2[GLEnum2["RENDERBUFFER_BLUE_SIZE"] = 36178] = "RENDERBUFFER_BLUE_SIZE";
        GLEnum2[GLEnum2["RENDERBUFFER_ALPHA_SIZE"] = 36179] = "RENDERBUFFER_ALPHA_SIZE";
        GLEnum2[GLEnum2["RENDERBUFFER_DEPTH_SIZE"] = 36180] = "RENDERBUFFER_DEPTH_SIZE";
        GLEnum2[GLEnum2["RENDERBUFFER_STENCIL_SIZE"] = 36181] = "RENDERBUFFER_STENCIL_SIZE";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE"] = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_OBJECT_NAME"] = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL"] = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE"] = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT0"] = 36064] = "COLOR_ATTACHMENT0";
        GLEnum2[GLEnum2["DEPTH_ATTACHMENT"] = 36096] = "DEPTH_ATTACHMENT";
        GLEnum2[GLEnum2["STENCIL_ATTACHMENT"] = 36128] = "STENCIL_ATTACHMENT";
        GLEnum2[GLEnum2["DEPTH_STENCIL_ATTACHMENT"] = 33306] = "DEPTH_STENCIL_ATTACHMENT";
        GLEnum2[GLEnum2["NONE"] = 0] = "NONE";
        GLEnum2[GLEnum2["FRAMEBUFFER_COMPLETE"] = 36053] = "FRAMEBUFFER_COMPLETE";
        GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"] = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
        GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"] = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
        GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"] = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
        GLEnum2[GLEnum2["FRAMEBUFFER_UNSUPPORTED"] = 36061] = "FRAMEBUFFER_UNSUPPORTED";
        GLEnum2[GLEnum2["FRAMEBUFFER_BINDING"] = 36006] = "FRAMEBUFFER_BINDING";
        GLEnum2[GLEnum2["RENDERBUFFER_BINDING"] = 36007] = "RENDERBUFFER_BINDING";
        GLEnum2[GLEnum2["READ_FRAMEBUFFER"] = 36008] = "READ_FRAMEBUFFER";
        GLEnum2[GLEnum2["DRAW_FRAMEBUFFER"] = 36009] = "DRAW_FRAMEBUFFER";
        GLEnum2[GLEnum2["MAX_RENDERBUFFER_SIZE"] = 34024] = "MAX_RENDERBUFFER_SIZE";
        GLEnum2[GLEnum2["INVALID_FRAMEBUFFER_OPERATION"] = 1286] = "INVALID_FRAMEBUFFER_OPERATION";
        GLEnum2[GLEnum2["UNPACK_FLIP_Y_WEBGL"] = 37440] = "UNPACK_FLIP_Y_WEBGL";
        GLEnum2[GLEnum2["UNPACK_PREMULTIPLY_ALPHA_WEBGL"] = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL";
        GLEnum2[GLEnum2["UNPACK_COLORSPACE_CONVERSION_WEBGL"] = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL";
        GLEnum2[GLEnum2["READ_BUFFER"] = 3074] = "READ_BUFFER";
        GLEnum2[GLEnum2["UNPACK_ROW_LENGTH"] = 3314] = "UNPACK_ROW_LENGTH";
        GLEnum2[GLEnum2["UNPACK_SKIP_ROWS"] = 3315] = "UNPACK_SKIP_ROWS";
        GLEnum2[GLEnum2["UNPACK_SKIP_PIXELS"] = 3316] = "UNPACK_SKIP_PIXELS";
        GLEnum2[GLEnum2["PACK_ROW_LENGTH"] = 3330] = "PACK_ROW_LENGTH";
        GLEnum2[GLEnum2["PACK_SKIP_ROWS"] = 3331] = "PACK_SKIP_ROWS";
        GLEnum2[GLEnum2["PACK_SKIP_PIXELS"] = 3332] = "PACK_SKIP_PIXELS";
        GLEnum2[GLEnum2["TEXTURE_BINDING_3D"] = 32874] = "TEXTURE_BINDING_3D";
        GLEnum2[GLEnum2["UNPACK_SKIP_IMAGES"] = 32877] = "UNPACK_SKIP_IMAGES";
        GLEnum2[GLEnum2["UNPACK_IMAGE_HEIGHT"] = 32878] = "UNPACK_IMAGE_HEIGHT";
        GLEnum2[GLEnum2["MAX_3D_TEXTURE_SIZE"] = 32883] = "MAX_3D_TEXTURE_SIZE";
        GLEnum2[GLEnum2["MAX_ELEMENTS_VERTICES"] = 33e3] = "MAX_ELEMENTS_VERTICES";
        GLEnum2[GLEnum2["MAX_ELEMENTS_INDICES"] = 33001] = "MAX_ELEMENTS_INDICES";
        GLEnum2[GLEnum2["MAX_TEXTURE_LOD_BIAS"] = 34045] = "MAX_TEXTURE_LOD_BIAS";
        GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_COMPONENTS"] = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS";
        GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_COMPONENTS"] = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS";
        GLEnum2[GLEnum2["MAX_ARRAY_TEXTURE_LAYERS"] = 35071] = "MAX_ARRAY_TEXTURE_LAYERS";
        GLEnum2[GLEnum2["MIN_PROGRAM_TEXEL_OFFSET"] = 35076] = "MIN_PROGRAM_TEXEL_OFFSET";
        GLEnum2[GLEnum2["MAX_PROGRAM_TEXEL_OFFSET"] = 35077] = "MAX_PROGRAM_TEXEL_OFFSET";
        GLEnum2[GLEnum2["MAX_VARYING_COMPONENTS"] = 35659] = "MAX_VARYING_COMPONENTS";
        GLEnum2[GLEnum2["FRAGMENT_SHADER_DERIVATIVE_HINT"] = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT";
        GLEnum2[GLEnum2["RASTERIZER_DISCARD"] = 35977] = "RASTERIZER_DISCARD";
        GLEnum2[GLEnum2["VERTEX_ARRAY_BINDING"] = 34229] = "VERTEX_ARRAY_BINDING";
        GLEnum2[GLEnum2["MAX_VERTEX_OUTPUT_COMPONENTS"] = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS";
        GLEnum2[GLEnum2["MAX_FRAGMENT_INPUT_COMPONENTS"] = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS";
        GLEnum2[GLEnum2["MAX_SERVER_WAIT_TIMEOUT"] = 37137] = "MAX_SERVER_WAIT_TIMEOUT";
        GLEnum2[GLEnum2["MAX_ELEMENT_INDEX"] = 36203] = "MAX_ELEMENT_INDEX";
        GLEnum2[GLEnum2["RED"] = 6403] = "RED";
        GLEnum2[GLEnum2["RGB8"] = 32849] = "RGB8";
        GLEnum2[GLEnum2["RGBA8"] = 32856] = "RGBA8";
        GLEnum2[GLEnum2["RGB10_A2"] = 32857] = "RGB10_A2";
        GLEnum2[GLEnum2["TEXTURE_3D"] = 32879] = "TEXTURE_3D";
        GLEnum2[GLEnum2["TEXTURE_WRAP_R"] = 32882] = "TEXTURE_WRAP_R";
        GLEnum2[GLEnum2["TEXTURE_MIN_LOD"] = 33082] = "TEXTURE_MIN_LOD";
        GLEnum2[GLEnum2["TEXTURE_MAX_LOD"] = 33083] = "TEXTURE_MAX_LOD";
        GLEnum2[GLEnum2["TEXTURE_BASE_LEVEL"] = 33084] = "TEXTURE_BASE_LEVEL";
        GLEnum2[GLEnum2["TEXTURE_MAX_LEVEL"] = 33085] = "TEXTURE_MAX_LEVEL";
        GLEnum2[GLEnum2["TEXTURE_COMPARE_MODE"] = 34892] = "TEXTURE_COMPARE_MODE";
        GLEnum2[GLEnum2["TEXTURE_COMPARE_FUNC"] = 34893] = "TEXTURE_COMPARE_FUNC";
        GLEnum2[GLEnum2["SRGB"] = 35904] = "SRGB";
        GLEnum2[GLEnum2["SRGB8"] = 35905] = "SRGB8";
        GLEnum2[GLEnum2["SRGB8_ALPHA8"] = 35907] = "SRGB8_ALPHA8";
        GLEnum2[GLEnum2["COMPARE_REF_TO_TEXTURE"] = 34894] = "COMPARE_REF_TO_TEXTURE";
        GLEnum2[GLEnum2["RGBA32F"] = 34836] = "RGBA32F";
        GLEnum2[GLEnum2["RGB32F"] = 34837] = "RGB32F";
        GLEnum2[GLEnum2["RGBA16F"] = 34842] = "RGBA16F";
        GLEnum2[GLEnum2["RGB16F"] = 34843] = "RGB16F";
        GLEnum2[GLEnum2["TEXTURE_2D_ARRAY"] = 35866] = "TEXTURE_2D_ARRAY";
        GLEnum2[GLEnum2["TEXTURE_BINDING_2D_ARRAY"] = 35869] = "TEXTURE_BINDING_2D_ARRAY";
        GLEnum2[GLEnum2["R11F_G11F_B10F"] = 35898] = "R11F_G11F_B10F";
        GLEnum2[GLEnum2["RGB9_E5"] = 35901] = "RGB9_E5";
        GLEnum2[GLEnum2["RGBA32UI"] = 36208] = "RGBA32UI";
        GLEnum2[GLEnum2["RGB32UI"] = 36209] = "RGB32UI";
        GLEnum2[GLEnum2["RGBA16UI"] = 36214] = "RGBA16UI";
        GLEnum2[GLEnum2["RGB16UI"] = 36215] = "RGB16UI";
        GLEnum2[GLEnum2["RGBA8UI"] = 36220] = "RGBA8UI";
        GLEnum2[GLEnum2["RGB8UI"] = 36221] = "RGB8UI";
        GLEnum2[GLEnum2["RGBA32I"] = 36226] = "RGBA32I";
        GLEnum2[GLEnum2["RGB32I"] = 36227] = "RGB32I";
        GLEnum2[GLEnum2["RGBA16I"] = 36232] = "RGBA16I";
        GLEnum2[GLEnum2["RGB16I"] = 36233] = "RGB16I";
        GLEnum2[GLEnum2["RGBA8I"] = 36238] = "RGBA8I";
        GLEnum2[GLEnum2["RGB8I"] = 36239] = "RGB8I";
        GLEnum2[GLEnum2["RED_INTEGER"] = 36244] = "RED_INTEGER";
        GLEnum2[GLEnum2["RGB_INTEGER"] = 36248] = "RGB_INTEGER";
        GLEnum2[GLEnum2["RGBA_INTEGER"] = 36249] = "RGBA_INTEGER";
        GLEnum2[GLEnum2["R8"] = 33321] = "R8";
        GLEnum2[GLEnum2["RG8"] = 33323] = "RG8";
        GLEnum2[GLEnum2["R16F"] = 33325] = "R16F";
        GLEnum2[GLEnum2["R32F"] = 33326] = "R32F";
        GLEnum2[GLEnum2["RG16F"] = 33327] = "RG16F";
        GLEnum2[GLEnum2["RG32F"] = 33328] = "RG32F";
        GLEnum2[GLEnum2["R8I"] = 33329] = "R8I";
        GLEnum2[GLEnum2["R8UI"] = 33330] = "R8UI";
        GLEnum2[GLEnum2["R16I"] = 33331] = "R16I";
        GLEnum2[GLEnum2["R16UI"] = 33332] = "R16UI";
        GLEnum2[GLEnum2["R32I"] = 33333] = "R32I";
        GLEnum2[GLEnum2["R32UI"] = 33334] = "R32UI";
        GLEnum2[GLEnum2["RG8I"] = 33335] = "RG8I";
        GLEnum2[GLEnum2["RG8UI"] = 33336] = "RG8UI";
        GLEnum2[GLEnum2["RG16I"] = 33337] = "RG16I";
        GLEnum2[GLEnum2["RG16UI"] = 33338] = "RG16UI";
        GLEnum2[GLEnum2["RG32I"] = 33339] = "RG32I";
        GLEnum2[GLEnum2["RG32UI"] = 33340] = "RG32UI";
        GLEnum2[GLEnum2["R8_SNORM"] = 36756] = "R8_SNORM";
        GLEnum2[GLEnum2["RG8_SNORM"] = 36757] = "RG8_SNORM";
        GLEnum2[GLEnum2["RGB8_SNORM"] = 36758] = "RGB8_SNORM";
        GLEnum2[GLEnum2["RGBA8_SNORM"] = 36759] = "RGBA8_SNORM";
        GLEnum2[GLEnum2["RGB10_A2UI"] = 36975] = "RGB10_A2UI";
        GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_FORMAT"] = 37167] = "TEXTURE_IMMUTABLE_FORMAT";
        GLEnum2[GLEnum2["TEXTURE_IMMUTABLE_LEVELS"] = 33503] = "TEXTURE_IMMUTABLE_LEVELS";
        GLEnum2[GLEnum2["UNSIGNED_INT_2_10_10_10_REV"] = 33640] = "UNSIGNED_INT_2_10_10_10_REV";
        GLEnum2[GLEnum2["UNSIGNED_INT_10F_11F_11F_REV"] = 35899] = "UNSIGNED_INT_10F_11F_11F_REV";
        GLEnum2[GLEnum2["UNSIGNED_INT_5_9_9_9_REV"] = 35902] = "UNSIGNED_INT_5_9_9_9_REV";
        GLEnum2[GLEnum2["FLOAT_32_UNSIGNED_INT_24_8_REV"] = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV";
        GLEnum2[GLEnum2["UNSIGNED_INT_24_8"] = 34042] = "UNSIGNED_INT_24_8";
        GLEnum2[GLEnum2["HALF_FLOAT"] = 5131] = "HALF_FLOAT";
        GLEnum2[GLEnum2["RG"] = 33319] = "RG";
        GLEnum2[GLEnum2["RG_INTEGER"] = 33320] = "RG_INTEGER";
        GLEnum2[GLEnum2["INT_2_10_10_10_REV"] = 36255] = "INT_2_10_10_10_REV";
        GLEnum2[GLEnum2["CURRENT_QUERY"] = 34917] = "CURRENT_QUERY";
        GLEnum2[GLEnum2["QUERY_RESULT"] = 34918] = "QUERY_RESULT";
        GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE"] = 34919] = "QUERY_RESULT_AVAILABLE";
        GLEnum2[GLEnum2["ANY_SAMPLES_PASSED"] = 35887] = "ANY_SAMPLES_PASSED";
        GLEnum2[GLEnum2["ANY_SAMPLES_PASSED_CONSERVATIVE"] = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE";
        GLEnum2[GLEnum2["MAX_DRAW_BUFFERS"] = 34852] = "MAX_DRAW_BUFFERS";
        GLEnum2[GLEnum2["DRAW_BUFFER0"] = 34853] = "DRAW_BUFFER0";
        GLEnum2[GLEnum2["DRAW_BUFFER1"] = 34854] = "DRAW_BUFFER1";
        GLEnum2[GLEnum2["DRAW_BUFFER2"] = 34855] = "DRAW_BUFFER2";
        GLEnum2[GLEnum2["DRAW_BUFFER3"] = 34856] = "DRAW_BUFFER3";
        GLEnum2[GLEnum2["DRAW_BUFFER4"] = 34857] = "DRAW_BUFFER4";
        GLEnum2[GLEnum2["DRAW_BUFFER5"] = 34858] = "DRAW_BUFFER5";
        GLEnum2[GLEnum2["DRAW_BUFFER6"] = 34859] = "DRAW_BUFFER6";
        GLEnum2[GLEnum2["DRAW_BUFFER7"] = 34860] = "DRAW_BUFFER7";
        GLEnum2[GLEnum2["DRAW_BUFFER8"] = 34861] = "DRAW_BUFFER8";
        GLEnum2[GLEnum2["DRAW_BUFFER9"] = 34862] = "DRAW_BUFFER9";
        GLEnum2[GLEnum2["DRAW_BUFFER10"] = 34863] = "DRAW_BUFFER10";
        GLEnum2[GLEnum2["DRAW_BUFFER11"] = 34864] = "DRAW_BUFFER11";
        GLEnum2[GLEnum2["DRAW_BUFFER12"] = 34865] = "DRAW_BUFFER12";
        GLEnum2[GLEnum2["DRAW_BUFFER13"] = 34866] = "DRAW_BUFFER13";
        GLEnum2[GLEnum2["DRAW_BUFFER14"] = 34867] = "DRAW_BUFFER14";
        GLEnum2[GLEnum2["DRAW_BUFFER15"] = 34868] = "DRAW_BUFFER15";
        GLEnum2[GLEnum2["MAX_COLOR_ATTACHMENTS"] = 36063] = "MAX_COLOR_ATTACHMENTS";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT1"] = 36065] = "COLOR_ATTACHMENT1";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT2"] = 36066] = "COLOR_ATTACHMENT2";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT3"] = 36067] = "COLOR_ATTACHMENT3";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT4"] = 36068] = "COLOR_ATTACHMENT4";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT5"] = 36069] = "COLOR_ATTACHMENT5";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT6"] = 36070] = "COLOR_ATTACHMENT6";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT7"] = 36071] = "COLOR_ATTACHMENT7";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT8"] = 36072] = "COLOR_ATTACHMENT8";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT9"] = 36073] = "COLOR_ATTACHMENT9";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT10"] = 36074] = "COLOR_ATTACHMENT10";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT11"] = 36075] = "COLOR_ATTACHMENT11";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT12"] = 36076] = "COLOR_ATTACHMENT12";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT13"] = 36077] = "COLOR_ATTACHMENT13";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT14"] = 36078] = "COLOR_ATTACHMENT14";
        GLEnum2[GLEnum2["COLOR_ATTACHMENT15"] = 36079] = "COLOR_ATTACHMENT15";
        GLEnum2[GLEnum2["SAMPLER_3D"] = 35679] = "SAMPLER_3D";
        GLEnum2[GLEnum2["SAMPLER_2D_SHADOW"] = 35682] = "SAMPLER_2D_SHADOW";
        GLEnum2[GLEnum2["SAMPLER_2D_ARRAY"] = 36289] = "SAMPLER_2D_ARRAY";
        GLEnum2[GLEnum2["SAMPLER_2D_ARRAY_SHADOW"] = 36292] = "SAMPLER_2D_ARRAY_SHADOW";
        GLEnum2[GLEnum2["SAMPLER_CUBE_SHADOW"] = 36293] = "SAMPLER_CUBE_SHADOW";
        GLEnum2[GLEnum2["INT_SAMPLER_2D"] = 36298] = "INT_SAMPLER_2D";
        GLEnum2[GLEnum2["INT_SAMPLER_3D"] = 36299] = "INT_SAMPLER_3D";
        GLEnum2[GLEnum2["INT_SAMPLER_CUBE"] = 36300] = "INT_SAMPLER_CUBE";
        GLEnum2[GLEnum2["INT_SAMPLER_2D_ARRAY"] = 36303] = "INT_SAMPLER_2D_ARRAY";
        GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D"] = 36306] = "UNSIGNED_INT_SAMPLER_2D";
        GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_3D"] = 36307] = "UNSIGNED_INT_SAMPLER_3D";
        GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_CUBE"] = 36308] = "UNSIGNED_INT_SAMPLER_CUBE";
        GLEnum2[GLEnum2["UNSIGNED_INT_SAMPLER_2D_ARRAY"] = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY";
        GLEnum2[GLEnum2["MAX_SAMPLES"] = 36183] = "MAX_SAMPLES";
        GLEnum2[GLEnum2["SAMPLER_BINDING"] = 35097] = "SAMPLER_BINDING";
        GLEnum2[GLEnum2["PIXEL_PACK_BUFFER"] = 35051] = "PIXEL_PACK_BUFFER";
        GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER"] = 35052] = "PIXEL_UNPACK_BUFFER";
        GLEnum2[GLEnum2["PIXEL_PACK_BUFFER_BINDING"] = 35053] = "PIXEL_PACK_BUFFER_BINDING";
        GLEnum2[GLEnum2["PIXEL_UNPACK_BUFFER_BINDING"] = 35055] = "PIXEL_UNPACK_BUFFER_BINDING";
        GLEnum2[GLEnum2["COPY_READ_BUFFER"] = 36662] = "COPY_READ_BUFFER";
        GLEnum2[GLEnum2["COPY_WRITE_BUFFER"] = 36663] = "COPY_WRITE_BUFFER";
        GLEnum2[GLEnum2["COPY_READ_BUFFER_BINDING"] = 36662] = "COPY_READ_BUFFER_BINDING";
        GLEnum2[GLEnum2["COPY_WRITE_BUFFER_BINDING"] = 36663] = "COPY_WRITE_BUFFER_BINDING";
        GLEnum2[GLEnum2["FLOAT_MAT2x3"] = 35685] = "FLOAT_MAT2x3";
        GLEnum2[GLEnum2["FLOAT_MAT2x4"] = 35686] = "FLOAT_MAT2x4";
        GLEnum2[GLEnum2["FLOAT_MAT3x2"] = 35687] = "FLOAT_MAT3x2";
        GLEnum2[GLEnum2["FLOAT_MAT3x4"] = 35688] = "FLOAT_MAT3x4";
        GLEnum2[GLEnum2["FLOAT_MAT4x2"] = 35689] = "FLOAT_MAT4x2";
        GLEnum2[GLEnum2["FLOAT_MAT4x3"] = 35690] = "FLOAT_MAT4x3";
        GLEnum2[GLEnum2["UNSIGNED_INT_VEC2"] = 36294] = "UNSIGNED_INT_VEC2";
        GLEnum2[GLEnum2["UNSIGNED_INT_VEC3"] = 36295] = "UNSIGNED_INT_VEC3";
        GLEnum2[GLEnum2["UNSIGNED_INT_VEC4"] = 36296] = "UNSIGNED_INT_VEC4";
        GLEnum2[GLEnum2["UNSIGNED_NORMALIZED"] = 35863] = "UNSIGNED_NORMALIZED";
        GLEnum2[GLEnum2["SIGNED_NORMALIZED"] = 36764] = "SIGNED_NORMALIZED";
        GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_INTEGER"] = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER";
        GLEnum2[GLEnum2["VERTEX_ATTRIB_ARRAY_DIVISOR"] = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_MODE"] = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE";
        GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS"] = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_VARYINGS"] = 35971] = "TRANSFORM_FEEDBACK_VARYINGS";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_START"] = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_SIZE"] = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN"] = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN";
        GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS"] = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS";
        GLEnum2[GLEnum2["MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS"] = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS";
        GLEnum2[GLEnum2["INTERLEAVED_ATTRIBS"] = 35980] = "INTERLEAVED_ATTRIBS";
        GLEnum2[GLEnum2["SEPARATE_ATTRIBS"] = 35981] = "SEPARATE_ATTRIBS";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER"] = 35982] = "TRANSFORM_FEEDBACK_BUFFER";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BUFFER_BINDING"] = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK"] = 36386] = "TRANSFORM_FEEDBACK";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_PAUSED"] = 36387] = "TRANSFORM_FEEDBACK_PAUSED";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_ACTIVE"] = 36388] = "TRANSFORM_FEEDBACK_ACTIVE";
        GLEnum2[GLEnum2["TRANSFORM_FEEDBACK_BINDING"] = 36389] = "TRANSFORM_FEEDBACK_BINDING";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING"] = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_RED_SIZE"] = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_GREEN_SIZE"] = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_BLUE_SIZE"] = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE"] = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE"] = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE"] = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE";
        GLEnum2[GLEnum2["FRAMEBUFFER_DEFAULT"] = 33304] = "FRAMEBUFFER_DEFAULT";
        GLEnum2[GLEnum2["DEPTH24_STENCIL8"] = 35056] = "DEPTH24_STENCIL8";
        GLEnum2[GLEnum2["DRAW_FRAMEBUFFER_BINDING"] = 36006] = "DRAW_FRAMEBUFFER_BINDING";
        GLEnum2[GLEnum2["READ_FRAMEBUFFER_BINDING"] = 36010] = "READ_FRAMEBUFFER_BINDING";
        GLEnum2[GLEnum2["RENDERBUFFER_SAMPLES"] = 36011] = "RENDERBUFFER_SAMPLES";
        GLEnum2[GLEnum2["FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER"] = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER";
        GLEnum2[GLEnum2["FRAMEBUFFER_INCOMPLETE_MULTISAMPLE"] = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE";
        GLEnum2[GLEnum2["UNIFORM_BUFFER"] = 35345] = "UNIFORM_BUFFER";
        GLEnum2[GLEnum2["UNIFORM_BUFFER_BINDING"] = 35368] = "UNIFORM_BUFFER_BINDING";
        GLEnum2[GLEnum2["UNIFORM_BUFFER_START"] = 35369] = "UNIFORM_BUFFER_START";
        GLEnum2[GLEnum2["UNIFORM_BUFFER_SIZE"] = 35370] = "UNIFORM_BUFFER_SIZE";
        GLEnum2[GLEnum2["MAX_VERTEX_UNIFORM_BLOCKS"] = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS";
        GLEnum2[GLEnum2["MAX_FRAGMENT_UNIFORM_BLOCKS"] = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS";
        GLEnum2[GLEnum2["MAX_COMBINED_UNIFORM_BLOCKS"] = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS";
        GLEnum2[GLEnum2["MAX_UNIFORM_BUFFER_BINDINGS"] = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS";
        GLEnum2[GLEnum2["MAX_UNIFORM_BLOCK_SIZE"] = 35376] = "MAX_UNIFORM_BLOCK_SIZE";
        GLEnum2[GLEnum2["MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS"] = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS";
        GLEnum2[GLEnum2["MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS"] = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS";
        GLEnum2[GLEnum2["UNIFORM_BUFFER_OFFSET_ALIGNMENT"] = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT";
        GLEnum2[GLEnum2["ACTIVE_UNIFORM_BLOCKS"] = 35382] = "ACTIVE_UNIFORM_BLOCKS";
        GLEnum2[GLEnum2["UNIFORM_TYPE"] = 35383] = "UNIFORM_TYPE";
        GLEnum2[GLEnum2["UNIFORM_SIZE"] = 35384] = "UNIFORM_SIZE";
        GLEnum2[GLEnum2["UNIFORM_BLOCK_INDEX"] = 35386] = "UNIFORM_BLOCK_INDEX";
        GLEnum2[GLEnum2["UNIFORM_OFFSET"] = 35387] = "UNIFORM_OFFSET";
        GLEnum2[GLEnum2["UNIFORM_ARRAY_STRIDE"] = 35388] = "UNIFORM_ARRAY_STRIDE";
        GLEnum2[GLEnum2["UNIFORM_MATRIX_STRIDE"] = 35389] = "UNIFORM_MATRIX_STRIDE";
        GLEnum2[GLEnum2["UNIFORM_IS_ROW_MAJOR"] = 35390] = "UNIFORM_IS_ROW_MAJOR";
        GLEnum2[GLEnum2["UNIFORM_BLOCK_BINDING"] = 35391] = "UNIFORM_BLOCK_BINDING";
        GLEnum2[GLEnum2["UNIFORM_BLOCK_DATA_SIZE"] = 35392] = "UNIFORM_BLOCK_DATA_SIZE";
        GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORMS"] = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS";
        GLEnum2[GLEnum2["UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES"] = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES";
        GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER"] = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER";
        GLEnum2[GLEnum2["UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER"] = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER";
        GLEnum2[GLEnum2["OBJECT_TYPE"] = 37138] = "OBJECT_TYPE";
        GLEnum2[GLEnum2["SYNC_CONDITION"] = 37139] = "SYNC_CONDITION";
        GLEnum2[GLEnum2["SYNC_STATUS"] = 37140] = "SYNC_STATUS";
        GLEnum2[GLEnum2["SYNC_FLAGS"] = 37141] = "SYNC_FLAGS";
        GLEnum2[GLEnum2["SYNC_FENCE"] = 37142] = "SYNC_FENCE";
        GLEnum2[GLEnum2["SYNC_GPU_COMMANDS_COMPLETE"] = 37143] = "SYNC_GPU_COMMANDS_COMPLETE";
        GLEnum2[GLEnum2["UNSIGNALED"] = 37144] = "UNSIGNALED";
        GLEnum2[GLEnum2["SIGNALED"] = 37145] = "SIGNALED";
        GLEnum2[GLEnum2["ALREADY_SIGNALED"] = 37146] = "ALREADY_SIGNALED";
        GLEnum2[GLEnum2["TIMEOUT_EXPIRED"] = 37147] = "TIMEOUT_EXPIRED";
        GLEnum2[GLEnum2["CONDITION_SATISFIED"] = 37148] = "CONDITION_SATISFIED";
        GLEnum2[GLEnum2["WAIT_FAILED"] = 37149] = "WAIT_FAILED";
        GLEnum2[GLEnum2["SYNC_FLUSH_COMMANDS_BIT"] = 1] = "SYNC_FLUSH_COMMANDS_BIT";
        GLEnum2[GLEnum2["COLOR"] = 6144] = "COLOR";
        GLEnum2[GLEnum2["DEPTH"] = 6145] = "DEPTH";
        GLEnum2[GLEnum2["STENCIL"] = 6146] = "STENCIL";
        GLEnum2[GLEnum2["MIN"] = 32775] = "MIN";
        GLEnum2[GLEnum2["MAX"] = 32776] = "MAX";
        GLEnum2[GLEnum2["DEPTH_COMPONENT24"] = 33190] = "DEPTH_COMPONENT24";
        GLEnum2[GLEnum2["STREAM_READ"] = 35041] = "STREAM_READ";
        GLEnum2[GLEnum2["STREAM_COPY"] = 35042] = "STREAM_COPY";
        GLEnum2[GLEnum2["STATIC_READ"] = 35045] = "STATIC_READ";
        GLEnum2[GLEnum2["STATIC_COPY"] = 35046] = "STATIC_COPY";
        GLEnum2[GLEnum2["DYNAMIC_READ"] = 35049] = "DYNAMIC_READ";
        GLEnum2[GLEnum2["DYNAMIC_COPY"] = 35050] = "DYNAMIC_COPY";
        GLEnum2[GLEnum2["DEPTH_COMPONENT32F"] = 36012] = "DEPTH_COMPONENT32F";
        GLEnum2[GLEnum2["DEPTH32F_STENCIL8"] = 36013] = "DEPTH32F_STENCIL8";
        GLEnum2[GLEnum2["INVALID_INDEX"] = 4294967295] = "INVALID_INDEX";
        GLEnum2[GLEnum2["TIMEOUT_IGNORED"] = -1] = "TIMEOUT_IGNORED";
        GLEnum2[GLEnum2["MAX_CLIENT_WAIT_TIMEOUT_WEBGL"] = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL";
        GLEnum2[GLEnum2["UNMASKED_VENDOR_WEBGL"] = 37445] = "UNMASKED_VENDOR_WEBGL";
        GLEnum2[GLEnum2["UNMASKED_RENDERER_WEBGL"] = 37446] = "UNMASKED_RENDERER_WEBGL";
        GLEnum2[GLEnum2["MAX_TEXTURE_MAX_ANISOTROPY_EXT"] = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT";
        GLEnum2[GLEnum2["TEXTURE_MAX_ANISOTROPY_EXT"] = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT";
        GLEnum2[GLEnum2["R16_EXT"] = 33322] = "R16_EXT";
        GLEnum2[GLEnum2["RG16_EXT"] = 33324] = "RG16_EXT";
        GLEnum2[GLEnum2["RGB16_EXT"] = 32852] = "RGB16_EXT";
        GLEnum2[GLEnum2["RGBA16_EXT"] = 32859] = "RGBA16_EXT";
        GLEnum2[GLEnum2["R16_SNORM_EXT"] = 36760] = "R16_SNORM_EXT";
        GLEnum2[GLEnum2["RG16_SNORM_EXT"] = 36761] = "RG16_SNORM_EXT";
        GLEnum2[GLEnum2["RGB16_SNORM_EXT"] = 36762] = "RGB16_SNORM_EXT";
        GLEnum2[GLEnum2["RGBA16_SNORM_EXT"] = 36763] = "RGBA16_SNORM_EXT";
        GLEnum2[GLEnum2["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
        GLEnum2[GLEnum2["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
        GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
        GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
        GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
        GLEnum2[GLEnum2["COMPRESSED_RED_RGTC1_EXT"] = 36283] = "COMPRESSED_RED_RGTC1_EXT";
        GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_RGTC1_EXT"] = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT";
        GLEnum2[GLEnum2["COMPRESSED_RED_GREEN_RGTC2_EXT"] = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT";
        GLEnum2[GLEnum2["COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT"] = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_BPTC_UNORM_EXT"] = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT";
        GLEnum2[GLEnum2["COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT"] = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT";
        GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT"] = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT";
        GLEnum2[GLEnum2["COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT"] = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT";
        GLEnum2[GLEnum2["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
        GLEnum2[GLEnum2["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
        GLEnum2[GLEnum2["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
        GLEnum2[GLEnum2["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
        GLEnum2[GLEnum2["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
        GLEnum2[GLEnum2["COMPRESSED_RGBA8_ETC2_EAC"] = 37493] = "COMPRESSED_RGBA8_ETC2_EAC";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ETC2"] = 37494] = "COMPRESSED_SRGB8_ETC2";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
        GLEnum2[GLEnum2["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
        GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
        GLEnum2[GLEnum2["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
        GLEnum2[GLEnum2["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
        GLEnum2[GLEnum2["COMPRESSED_RGB_ATC_WEBGL"] = 35986] = "COMPRESSED_RGB_ATC_WEBGL";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL"] = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL"] = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
        GLEnum2[GLEnum2["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
        GLEnum2[GLEnum2["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
        GLEnum2[GLEnum2["QUERY_COUNTER_BITS_EXT"] = 34916] = "QUERY_COUNTER_BITS_EXT";
        GLEnum2[GLEnum2["CURRENT_QUERY_EXT"] = 34917] = "CURRENT_QUERY_EXT";
        GLEnum2[GLEnum2["QUERY_RESULT_EXT"] = 34918] = "QUERY_RESULT_EXT";
        GLEnum2[GLEnum2["QUERY_RESULT_AVAILABLE_EXT"] = 34919] = "QUERY_RESULT_AVAILABLE_EXT";
        GLEnum2[GLEnum2["TIME_ELAPSED_EXT"] = 35007] = "TIME_ELAPSED_EXT";
        GLEnum2[GLEnum2["TIMESTAMP_EXT"] = 36392] = "TIMESTAMP_EXT";
        GLEnum2[GLEnum2["GPU_DISJOINT_EXT"] = 36795] = "GPU_DISJOINT_EXT";
        GLEnum2[GLEnum2["COMPLETION_STATUS_KHR"] = 37297] = "COMPLETION_STATUS_KHR";
        GLEnum2[GLEnum2["DEPTH_CLAMP_EXT"] = 34383] = "DEPTH_CLAMP_EXT";
        GLEnum2[GLEnum2["FIRST_VERTEX_CONVENTION_WEBGL"] = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL";
        GLEnum2[GLEnum2["LAST_VERTEX_CONVENTION_WEBGL"] = 36430] = "LAST_VERTEX_CONVENTION_WEBGL";
        GLEnum2[GLEnum2["PROVOKING_VERTEX_WEBL"] = 36431] = "PROVOKING_VERTEX_WEBL";
        GLEnum2[GLEnum2["POLYGON_MODE_WEBGL"] = 2880] = "POLYGON_MODE_WEBGL";
        GLEnum2[GLEnum2["POLYGON_OFFSET_LINE_WEBGL"] = 10754] = "POLYGON_OFFSET_LINE_WEBGL";
        GLEnum2[GLEnum2["LINE_WEBGL"] = 6913] = "LINE_WEBGL";
        GLEnum2[GLEnum2["FILL_WEBGL"] = 6914] = "FILL_WEBGL";
        GLEnum2[GLEnum2["MAX_CLIP_DISTANCES_WEBGL"] = 3378] = "MAX_CLIP_DISTANCES_WEBGL";
        GLEnum2[GLEnum2["MAX_CULL_DISTANCES_WEBGL"] = 33529] = "MAX_CULL_DISTANCES_WEBGL";
        GLEnum2[GLEnum2["MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL"] = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL";
        GLEnum2[GLEnum2["CLIP_DISTANCE0_WEBGL"] = 12288] = "CLIP_DISTANCE0_WEBGL";
        GLEnum2[GLEnum2["CLIP_DISTANCE1_WEBGL"] = 12289] = "CLIP_DISTANCE1_WEBGL";
        GLEnum2[GLEnum2["CLIP_DISTANCE2_WEBGL"] = 12290] = "CLIP_DISTANCE2_WEBGL";
        GLEnum2[GLEnum2["CLIP_DISTANCE3_WEBGL"] = 12291] = "CLIP_DISTANCE3_WEBGL";
        GLEnum2[GLEnum2["CLIP_DISTANCE4_WEBGL"] = 12292] = "CLIP_DISTANCE4_WEBGL";
        GLEnum2[GLEnum2["CLIP_DISTANCE5_WEBGL"] = 12293] = "CLIP_DISTANCE5_WEBGL";
        GLEnum2[GLEnum2["CLIP_DISTANCE6_WEBGL"] = 12294] = "CLIP_DISTANCE6_WEBGL";
        GLEnum2[GLEnum2["CLIP_DISTANCE7_WEBGL"] = 12295] = "CLIP_DISTANCE7_WEBGL";
        GLEnum2[GLEnum2["POLYGON_OFFSET_CLAMP_EXT"] = 36379] = "POLYGON_OFFSET_CLAMP_EXT";
        GLEnum2[GLEnum2["LOWER_LEFT_EXT"] = 36001] = "LOWER_LEFT_EXT";
        GLEnum2[GLEnum2["UPPER_LEFT_EXT"] = 36002] = "UPPER_LEFT_EXT";
        GLEnum2[GLEnum2["NEGATIVE_ONE_TO_ONE_EXT"] = 37726] = "NEGATIVE_ONE_TO_ONE_EXT";
        GLEnum2[GLEnum2["ZERO_TO_ONE_EXT"] = 37727] = "ZERO_TO_ONE_EXT";
        GLEnum2[GLEnum2["CLIP_ORIGIN_EXT"] = 37724] = "CLIP_ORIGIN_EXT";
        GLEnum2[GLEnum2["CLIP_DEPTH_MODE_EXT"] = 37725] = "CLIP_DEPTH_MODE_EXT";
        GLEnum2[GLEnum2["SRC1_COLOR_WEBGL"] = 35065] = "SRC1_COLOR_WEBGL";
        GLEnum2[GLEnum2["SRC1_ALPHA_WEBGL"] = 34185] = "SRC1_ALPHA_WEBGL";
        GLEnum2[GLEnum2["ONE_MINUS_SRC1_COLOR_WEBGL"] = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL";
        GLEnum2[GLEnum2["ONE_MINUS_SRC1_ALPHA_WEBGL"] = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL";
        GLEnum2[GLEnum2["MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL"] = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL";
        GLEnum2[GLEnum2["MIRROR_CLAMP_TO_EDGE_EXT"] = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
      })(GLEnum || (GLEnum = {}));
    }
  });

  // ../../node_modules/@luma.gl/constants/dist/index.js
  var init_dist = __esm({
    "../../node_modules/@luma.gl/constants/dist/index.js"() {
      init_webgl_constants();
    }
  });

  // external-global-plugin:@luma.gl/core
  var require_core2 = __commonJS({
    "external-global-plugin:@luma.gl/core"(exports, module) {
      module.exports = globalThis.luma;
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/context/debug/spector.js
  function initializeSpectorJS(props) {
    props = { ...DEFAULT_SPECTOR_PROPS, ...props };
    if (!props.debugSpectorJS) {
      return null;
    }
    if (!spector && globalThis.SPECTOR && !globalThis.luma?.spector) {
      import_core2.log.probe(LOG_LEVEL, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
      const { Spector: SpectorJS } = globalThis.SPECTOR;
      spector = new SpectorJS();
      if (globalThis.luma) {
        globalThis.luma.spector = spector;
      }
    }
    if (!spector) {
      return null;
    }
    if (!initialized) {
      initialized = true;
      spector.spyCanvases();
      spector?.onCaptureStarted.add((capture) => import_core2.log.info("Spector capture started:", capture)());
      spector?.onCapture.add((capture) => {
        import_core2.log.info("Spector capture complete:", capture)();
        spector?.getResultUI();
        spector?.resultView.display();
        spector?.resultView.addCapture(capture);
      });
    }
    if (props.gl) {
      const gl = props.gl;
      const device = gl.device;
      spector?.startCapture(props.gl, 500);
      gl.device = device;
      new Promise((resolve) => setTimeout(resolve, 2e3)).then((_) => {
        import_core2.log.info("Spector capture stopped after 2 seconds")();
        spector?.stopCapture();
      });
    }
    return spector;
  }
  var import_core2, LOG_LEVEL, spector, initialized, DEFAULT_SPECTOR_PROPS;
  var init_spector = __esm({
    "../../node_modules/@luma.gl/webgl/dist/context/debug/spector.js"() {
      import_core2 = __toESM(require_core2(), 1);
      LOG_LEVEL = 1;
      spector = null;
      initialized = false;
      DEFAULT_SPECTOR_PROPS = {
        debugSpectorJS: import_core2.log.get("debug-spectorjs"),
        // https://github.com/BabylonJS/Spector.js#basic-usage
        // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
        // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
        debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
        gl: void 0
      };
    }
  });

  // ../../node_modules/@probe.gl/env/dist/lib/globals.js
  var document_, process_, console_, navigator_;
  var init_globals = __esm({
    "../../node_modules/@probe.gl/env/dist/lib/globals.js"() {
      document_ = globalThis.document || {};
      process_ = globalThis.process || {};
      console_ = globalThis.console;
      navigator_ = globalThis.navigator || {};
    }
  });

  // ../../node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && window.process?.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && Boolean(process.versions?.["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator !== "undefined" && navigator.userAgent;
    const userAgent = mockUserAgent || realUserAgent;
    return Boolean(userAgent && userAgent.indexOf("Electron") >= 0);
  }
  var init_is_electron = __esm({
    "../../node_modules/@probe.gl/env/dist/lib/is-electron.js"() {
    }
  });

  // ../../node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser() {
    const isNode = (
      // @ts-expect-error
      typeof process === "object" && String(process) === "[object process]" && !process?.browser
    );
    return !isNode || isElectron();
  }
  var init_is_browser = __esm({
    "../../node_modules/@probe.gl/env/dist/lib/is-browser.js"() {
      init_is_electron();
    }
  });

  // ../../node_modules/@probe.gl/env/dist/lib/get-browser.js
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser()) {
      return "Node";
    }
    if (isElectron(mockUserAgent)) {
      return "Electron";
    }
    const userAgent = mockUserAgent || navigator_.userAgent || "";
    if (userAgent.indexOf("Edge") > -1) {
      return "Edge";
    }
    if (globalThis.chrome) {
      return "Chrome";
    }
    if (globalThis.safari) {
      return "Safari";
    }
    if (globalThis.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }
  var init_get_browser = __esm({
    "../../node_modules/@probe.gl/env/dist/lib/get-browser.js"() {
      init_is_browser();
      init_is_electron();
      init_globals();
    }
  });

  // ../../node_modules/@probe.gl/env/dist/index.js
  var init_dist2 = __esm({
    "../../node_modules/@probe.gl/env/dist/index.js"() {
      init_get_browser();
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js
  function getWebGLContextData(gl) {
    gl.luma = gl.luma || {};
    return gl.luma;
  }
  function makeDebugContext(gl, props = {}) {
    return props.debugWebGL || props.traceWebGL ? getDebugContext(gl, props) : getRealContext(gl);
  }
  function getRealContext(gl) {
    const data = getWebGLContextData(gl);
    return data.realContext ? data.realContext : gl;
  }
  function getDebugContext(gl, props) {
    if (!globalThis.WebGLDebugUtils) {
      import_core3.log.warn("webgl-debug not loaded")();
      return gl;
    }
    const data = getWebGLContextData(gl);
    if (data.debugContext) {
      return data.debugContext;
    }
    globalThis.WebGLDebugUtils.init({ ...GLEnum, ...gl });
    const glDebug = globalThis.WebGLDebugUtils.makeDebugContext(gl, onGLError.bind(null, props), onValidateGLFunc.bind(null, props));
    for (const key in GLEnum) {
      if (!(key in glDebug) && typeof GLEnum[key] === "number") {
        glDebug[key] = GLEnum[key];
      }
    }
    class WebGLDebugContext {
    }
    Object.setPrototypeOf(glDebug, Object.getPrototypeOf(gl));
    Object.setPrototypeOf(WebGLDebugContext, glDebug);
    const debugContext = Object.create(WebGLDebugContext);
    data.realContext = gl;
    data.debugContext = debugContext;
    debugContext.debug = true;
    return debugContext;
  }
  function getFunctionString(functionName, functionArgs) {
    functionArgs = Array.from(functionArgs).map((arg) => arg === void 0 ? "undefined" : arg);
    let args = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, functionArgs);
    args = `${args.slice(0, 100)}${args.length > 100 ? "..." : ""}`;
    return `gl.${functionName}(${args})`;
  }
  function onGLError(props, err, functionName, args) {
    args = Array.from(args).map((arg) => arg === void 0 ? "undefined" : arg);
    const errorMessage = globalThis.WebGLDebugUtils.glEnumToString(err);
    const functionArgs = globalThis.WebGLDebugUtils.glFunctionArgsToString(functionName, args);
    const message2 = `${errorMessage} in gl.${functionName}(${functionArgs})`;
    import_core3.log.error(message2)();
    debugger;
  }
  function onValidateGLFunc(props, functionName, functionArgs) {
    let functionString = "";
    if (import_core3.log.level >= 1) {
      functionString = getFunctionString(functionName, functionArgs);
      if (props.traceWebGL) {
        import_core3.log.log(1, functionString)();
      }
    }
    for (const arg of functionArgs) {
      if (arg === void 0) {
        functionString = functionString || getFunctionString(functionName, functionArgs);
        debugger;
      }
    }
  }
  var import_core3;
  var init_webgl_developer_tools = __esm({
    "../../node_modules/@luma.gl/webgl/dist/context/debug/webgl-developer-tools.js"() {
      import_core3 = __toESM(require_core2(), 1);
      init_dist();
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/context/parameters/webgl-parameter-tables.js
  function isArray(array) {
    return Array.isArray(array) || ArrayBuffer.isView(array) && !(array instanceof DataView);
  }
  function getValue(glEnum, values, cache) {
    return values[glEnum] !== void 0 ? values[glEnum] : cache[glEnum];
  }
  var GL_PARAMETER_DEFAULTS, enable, hint, pixelStorei, bindFramebuffer, bindBuffer, GL_PARAMETER_SETTERS, GL_COMPOSITE_PARAMETER_SETTERS, GL_HOOKED_SETTERS, isEnabled, GL_PARAMETER_GETTERS, NON_CACHE_PARAMETERS;
  var init_webgl_parameter_tables = __esm({
    "../../node_modules/@luma.gl/webgl/dist/context/parameters/webgl-parameter-tables.js"() {
      GL_PARAMETER_DEFAULTS = {
        [3042]: false,
        [32773]: new Float32Array([0, 0, 0, 0]),
        [32777]: 32774,
        [34877]: 32774,
        [32969]: 1,
        [32968]: 0,
        [32971]: 1,
        [32970]: 0,
        [3106]: new Float32Array([0, 0, 0, 0]),
        // TBD
        [3107]: [true, true, true, true],
        [2884]: false,
        [2885]: 1029,
        [2929]: false,
        [2931]: 1,
        [2932]: 513,
        [2928]: new Float32Array([0, 1]),
        // TBD
        [2930]: true,
        [3024]: true,
        [35725]: null,
        // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
        [36006]: null,
        [36007]: null,
        [34229]: null,
        [34964]: null,
        [2886]: 2305,
        [33170]: 4352,
        [2849]: 1,
        [32823]: false,
        [32824]: 0,
        [10752]: 0,
        [32926]: false,
        [32928]: false,
        [32938]: 1,
        [32939]: false,
        [3089]: false,
        // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
        [3088]: new Int32Array([0, 0, 1024, 1024]),
        [2960]: false,
        [2961]: 0,
        [2968]: 4294967295,
        [36005]: 4294967295,
        [2962]: 519,
        [2967]: 0,
        [2963]: 4294967295,
        [34816]: 519,
        [36003]: 0,
        [36004]: 4294967295,
        [2964]: 7680,
        [2965]: 7680,
        [2966]: 7680,
        [34817]: 7680,
        [34818]: 7680,
        [34819]: 7680,
        // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
        [2978]: [0, 0, 1024, 1024],
        [36389]: null,
        [36662]: null,
        [36663]: null,
        [35053]: null,
        [35055]: null,
        [35723]: 4352,
        [36010]: null,
        [35977]: false,
        [3333]: 4,
        [3317]: 4,
        [37440]: false,
        [37441]: false,
        [37443]: 37444,
        [3330]: 0,
        [3332]: 0,
        [3331]: 0,
        [3314]: 0,
        [32878]: 0,
        [3316]: 0,
        [3315]: 0,
        [32877]: 0
      };
      enable = (gl, value, key) => value ? gl.enable(key) : gl.disable(key);
      hint = (gl, value, key) => gl.hint(key, value);
      pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);
      bindFramebuffer = (gl, value, key) => {
        const target2 = key === 36006 ? 36009 : 36008;
        return gl.bindFramebuffer(target2, value);
      };
      bindBuffer = (gl, value, key) => {
        const bindingMap = {
          [34964]: 34962,
          [36662]: 36662,
          [36663]: 36663,
          [35053]: 35051,
          [35055]: 35052
        };
        const glTarget = bindingMap[key];
        gl.bindBuffer(glTarget, value);
      };
      GL_PARAMETER_SETTERS = {
        [3042]: enable,
        [32773]: (gl, value) => gl.blendColor(...value),
        [32777]: "blendEquation",
        [34877]: "blendEquation",
        [32969]: "blendFunc",
        [32968]: "blendFunc",
        [32971]: "blendFunc",
        [32970]: "blendFunc",
        [3106]: (gl, value) => gl.clearColor(...value),
        [3107]: (gl, value) => gl.colorMask(...value),
        [2884]: enable,
        [2885]: (gl, value) => gl.cullFace(value),
        [2929]: enable,
        [2931]: (gl, value) => gl.clearDepth(value),
        [2932]: (gl, value) => gl.depthFunc(value),
        [2928]: (gl, value) => gl.depthRange(...value),
        [2930]: (gl, value) => gl.depthMask(value),
        [3024]: enable,
        [35723]: hint,
        [35725]: (gl, value) => gl.useProgram(value),
        [36007]: (gl, value) => gl.bindRenderbuffer(36161, value),
        [36389]: (gl, value) => gl.bindTransformFeedback?.(36386, value),
        [34229]: (gl, value) => gl.bindVertexArray(value),
        // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
        [36006]: bindFramebuffer,
        [36010]: bindFramebuffer,
        // Buffers
        [34964]: bindBuffer,
        [36662]: bindBuffer,
        [36663]: bindBuffer,
        [35053]: bindBuffer,
        [35055]: bindBuffer,
        [2886]: (gl, value) => gl.frontFace(value),
        [33170]: hint,
        [2849]: (gl, value) => gl.lineWidth(value),
        [32823]: enable,
        [32824]: "polygonOffset",
        [10752]: "polygonOffset",
        [35977]: enable,
        [32926]: enable,
        [32928]: enable,
        [32938]: "sampleCoverage",
        [32939]: "sampleCoverage",
        [3089]: enable,
        [3088]: (gl, value) => gl.scissor(...value),
        [2960]: enable,
        [2961]: (gl, value) => gl.clearStencil(value),
        [2968]: (gl, value) => gl.stencilMaskSeparate(1028, value),
        [36005]: (gl, value) => gl.stencilMaskSeparate(1029, value),
        [2962]: "stencilFuncFront",
        [2967]: "stencilFuncFront",
        [2963]: "stencilFuncFront",
        [34816]: "stencilFuncBack",
        [36003]: "stencilFuncBack",
        [36004]: "stencilFuncBack",
        [2964]: "stencilOpFront",
        [2965]: "stencilOpFront",
        [2966]: "stencilOpFront",
        [34817]: "stencilOpBack",
        [34818]: "stencilOpBack",
        [34819]: "stencilOpBack",
        [2978]: (gl, value) => gl.viewport(...value),
        // WEBGL2 EXTENSIONS
        // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
        [34383]: enable,
        // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
        // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
        // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
        // POLYGON_MODE_WEBGL  TODO - extension function needed
        [10754]: enable,
        // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
        [12288]: enable,
        [12289]: enable,
        [12290]: enable,
        [12291]: enable,
        [12292]: enable,
        [12293]: enable,
        [12294]: enable,
        [12295]: enable,
        // PIXEL PACK/UNPACK MODES
        [3333]: pixelStorei,
        [3317]: pixelStorei,
        [37440]: pixelStorei,
        [37441]: pixelStorei,
        [37443]: pixelStorei,
        [3330]: pixelStorei,
        [3332]: pixelStorei,
        [3331]: pixelStorei,
        [3314]: pixelStorei,
        [32878]: pixelStorei,
        [3316]: pixelStorei,
        [3315]: pixelStorei,
        [32877]: pixelStorei,
        // Function-style setters
        framebuffer: (gl, framebuffer) => {
          const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
          return gl.bindFramebuffer(36160, handle);
        },
        blend: (gl, value) => value ? gl.enable(3042) : gl.disable(3042),
        blendColor: (gl, value) => gl.blendColor(...value),
        blendEquation: (gl, args) => {
          const separateModes = typeof args === "number" ? [args, args] : args;
          gl.blendEquationSeparate(...separateModes);
        },
        blendFunc: (gl, args) => {
          const separateFuncs = args?.length === 2 ? [...args, ...args] : args;
          gl.blendFuncSeparate(...separateFuncs);
        },
        clearColor: (gl, value) => gl.clearColor(...value),
        clearDepth: (gl, value) => gl.clearDepth(value),
        clearStencil: (gl, value) => gl.clearStencil(value),
        colorMask: (gl, value) => gl.colorMask(...value),
        cull: (gl, value) => value ? gl.enable(2884) : gl.disable(2884),
        cullFace: (gl, value) => gl.cullFace(value),
        depthTest: (gl, value) => value ? gl.enable(2929) : gl.disable(2929),
        depthFunc: (gl, value) => gl.depthFunc(value),
        depthMask: (gl, value) => gl.depthMask(value),
        depthRange: (gl, value) => gl.depthRange(...value),
        dither: (gl, value) => value ? gl.enable(3024) : gl.disable(3024),
        derivativeHint: (gl, value) => {
          gl.hint(35723, value);
        },
        frontFace: (gl, value) => gl.frontFace(value),
        mipmapHint: (gl, value) => gl.hint(33170, value),
        lineWidth: (gl, value) => gl.lineWidth(value),
        polygonOffsetFill: (gl, value) => value ? gl.enable(32823) : gl.disable(32823),
        polygonOffset: (gl, value) => gl.polygonOffset(...value),
        sampleCoverage: (gl, value) => gl.sampleCoverage(value[0], value[1] || false),
        scissorTest: (gl, value) => value ? gl.enable(3089) : gl.disable(3089),
        scissor: (gl, value) => gl.scissor(...value),
        stencilTest: (gl, value) => value ? gl.enable(2960) : gl.disable(2960),
        stencilMask: (gl, value) => {
          value = isArray(value) ? value : [value, value];
          const [mask, backMask] = value;
          gl.stencilMaskSeparate(1028, mask);
          gl.stencilMaskSeparate(1029, backMask);
        },
        stencilFunc: (gl, args) => {
          args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
          const [func, ref, mask, backFunc, backRef, backMask] = args;
          gl.stencilFuncSeparate(1028, func, ref, mask);
          gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
        },
        stencilOp: (gl, args) => {
          args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
          const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
          gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
          gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
        },
        viewport: (gl, value) => gl.viewport(...value)
      };
      GL_COMPOSITE_PARAMETER_SETTERS = {
        blendEquation: (gl, values, cache) => gl.blendEquationSeparate(getValue(32777, values, cache), getValue(34877, values, cache)),
        blendFunc: (gl, values, cache) => gl.blendFuncSeparate(getValue(32969, values, cache), getValue(32968, values, cache), getValue(32971, values, cache), getValue(32970, values, cache)),
        polygonOffset: (gl, values, cache) => gl.polygonOffset(getValue(32824, values, cache), getValue(10752, values, cache)),
        sampleCoverage: (gl, values, cache) => gl.sampleCoverage(getValue(32938, values, cache), getValue(32939, values, cache)),
        stencilFuncFront: (gl, values, cache) => gl.stencilFuncSeparate(1028, getValue(2962, values, cache), getValue(2967, values, cache), getValue(2963, values, cache)),
        stencilFuncBack: (gl, values, cache) => gl.stencilFuncSeparate(1029, getValue(34816, values, cache), getValue(36003, values, cache), getValue(36004, values, cache)),
        stencilOpFront: (gl, values, cache) => gl.stencilOpSeparate(1028, getValue(2964, values, cache), getValue(2965, values, cache), getValue(2966, values, cache)),
        stencilOpBack: (gl, values, cache) => gl.stencilOpSeparate(1029, getValue(34817, values, cache), getValue(34818, values, cache), getValue(34819, values, cache))
      };
      GL_HOOKED_SETTERS = {
        // GENERIC SETTERS
        enable: (update, capability) => update({
          [capability]: true
        }),
        disable: (update, capability) => update({
          [capability]: false
        }),
        pixelStorei: (update, pname, value) => update({
          [pname]: value
        }),
        hint: (update, pname, value) => update({
          [pname]: value
        }),
        // SPECIFIC SETTERS
        useProgram: (update, value) => update({
          [35725]: value
        }),
        bindRenderbuffer: (update, target2, value) => update({
          [36007]: value
        }),
        bindTransformFeedback: (update, target2, value) => update({
          [36389]: value
        }),
        bindVertexArray: (update, value) => update({
          [34229]: value
        }),
        bindFramebuffer: (update, target2, framebuffer) => {
          switch (target2) {
            case 36160:
              return update({
                [36006]: framebuffer,
                [36010]: framebuffer
              });
            case 36009:
              return update({ [36006]: framebuffer });
            case 36008:
              return update({ [36010]: framebuffer });
            default:
              return null;
          }
        },
        bindBuffer: (update, target2, buffer) => {
          const pname = {
            [34962]: [34964],
            [36662]: [36662],
            [36663]: [36663],
            [35051]: [35053],
            [35052]: [35055]
          }[target2];
          if (pname) {
            return update({ [pname]: buffer });
          }
          return { valueChanged: true };
        },
        blendColor: (update, r, g, b, a) => update({
          [32773]: new Float32Array([r, g, b, a])
        }),
        blendEquation: (update, mode) => update({
          [32777]: mode,
          [34877]: mode
        }),
        blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
          [32777]: modeRGB,
          [34877]: modeAlpha
        }),
        blendFunc: (update, src, dst) => update({
          [32969]: src,
          [32968]: dst,
          [32971]: src,
          [32970]: dst
        }),
        blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
          [32969]: srcRGB,
          [32968]: dstRGB,
          [32971]: srcAlpha,
          [32970]: dstAlpha
        }),
        clearColor: (update, r, g, b, a) => update({
          [3106]: new Float32Array([r, g, b, a])
        }),
        clearDepth: (update, depth) => update({
          [2931]: depth
        }),
        clearStencil: (update, s) => update({
          [2961]: s
        }),
        colorMask: (update, r, g, b, a) => update({
          [3107]: [r, g, b, a]
        }),
        cullFace: (update, mode) => update({
          [2885]: mode
        }),
        depthFunc: (update, func) => update({
          [2932]: func
        }),
        depthRange: (update, zNear, zFar) => update({
          [2928]: new Float32Array([zNear, zFar])
        }),
        depthMask: (update, mask) => update({
          [2930]: mask
        }),
        frontFace: (update, face) => update({
          [2886]: face
        }),
        lineWidth: (update, width) => update({
          [2849]: width
        }),
        polygonOffset: (update, factor, units) => update({
          [32824]: factor,
          [10752]: units
        }),
        sampleCoverage: (update, value, invert2) => update({
          [32938]: value,
          [32939]: invert2
        }),
        scissor: (update, x, y, width, height) => update({
          [3088]: new Int32Array([x, y, width, height])
        }),
        stencilMask: (update, mask) => update({
          [2968]: mask,
          [36005]: mask
        }),
        stencilMaskSeparate: (update, face, mask) => update({
          [face === 1028 ? 2968 : 36005]: mask
        }),
        stencilFunc: (update, func, ref, mask) => update({
          [2962]: func,
          [2967]: ref,
          [2963]: mask,
          [34816]: func,
          [36003]: ref,
          [36004]: mask
        }),
        stencilFuncSeparate: (update, face, func, ref, mask) => update({
          [face === 1028 ? 2962 : 34816]: func,
          [face === 1028 ? 2967 : 36003]: ref,
          [face === 1028 ? 2963 : 36004]: mask
        }),
        stencilOp: (update, fail, zfail, zpass) => update({
          [2964]: fail,
          [2965]: zfail,
          [2966]: zpass,
          [34817]: fail,
          [34818]: zfail,
          [34819]: zpass
        }),
        stencilOpSeparate: (update, face, fail, zfail, zpass) => update({
          [face === 1028 ? 2964 : 34817]: fail,
          [face === 1028 ? 2965 : 34818]: zfail,
          [face === 1028 ? 2966 : 34819]: zpass
        }),
        viewport: (update, x, y, width, height) => update({
          [2978]: [x, y, width, height]
        })
      };
      isEnabled = (gl, key) => gl.isEnabled(key);
      GL_PARAMETER_GETTERS = {
        [3042]: isEnabled,
        [2884]: isEnabled,
        [2929]: isEnabled,
        [3024]: isEnabled,
        [32823]: isEnabled,
        [32926]: isEnabled,
        [32928]: isEnabled,
        [3089]: isEnabled,
        [2960]: isEnabled,
        [35977]: isEnabled
      };
      NON_CACHE_PARAMETERS = /* @__PURE__ */ new Set([
        34016,
        36388,
        36387,
        35983,
        35368,
        34965,
        35739,
        35738,
        3074,
        34853,
        34854,
        34855,
        34856,
        34857,
        34858,
        34859,
        34860,
        34861,
        34862,
        34863,
        34864,
        34865,
        34866,
        34867,
        34868,
        35097,
        32873,
        35869,
        32874,
        34068
      ]);
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js
  function setGLParameters(gl, parameters) {
    if (isObjectEmpty(parameters)) {
      return;
    }
    const compositeSetters = {};
    for (const key in parameters) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, parameters[key], glConstant);
        }
      }
    }
    const cache = gl.state && gl.state.cache;
    if (cache) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, parameters, cache);
      }
    }
  }
  function getGLParameters(gl, parameters = GL_PARAMETER_DEFAULTS) {
    if (typeof parameters === "number") {
      const key = parameters;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state;
  }
  function resetGLParameters(gl) {
    setGLParameters(gl, GL_PARAMETER_DEFAULTS);
  }
  function isObjectEmpty(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }
  var init_unified_parameter_api = __esm({
    "../../node_modules/@luma.gl/webgl/dist/context/parameters/unified-parameter-api.js"() {
      init_webgl_parameter_tables();
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/context/state-tracker/deep-array-equal.js
  function deepArrayEqual(x, y) {
    if (x === y) {
      return true;
    }
    if (isArray2(x) && isArray2(y) && x.length === y.length) {
      for (let i = 0; i < x.length; ++i) {
        if (x[i] !== y[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function isArray2(x) {
    return Array.isArray(x) || ArrayBuffer.isView(x);
  }
  var init_deep_array_equal = __esm({
    "../../node_modules/@luma.gl/webgl/dist/context/state-tracker/deep-array-equal.js"() {
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/context/state-tracker/webgl-state-tracker.js
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get(pname) {
      if (pname === void 0 || NON_CACHE_PARAMETERS.has(pname)) {
        return originalGetterFunc(pname);
      }
      const glState = WebGLStateTracker.get(gl);
      if (!(pname in glState.cache)) {
        glState.cache[pname] = originalGetterFunc(pname);
      }
      return glState.enable ? (
        // Call the getter the params so that it can e.g. serve from a cache
        glState.cache[pname]
      ) : (
        // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
        originalGetterFunc(pname)
      );
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-from-cache`,
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    if (!gl[functionName]) {
      return;
    }
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set(...params) {
      const glState = WebGLStateTracker.get(gl);
      const { valueChanged, oldValue } = setter(glState._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: `${functionName}-to-cache`,
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      const glState = WebGLStateTracker.get(gl);
      if (glState.program !== handle) {
        originalUseProgram(handle);
        glState.program = handle;
      }
    };
  }
  var WebGLStateTracker;
  var init_webgl_state_tracker = __esm({
    "../../node_modules/@luma.gl/webgl/dist/context/state-tracker/webgl-state-tracker.js"() {
      init_unified_parameter_api();
      init_deep_array_equal();
      init_webgl_parameter_tables();
      WebGLStateTracker = class {
        static get(gl) {
          return gl.state;
        }
        gl;
        program = null;
        stateStack = [];
        enable = true;
        cache = null;
        log;
        initialized = false;
        constructor(gl, props) {
          this.gl = gl;
          this.log = props?.log || (() => {
          });
          this._updateCache = this._updateCache.bind(this);
          Object.seal(this);
        }
        push(values = {}) {
          this.stateStack.push({});
        }
        pop() {
          const oldValues = this.stateStack[this.stateStack.length - 1];
          setGLParameters(this.gl, oldValues);
          this.stateStack.pop();
        }
        /**
         * Initialize WebGL state caching on a context
         * can be called multiple times to enable/disable
         *
         * @note After calling this function, context state will be cached
         * .push() and .pop() will be available for saving,
         * temporarily modifying, and then restoring state.
         */
        trackState(gl, options) {
          this.cache = options?.copyState ? getGLParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
          if (this.initialized) {
            throw new Error("WebGLStateTracker");
          }
          this.initialized = true;
          this.gl.state = this;
          installProgramSpy(gl);
          for (const key in GL_HOOKED_SETTERS) {
            const setter = GL_HOOKED_SETTERS[key];
            installSetterSpy(gl, key, setter);
          }
          installGetterOverride(gl, "getParameter");
          installGetterOverride(gl, "isEnabled");
        }
        /**
        // interceptor for context set functions - update our cache and our stack
        // values (Object) - the key values for this setter
         * @param values
         * @returns
         */
        _updateCache(values) {
          let valueChanged = false;
          let oldValue;
          const oldValues = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
          for (const key in values) {
            const value = values[key];
            const cached = this.cache[key];
            if (!deepArrayEqual(value, cached)) {
              valueChanged = true;
              oldValue = cached;
              if (oldValues && !(key in oldValues)) {
                oldValues[key] = cached;
              }
              this.cache[key] = value;
            }
          }
          return { valueChanged, oldValue };
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/context/helpers/create-browser-context.js
  function createBrowserContext(canvas, props, webglContextAttributes) {
    let errorMessage = "";
    const webglProps = {
      preserveDrawingBuffer: true,
      // failIfMajorPerformanceCaveat: true,
      ...webglContextAttributes
    };
    let gl = null;
    gl ||= canvas.getContext("webgl2", webglProps);
    if (webglProps.failIfMajorPerformanceCaveat) {
      errorMessage ||= "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow.";
    }
    if (!gl && !webglContextAttributes.failIfMajorPerformanceCaveat) {
      webglProps.failIfMajorPerformanceCaveat = false;
      gl = canvas.getContext("webgl2", webglProps);
      gl.luma ||= {};
      gl.luma.softwareRenderer = true;
    }
    if (!gl) {
      gl = canvas.getContext("webgl", {});
      if (gl) {
        gl = null;
        errorMessage ||= "Your browser only supports WebGL1";
      }
    }
    if (!gl) {
      errorMessage ||= "Your browser does not support WebGL";
      throw new Error(`Failed to create WebGL context: ${errorMessage}`);
    }
    const { onContextLost, onContextRestored } = props;
    canvas.addEventListener("webglcontextlost", (event) => onContextLost(event), false);
    canvas.addEventListener("webglcontextrestored", (event) => onContextRestored(event), false);
    gl.luma ||= {};
    return gl;
  }
  var init_create_browser_context = __esm({
    "../../node_modules/@luma.gl/webgl/dist/context/helpers/create-browser-context.js"() {
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js
  function getWebGLExtension(gl, name, extensions) {
    if (extensions[name] === void 0) {
      extensions[name] = gl.getExtension(name) || null;
    }
    return extensions[name];
  }
  var init_webgl_extensions = __esm({
    "../../node_modules/@luma.gl/webgl/dist/context/helpers/webgl-extensions.js"() {
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-info.js
  function getDeviceInfo(gl, extensions) {
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    getWebGLExtension(gl, "WEBGL_debug_renderer_info", extensions);
    const ext = extensions.WEBGL_debug_renderer_info;
    const vendorUnmasked = gl.getParameter(ext ? ext.UNMASKED_VENDOR_WEBGL : 7936);
    const rendererUnmasked = gl.getParameter(ext ? ext.UNMASKED_RENDERER_WEBGL : 7937);
    const vendor = vendorUnmasked || vendorMasked;
    const renderer = rendererUnmasked || rendererMasked;
    const version = gl.getParameter(7938);
    const gpu = identifyGPUVendor(vendor, renderer);
    const gpuBackend = identifyGPUBackend(vendor, renderer);
    const gpuType = identifyGPUType(vendor, renderer);
    const shadingLanguage = "glsl";
    const shadingLanguageVersion = 300;
    return {
      type: "webgl",
      gpu,
      gpuType,
      gpuBackend,
      vendor,
      renderer,
      version,
      shadingLanguage,
      shadingLanguageVersion
    };
  }
  function identifyGPUVendor(vendor, renderer) {
    if (/NVIDIA/i.exec(vendor) || /NVIDIA/i.exec(renderer)) {
      return "nvidia";
    }
    if (/INTEL/i.exec(vendor) || /INTEL/i.exec(renderer)) {
      return "intel";
    }
    if (/Apple/i.exec(vendor) || /Apple/i.exec(renderer)) {
      return "apple";
    }
    if (/AMD/i.exec(vendor) || /AMD/i.exec(renderer) || /ATI/i.exec(vendor) || /ATI/i.exec(renderer)) {
      return "amd";
    }
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "software";
    }
    return "unknown";
  }
  function identifyGPUBackend(vendor, renderer) {
    if (/Metal/i.exec(vendor) || /Metal/i.exec(renderer)) {
      return "metal";
    }
    if (/ANGLE/i.exec(vendor) || /ANGLE/i.exec(renderer)) {
      return "opengl";
    }
    return "unknown";
  }
  function identifyGPUType(vendor, renderer) {
    if (/SwiftShader/i.exec(vendor) || /SwiftShader/i.exec(renderer)) {
      return "cpu";
    }
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    switch (gpuVendor) {
      case "intel":
        return "integrated";
      case "software":
        return "cpu";
      case "unknown":
        return "unknown";
      default:
        return "discrete";
    }
  }
  var init_webgl_device_info = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-info.js"() {
      init_webgl_extensions();
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-vertex-formats.js
  function getGLFromVertexType(dataType) {
    switch (dataType) {
      case "uint8":
        return 5121;
      case "sint8":
        return 5120;
      case "unorm8":
        return 5121;
      case "snorm8":
        return 5120;
      case "uint16":
        return 5123;
      case "sint16":
        return 5122;
      case "unorm16":
        return 5123;
      case "snorm16":
        return 5122;
      case "uint32":
        return 5125;
      case "sint32":
        return 5124;
      case "float16":
        return 5131;
      case "float32":
        return 5126;
    }
    throw new Error(String(dataType));
  }
  var init_webgl_vertex_formats = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-vertex-formats.js"() {
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js
  function isTextureFeature(feature) {
    return feature in TEXTURE_FEATURES;
  }
  function checkTextureFeature(gl, feature, extensions) {
    const textureExtensions = TEXTURE_FEATURES[feature] || [];
    return textureExtensions.every((extension) => getWebGLExtension(gl, extension, extensions));
  }
  function getTextureFormatCapabilitiesWebGL(gl, formatSupport, extensions) {
    let supported = formatSupport.create;
    const webglFormatInfo = WEBGL_TEXTURE_FORMATS[formatSupport.format];
    if (webglFormatInfo?.gl === void 0) {
      supported = false;
    }
    if (webglFormatInfo?.x) {
      supported = supported && Boolean(getWebGLExtension(gl, webglFormatInfo.x, extensions));
    }
    return {
      format: formatSupport.format,
      // @ts-ignore
      create: supported && formatSupport.create,
      // @ts-ignore
      render: supported && formatSupport.render,
      // @ts-ignore
      filter: supported && formatSupport.filter,
      // @ts-ignore
      blend: supported && formatSupport.blend,
      // @ts-ignore
      store: supported && formatSupport.store
    };
  }
  function getTextureFormatWebGL(format) {
    const formatData = WEBGL_TEXTURE_FORMATS[format];
    const webglFormat = convertTextureFormatToGL(format);
    const decoded = import_core4.textureFormatDecoder.getInfo(format);
    if (decoded.compressed) {
      formatData.dataFormat = webglFormat;
    }
    return {
      internalFormat: webglFormat,
      format: formatData?.dataFormat || getWebGLPixelDataFormat(decoded.channels, decoded.integer, decoded.normalized, webglFormat),
      // depth formats don't have a type
      type: decoded.dataType ? getGLFromVertexType(decoded.dataType) : formatData?.types?.[0] || 5121,
      compressed: decoded.compressed || false
    };
  }
  function getDepthStencilAttachmentWebGL(format) {
    const formatInfo = import_core4.textureFormatDecoder.getInfo(format);
    switch (formatInfo.attachment) {
      case "depth":
        return 36096;
      case "stencil":
        return 36128;
      case "depth-stencil":
        return 33306;
      default:
        throw new Error(`Not a depth stencil format: ${format}`);
    }
  }
  function getWebGLPixelDataFormat(channels, integer, normalized, format) {
    if (format === 6408 || format === 6407) {
      return format;
    }
    switch (channels) {
      case "r":
        return integer && !normalized ? 36244 : 6403;
      case "rg":
        return integer && !normalized ? 33320 : 33319;
      case "rgb":
        return integer && !normalized ? 36248 : 6407;
      case "rgba":
        return integer && !normalized ? 36249 : 6408;
      case "bgra":
        throw new Error("bgra pixels not supported by WebGL");
      default:
        return 6408;
    }
  }
  function convertTextureFormatToGL(format) {
    const formatInfo = WEBGL_TEXTURE_FORMATS[format];
    const webglFormat = formatInfo?.gl;
    if (webglFormat === void 0) {
      throw new Error(`Unsupported texture format ${format}`);
    }
    return webglFormat;
  }
  var import_core4, X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC, X_ETC2, X_ASTC, X_ETC1, X_PVRTC, X_ATC, EXT_texture_norm16, EXT_render_snorm, EXT_color_buffer_float, TEXTURE_FEATURES, WEBGL_TEXTURE_FORMATS;
  var init_webgl_texture_table = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-texture-table.js"() {
      import_core4 = __toESM(require_core2(), 1);
      init_webgl_extensions();
      init_webgl_vertex_formats();
      X_S3TC = "WEBGL_compressed_texture_s3tc";
      X_S3TC_SRGB = "WEBGL_compressed_texture_s3tc_srgb";
      X_RGTC = "EXT_texture_compression_rgtc";
      X_BPTC = "EXT_texture_compression_bptc";
      X_ETC2 = "WEBGL_compressed_texture_etc";
      X_ASTC = "WEBGL_compressed_texture_astc";
      X_ETC1 = "WEBGL_compressed_texture_etc1";
      X_PVRTC = "WEBGL_compressed_texture_pvrtc";
      X_ATC = "WEBGL_compressed_texture_atc";
      EXT_texture_norm16 = "EXT_texture_norm16";
      EXT_render_snorm = "EXT_render_snorm";
      EXT_color_buffer_float = "EXT_color_buffer_float";
      TEXTURE_FEATURES = {
        "float32-renderable-webgl": ["EXT_color_buffer_float"],
        "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
        "rgb9e5ufloat-renderable-webgl": ["WEBGL_render_shared_exponent"],
        "snorm8-renderable-webgl": [EXT_render_snorm],
        "norm16-renderable-webgl": [EXT_texture_norm16],
        "snorm16-renderable-webgl": [EXT_texture_norm16, EXT_render_snorm],
        "float32-filterable": ["OES_texture_float_linear"],
        "float16-filterable-webgl": ["OES_texture_half_float_linear"],
        "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
        "texture-blend-float-webgl": ["EXT_float_blend"],
        "texture-compression-bc": [X_S3TC, X_S3TC_SRGB, X_RGTC, X_BPTC],
        // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
        // 'texture-compression-bc3-webgl': [X_S3TC],
        "texture-compression-bc5-webgl": [X_RGTC],
        "texture-compression-bc7-webgl": [X_BPTC],
        "texture-compression-etc2": [X_ETC2],
        "texture-compression-astc": [X_ASTC],
        "texture-compression-etc1-webgl": [X_ETC1],
        "texture-compression-pvrtc-webgl": [X_PVRTC],
        "texture-compression-atc-webgl": [X_ATC]
      };
      WEBGL_TEXTURE_FORMATS = {
        // 8-bit formats
        "r8unorm": { gl: 33321, rb: true },
        "r8snorm": { gl: 36756 },
        "r8uint": { gl: 33330, rb: true },
        "r8sint": { gl: 33329, rb: true },
        // 16-bit formats
        "rg8unorm": { gl: 33323, rb: true },
        "rg8snorm": { gl: 36757 },
        "rg8uint": { gl: 33336, rb: true },
        "rg8sint": { gl: 33335, rb: true },
        "r16uint": { gl: 33332, rb: true },
        "r16sint": { gl: 33331, rb: true },
        "r16float": { gl: 33325, rb: true },
        "r16unorm": { gl: 33322, rb: true },
        "r16snorm": { gl: 36760 },
        // Packed 16-bit formats
        "rgba4unorm-webgl": { gl: 32854, rb: true },
        "rgb565unorm-webgl": { gl: 36194, rb: true },
        "rgb5a1unorm-webgl": { gl: 32855, rb: true },
        // 24-bit formats
        "rgb8unorm-webgl": { gl: 32849 },
        "rgb8snorm-webgl": { gl: 36758 },
        // 32-bit formats
        "rgba8unorm": { gl: 32856 },
        "rgba8unorm-srgb": { gl: 35907 },
        "rgba8snorm": { gl: 36759 },
        "rgba8uint": { gl: 36220 },
        "rgba8sint": { gl: 36238 },
        // reverse colors, webgpu only
        "bgra8unorm": {},
        "bgra8unorm-srgb": {},
        "rg16uint": { gl: 33338 },
        "rg16sint": { gl: 33337 },
        "rg16float": { gl: 33327, rb: true },
        "rg16unorm": { gl: 33324 },
        "rg16snorm": { gl: 36761 },
        "r32uint": { gl: 33334, rb: true },
        "r32sint": { gl: 33333, rb: true },
        "r32float": { gl: 33326 },
        // Packed 32-bit formats
        "rgb9e5ufloat": { gl: 35901 },
        // , filter: true},
        "rg11b10ufloat": { gl: 35898, rb: true },
        "rgb10a2unorm": { gl: 32857, rb: true },
        "rgb10a2uint": { gl: 36975, rb: true },
        // 48-bit formats
        "rgb16unorm-webgl": { gl: 32852 },
        // rgb not renderable
        "rgb16snorm-webgl": { gl: 36762 },
        // rgb not renderable
        // 64-bit formats
        "rg32uint": { gl: 33340, rb: true },
        "rg32sint": { gl: 33339, rb: true },
        "rg32float": { gl: 33328, rb: true },
        "rgba16uint": { gl: 36214, rb: true },
        "rgba16sint": { gl: 36232, rb: true },
        "rgba16float": { gl: 34842 },
        "rgba16unorm": { gl: 32859, rb: true },
        "rgba16snorm": { gl: 36763 },
        // 96-bit formats (deprecated!)
        "rgb32float-webgl": { gl: 34837, x: EXT_color_buffer_float, dataFormat: 6407, types: [5126] },
        // 128-bit formats
        "rgba32uint": { gl: 36208, rb: true },
        "rgba32sint": { gl: 36226, rb: true },
        "rgba32float": { gl: 34836, rb: true },
        // Depth and stencil formats
        "stencil8": { gl: 36168, rb: true },
        // 8 stencil bits
        "depth16unorm": { gl: 33189, dataFormat: 6402, types: [5123], rb: true },
        // 16 depth bits
        "depth24plus": { gl: 33190, dataFormat: 6402, types: [5125] },
        "depth32float": { gl: 36012, dataFormat: 6402, types: [5126], rb: true },
        // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
        "depth24plus-stencil8": { gl: 35056, rb: true, depthTexture: true, dataFormat: 34041, types: [34042] },
        // "depth32float-stencil8" feature - TODO below is render buffer only?
        "depth32float-stencil8": { gl: 36013, dataFormat: 34041, types: [36269], rb: true },
        // BC compressed formats: check device.features.has("texture-compression-bc");
        "bc1-rgb-unorm-webgl": { gl: 33776, x: X_S3TC },
        "bc1-rgb-unorm-srgb-webgl": { gl: 35916, x: X_S3TC_SRGB },
        "bc1-rgba-unorm": { gl: 33777, x: X_S3TC },
        "bc1-rgba-unorm-srgb": { gl: 35916, x: X_S3TC_SRGB },
        "bc2-rgba-unorm": { gl: 33778, x: X_S3TC },
        "bc2-rgba-unorm-srgb": { gl: 35918, x: X_S3TC_SRGB },
        "bc3-rgba-unorm": { gl: 33779, x: X_S3TC },
        "bc3-rgba-unorm-srgb": { gl: 35919, x: X_S3TC_SRGB },
        "bc4-r-unorm": { gl: 36283, x: X_RGTC },
        "bc4-r-snorm": { gl: 36284, x: X_RGTC },
        "bc5-rg-unorm": { gl: 36285, x: X_RGTC },
        "bc5-rg-snorm": { gl: 36286, x: X_RGTC },
        "bc6h-rgb-ufloat": { gl: 36495, x: X_BPTC },
        "bc6h-rgb-float": { gl: 36494, x: X_BPTC },
        "bc7-rgba-unorm": { gl: 36492, x: X_BPTC },
        "bc7-rgba-unorm-srgb": { gl: 36493, x: X_BPTC },
        // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
        // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
        "etc2-rgb8unorm": { gl: 37492 },
        "etc2-rgb8unorm-srgb": { gl: 37494 },
        "etc2-rgb8a1unorm": { gl: 37496 },
        "etc2-rgb8a1unorm-srgb": { gl: 37497 },
        "etc2-rgba8unorm": { gl: 37493 },
        "etc2-rgba8unorm-srgb": { gl: 37495 },
        "eac-r11unorm": { gl: 37488 },
        "eac-r11snorm": { gl: 37489 },
        "eac-rg11unorm": { gl: 37490 },
        "eac-rg11snorm": { gl: 37491 },
        // X_ASTC compressed formats: device.features.has("texture-compression-astc")
        "astc-4x4-unorm": { gl: 37808 },
        "astc-4x4-unorm-srgb": { gl: 37840 },
        "astc-5x4-unorm": { gl: 37809 },
        "astc-5x4-unorm-srgb": { gl: 37841 },
        "astc-5x5-unorm": { gl: 37810 },
        "astc-5x5-unorm-srgb": { gl: 37842 },
        "astc-6x5-unorm": { gl: 37811 },
        "astc-6x5-unorm-srgb": { gl: 37843 },
        "astc-6x6-unorm": { gl: 37812 },
        "astc-6x6-unorm-srgb": { gl: 37844 },
        "astc-8x5-unorm": { gl: 37813 },
        "astc-8x5-unorm-srgb": { gl: 37845 },
        "astc-8x6-unorm": { gl: 37814 },
        "astc-8x6-unorm-srgb": { gl: 37846 },
        "astc-8x8-unorm": { gl: 37815 },
        "astc-8x8-unorm-srgb": { gl: 37847 },
        "astc-10x5-unorm": { gl: 37819 },
        "astc-10x5-unorm-srgb": { gl: 37851 },
        "astc-10x6-unorm": { gl: 37817 },
        "astc-10x6-unorm-srgb": { gl: 37849 },
        "astc-10x8-unorm": { gl: 37818 },
        "astc-10x8-unorm-srgb": { gl: 37850 },
        "astc-10x10-unorm": { gl: 37819 },
        "astc-10x10-unorm-srgb": { gl: 37851 },
        "astc-12x10-unorm": { gl: 37820 },
        "astc-12x10-unorm-srgb": { gl: 37852 },
        "astc-12x12-unorm": { gl: 37821 },
        "astc-12x12-unorm-srgb": { gl: 37853 },
        // WEBGL_compressed_texture_pvrtc
        "pvrtc-rgb4unorm-webgl": { gl: 35840 },
        "pvrtc-rgba4unorm-webgl": { gl: 35842 },
        "pvrtc-rbg2unorm-webgl": { gl: 35841 },
        "pvrtc-rgba2unorm-webgl": { gl: 35843 },
        // WEBGL_compressed_texture_etc1
        "etc1-rbg-unorm-webgl": { gl: 36196 },
        // WEBGL_compressed_texture_atc
        "atc-rgb-unorm-webgl": { gl: 35986 },
        "atc-rgba-unorm-webgl": { gl: 35986 },
        "atc-rgbai-unorm-webgl": { gl: 34798 }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-features.js
  var import_core5, WEBGL_FEATURES, WebGLDeviceFeatures;
  var init_webgl_device_features = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-features.js"() {
      import_core5 = __toESM(require_core2(), 1);
      init_webgl_extensions();
      init_webgl_texture_table();
      WEBGL_FEATURES = {
        // optional WebGPU features
        "depth-clip-control": "EXT_depth_clamp",
        // TODO these seem subtly different
        // 'timestamp-query' // GPUQueryType "timestamp-query"
        // "indirect-first-instance"
        // Textures are handled by getTextureFeatures()
        // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
        // optional WebGL features
        "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
        "compilation-status-async-webgl": "KHR_parallel_shader_compile",
        "polygon-mode-webgl": "WEBGL_polygon_mode",
        "provoking-vertex-webgl": "WEBGL_provoking_vertex",
        "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
        "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
        "shader-conservative-depth-webgl": "EXT_conservative_depth"
        // Textures are handled by getTextureFeatures()
      };
      WebGLDeviceFeatures = class extends import_core5.DeviceFeatures {
        gl;
        extensions;
        testedFeatures = /* @__PURE__ */ new Set();
        constructor(gl, extensions, disabledFeatures) {
          super([], disabledFeatures);
          this.gl = gl;
          this.extensions = extensions;
          getWebGLExtension(gl, "EXT_color_buffer_float", extensions);
        }
        *[Symbol.iterator]() {
          const features = this.getFeatures();
          for (const feature of features) {
            if (this.has(feature)) {
              yield feature;
            }
          }
          return [];
        }
        has(feature) {
          if (this.disabledFeatures?.[feature]) {
            return false;
          }
          if (!this.testedFeatures.has(feature)) {
            this.testedFeatures.add(feature);
            if (isTextureFeature(feature) && checkTextureFeature(this.gl, feature, this.extensions)) {
              this.features.add(feature);
            }
            if (this.getWebGLFeature(feature)) {
              this.features.add(feature);
            }
          }
          return this.features.has(feature);
        }
        // FOR DEVICE
        initializeFeatures() {
          const features = this.getFeatures().filter((feature) => feature !== "polygon-mode-webgl");
          for (const feature of features) {
            this.has(feature);
          }
        }
        // IMPLEMENTATION
        getFeatures() {
          return [...Object.keys(WEBGL_FEATURES), ...Object.keys(TEXTURE_FEATURES)];
        }
        /** Extract all WebGL features */
        getWebGLFeature(feature) {
          const featureInfo = WEBGL_FEATURES[feature];
          const isSupported = typeof featureInfo === "string" ? Boolean(getWebGLExtension(this.gl, featureInfo, this.extensions)) : Boolean(featureInfo);
          return isSupported;
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-limits.js
  var import_core6, WebGLDeviceLimits;
  var init_webgl_device_limits = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/device-helpers/webgl-device-limits.js"() {
      import_core6 = __toESM(require_core2(), 1);
      WebGLDeviceLimits = class extends import_core6.DeviceLimits {
        get maxTextureDimension1D() {
          return 0;
        }
        // WebGL does not support 1D textures
        get maxTextureDimension2D() {
          return this.getParameter(3379);
        }
        get maxTextureDimension3D() {
          return this.getParameter(32883);
        }
        get maxTextureArrayLayers() {
          return this.getParameter(35071);
        }
        get maxBindGroups() {
          return 0;
        }
        get maxDynamicUniformBuffersPerPipelineLayout() {
          return 0;
        }
        // TBD
        get maxDynamicStorageBuffersPerPipelineLayout() {
          return 0;
        }
        // TBD
        get maxSampledTexturesPerShaderStage() {
          return this.getParameter(35660);
        }
        // ) TBD
        get maxSamplersPerShaderStage() {
          return this.getParameter(35661);
        }
        get maxStorageBuffersPerShaderStage() {
          return 0;
        }
        // TBD
        get maxStorageTexturesPerShaderStage() {
          return 0;
        }
        // TBD
        get maxUniformBuffersPerShaderStage() {
          return this.getParameter(35375);
        }
        get maxUniformBufferBindingSize() {
          return this.getParameter(35376);
        }
        get maxStorageBufferBindingSize() {
          return 0;
        }
        get minUniformBufferOffsetAlignment() {
          return this.getParameter(35380);
        }
        get minStorageBufferOffsetAlignment() {
          return 0;
        }
        get maxVertexBuffers() {
          return 16;
        }
        // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
        get maxVertexAttributes() {
          return this.getParameter(34921);
        }
        get maxVertexBufferArrayStride() {
          return 2048;
        }
        // TBD, this is just the default value from WebGPU
        get maxInterStageShaderVariables() {
          return this.getParameter(35659);
        }
        get maxComputeWorkgroupStorageSize() {
          return 0;
        }
        // WebGL does not support compute shaders
        get maxComputeInvocationsPerWorkgroup() {
          return 0;
        }
        // WebGL does not support compute shaders
        get maxComputeWorkgroupSizeX() {
          return 0;
        }
        // WebGL does not support compute shaders
        get maxComputeWorkgroupSizeY() {
          return 0;
        }
        // WebGL does not support compute shaders
        get maxComputeWorkgroupSizeZ() {
          return 0;
        }
        // WebGL does not support compute shaders
        get maxComputeWorkgroupsPerDimension() {
          return 0;
        }
        // WebGL does not support compute shaders
        // PRIVATE
        gl;
        limits = {};
        constructor(gl) {
          super();
          this.gl = gl;
        }
        getParameter(parameter) {
          if (this.limits[parameter] === void 0) {
            this.limits[parameter] = this.gl.getParameter(parameter);
          }
          return this.limits[parameter] || 0;
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    switch (status) {
      case 36053:
        return "success";
      case 36054:
        return "Mismatched attachments";
      case 36055:
        return "No attachments";
      case 36057:
        return "Height/width mismatch";
      case 36061:
        return "Unsupported or split attachments";
      case 36182:
        return "Samples mismatch";
      default:
        return `${status}`;
    }
  }
  var import_core7, WEBGLFramebuffer;
  var init_webgl_framebuffer = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-framebuffer.js"() {
      import_core7 = __toESM(require_core2(), 1);
      init_webgl_texture_table();
      WEBGLFramebuffer = class extends import_core7.Framebuffer {
        device;
        gl;
        handle;
        colorAttachments = [];
        depthStencilAttachment = null;
        constructor(device, props) {
          super(device, props);
          const isDefaultFramebuffer = props.handle === null;
          this.device = device;
          this.gl = device.gl;
          this.handle = this.props.handle || isDefaultFramebuffer ? this.props.handle : this.gl.createFramebuffer();
          if (!isDefaultFramebuffer) {
            device._setWebGLDebugMetadata(this.handle, this, { spector: this.props });
            this.autoCreateAttachmentTextures();
            this.updateAttachments();
          }
        }
        /** destroys any auto created resources etc. */
        destroy() {
          super.destroy();
          if (!this.destroyed && this.handle !== null) {
            this.gl.deleteFramebuffer(this.handle);
          }
        }
        updateAttachments() {
          const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
          for (let i = 0; i < this.colorAttachments.length; ++i) {
            const attachment = this.colorAttachments[i];
            if (attachment) {
              const attachmentPoint = 36064 + i;
              this._attachTextureView(attachmentPoint, attachment);
            }
          }
          if (this.depthStencilAttachment) {
            const attachmentPoint = getDepthStencilAttachmentWebGL(this.depthStencilAttachment.props.format);
            this._attachTextureView(attachmentPoint, this.depthStencilAttachment);
          }
          if (this.device.props.debug) {
            const status = this.gl.checkFramebufferStatus(36160);
            if (status !== 36053) {
              throw new Error(`Framebuffer ${_getFrameBufferStatus(status)}`);
            }
          }
          this.gl.bindFramebuffer(36160, prevHandle);
        }
        // PRIVATE
        /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
        // protected override createDepthStencilTexture(format: TextureFormat): Texture {
        //   // return new WEBGLRenderbuffer(this.device, {
        //   return new WEBGLTexture(this.device, {
        //     id: `${this.id}-depth-stencil`,
        //     format,
        //     width: this.width,
        //     height: this.height,
        //     mipmaps: false
        //   });
        // }
        /**
         * @param attachment
         * @param texture
         * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
         * @param level = 0 - mipmapLevel
         */
        _attachTextureView(attachment, textureView) {
          const { gl } = this.device;
          const { texture } = textureView;
          const level = textureView.props.baseMipLevel;
          const layer = textureView.props.baseArrayLayer;
          gl.bindTexture(texture.glTarget, texture.handle);
          switch (texture.glTarget) {
            case 35866:
            case 32879:
              gl.framebufferTextureLayer(36160, attachment, texture.handle, level, layer);
              break;
            case 34067:
              const face = mapIndexToCubeMapFace(layer);
              gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
              break;
            case 3553:
              gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
              break;
            default:
              throw new Error("Illegal texture type");
          }
          gl.bindTexture(texture.glTarget, null);
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/webgl-canvas-context.js
  var import_core8, WebGLCanvasContext;
  var init_webgl_canvas_context = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/webgl-canvas-context.js"() {
      import_core8 = __toESM(require_core2(), 1);
      init_webgl_framebuffer();
      WebGLCanvasContext = class extends import_core8.CanvasContext {
        device;
        handle = null;
        _framebuffer = null;
        get [Symbol.toStringTag]() {
          return "WebGLCanvasContext";
        }
        constructor(device, props) {
          super(props);
          this.device = device;
          this._setAutoCreatedCanvasId(`${this.device.id}-canvas`);
          this._updateDevice();
        }
        getCurrentFramebuffer() {
          this._framebuffer = this._framebuffer || new WEBGLFramebuffer(this.device, { handle: null });
          return this._framebuffer;
        }
        // IMPLEMENTATION OF ABSTRACT METHODS
        _updateDevice() {
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/utils/uid.js
  function uid(id = "id") {
    uidCounters[id] = uidCounters[id] || 1;
    const count = uidCounters[id]++;
    return `${id}-${count}`;
  }
  var uidCounters;
  var init_uid = __esm({
    "../../node_modules/@luma.gl/webgl/dist/utils/uid.js"() {
      uidCounters = {};
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js
  function getWebGLTarget(usage) {
    if (usage & import_core9.Buffer.INDEX) {
      return 34963;
    }
    if (usage & import_core9.Buffer.VERTEX) {
      return 34962;
    }
    if (usage & import_core9.Buffer.UNIFORM) {
      return 35345;
    }
    return 34962;
  }
  function getWebGLUsage(usage) {
    if (usage & import_core9.Buffer.INDEX) {
      return 35044;
    }
    if (usage & import_core9.Buffer.VERTEX) {
      return 35044;
    }
    if (usage & import_core9.Buffer.UNIFORM) {
      return 35048;
    }
    return 35044;
  }
  var import_core9, WEBGLBuffer;
  var init_webgl_buffer = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-buffer.js"() {
      import_core9 = __toESM(require_core2(), 1);
      WEBGLBuffer = class extends import_core9.Buffer {
        device;
        gl;
        handle;
        /** Target in OpenGL defines the type of buffer */
        glTarget;
        /** Usage is a hint on how frequently the buffer will be updates */
        glUsage;
        /** Index type is needed when issuing draw calls, so we pre-compute it */
        glIndexType = 5123;
        /** Number of bytes allocated on the GPU for this buffer */
        byteLength = 0;
        /** Number of bytes used */
        bytesUsed = 0;
        constructor(device, props = {}) {
          super(device, props);
          this.device = device;
          this.gl = this.device.gl;
          const handle = typeof props === "object" ? props.handle : void 0;
          this.handle = handle || this.gl.createBuffer();
          device._setWebGLDebugMetadata(this.handle, this, {
            spector: { ...this.props, data: typeof this.props.data }
          });
          this.glTarget = getWebGLTarget(this.props.usage);
          this.glUsage = getWebGLUsage(this.props.usage);
          this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123;
          if (props.data) {
            this._initWithData(props.data, props.byteOffset, props.byteLength);
          } else {
            this._initWithByteLength(props.byteLength || 0);
          }
        }
        destroy() {
          if (!this.destroyed && this.handle) {
            this.removeStats();
            this.trackDeallocatedMemory();
            this.gl.deleteBuffer(this.handle);
            this.destroyed = true;
            this.handle = null;
          }
        }
        /** Allocate a new buffer and initialize to contents of typed array */
        _initWithData(data, byteOffset = 0, byteLength = data.byteLength + byteOffset) {
          const glTarget = this.glTarget;
          this.gl.bindBuffer(glTarget, this.handle);
          this.gl.bufferData(glTarget, byteLength, this.glUsage);
          this.gl.bufferSubData(glTarget, byteOffset, data);
          this.gl.bindBuffer(glTarget, null);
          this.bytesUsed = byteLength;
          this.byteLength = byteLength;
          this._setDebugData(data, byteOffset, byteLength);
          this.trackAllocatedMemory(byteLength);
        }
        // Allocate a GPU buffer of specified size.
        _initWithByteLength(byteLength) {
          let data = byteLength;
          if (byteLength === 0) {
            data = new Float32Array(0);
          }
          const glTarget = this.glTarget;
          this.gl.bindBuffer(glTarget, this.handle);
          this.gl.bufferData(glTarget, data, this.glUsage);
          this.gl.bindBuffer(glTarget, null);
          this.bytesUsed = byteLength;
          this.byteLength = byteLength;
          this._setDebugData(null, 0, byteLength);
          this.trackAllocatedMemory(byteLength);
          return this;
        }
        write(data, byteOffset = 0) {
          const dataView = ArrayBuffer.isView(data) ? data : new Uint8Array(data);
          const srcOffset = 0;
          const byteLength = void 0;
          const glTarget = 36663;
          this.gl.bindBuffer(glTarget, this.handle);
          if (srcOffset !== 0 || byteLength !== void 0) {
            this.gl.bufferSubData(glTarget, byteOffset, dataView, srcOffset, byteLength);
          } else {
            this.gl.bufferSubData(glTarget, byteOffset, dataView);
          }
          this.gl.bindBuffer(glTarget, null);
          this._setDebugData(data, byteOffset, data.byteLength);
        }
        async mapAndWriteAsync(callback, byteOffset = 0, byteLength = this.byteLength - byteOffset) {
          const arrayBuffer = new ArrayBuffer(byteLength);
          await callback(arrayBuffer, "copied");
          this.write(arrayBuffer, byteOffset);
        }
        async readAsync(byteOffset = 0, byteLength) {
          return this.readSyncWebGL(byteOffset, byteLength);
        }
        async mapAndReadAsync(callback, byteOffset = 0, byteLength) {
          const data = await this.readAsync(byteOffset, byteLength);
          return await callback(data.buffer, "copied");
        }
        readSyncWebGL(byteOffset = 0, byteLength) {
          byteLength = byteLength ?? this.byteLength - byteOffset;
          const data = new Uint8Array(byteLength);
          const dstOffset = 0;
          this.gl.bindBuffer(36662, this.handle);
          this.gl.getBufferSubData(36662, byteOffset, data, dstOffset, byteLength);
          this.gl.bindBuffer(36662, null);
          this._setDebugData(data, byteOffset, byteLength);
          return data;
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/parse-shader-compiler-log.js
  function parseShaderCompilerLog(errLog) {
    const lines = errLog.split(/\r?\n/);
    const messages = [];
    for (const line of lines) {
      if (line.length <= 1) {
        continue;
      }
      const segments = line.split(":");
      if (segments.length === 2) {
        const [messageType2, message2] = segments;
        messages.push({
          message: message2.trim(),
          type: getMessageType(messageType2),
          lineNum: 0,
          linePos: 0
        });
        continue;
      }
      const [messageType, linePosition, lineNumber, ...rest] = segments;
      let lineNum = parseInt(lineNumber, 10);
      if (isNaN(lineNum)) {
        lineNum = 0;
      }
      let linePos = parseInt(linePosition, 10);
      if (isNaN(linePos)) {
        linePos = 0;
      }
      messages.push({
        message: rest.join(":").trim(),
        type: getMessageType(messageType),
        lineNum,
        linePos
        // TODO
      });
    }
    return messages;
  }
  function getMessageType(messageType) {
    const MESSAGE_TYPES = ["warning", "error", "info"];
    const lowerCaseType = messageType.toLowerCase();
    return MESSAGE_TYPES.includes(lowerCaseType) ? lowerCaseType : "info";
  }
  var init_parse_shader_compiler_log = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/helpers/parse-shader-compiler-log.js"() {
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-shader.js
  var import_core10, WEBGLShader;
  var init_webgl_shader = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-shader.js"() {
      import_core10 = __toESM(require_core2(), 1);
      init_parse_shader_compiler_log();
      WEBGLShader = class extends import_core10.Shader {
        device;
        handle;
        constructor(device, props) {
          super(device, props);
          this.device = device;
          switch (this.props.stage) {
            case "vertex":
              this.handle = this.props.handle || this.device.gl.createShader(35633);
              break;
            case "fragment":
              this.handle = this.props.handle || this.device.gl.createShader(35632);
              break;
            default:
              throw new Error(this.props.stage);
          }
          device._setWebGLDebugMetadata(this.handle, this, { spector: this.props });
          this._compile(this.source);
        }
        destroy() {
          if (this.handle) {
            this.removeStats();
            this.device.gl.deleteShader(this.handle);
            this.destroyed = true;
            this.handle.destroyed = true;
          }
        }
        get asyncCompilationStatus() {
          return this._waitForCompilationComplete().then(() => {
            this._getCompilationStatus();
            return this.compilationStatus;
          });
        }
        async getCompilationInfo() {
          await this._waitForCompilationComplete();
          return this.getCompilationInfoSync();
        }
        getCompilationInfoSync() {
          const shaderLog = this.device.gl.getShaderInfoLog(this.handle);
          return shaderLog ? parseShaderCompilerLog(shaderLog) : [];
        }
        getTranslatedSource() {
          const extensions = this.device.getExtension("WEBGL_debug_shaders");
          const ext = extensions.WEBGL_debug_shaders;
          return ext?.getTranslatedShaderSource(this.handle) || null;
        }
        // PRIVATE METHODS
        /** Compile a shader and get compilation status */
        async _compile(source) {
          source = source.startsWith("#version ") ? source : `#version 300 es
${source}`;
          const { gl } = this.device;
          gl.shaderSource(this.handle, source);
          gl.compileShader(this.handle);
          if (!this.device.props.debug) {
            this.compilationStatus = "pending";
            return;
          }
          if (!this.device.features.has("compilation-status-async-webgl")) {
            this._getCompilationStatus();
            this.debugShader();
            if (this.compilationStatus === "error") {
              throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
            }
            return;
          }
          import_core10.log.once(1, "Shader compilation is asynchronous")();
          await this._waitForCompilationComplete();
          import_core10.log.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();
          this._getCompilationStatus();
          this.debugShader();
        }
        /** Use KHR_parallel_shader_compile extension if available */
        async _waitForCompilationComplete() {
          const waitMs = async (ms) => await new Promise((resolve) => setTimeout(resolve, ms));
          const DELAY_MS = 10;
          if (!this.device.features.has("compilation-status-async-webgl")) {
            await waitMs(DELAY_MS);
            return;
          }
          const { gl } = this.device;
          for (; ; ) {
            const complete = gl.getShaderParameter(this.handle, 37297);
            if (complete) {
              return;
            }
            await waitMs(DELAY_MS);
          }
        }
        /**
         * Get the shader compilation status
         * TODO - Load log even when no error reported, to catch warnings?
         * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
         */
        _getCompilationStatus() {
          this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/device-parameters.js
  function withDeviceAndGLParameters(device, parameters, glParameters, func) {
    if (isObjectEmpty2(parameters)) {
      return func(device);
    }
    const webglDevice = device;
    webglDevice.pushState();
    try {
      setDeviceParameters(device, parameters);
      setGLParameters(webglDevice.gl, glParameters);
      return func(device);
    } finally {
      webglDevice.popState();
    }
  }
  function setDeviceParameters(device, parameters) {
    const webglDevice = device;
    const { gl } = webglDevice;
    if (parameters.cullMode) {
      switch (parameters.cullMode) {
        case "none":
          gl.disable(2884);
          break;
        case "front":
          gl.enable(2884);
          gl.cullFace(1028);
          break;
        case "back":
          gl.enable(2884);
          gl.cullFace(1029);
          break;
      }
    }
    if (parameters.frontFace) {
      gl.frontFace(map("frontFace", parameters.frontFace, {
        ccw: 2305,
        cw: 2304
      }));
    }
    if (parameters.unclippedDepth) {
      if (device.features.has("depth-clip-control")) {
        gl.enable(34383);
      }
    }
    if (parameters.depthBias !== void 0) {
      gl.enable(32823);
      gl.polygonOffset(parameters.depthBias, parameters.depthBiasSlopeScale || 0);
    }
    if (parameters.provokingVertex) {
      if (device.features.has("provoking-vertex-webgl")) {
        const extensions = webglDevice.getExtension("WEBGL_provoking_vertex");
        const ext = extensions.WEBGL_provoking_vertex;
        const vertex = map("provokingVertex", parameters.provokingVertex, {
          first: 36429,
          last: 36430
        });
        ext?.provokingVertexWEBGL(vertex);
      }
    }
    if (parameters.polygonMode || parameters.polygonOffsetLine) {
      if (device.features.has("polygon-mode-webgl")) {
        if (parameters.polygonMode) {
          const extensions = webglDevice.getExtension("WEBGL_polygon_mode");
          const ext = extensions.WEBGL_polygon_mode;
          const mode = map("polygonMode", parameters.polygonMode, {
            fill: 6914,
            line: 6913
          });
          ext?.polygonModeWEBGL(1028, mode);
          ext?.polygonModeWEBGL(1029, mode);
        }
        if (parameters.polygonOffsetLine) {
          gl.enable(10754);
        }
      }
    }
    if (device.features.has("shader-clip-cull-distance-webgl")) {
      if (parameters.clipDistance0) {
        gl.enable(12288);
      }
      if (parameters.clipDistance1) {
        gl.enable(12289);
      }
      if (parameters.clipDistance2) {
        gl.enable(12290);
      }
      if (parameters.clipDistance3) {
        gl.enable(12291);
      }
      if (parameters.clipDistance4) {
        gl.enable(12292);
      }
      if (parameters.clipDistance5) {
        gl.enable(12293);
      }
      if (parameters.clipDistance6) {
        gl.enable(12294);
      }
      if (parameters.clipDistance7) {
        gl.enable(12295);
      }
    }
    if (parameters.depthWriteEnabled !== void 0) {
      gl.depthMask(mapBoolean("depthWriteEnabled", parameters.depthWriteEnabled));
    }
    if (parameters.depthCompare) {
      parameters.depthCompare !== "always" ? gl.enable(2929) : gl.disable(2929);
      gl.depthFunc(convertCompareFunction("depthCompare", parameters.depthCompare));
    }
    if (parameters.stencilWriteMask) {
      const mask = parameters.stencilWriteMask;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, mask);
    }
    if (parameters.stencilReadMask) {
      import_core11.log.warn("stencilReadMask not supported under WebGL");
    }
    if (parameters.stencilCompare) {
      const mask = parameters.stencilReadMask || 4294967295;
      const glValue = convertCompareFunction("depthCompare", parameters.stencilCompare);
      parameters.stencilCompare !== "always" ? gl.enable(2960) : gl.disable(2960);
      gl.stencilFuncSeparate(1028, glValue, 0, mask);
      gl.stencilFuncSeparate(1029, glValue, 0, mask);
    }
    if (parameters.stencilPassOperation && parameters.stencilFailOperation && parameters.stencilDepthFailOperation) {
      const dppass = convertStencilOperation("stencilPassOperation", parameters.stencilPassOperation);
      const sfail = convertStencilOperation("stencilFailOperation", parameters.stencilFailOperation);
      const dpfail = convertStencilOperation("stencilDepthFailOperation", parameters.stencilDepthFailOperation);
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, sfail, dpfail, dppass);
    }
    switch (parameters.blend) {
      case true:
        gl.enable(3042);
        break;
      case false:
        gl.disable(3042);
        break;
      default:
    }
    if (parameters.blendColorOperation || parameters.blendAlphaOperation) {
      const colorEquation = convertBlendOperationToEquation("blendColorOperation", parameters.blendColorOperation || "add");
      const alphaEquation = convertBlendOperationToEquation("blendAlphaOperation", parameters.blendAlphaOperation || "add");
      gl.blendEquationSeparate(colorEquation, alphaEquation);
      const colorSrcFactor = convertBlendFactorToFunction("blendColorSrcFactor", parameters.blendColorSrcFactor || "one");
      const colorDstFactor = convertBlendFactorToFunction("blendColorDstFactor", parameters.blendColorDstFactor || "zero");
      const alphaSrcFactor = convertBlendFactorToFunction("blendAlphaSrcFactor", parameters.blendAlphaSrcFactor || "one");
      const alphaDstFactor = convertBlendFactorToFunction("blendAlphaDstFactor", parameters.blendAlphaDstFactor || "zero");
      gl.blendFuncSeparate(colorSrcFactor, colorDstFactor, alphaSrcFactor, alphaDstFactor);
    }
  }
  function convertCompareFunction(parameter, value) {
    return map(parameter, value, {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    });
  }
  function convertStencilOperation(parameter, value) {
    return map(parameter, value, {
      keep: 7680,
      zero: 0,
      replace: 7681,
      invert: 5386,
      "increment-clamp": 7682,
      "decrement-clamp": 7683,
      "increment-wrap": 34055,
      "decrement-wrap": 34056
    });
  }
  function convertBlendOperationToEquation(parameter, value) {
    return map(parameter, value, {
      add: 32774,
      subtract: 32778,
      "reverse-subtract": 32779,
      min: 32775,
      max: 32776
    });
  }
  function convertBlendFactorToFunction(parameter, value, type = "color") {
    return map(parameter, value, {
      one: 1,
      zero: 0,
      src: 768,
      "one-minus-src": 769,
      dst: 774,
      "one-minus-dst": 775,
      "src-alpha": 770,
      "one-minus-src-alpha": 771,
      "dst-alpha": 772,
      "one-minus-dst-alpha": 773,
      "src-alpha-saturated": 776,
      constant: type === "color" ? 32769 : 32771,
      "one-minus-constant": type === "color" ? 32770 : 32772,
      // 'constant-alpha': GL.CONSTANT_ALPHA,
      // 'one-minus-constant-alpha': GL.ONE_MINUS_CONSTANT_ALPHA,
      // TODO not supported in WebGL2
      src1: 768,
      "one-minus-src1": 769,
      "src1-alpha": 770,
      "one-minus-src1-alpha": 771
    });
  }
  function message(parameter, value) {
    return `Illegal parameter ${value} for ${parameter}`;
  }
  function map(parameter, value, valueMap) {
    if (!(value in valueMap)) {
      throw new Error(message(parameter, value));
    }
    return valueMap[value];
  }
  function mapBoolean(parameter, value) {
    return value;
  }
  function isObjectEmpty2(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }
  var import_core11;
  var init_device_parameters = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/converters/device-parameters.js"() {
      import_core11 = __toESM(require_core2(), 1);
      init_unified_parameter_api();
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/sampler-parameters.js
  function convertSamplerParametersToWebGL(props) {
    const params = {};
    if (props.addressModeU) {
      params[10242] = convertAddressMode(props.addressModeU);
    }
    if (props.addressModeV) {
      params[10243] = convertAddressMode(props.addressModeV);
    }
    if (props.addressModeW) {
      params[32882] = convertAddressMode(props.addressModeW);
    }
    if (props.magFilter) {
      params[10240] = convertMaxFilterMode(props.magFilter);
    }
    if (props.minFilter || props.mipmapFilter) {
      params[10241] = convertMinFilterMode(props.minFilter || "linear", props.mipmapFilter);
    }
    if (props.lodMinClamp !== void 0) {
      params[33082] = props.lodMinClamp;
    }
    if (props.lodMaxClamp !== void 0) {
      params[33083] = props.lodMaxClamp;
    }
    if (props.type === "comparison-sampler") {
      params[34892] = 34894;
    }
    if (props.compare) {
      params[34893] = convertCompareFunction("compare", props.compare);
    }
    if (props.maxAnisotropy) {
      params[34046] = props.maxAnisotropy;
    }
    return params;
  }
  function convertAddressMode(addressMode) {
    switch (addressMode) {
      case "clamp-to-edge":
        return 33071;
      case "repeat":
        return 10497;
      case "mirror-repeat":
        return 33648;
    }
  }
  function convertMaxFilterMode(maxFilter) {
    switch (maxFilter) {
      case "nearest":
        return 9728;
      case "linear":
        return 9729;
    }
  }
  function convertMinFilterMode(minFilter, mipmapFilter = "none") {
    if (!mipmapFilter) {
      return convertMaxFilterMode(minFilter);
    }
    switch (mipmapFilter) {
      case "none":
        return convertMaxFilterMode(minFilter);
      case "nearest":
        switch (minFilter) {
          case "nearest":
            return 9984;
          case "linear":
            return 9985;
        }
        break;
      case "linear":
        switch (minFilter) {
          case "nearest":
            return 9986;
          case "linear":
            return 9987;
        }
    }
  }
  var init_sampler_parameters = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/converters/sampler-parameters.js"() {
      init_device_parameters();
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-sampler.js
  var import_core12, WEBGLSampler;
  var init_webgl_sampler = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-sampler.js"() {
      import_core12 = __toESM(require_core2(), 1);
      init_sampler_parameters();
      WEBGLSampler = class extends import_core12.Sampler {
        device;
        handle;
        parameters;
        constructor(device, props) {
          super(device, props);
          this.device = device;
          this.parameters = convertSamplerParametersToWebGL(props);
          this.handle = props.handle || this.device.gl.createSampler();
          this._setSamplerParameters(this.parameters);
        }
        destroy() {
          if (this.handle) {
            this.device.gl.deleteSampler(this.handle);
            this.handle = void 0;
          }
        }
        toString() {
          return `Sampler(${this.id},${JSON.stringify(this.props)})`;
        }
        /** Set sampler parameters on the sampler */
        _setSamplerParameters(parameters) {
          for (const [pname, value] of Object.entries(parameters)) {
            const param = Number(pname);
            switch (param) {
              case 33082:
              case 33083:
                this.device.gl.samplerParameterf(this.handle, param, value);
                break;
              default:
                this.device.gl.samplerParameteri(this.handle, param, value);
                break;
            }
          }
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js
  function withGLParameters(gl, parameters, func) {
    if (isObjectEmpty3(parameters)) {
      return func(gl);
    }
    const { nocatch = true } = parameters;
    const webglState = WebGLStateTracker.get(gl);
    webglState.push();
    setGLParameters(gl, parameters);
    let value;
    if (nocatch) {
      value = func(gl);
      webglState.pop();
    } else {
      try {
        value = func(gl);
      } finally {
        webglState.pop();
      }
    }
    return value;
  }
  function isObjectEmpty3(object) {
    for (const key in object) {
      return false;
    }
    return true;
  }
  var init_with_parameters = __esm({
    "../../node_modules/@luma.gl/webgl/dist/context/state-tracker/with-parameters.js"() {
      init_unified_parameter_api();
      init_webgl_state_tracker();
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture-view.js
  var import_core13, WEBGLTextureView;
  var init_webgl_texture_view = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture-view.js"() {
      import_core13 = __toESM(require_core2(), 1);
      WEBGLTextureView = class extends import_core13.TextureView {
        device;
        gl;
        handle;
        // Does not have a WebGL representation
        texture;
        constructor(device, props) {
          super(device, { ...import_core13.Texture.defaultProps, ...props });
          this.device = device;
          this.gl = this.device.gl;
          this.handle = null;
          this.texture = props.texture;
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js
  function getWebGLTextureTarget(dimension) {
    switch (dimension) {
      case "1d":
        break;
      case "2d":
        return 3553;
      case "3d":
        return 32879;
      case "cube":
        return 34067;
      case "2d-array":
        return 35866;
      case "cube-array":
        break;
    }
    throw new Error(dimension);
  }
  function getWebGLCubeFaceTarget(glTarget, dimension, level) {
    return dimension === "cube" ? 34069 + level : glTarget;
  }
  var import_core14, WEBGLTexture;
  var init_webgl_texture = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-texture.js"() {
      import_core14 = __toESM(require_core2(), 1);
      init_webgl_texture_table();
      init_sampler_parameters();
      init_with_parameters();
      init_webgl_texture_view();
      WEBGLTexture = class extends import_core14.Texture {
        // readonly MAX_ATTRIBUTES: number;
        device;
        gl;
        handle;
        // @ts-ignore TODO - currently unused in WebGL. Create dummy sampler?
        sampler = void 0;
        view;
        /**
         * The WebGL target corresponding to the texture type
         * @note `target` cannot be modified by bind:
         * textures are special because when you first bind them to a target,
         * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
         * And it will always be a 2D texture; this state cannot be changed ever.
         * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
         * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
         */
        glTarget;
        /** The WebGL format - essentially channel structure */
        glFormat;
        /** The WebGL data format - the type of each channel */
        glType;
        /** The WebGL constant corresponding to the WebGPU style constant in format */
        glInternalFormat;
        /** Whether the internal format is compressed */
        compressed;
        // state
        /** Texture binding slot - TODO - move to texture view? */
        _textureUnit = 0;
        constructor(device, props) {
          super(device, props);
          this.device = device;
          this.gl = this.device.gl;
          const formatInfo = getTextureFormatWebGL(this.props.format);
          this.glTarget = getWebGLTextureTarget(this.props.dimension);
          this.glInternalFormat = formatInfo.internalFormat;
          this.glFormat = formatInfo.format;
          this.glType = formatInfo.type;
          this.compressed = formatInfo.compressed;
          this.handle = this.props.handle || this.gl.createTexture();
          this.device._setWebGLDebugMetadata(this.handle, this, { spector: this.props });
          this.gl.bindTexture(this.glTarget, this.handle);
          const { dimension, width, height, depth, mipLevels, glTarget, glInternalFormat } = this;
          switch (dimension) {
            case "2d":
            case "cube":
              this.gl.texStorage2D(glTarget, mipLevels, glInternalFormat, width, height);
              break;
            case "2d-array":
            case "3d":
              this.gl.texStorage3D(glTarget, mipLevels, glInternalFormat, width, height, depth);
              break;
            default:
              throw new Error(dimension);
          }
          this.gl.bindTexture(this.glTarget, null);
          this._initializeData(props.data);
          this.setSampler(this.props.sampler);
          this.view = new WEBGLTextureView(this.device, { ...this.props, texture: this });
          Object.seal(this);
        }
        destroy() {
          if (this.handle) {
            this.gl.deleteTexture(this.handle);
            this.removeStats();
            this.trackDeallocatedMemory("Texture");
            this.destroyed = true;
          }
        }
        createView(props) {
          return new WEBGLTextureView(this.device, { ...props, texture: this });
        }
        setSampler(sampler = {}) {
          super.setSampler(sampler);
          const parameters = convertSamplerParametersToWebGL(this.sampler.props);
          this._setSamplerParameters(parameters);
        }
        copyImageData(options_) {
          const options = this._normalizeCopyImageDataOptions(options_);
          const typedArray = options.data;
          const { width, height, depth } = this;
          const { mipLevel = 0, byteOffset = 0, x = 0, y = 0, z = 0 } = options;
          const { glFormat, glType, compressed } = this;
          const glTarget = getWebGLCubeFaceTarget(this.glTarget, this.dimension, z);
          let unpackRowLength;
          if (!this.compressed) {
            const { bytesPerPixel } = this.device.getTextureFormatInfo(this.format);
            if (bytesPerPixel) {
              if (options.bytesPerRow % bytesPerPixel !== 0) {
                throw new Error(`bytesPerRow (${options.bytesPerRow}) must be a multiple of bytesPerPixel (${bytesPerPixel}) for ${this.format}`);
              }
              unpackRowLength = options.bytesPerRow / bytesPerPixel;
            }
          }
          const glParameters = !this.compressed ? {
            ...unpackRowLength !== void 0 ? { [3314]: unpackRowLength } : {},
            [32878]: options.rowsPerImage
          } : {};
          this.gl.bindTexture(glTarget, this.handle);
          withGLParameters(this.gl, glParameters, () => {
            switch (this.dimension) {
              case "2d":
              case "cube":
                if (compressed) {
                  this.gl.compressedTexSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, typedArray, byteOffset);
                } else {
                  this.gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, typedArray, byteOffset);
                }
                break;
              case "2d-array":
              case "3d":
                if (compressed) {
                  this.gl.compressedTexSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, typedArray, byteOffset);
                } else {
                  this.gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, typedArray, byteOffset);
                }
                break;
              default:
            }
          });
          this.gl.bindTexture(glTarget, null);
        }
        copyExternalImage(options_) {
          const options = this._normalizeCopyExternalImageOptions(options_);
          if (options.sourceX || options.sourceY) {
            throw new Error("WebGL does not support sourceX/sourceY)");
          }
          const { glFormat, glType } = this;
          const { image, depth, mipLevel, x, y, z, width, height } = options;
          const glTarget = getWebGLCubeFaceTarget(this.glTarget, this.dimension, depth);
          const glParameters = options.flipY ? { [37440]: true } : {};
          this.gl.bindTexture(this.glTarget, this.handle);
          withGLParameters(this.gl, glParameters, () => {
            switch (this.dimension) {
              case "2d":
              case "cube":
                this.gl.texSubImage2D(glTarget, mipLevel, x, y, width, height, glFormat, glType, image);
                break;
              case "2d-array":
              case "3d":
                this.gl.texSubImage3D(glTarget, mipLevel, x, y, z, width, height, depth, glFormat, glType, image);
                break;
              default:
            }
          });
          this.gl.bindTexture(this.glTarget, null);
          return { width: options.width, height: options.height };
        }
        // WEBGL SPECIFIC
        generateMipmapsWebGL(options) {
          const isFilterableAndRenderable = this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format);
          if (!isFilterableAndRenderable) {
            import_core14.log.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)();
            if (!options?.force) {
              return;
            }
          }
          try {
            this.gl.bindTexture(this.glTarget, this.handle);
            this.gl.generateMipmap(this.glTarget);
          } catch (error) {
            import_core14.log.warn(`Error generating mipmap for ${this}: ${error.message}`)();
          } finally {
            this.gl.bindTexture(this.glTarget, null);
          }
        }
        // INTERNAL
        /**
         * Sets sampler parameters on texture
         */
        _setSamplerParameters(parameters) {
          import_core14.log.log(2, `${this.id} sampler parameters`, this.device.getGLKeys(parameters))();
          this.gl.bindTexture(this.glTarget, this.handle);
          for (const [pname, pvalue] of Object.entries(parameters)) {
            const param = Number(pname);
            const value = pvalue;
            switch (param) {
              case 33082:
              case 33083:
                this.gl.texParameterf(this.glTarget, param, value);
                break;
              case 10240:
              case 10241:
                this.gl.texParameteri(this.glTarget, param, value);
                break;
              case 10242:
              case 10243:
              case 32882:
                this.gl.texParameteri(this.glTarget, param, value);
                break;
              case 34046:
                if (this.device.features.has("texture-filterable-anisotropic-webgl")) {
                  this.gl.texParameteri(this.glTarget, param, value);
                }
                break;
              case 34892:
              case 34893:
                this.gl.texParameteri(this.glTarget, param, value);
                break;
            }
          }
          this.gl.bindTexture(this.glTarget, null);
        }
        _getActiveUnit() {
          return this.gl.getParameter(34016) - 33984;
        }
        _bind(_textureUnit) {
          const { gl } = this;
          if (_textureUnit !== void 0) {
            this._textureUnit = _textureUnit;
            gl.activeTexture(33984 + _textureUnit);
          }
          gl.bindTexture(this.glTarget, this.handle);
          return _textureUnit;
        }
        _unbind(_textureUnit) {
          const { gl } = this;
          if (_textureUnit !== void 0) {
            this._textureUnit = _textureUnit;
            gl.activeTexture(33984 + _textureUnit);
          }
          gl.bindTexture(this.glTarget, null);
          return _textureUnit;
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-shadertypes.js
  function convertDataTypeToGLDataType(normalizedType) {
    return NORMALIZED_SHADER_TYPE_TO_WEBGL[normalizedType];
  }
  function convertGLUniformTypeToShaderVariableType(glUniformType) {
    return WEBGL_SHADER_TYPES[glUniformType];
  }
  function isGLSamplerType(type) {
    return Boolean(WEBGL_SAMPLER_TO_TEXTURE_BINDINGS[type]);
  }
  function getTextureBindingFromGLSamplerType(glSamplerType) {
    return WEBGL_SAMPLER_TO_TEXTURE_BINDINGS[glSamplerType];
  }
  var WEBGL_SHADER_TYPES, WEBGL_SAMPLER_TO_TEXTURE_BINDINGS, NORMALIZED_SHADER_TYPE_TO_WEBGL;
  var init_webgl_shadertypes = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/converters/webgl-shadertypes.js"() {
      WEBGL_SHADER_TYPES = {
        [5126]: "f32",
        [35664]: "vec2<f32>",
        [35665]: "vec3<f32>",
        [35666]: "vec4<f32>",
        [5124]: "i32",
        [35667]: "vec2<i32>",
        [35668]: "vec3<i32>",
        [35669]: "vec4<i32>",
        [5125]: "u32",
        [36294]: "vec2<u32>",
        [36295]: "vec3<u32>",
        [36296]: "vec4<u32>",
        [35670]: "f32",
        [35671]: "vec2<f32>",
        [35672]: "vec3<f32>",
        [35673]: "vec4<f32>",
        // TODO - are sizes/components below correct?
        [35674]: "mat2x2<f32>",
        [35685]: "mat2x3<f32>",
        [35686]: "mat2x4<f32>",
        [35687]: "mat3x2<f32>",
        [35675]: "mat3x3<f32>",
        [35688]: "mat3x4<f32>",
        [35689]: "mat4x2<f32>",
        [35690]: "mat4x3<f32>",
        [35676]: "mat4x4<f32>"
      };
      WEBGL_SAMPLER_TO_TEXTURE_BINDINGS = {
        [35678]: { viewDimension: "2d", sampleType: "float" },
        [35680]: { viewDimension: "cube", sampleType: "float" },
        [35679]: { viewDimension: "3d", sampleType: "float" },
        [35682]: { viewDimension: "3d", sampleType: "depth" },
        [36289]: { viewDimension: "2d-array", sampleType: "float" },
        [36292]: { viewDimension: "2d-array", sampleType: "depth" },
        [36293]: { viewDimension: "cube", sampleType: "float" },
        [36298]: { viewDimension: "2d", sampleType: "sint" },
        [36299]: { viewDimension: "3d", sampleType: "sint" },
        [36300]: { viewDimension: "cube", sampleType: "sint" },
        [36303]: { viewDimension: "2d-array", sampleType: "uint" },
        [36306]: { viewDimension: "2d", sampleType: "uint" },
        [36307]: { viewDimension: "3d", sampleType: "uint" },
        [36308]: { viewDimension: "cube", sampleType: "uint" },
        [36311]: { viewDimension: "2d-array", sampleType: "uint" }
      };
      NORMALIZED_SHADER_TYPE_TO_WEBGL = {
        uint8: 5121,
        sint8: 5120,
        unorm8: 5121,
        snorm8: 5120,
        uint16: 5123,
        sint16: 5122,
        unorm16: 5123,
        snorm16: 5122,
        uint32: 5125,
        sint32: 5124,
        // WebGPU does not support normalized 32 bit integer attributes
        //  'unorm32': GL.UNSIGNED_INT,
        //  'snorm32': GL.INT,
        float16: 5131,
        float32: 5126
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/get-shader-layout-from-glsl.js
  function getShaderLayoutFromGLSL(gl, program) {
    const shaderLayout = {
      attributes: [],
      bindings: []
    };
    shaderLayout.attributes = readAttributeDeclarations(gl, program);
    const uniformBlocks = readUniformBlocks(gl, program);
    for (const uniformBlock of uniformBlocks) {
      const uniforms2 = uniformBlock.uniforms.map((uniform) => ({
        name: uniform.name,
        format: uniform.format,
        byteOffset: uniform.byteOffset,
        byteStride: uniform.byteStride,
        arrayLength: uniform.arrayLength
      }));
      shaderLayout.bindings.push({
        type: "uniform",
        name: uniformBlock.name,
        group: 0,
        location: uniformBlock.location,
        visibility: (uniformBlock.vertex ? 1 : 0) & (uniformBlock.fragment ? 2 : 0),
        minBindingSize: uniformBlock.byteLength,
        uniforms: uniforms2
      });
    }
    const uniforms = readUniformBindings(gl, program);
    let textureUnit = 0;
    for (const uniform of uniforms) {
      if (isGLSamplerType(uniform.type)) {
        const { viewDimension, sampleType } = getTextureBindingFromGLSamplerType(uniform.type);
        shaderLayout.bindings.push({
          type: "texture",
          name: uniform.name,
          group: 0,
          location: textureUnit,
          viewDimension,
          sampleType
        });
        uniform.textureUnit = textureUnit;
        textureUnit += 1;
      }
    }
    if (uniforms.length) {
      shaderLayout.uniforms = uniforms;
    }
    const varyings = readVaryings(gl, program);
    if (varyings?.length) {
      shaderLayout.varyings = varyings;
    }
    return shaderLayout;
  }
  function readAttributeDeclarations(gl, program) {
    const attributes = [];
    const count = gl.getProgramParameter(program, 35721);
    for (let index = 0; index < count; index++) {
      const activeInfo = gl.getActiveAttrib(program, index);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const {
        name,
        type: compositeType
        /* , size*/
      } = activeInfo;
      const location = gl.getAttribLocation(program, name);
      if (location >= 0) {
        const attributeType = convertGLUniformTypeToShaderVariableType(compositeType);
        const stepMode = /instance/i.test(name) ? "instance" : "vertex";
        attributes.push({
          name,
          location,
          stepMode,
          type: attributeType
          // size - for arrays, size is the number of elements in the array
        });
      }
    }
    attributes.sort((a, b) => a.location - b.location);
    return attributes;
  }
  function readVaryings(gl, program) {
    const varyings = [];
    const count = gl.getProgramParameter(program, 35971);
    for (let location = 0; location < count; location++) {
      const activeInfo = gl.getTransformFeedbackVarying(program, location);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const { name, type: glUniformType, size } = activeInfo;
      const uniformType = convertGLUniformTypeToShaderVariableType(glUniformType);
      const { type, components } = (0, import_core15.getVariableShaderTypeInfo)(uniformType);
      varyings.push({ location, name, type, size: size * components });
    }
    varyings.sort((a, b) => a.location - b.location);
    return varyings;
  }
  function readUniformBindings(gl, program) {
    const uniforms = [];
    const uniformCount = gl.getProgramParameter(program, 35718);
    for (let i = 0; i < uniformCount; i++) {
      const activeInfo = gl.getActiveUniform(program, i);
      if (!activeInfo) {
        throw new Error("activeInfo");
      }
      const { name: rawName, size, type } = activeInfo;
      const { name, isArray: isArray4 } = parseUniformName(rawName);
      let webglLocation = gl.getUniformLocation(program, name);
      const uniformInfo = {
        // WebGL locations are uniquely typed but just numbers
        location: webglLocation,
        name,
        size,
        type,
        isArray: isArray4
      };
      uniforms.push(uniformInfo);
      if (uniformInfo.size > 1) {
        for (let j = 0; j < uniformInfo.size; j++) {
          const elementName = `${name}[${j}]`;
          webglLocation = gl.getUniformLocation(program, elementName);
          const arrayElementUniformInfo = {
            ...uniformInfo,
            name: elementName,
            location: webglLocation
          };
          uniforms.push(arrayElementUniformInfo);
        }
      }
    }
    return uniforms;
  }
  function readUniformBlocks(gl, program) {
    const getBlockParameter = (blockIndex, pname) => gl.getActiveUniformBlockParameter(program, blockIndex, pname);
    const uniformBlocks = [];
    const blockCount = gl.getProgramParameter(program, 35382);
    for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
      const blockInfo = {
        name: gl.getActiveUniformBlockName(program, blockIndex) || "",
        location: getBlockParameter(blockIndex, 35391),
        byteLength: getBlockParameter(blockIndex, 35392),
        vertex: getBlockParameter(blockIndex, 35396),
        fragment: getBlockParameter(blockIndex, 35398),
        uniformCount: getBlockParameter(blockIndex, 35394),
        uniforms: []
      };
      const uniformIndices = getBlockParameter(blockIndex, 35395) || [];
      const uniformType = gl.getActiveUniforms(program, uniformIndices, 35383);
      const uniformArrayLength = gl.getActiveUniforms(program, uniformIndices, 35384);
      const uniformOffset = gl.getActiveUniforms(program, uniformIndices, 35387);
      const uniformStride = gl.getActiveUniforms(program, uniformIndices, 35388);
      for (let i = 0; i < blockInfo.uniformCount; ++i) {
        const activeInfo = gl.getActiveUniform(program, uniformIndices[i]);
        if (!activeInfo) {
          throw new Error("activeInfo");
        }
        const format = convertGLUniformTypeToShaderVariableType(uniformType[i]);
        blockInfo.uniforms.push({
          name: activeInfo.name,
          format,
          type: uniformType[i],
          arrayLength: uniformArrayLength[i],
          byteOffset: uniformOffset[i],
          byteStride: uniformStride[i]
          // matrixStride: uniformStride[i],
          // rowMajor: uniformRowMajor[i]
        });
      }
      uniformBlocks.push(blockInfo);
    }
    uniformBlocks.sort((a, b) => a.location - b.location);
    return uniformBlocks;
  }
  function parseUniformName(name) {
    if (name[name.length - 1] !== "]") {
      return {
        name,
        length: 1,
        isArray: false
      };
    }
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches = UNIFORM_NAME_REGEXP.exec(name);
    if (!matches || matches.length < 2) {
      throw new Error(`Failed to parse GLSL uniform name ${name}`);
    }
    return {
      name: matches[1],
      length: matches[2] ? 1 : 0,
      isArray: Boolean(matches[2])
    };
  }
  var import_core15;
  var init_get_shader_layout_from_glsl = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/helpers/get-shader-layout-from-glsl.js"() {
      import_core15 = __toESM(require_core2(), 1);
      init_webgl_shadertypes();
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/set-uniform.js
  function setUniform(gl, location, type, value) {
    const gl2 = gl;
    let uniformValue = value;
    if (uniformValue === true) {
      uniformValue = 1;
    }
    if (uniformValue === false) {
      uniformValue = 0;
    }
    const arrayValue = typeof uniformValue === "number" ? [uniformValue] : uniformValue;
    switch (type) {
      case 35678:
      case 35680:
      case 35679:
      case 35682:
      case 36289:
      case 36292:
      case 36293:
      case 36298:
      case 36299:
      case 36300:
      case 36303:
      case 36306:
      case 36307:
      case 36308:
      case 36311:
        if (typeof value !== "number") {
          throw new Error("samplers must be set to integers");
        }
        return gl.uniform1i(location, value);
      case 5126:
        return gl.uniform1fv(location, arrayValue);
      case 35664:
        return gl.uniform2fv(location, arrayValue);
      case 35665:
        return gl.uniform3fv(location, arrayValue);
      case 35666:
        return gl.uniform4fv(location, arrayValue);
      case 5124:
        return gl.uniform1iv(location, arrayValue);
      case 35667:
        return gl.uniform2iv(location, arrayValue);
      case 35668:
        return gl.uniform3iv(location, arrayValue);
      case 35669:
        return gl.uniform4iv(location, arrayValue);
      case 35670:
        return gl.uniform1iv(location, arrayValue);
      case 35671:
        return gl.uniform2iv(location, arrayValue);
      case 35672:
        return gl.uniform3iv(location, arrayValue);
      case 35673:
        return gl.uniform4iv(location, arrayValue);
      case 5125:
        return gl2.uniform1uiv(location, arrayValue, 1);
      case 36294:
        return gl2.uniform2uiv(location, arrayValue, 2);
      case 36295:
        return gl2.uniform3uiv(location, arrayValue, 3);
      case 36296:
        return gl2.uniform4uiv(location, arrayValue, 4);
      case 35674:
        return gl.uniformMatrix2fv(location, false, arrayValue);
      case 35675:
        return gl.uniformMatrix3fv(location, false, arrayValue);
      case 35676:
        return gl.uniformMatrix4fv(location, false, arrayValue);
      case 35685:
        return gl2.uniformMatrix2x3fv(location, false, arrayValue);
      case 35686:
        return gl2.uniformMatrix2x4fv(location, false, arrayValue);
      case 35687:
        return gl2.uniformMatrix3x2fv(location, false, arrayValue);
      case 35688:
        return gl2.uniformMatrix3x4fv(location, false, arrayValue);
      case 35689:
        return gl2.uniformMatrix4x2fv(location, false, arrayValue);
      case 35690:
        return gl2.uniformMatrix4x3fv(location, false, arrayValue);
    }
    throw new Error("Illegal uniform");
  }
  var init_set_uniform = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/helpers/set-uniform.js"() {
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-topology-utils.js
  function getGLDrawMode(topology) {
    switch (topology) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 3;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 5;
      default:
        throw new Error(topology);
    }
  }
  function getGLPrimitive(topology) {
    switch (topology) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 1;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 4;
      default:
        throw new Error(topology);
    }
  }
  var init_webgl_topology_utils = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-topology-utils.js"() {
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pipeline.js
  function mergeShaderLayout(baseLayout, overrideLayout) {
    const mergedLayout = {
      ...baseLayout,
      attributes: baseLayout.attributes.map((attribute) => ({ ...attribute }))
    };
    for (const attribute of overrideLayout?.attributes || []) {
      const baseAttribute = mergedLayout.attributes.find((attr) => attr.name === attribute.name);
      if (!baseAttribute) {
        import_core16.log.warn(`shader layout attribute ${attribute.name} not present in shader`);
      } else {
        baseAttribute.type = attribute.type || baseAttribute.type;
        baseAttribute.stepMode = attribute.stepMode || baseAttribute.stepMode;
      }
    }
    return mergedLayout;
  }
  var import_core16, LOG_PROGRAM_PERF_PRIORITY, WEBGLRenderPipeline;
  var init_webgl_render_pipeline = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pipeline.js"() {
      import_core16 = __toESM(require_core2(), 1);
      init_get_shader_layout_from_glsl();
      init_device_parameters();
      init_set_uniform();
      init_webgl_buffer();
      init_webgl_framebuffer();
      init_webgl_texture();
      init_webgl_texture_view();
      init_webgl_topology_utils();
      LOG_PROGRAM_PERF_PRIORITY = 4;
      WEBGLRenderPipeline = class extends import_core16.RenderPipeline {
        /** The WebGL device that created this render pipeline */
        device;
        /** Handle to underlying WebGL program */
        handle;
        /** vertex shader */
        vs;
        /** fragment shader */
        fs;
        /** The layout extracted from shader by WebGL introspection APIs */
        introspectedLayout;
        /** Uniforms set on this model */
        uniforms = {};
        /** Bindings set on this model */
        bindings = {};
        /** WebGL varyings */
        varyings = null;
        _uniformCount = 0;
        _uniformSetters = {};
        // TODO are these used?
        get [Symbol.toStringTag]() {
          return "WEBGLRenderPipeline";
        }
        constructor(device, props) {
          super(device, props);
          this.device = device;
          this.handle = this.props.handle || this.device.gl.createProgram();
          this.device._setWebGLDebugMetadata(this.handle, this, { spector: { id: this.props.id } });
          this.vs = props.vs;
          this.fs = props.fs;
          const { varyings, bufferMode = 35981 } = props;
          if (varyings && varyings.length > 0) {
            this.varyings = varyings;
            this.device.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
          }
          this._linkShaders();
          import_core16.log.time(3, `RenderPipeline ${this.id} - shaderLayout introspection`)();
          this.introspectedLayout = getShaderLayoutFromGLSL(this.device.gl, this.handle);
          import_core16.log.timeEnd(3, `RenderPipeline ${this.id} - shaderLayout introspection`)();
          this.shaderLayout = props.shaderLayout ? mergeShaderLayout(this.introspectedLayout, props.shaderLayout) : this.introspectedLayout;
        }
        destroy() {
          if (this.handle) {
            this.device.gl.useProgram(null);
            this.device.gl.deleteProgram(this.handle);
            this.destroyed = true;
            this.handle.destroyed = true;
            this.handle = null;
          }
        }
        /**
         * Bindings include: textures, samplers and uniform buffers
         * @todo needed for portable model
         */
        setBindings(bindings, options) {
          for (const [name, value] of Object.entries(bindings)) {
            const binding = this.shaderLayout.bindings.find((binding_) => binding_.name === name) || this.shaderLayout.bindings.find((binding_) => binding_.name === `${name}Uniforms`);
            if (!binding) {
              const validBindings = this.shaderLayout.bindings.map((binding_) => `"${binding_.name}"`).join(", ");
              if (!options?.disableWarnings) {
                import_core16.log.warn(`No binding "${name}" in render pipeline "${this.id}", expected one of ${validBindings}`, value)();
              }
              continue;
            }
            if (!value) {
              import_core16.log.warn(`Unsetting binding "${name}" in render pipeline "${this.id}"`)();
            }
            switch (binding.type) {
              case "uniform":
                if (!(value instanceof WEBGLBuffer) && !(value.buffer instanceof WEBGLBuffer)) {
                  throw new Error("buffer value");
                }
                break;
              case "texture":
                if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
                  throw new Error(`${this} Bad texture binding for ${name}`);
                }
                break;
              case "sampler":
                import_core16.log.warn(`Ignoring sampler ${name}`)();
                break;
              default:
                throw new Error(binding.type);
            }
            this.bindings[name] = value;
          }
        }
        /** @todo needed for portable model
         * @note The WebGL API is offers many ways to draw things
         * This function unifies those ways into a single call using common parameters with sane defaults
         */
        draw(options) {
          const {
            renderPass,
            parameters = this.props.parameters,
            topology = this.props.topology,
            vertexArray,
            vertexCount,
            // indexCount,
            instanceCount,
            isInstanced = false,
            firstVertex = 0,
            // firstIndex,
            // firstInstance,
            // baseVertex,
            transformFeedback
          } = options;
          const glDrawMode = getGLDrawMode(topology);
          const isIndexed = Boolean(vertexArray.indexBuffer);
          const glIndexType = vertexArray.indexBuffer?.glIndexType;
          if (this.linkStatus !== "success") {
            import_core16.log.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)();
            return false;
          }
          if (!this._areTexturesRenderable()) {
            import_core16.log.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)();
            return false;
          }
          this.device.gl.useProgram(this.handle);
          vertexArray.bindBeforeRender(renderPass);
          if (transformFeedback) {
            transformFeedback.begin(this.props.topology);
          }
          this._applyBindings();
          this._applyUniforms();
          const webglRenderPass = renderPass;
          withDeviceAndGLParameters(this.device, parameters, webglRenderPass.glParameters, () => {
            if (isIndexed && isInstanced) {
              this.device.gl.drawElementsInstanced(
                glDrawMode,
                vertexCount || 0,
                // indexCount?
                glIndexType,
                firstVertex,
                instanceCount || 0
              );
            } else if (isIndexed) {
              this.device.gl.drawElements(glDrawMode, vertexCount || 0, glIndexType, firstVertex);
            } else if (isInstanced) {
              this.device.gl.drawArraysInstanced(glDrawMode, firstVertex, vertexCount || 0, instanceCount || 0);
            } else {
              this.device.gl.drawArrays(glDrawMode, firstVertex, vertexCount || 0);
            }
            if (transformFeedback) {
              transformFeedback.end();
            }
          });
          vertexArray.unbindAfterRender(renderPass);
          return true;
        }
        // PRIVATE METHODS
        // setAttributes(attributes: Record<string, Buffer>): void {}
        // setBindings(bindings: Record<string, Binding>): void {}
        async _linkShaders() {
          const { gl } = this.device;
          gl.attachShader(this.handle, this.vs.handle);
          gl.attachShader(this.handle, this.fs.handle);
          import_core16.log.time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
          gl.linkProgram(this.handle);
          import_core16.log.timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this.id}`)();
          if (import_core16.log.level === 0) {
          }
          if (!this.device.features.has("compilation-status-async-webgl")) {
            const status2 = this._getLinkStatus();
            this._reportLinkStatus(status2);
            return;
          }
          import_core16.log.once(1, "RenderPipeline linking is asynchronous")();
          await this._waitForLinkComplete();
          import_core16.log.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
          const status = this._getLinkStatus();
          this._reportLinkStatus(status);
        }
        /** Report link status. First, check for shader compilation failures if linking fails */
        async _reportLinkStatus(status) {
          switch (status) {
            case "success":
              return;
            default:
              const errorType = status === "link-error" ? "Link error" : "Validation error";
              switch (this.vs.compilationStatus) {
                case "error":
                  this.vs.debugShader();
                  throw new Error(`${this} ${errorType} during compilation of ${this.vs}`);
                case "pending":
                  await this.vs.asyncCompilationStatus;
                  this.vs.debugShader();
                  break;
                case "success":
                  break;
              }
              switch (this.fs?.compilationStatus) {
                case "error":
                  this.fs.debugShader();
                  throw new Error(`${this} ${errorType} during compilation of ${this.fs}`);
                case "pending":
                  await this.fs.asyncCompilationStatus;
                  this.fs.debugShader();
                  break;
                case "success":
                  break;
              }
              const linkErrorLog = this.device.gl.getProgramInfoLog(this.handle);
              this.device.reportError(new Error(`${errorType} during ${status}: ${linkErrorLog}`), this)();
              this.device.debug();
          }
        }
        /**
         * Get the shader compilation status
         * TODO - Load log even when no error reported, to catch warnings?
         * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
         */
        _getLinkStatus() {
          const { gl } = this.device;
          const linked = gl.getProgramParameter(this.handle, 35714);
          if (!linked) {
            this.linkStatus = "error";
            return "link-error";
          }
          gl.validateProgram(this.handle);
          const validated = gl.getProgramParameter(this.handle, 35715);
          if (!validated) {
            this.linkStatus = "error";
            return "validation-error";
          }
          this.linkStatus = "success";
          return "success";
        }
        /** Use KHR_parallel_shader_compile extension if available */
        async _waitForLinkComplete() {
          const waitMs = async (ms) => await new Promise((resolve) => setTimeout(resolve, ms));
          const DELAY_MS = 10;
          if (!this.device.features.has("compilation-status-async-webgl")) {
            await waitMs(DELAY_MS);
            return;
          }
          const { gl } = this.device;
          for (; ; ) {
            const complete = gl.getProgramParameter(this.handle, 37297);
            if (complete) {
              return;
            }
            await waitMs(DELAY_MS);
          }
        }
        /**
         * Checks if all texture-values uniforms are renderable (i.e. loaded)
         * Update a texture if needed (e.g. from video)
         * Note: This is currently done before every draw call
         */
        _areTexturesRenderable() {
          let texturesRenderable = true;
          for (const bindingInfo of this.shaderLayout.bindings) {
            if (!this.bindings[bindingInfo.name] && !this.bindings[bindingInfo.name.replace(/Uniforms$/, "")]) {
              import_core16.log.warn(`Binding ${bindingInfo.name} not found in ${this.id}`)();
              texturesRenderable = false;
            }
          }
          return texturesRenderable;
        }
        /** Apply any bindings (before each draw call) */
        _applyBindings() {
          if (this.linkStatus !== "success") {
            return;
          }
          const { gl } = this.device;
          gl.useProgram(this.handle);
          let textureUnit = 0;
          let uniformBufferIndex = 0;
          for (const binding of this.shaderLayout.bindings) {
            const value = this.bindings[binding.name] || this.bindings[binding.name.replace(/Uniforms$/, "")];
            if (!value) {
              throw new Error(`No value for binding ${binding.name} in ${this.id}`);
            }
            switch (binding.type) {
              case "uniform":
                const { name } = binding;
                const location = gl.getUniformBlockIndex(this.handle, name);
                if (location === 4294967295) {
                  throw new Error(`Invalid uniform block name ${name}`);
                }
                gl.uniformBlockBinding(this.handle, uniformBufferIndex, location);
                if (value instanceof WEBGLBuffer) {
                  gl.bindBufferBase(35345, uniformBufferIndex, value.handle);
                } else {
                  gl.bindBufferRange(
                    35345,
                    uniformBufferIndex,
                    // @ts-expect-error
                    value.buffer.handle,
                    // @ts-expect-error
                    value.offset || 0,
                    // @ts-expect-error
                    value.size || value.buffer.byteLength - value.offset
                  );
                }
                uniformBufferIndex += 1;
                break;
              case "texture":
                if (!(value instanceof WEBGLTextureView || value instanceof WEBGLTexture || value instanceof WEBGLFramebuffer)) {
                  throw new Error("texture");
                }
                let texture;
                if (value instanceof WEBGLTextureView) {
                  texture = value.texture;
                } else if (value instanceof WEBGLTexture) {
                  texture = value;
                } else if (value instanceof WEBGLFramebuffer && value.colorAttachments[0] instanceof WEBGLTextureView) {
                  import_core16.log.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")();
                  texture = value.colorAttachments[0].texture;
                } else {
                  throw new Error("No texture");
                }
                gl.activeTexture(33984 + textureUnit);
                gl.bindTexture(texture.glTarget, texture.handle);
                textureUnit += 1;
                break;
              case "sampler":
                break;
              case "storage":
              case "read-only-storage":
                throw new Error(`binding type '${binding.type}' not supported in WebGL`);
            }
          }
        }
        /**
         * Due to program sharing, uniforms need to be reset before every draw call
         * (though caching will avoid redundant WebGL calls)
         */
        _applyUniforms() {
          for (const uniformLayout of this.shaderLayout.uniforms || []) {
            const { name, location, type, textureUnit } = uniformLayout;
            const value = this.uniforms[name] ?? textureUnit;
            if (value !== void 0) {
              setUniform(this.device.gl, location, type, value);
            }
          }
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-buffer.js
  function _copyBufferToBuffer(device, options) {
    const source = options.sourceBuffer;
    const destination = options.destinationBuffer;
    device.gl.bindBuffer(36662, source.handle);
    device.gl.bindBuffer(36663, destination.handle);
    device.gl.copyBufferSubData(36662, 36663, options.sourceOffset ?? 0, options.destinationOffset ?? 0, options.size);
    device.gl.bindBuffer(36662, null);
    device.gl.bindBuffer(36663, null);
  }
  function _copyBufferToTexture(device, options) {
    throw new Error("Not implemented");
  }
  function _copyTextureToBuffer(device, options) {
    const {
      /** Texture to copy to/from. */
      sourceTexture,
      /**  Mip-map level of the texture to copy to/from. (Default 0) */
      mipLevel = 0,
      /** Defines which aspects of the texture to copy to/from. */
      aspect = "all",
      /** Width to copy */
      width = options.sourceTexture.width,
      /** Height to copy */
      height = options.sourceTexture.height,
      depthOrArrayLayers = 0,
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
      origin = [0, 0],
      /** Destination buffer */
      destinationBuffer,
      /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
      byteOffset = 0,
      /**
       * The stride, in bytes, between the beginning of each block row and the subsequent block row.
       * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
       */
      bytesPerRow,
      /**
       * Number of block rows per single image of the texture.
       * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
       * Required if there are multiple images (i.e. the copy depth is more than one).
       */
      rowsPerImage
    } = options;
    if (aspect !== "all") {
      throw new Error("aspect not supported in WebGL");
    }
    if (mipLevel !== 0 || depthOrArrayLayers !== 0 || bytesPerRow || rowsPerImage) {
      throw new Error("not implemented");
    }
    const { framebuffer, destroyFramebuffer } = getFramebuffer(sourceTexture);
    let prevHandle;
    try {
      const webglBuffer = destinationBuffer;
      const sourceWidth = width || framebuffer.width;
      const sourceHeight = height || framebuffer.height;
      const sourceParams = getTextureFormatWebGL(framebuffer.colorAttachments[0].texture.props.format);
      const sourceFormat = sourceParams.format;
      const sourceType = sourceParams.type;
      device.gl.bindBuffer(35051, webglBuffer.handle);
      prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
      device.gl.readPixels(origin[0], origin[1], sourceWidth, sourceHeight, sourceFormat, sourceType, byteOffset);
    } finally {
      device.gl.bindBuffer(35051, null);
      if (prevHandle !== void 0) {
        device.gl.bindFramebuffer(36160, prevHandle);
      }
      if (destroyFramebuffer) {
        framebuffer.destroy();
      }
    }
  }
  function _copyTextureToTexture(device, options) {
    const {
      /** Texture to copy to/from. */
      sourceTexture,
      /**  Mip-map level of the texture to copy to (Default 0) */
      destinationMipLevel = 0,
      /** Defines which aspects of the texture to copy to/from. */
      // aspect = 'all',
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
      origin = [0, 0],
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
      destinationOrigin = [0, 0],
      /** Texture to copy to/from. */
      destinationTexture
      /**  Mip-map level of the texture to copy to/from. (Default 0) */
      // destinationMipLevel = options.mipLevel,
      /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
      // destinationOrigin = [0, 0],
      /** Defines which aspects of the texture to copy to/from. */
      // destinationAspect = options.aspect,
    } = options;
    let {
      width = options.destinationTexture.width,
      height = options.destinationTexture.height
      // depthOrArrayLayers = 0
    } = options;
    const { framebuffer, destroyFramebuffer } = getFramebuffer(sourceTexture);
    const [sourceX, sourceY] = origin;
    const [destinationX, destinationY, destinationZ] = destinationOrigin;
    const prevHandle = device.gl.bindFramebuffer(36160, framebuffer.handle);
    let texture;
    let textureTarget;
    if (destinationTexture instanceof WEBGLTexture) {
      texture = destinationTexture;
      width = Number.isFinite(width) ? width : texture.width;
      height = Number.isFinite(height) ? height : texture.height;
      texture._bind(0);
      textureTarget = texture.glTarget;
    } else {
      throw new Error("invalid destination");
    }
    switch (textureTarget) {
      case 3553:
      case 34067:
        device.gl.copyTexSubImage2D(textureTarget, destinationMipLevel, destinationX, destinationY, sourceX, sourceY, width, height);
        break;
      case 35866:
      case 32879:
        device.gl.copyTexSubImage3D(textureTarget, destinationMipLevel, destinationX, destinationY, destinationZ, sourceX, sourceY, width, height);
        break;
      default:
    }
    if (texture) {
      texture._unbind();
    }
    device.gl.bindFramebuffer(36160, prevHandle);
    if (destroyFramebuffer) {
      framebuffer.destroy();
    }
  }
  function getFramebuffer(source) {
    if (source instanceof import_core17.Texture) {
      const { width, height, id } = source;
      const framebuffer = source.device.createFramebuffer({
        id: `framebuffer-for-${id}`,
        width,
        height,
        colorAttachments: [source]
      });
      return { framebuffer, destroyFramebuffer: true };
    }
    return { framebuffer: source, destroyFramebuffer: false };
  }
  var import_core17, WEBGLCommandBuffer;
  var init_webgl_command_buffer = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-buffer.js"() {
      import_core17 = __toESM(require_core2(), 1);
      init_webgl_texture();
      init_webgl_texture_table();
      WEBGLCommandBuffer = class extends import_core17.CommandBuffer {
        device;
        handle = null;
        commands = [];
        constructor(device) {
          super(device, {});
          this.device = device;
        }
        _executeCommands(commands = this.commands) {
          for (const command of commands) {
            switch (command.name) {
              case "copy-buffer-to-buffer":
                _copyBufferToBuffer(this.device, command.options);
                break;
              case "copy-buffer-to-texture":
                _copyBufferToTexture(this.device, command.options);
                break;
              case "copy-texture-to-buffer":
                _copyTextureToBuffer(this.device, command.options);
                break;
              case "copy-texture-to-texture":
                _copyTextureToTexture(this.device, command.options);
                break;
              default:
                throw new Error(command.name);
            }
          }
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pass.js
  var import_core18, COLOR_CHANNELS, WEBGLRenderPass;
  var init_webgl_render_pass = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-render-pass.js"() {
      import_core18 = __toESM(require_core2(), 1);
      init_with_parameters();
      init_unified_parameter_api();
      COLOR_CHANNELS = [1, 2, 4, 8];
      WEBGLRenderPass = class extends import_core18.RenderPass {
        device;
        handle = null;
        /** Parameters that should be applied before each draw call */
        glParameters = {};
        constructor(device, props) {
          super(device, props);
          this.device = device;
          let viewport;
          if (!props?.parameters?.viewport) {
            if (props?.framebuffer) {
              const { width, height } = props.framebuffer;
              viewport = [0, 0, width, height];
            } else {
              const [width, height] = device.getDefaultCanvasContext().getDrawingBufferSize();
              viewport = [0, 0, width, height];
            }
          }
          this.device.pushState();
          this.setParameters({ viewport, ...this.props.parameters });
          const webglFramebuffer = this.props.framebuffer;
          if (this.props.framebuffer && webglFramebuffer?.handle) {
            const drawBuffers = this.props.framebuffer.colorAttachments.map((_, i) => 36064 + i);
            this.device.gl.drawBuffers(drawBuffers);
          } else {
            this.device.gl.drawBuffers([1029]);
          }
          this.clear();
        }
        end() {
          this.device.popState();
        }
        pushDebugGroup(groupLabel) {
        }
        popDebugGroup() {
        }
        insertDebugMarker(markerLabel) {
        }
        // beginOcclusionQuery(queryIndex: number): void;
        // endOcclusionQuery(): void;
        // executeBundles(bundles: Iterable<GPURenderBundle>): void;
        /**
         * Maps RenderPass parameters to GL parameters
         */
        setParameters(parameters = {}) {
          const glParameters = { ...this.glParameters };
          glParameters.framebuffer = this.props.framebuffer || null;
          if (this.props.depthReadOnly) {
            glParameters.depthMask = !this.props.depthReadOnly;
          }
          glParameters.stencilMask = this.props.stencilReadOnly ? 0 : 1;
          glParameters[35977] = this.props.discard;
          if (parameters.viewport) {
            if (parameters.viewport.length >= 6) {
              glParameters.viewport = parameters.viewport.slice(0, 4);
              glParameters.depthRange = [
                parameters.viewport[4],
                parameters.viewport[5]
              ];
            } else {
              glParameters.viewport = parameters.viewport;
            }
          }
          if (parameters.scissorRect) {
            glParameters.scissorTest = true;
            glParameters.scissor = parameters.scissorRect;
          }
          if (parameters.blendConstant) {
            glParameters.blendColor = parameters.blendConstant;
          }
          if (parameters.stencilReference) {
            console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL");
            glParameters[2967] = parameters.stencilReference;
          }
          if ("colorMask" in parameters) {
            glParameters.colorMask = COLOR_CHANNELS.map((channel) => Boolean(channel & parameters.colorMask));
          }
          this.glParameters = glParameters;
          setGLParameters(this.device.gl, glParameters);
        }
        beginOcclusionQuery(queryIndex) {
          const webglQuerySet = this.props.occlusionQuerySet;
          webglQuerySet?.beginOcclusionQuery();
        }
        endOcclusionQuery() {
          const webglQuerySet = this.props.occlusionQuerySet;
          webglQuerySet?.endOcclusionQuery();
        }
        // PRIVATE
        /**
         * Optionally clears depth, color and stencil buffers based on parameters
         */
        clear() {
          const glParameters = { ...this.glParameters };
          let clearMask = 0;
          if (this.props.clearColors) {
            this.props.clearColors.forEach((color, drawBufferIndex) => {
              if (color) {
                this.clearColorBuffer(drawBufferIndex, color);
              }
            });
          }
          if (this.props.clearColor !== false && this.props.clearColors === void 0) {
            clearMask |= 16384;
            glParameters.clearColor = this.props.clearColor;
          }
          if (this.props.clearDepth !== false) {
            clearMask |= 256;
            glParameters.clearDepth = this.props.clearDepth;
          }
          if (this.props.clearStencil !== false) {
            clearMask |= 1024;
            glParameters.clearStencil = this.props.clearStencil;
          }
          if (clearMask !== 0) {
            withGLParameters(this.device.gl, glParameters, () => {
              this.device.gl.clear(clearMask);
            });
          }
        }
        /**
         * WebGL2 - clear a specific color buffer
         */
        clearColorBuffer(drawBuffer = 0, value = [0, 0, 0, 0]) {
          withGLParameters(this.device.gl, { framebuffer: this.props.framebuffer }, () => {
            switch (value.constructor) {
              case Int8Array:
              case Int16Array:
              case Int32Array:
                this.device.gl.clearBufferiv(6144, drawBuffer, value);
                break;
              case Uint8Array:
              case Uint8ClampedArray:
              case Uint16Array:
              case Uint32Array:
                this.device.gl.clearBufferuiv(6144, drawBuffer, value);
                break;
              case Float32Array:
                this.device.gl.clearBufferfv(6144, drawBuffer, value);
                break;
              default:
                throw new Error("clearColorBuffer: color must be typed array");
            }
          });
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-encoder.js
  var import_core19, WEBGLCommandEncoder;
  var init_webgl_command_encoder = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-command-encoder.js"() {
      import_core19 = __toESM(require_core2(), 1);
      init_webgl_command_buffer();
      init_webgl_render_pass();
      WEBGLCommandEncoder = class extends import_core19.CommandEncoder {
        device;
        handle = null;
        commandBuffer;
        constructor(device, props) {
          super(device, props);
          this.device = device;
          this.commandBuffer = new WEBGLCommandBuffer(device);
        }
        destroy() {
        }
        finish() {
          return this.commandBuffer;
        }
        beginRenderPass(props) {
          return new WEBGLRenderPass(this.device, props);
        }
        beginComputePass(props) {
          throw new Error("ComputePass not supported in WebGL");
        }
        copyBufferToBuffer(options) {
          this.commandBuffer.commands.push({ name: "copy-buffer-to-buffer", options });
        }
        copyBufferToTexture(options) {
          this.commandBuffer.commands.push({ name: "copy-buffer-to-texture", options });
        }
        copyTextureToBuffer(options) {
          this.commandBuffer.commands.push({ name: "copy-texture-to-buffer", options });
        }
        copyTextureToTexture(options) {
          this.commandBuffer.commands.push({ name: "copy-texture-to-texture", options });
        }
        // clearTexture(options: ClearTextureOptions): void {
        //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
        // }
        pushDebugGroup(groupLabel) {
        }
        popDebugGroup() {
        }
        insertDebugMarker(markerLabel) {
        }
        resolveQuerySet(querySet, destination, options) {
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/utils/fill-array.js
  function fillArray(options) {
    const { target: target2, source, start = 0, count = 1 } = options;
    const length = source.length;
    const total = count * length;
    let copied = 0;
    for (let i = start; copied < length; copied++) {
      target2[i++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target2.copyWithin(start + copied, start, start + copied);
        copied *= 2;
      } else {
        target2.copyWithin(start + copied, start, start + total - copied);
        copied = total;
      }
    }
    return options.target;
  }
  var init_fill_array = __esm({
    "../../node_modules/@luma.gl/webgl/dist/utils/fill-array.js"() {
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-vertex-array.js
  function normalizeConstantArrayValue(arrayValue) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }
    return arrayValue;
  }
  function compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }
  var import_core20, WEBGLVertexArray;
  var init_webgl_vertex_array = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-vertex-array.js"() {
      import_core20 = __toESM(require_core2(), 1);
      init_dist2();
      init_webgl_vertex_formats();
      init_fill_array();
      WEBGLVertexArray = class extends import_core20.VertexArray {
        get [Symbol.toStringTag]() {
          return "VertexArray";
        }
        device;
        handle;
        /** Attribute 0 buffer constant */
        buffer = null;
        bufferValue = null;
        /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
        static isConstantAttributeZeroSupported(device) {
          return getBrowser() === "Chrome";
        }
        // Create a VertexArray
        constructor(device, props) {
          super(device, props);
          this.device = device;
          this.handle = this.device.gl.createVertexArray();
        }
        destroy() {
          super.destroy();
          if (this.buffer) {
            this.buffer?.destroy();
          }
          if (this.handle) {
            this.device.gl.deleteVertexArray(this.handle);
            this.handle = void 0;
          }
        }
        /**
        // Set (bind/unbind) an elements buffer, for indexed rendering.
        // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
         *
         * @param elementBuffer
         */
        setIndexBuffer(indexBuffer) {
          const buffer = indexBuffer;
          if (buffer && buffer.glTarget !== 34963) {
            throw new Error("Use .setBuffer()");
          }
          this.device.gl.bindVertexArray(this.handle);
          this.device.gl.bindBuffer(34963, buffer ? buffer.handle : null);
          this.indexBuffer = buffer;
          this.device.gl.bindVertexArray(null);
        }
        /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
        setBuffer(location, attributeBuffer) {
          const buffer = attributeBuffer;
          if (buffer.glTarget === 34963) {
            throw new Error("Use .setIndexBuffer()");
          }
          const { size, type, stride, offset, normalized, integer, divisor } = this._getAccessor(location);
          this.device.gl.bindVertexArray(this.handle);
          this.device.gl.bindBuffer(34962, buffer.handle);
          if (integer) {
            this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
          } else {
            this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
          }
          this.device.gl.bindBuffer(34962, null);
          this.device.gl.enableVertexAttribArray(location);
          this.device.gl.vertexAttribDivisor(location, divisor || 0);
          this.attributes[location] = buffer;
          this.device.gl.bindVertexArray(null);
        }
        /** Set a location in vertex attributes array to a constant value, disables the location */
        setConstantWebGL(location, value) {
          this._enable(location, false);
          this.attributes[location] = value;
        }
        bindBeforeRender() {
          this.device.gl.bindVertexArray(this.handle);
          this._applyConstantAttributes();
        }
        unbindAfterRender() {
          this.device.gl.bindVertexArray(null);
        }
        // Internal methods
        /**
         * Constant attributes need to be reset before every draw call
         * Any attribute that is disabled in the current vertex array object
         * is read from the context's global constant value for that attribute location.
         * @note Constant attributes are only supported in WebGL, not in WebGPU
         */
        _applyConstantAttributes() {
          for (let location = 0; location < this.maxVertexAttributes; ++location) {
            const constant = this.attributes[location];
            if (ArrayBuffer.isView(constant)) {
              this.device.setConstantAttributeWebGL(location, constant);
            }
          }
        }
        /**
         * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
         * @note requires vertex array to be bound
         */
        // protected _setAttributeLayout(location: number): void {
        //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
        //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
        //   if (integer) {
        //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
        //   } else {
        //     // Attaches ARRAY_BUFFER with specified buffer format to location
        //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
        //   }
        //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
        // }
        /** Get an accessor from the  */
        _getAccessor(location) {
          const attributeInfo = this.attributeInfos[location];
          if (!attributeInfo) {
            throw new Error(`Unknown attribute location ${location}`);
          }
          const glType = getGLFromVertexType(attributeInfo.bufferDataType);
          return {
            size: attributeInfo.bufferComponents,
            type: glType,
            stride: attributeInfo.byteStride,
            offset: attributeInfo.byteOffset,
            normalized: attributeInfo.normalized,
            // it is the shader attribute declaration, not the vertex memory format,
            // that determines if the data in the buffer will be treated as integers.
            //
            // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
            // but as far as we can tell, WebGPU does not.
            integer: attributeInfo.integer,
            divisor: attributeInfo.stepMode === "instance" ? 1 : 0
          };
        }
        /**
         * Enabling an attribute location makes it reference the currently bound buffer
         * Disabling an attribute location makes it reference the global constant value
         * TODO - handle single values for size 1 attributes?
         * TODO - convert classic arrays based on known type?
         */
        _enable(location, enable2 = true) {
          const canDisableAttributeZero = WEBGLVertexArray.isConstantAttributeZeroSupported(this.device);
          const canDisableAttribute = canDisableAttributeZero || location !== 0;
          if (enable2 || canDisableAttribute) {
            location = Number(location);
            this.device.gl.bindVertexArray(this.handle);
            if (enable2) {
              this.device.gl.enableVertexAttribArray(location);
            } else {
              this.device.gl.disableVertexAttribArray(location);
            }
            this.device.gl.bindVertexArray(null);
          }
        }
        /**
         * Provide a means to create a buffer that is equivalent to a constant.
         * NOTE: Desktop OpenGL cannot disable attribute 0.
         * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
         * this-has-significant-performance-penalty
         */
        getConstantBuffer(elementCount, value) {
          const constantValue = normalizeConstantArrayValue(value);
          const byteLength = constantValue.byteLength * elementCount;
          const length = constantValue.length * elementCount;
          if (this.buffer && byteLength !== this.buffer.byteLength) {
            throw new Error(`Buffer size is immutable, byte length ${byteLength} !== ${this.buffer.byteLength}.`);
          }
          let updateNeeded = !this.buffer;
          this.buffer = this.buffer || this.device.createBuffer({ byteLength });
          updateNeeded ||= !compareConstantArrayValues(constantValue, this.bufferValue);
          if (updateNeeded) {
            const typedArray = (0, import_core20.getScratchArray)(value.constructor, length);
            fillArray({ target: typedArray, source: constantValue, start: 0, count: length });
            this.buffer.write(typedArray);
            this.bufferValue = value;
          }
          return this.buffer;
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-transform-feedback.js
  function isIndex(value) {
    if (typeof value === "number") {
      return Number.isInteger(value);
    }
    return /^\d+$/.test(value);
  }
  var import_core21, WEBGLTransformFeedback;
  var init_webgl_transform_feedback = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-transform-feedback.js"() {
      import_core21 = __toESM(require_core2(), 1);
      init_dist3();
      init_webgl_topology_utils();
      WEBGLTransformFeedback = class extends import_core21.TransformFeedback {
        device;
        gl;
        handle;
        /**
         * NOTE: The Model already has this information while drawing, but
         * TransformFeedback currently needs it internally, to look up
         * varying information outside of a draw() call.
         */
        layout;
        buffers = {};
        unusedBuffers = {};
        /**
         * Allows us to avoid a Chrome bug where a buffer that is already bound to a
         * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
         * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
         */
        bindOnUse = true;
        _bound = false;
        constructor(device, props) {
          super(device, props);
          this.device = device;
          this.gl = device.gl;
          this.handle = this.props.handle || this.gl.createTransformFeedback();
          this.layout = this.props.layout;
          if (props.buffers) {
            this.setBuffers(props.buffers);
          }
          Object.seal(this);
        }
        destroy() {
          this.gl.deleteTransformFeedback(this.handle);
          super.destroy();
        }
        begin(topology = "point-list") {
          this.gl.bindTransformFeedback(36386, this.handle);
          if (this.bindOnUse) {
            this._bindBuffers();
          }
          this.gl.beginTransformFeedback(getGLPrimitive(topology));
        }
        end() {
          this.gl.endTransformFeedback();
          if (this.bindOnUse) {
            this._unbindBuffers();
          }
          this.gl.bindTransformFeedback(36386, null);
        }
        // SUBCLASS
        setBuffers(buffers) {
          this.buffers = {};
          this.unusedBuffers = {};
          this.bind(() => {
            for (const bufferName in buffers) {
              this.setBuffer(bufferName, buffers[bufferName]);
            }
          });
        }
        setBuffer(locationOrName, bufferOrRange) {
          const location = this._getVaryingIndex(locationOrName);
          const { buffer, byteLength, byteOffset } = this._getBufferRange(bufferOrRange);
          if (location < 0) {
            this.unusedBuffers[locationOrName] = buffer;
            import_core21.log.warn(`${this.id} unusedBuffers varying buffer ${locationOrName}`)();
            return;
          }
          this.buffers[location] = { buffer, byteLength, byteOffset };
          if (!this.bindOnUse) {
            this._bindBuffer(location, buffer, byteOffset, byteLength);
          }
        }
        getBuffer(locationOrName) {
          if (isIndex(locationOrName)) {
            return this.buffers[locationOrName] || null;
          }
          const location = this._getVaryingIndex(locationOrName);
          return location >= 0 ? this.buffers[location] : null;
        }
        bind(funcOrHandle = this.handle) {
          if (typeof funcOrHandle !== "function") {
            this.gl.bindTransformFeedback(36386, funcOrHandle);
            return this;
          }
          let value;
          if (!this._bound) {
            this.gl.bindTransformFeedback(36386, this.handle);
            this._bound = true;
            value = funcOrHandle();
            this._bound = false;
            this.gl.bindTransformFeedback(36386, null);
          } else {
            value = funcOrHandle();
          }
          return value;
        }
        unbind() {
          this.bind(null);
        }
        // PRIVATE METHODS
        /** Extract offsets for bindBufferRange */
        _getBufferRange(bufferOrRange) {
          if (bufferOrRange instanceof WEBGLBuffer) {
            return { buffer: bufferOrRange, byteOffset: 0, byteLength: bufferOrRange.byteLength };
          }
          const { buffer, byteOffset = 0, byteLength = bufferOrRange.buffer.byteLength } = bufferOrRange;
          return { buffer, byteOffset, byteLength };
        }
        _getVaryingIndex(locationOrName) {
          if (isIndex(locationOrName)) {
            return Number(locationOrName);
          }
          for (const varying of this.layout.varyings || []) {
            if (locationOrName === varying.name) {
              return varying.location;
            }
          }
          return -1;
        }
        /**
         * Need to avoid chrome bug where buffer that is already bound to a different target
         * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
         */
        _bindBuffers() {
          for (const bufferIndex in this.buffers) {
            const { buffer, byteLength, byteOffset } = this._getBufferRange(this.buffers[bufferIndex]);
            this._bindBuffer(Number(bufferIndex), buffer, byteOffset, byteLength);
          }
        }
        _unbindBuffers() {
          for (const bufferIndex in this.buffers) {
            this.gl.bindBufferBase(35982, Number(bufferIndex), null);
          }
        }
        _bindBuffer(index, buffer, byteOffset = 0, byteLength) {
          const handle = buffer && buffer.handle;
          if (!handle || byteLength === void 0) {
            this.gl.bindBufferBase(35982, index, handle);
          } else {
            this.gl.bindBufferRange(35982, index, handle, byteOffset, byteLength);
          }
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-query-set.js
  var import_core22, WEBGLQuerySet;
  var init_webgl_query_set = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-query-set.js"() {
      import_core22 = __toESM(require_core2(), 1);
      WEBGLQuerySet = class extends import_core22.QuerySet {
        device;
        handle;
        target = null;
        _queryPending = false;
        _pollingPromise = null;
        get [Symbol.toStringTag]() {
          return "Query";
        }
        // Create a query class
        constructor(device, props) {
          super(device, props);
          this.device = device;
          if (props.count > 1) {
            throw new Error("WebGL QuerySet can only have one value");
          }
          const handle = this.device.gl.createQuery();
          if (!handle) {
            throw new Error("WebGL query not supported");
          }
          this.handle = handle;
          Object.seal(this);
        }
        destroy() {
          this.device.gl.deleteQuery(this.handle);
        }
        // FOR RENDER PASS AND COMMAND ENCODER
        /**
         * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
         * Measures GPU time delta between this call and a matching `end` call in the
         * GPU instruction stream.
         */
        beginTimestampQuery() {
          return this._begin(35007);
        }
        endTimestampQuery() {
          this._end();
        }
        // Shortcut for occlusion queries
        beginOcclusionQuery(options) {
          return this._begin(options?.conservative ? 36202 : 35887);
        }
        endOcclusionQuery() {
          this._end();
        }
        // Shortcut for transformFeedbackQuery
        beginTransformFeedbackQuery() {
          return this._begin(35976);
        }
        endTransformFeedbackQuery() {
          this._end();
        }
        async resolveQuery() {
          const value = await this.pollQuery();
          return [value];
        }
        // PRIVATE METHODS
        /**
         * Due to OpenGL API limitations, after calling `begin()` on one Query
         * instance, `end()` must be called on that same instance before
         * calling `begin()` on another query. While there can be multiple
         * outstanding queries representing disjoint `begin()`/`end()` intervals.
         * It is not possible to interleave or overlap `begin` and `end` calls.
         */
        _begin(target2) {
          if (this._queryPending) {
            return;
          }
          this.target = target2;
          this.device.gl.beginQuery(this.target, this.handle);
          return;
        }
        // ends the current query
        _end() {
          if (this._queryPending) {
            return;
          }
          if (this.target) {
            this.device.gl.endQuery(this.target);
            this.target = null;
            this._queryPending = true;
          }
          return;
        }
        // Returns true if the query result is available
        isResultAvailable() {
          if (!this._queryPending) {
            return false;
          }
          const resultAvailable = this.device.gl.getQueryParameter(this.handle, 34919);
          if (resultAvailable) {
            this._queryPending = false;
          }
          return resultAvailable;
        }
        // Timing query is disjoint, i.e. results are invalid
        isTimerDisjoint() {
          return this.device.gl.getParameter(36795);
        }
        // Returns query result.
        getResult() {
          return this.device.gl.getQueryParameter(this.handle, 34918);
        }
        // Returns the query result, converted to milliseconds to match JavaScript conventions.
        getTimerMilliseconds() {
          return this.getResult() / 1e6;
        }
        // Polls the query
        pollQuery(limit = Number.POSITIVE_INFINITY) {
          if (this._pollingPromise) {
            return this._pollingPromise;
          }
          let counter = 0;
          this._pollingPromise = new Promise((resolve, reject) => {
            const poll = () => {
              if (this.isResultAvailable()) {
                resolve(this.getResult());
                this._pollingPromise = null;
              } else if (counter++ > limit) {
                reject("Timed out");
                this._pollingPromise = null;
              } else {
                requestAnimationFrame(poll);
              }
            };
            requestAnimationFrame(poll);
          });
          return this._pollingPromise;
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/format-utils.js
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
      case 36244:
        return 1;
      case 33339:
      case 33340:
      case 33328:
      case 33320:
      case 33319:
        return 2;
      case 6407:
      case 36248:
      case 34837:
        return 3;
      case 6408:
      case 36249:
      case 34836:
        return 4;
      default:
        return 0;
    }
  }
  function glTypeToBytes(type) {
    switch (type) {
      case 5121:
        return 1;
      case 33635:
      case 32819:
      case 32820:
        return 2;
      case 5126:
        return 4;
      default:
        return 0;
    }
  }
  var init_format_utils = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/helpers/format-utils.js"() {
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/converters/shader-formats.js
  function convertGLDataTypeToDataType(type) {
    return GL_DATA_TYPE_MAP[type];
  }
  var GL_DATA_TYPE_MAP;
  var init_shader_formats = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/converters/shader-formats.js"() {
      GL_DATA_TYPE_MAP = {
        [5124]: "sint32",
        [5125]: "uint32",
        [5122]: "sint16",
        [5123]: "uint16",
        [5120]: "sint8",
        [5121]: "uint8",
        [5126]: "float32",
        [5131]: "float16",
        [33635]: "uint16",
        [32819]: "uint16",
        [32820]: "uint16",
        [33640]: "uint32",
        [35899]: "uint32",
        [35902]: "uint32",
        [34042]: "uint32",
        [36269]: "uint32"
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-texture-utils.js
  function readPixelsToArray(source, options) {
    const {
      sourceX = 0,
      sourceY = 0,
      sourceAttachment = 0
      // TODO - support gl.readBuffer
    } = options || {};
    let {
      target: target2 = null,
      // following parameters are auto deduced if not provided
      sourceWidth,
      sourceHeight,
      sourceDepth,
      sourceFormat,
      sourceType
    } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
    const { gl, handle } = framebuffer;
    sourceWidth ||= framebuffer.width;
    sourceHeight ||= framebuffer.height;
    const texture = framebuffer.colorAttachments[sourceAttachment]?.texture;
    if (!texture) {
      throw new Error(`Invalid framebuffer attachment ${sourceAttachment}`);
    }
    sourceDepth = texture?.depth || 1;
    sourceFormat ||= texture?.glFormat || 6408;
    sourceType ||= texture?.glType || 5121;
    target2 = getPixelArray(target2, sourceType, sourceFormat, sourceWidth, sourceHeight, sourceDepth);
    const signedType = (0, import_core23.getDataType)(target2);
    sourceType = sourceType || convertDataTypeToGLDataType(signedType);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readBuffer(36064 + sourceAttachment);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target2);
    gl.readBuffer(36064);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return target2;
  }
  function readPixelsToBuffer(source, options) {
    const { target: target2, sourceX = 0, sourceY = 0, sourceFormat = 6408, targetByteOffset = 0 } = options || {};
    let { sourceWidth, sourceHeight, sourceType } = options || {};
    const { framebuffer, deleteFramebuffer } = getFramebuffer2(source);
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    const webglFramebuffer = framebuffer;
    sourceType = sourceType || 5121;
    let webglBufferTarget = target2;
    if (!webglBufferTarget) {
      const components = glFormatToComponents(sourceFormat);
      const byteCount = glTypeToBytes(sourceType);
      const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
      webglBufferTarget = webglFramebuffer.device.createBuffer({ byteLength });
    }
    const commandEncoder = source.device.createCommandEncoder();
    commandEncoder.copyTextureToBuffer({
      sourceTexture: source,
      width: sourceWidth,
      height: sourceHeight,
      origin: [sourceX, sourceY],
      destinationBuffer: webglBufferTarget,
      byteOffset: targetByteOffset
    });
    commandEncoder.destroy();
    if (deleteFramebuffer) {
      framebuffer.destroy();
    }
    return webglBufferTarget;
  }
  function getFramebuffer2(source) {
    if (!(source instanceof import_core23.Framebuffer)) {
      return { framebuffer: toFramebuffer(source), deleteFramebuffer: true };
    }
    return { framebuffer: source, deleteFramebuffer: false };
  }
  function toFramebuffer(texture, props) {
    const { device, width, height, id } = texture;
    const framebuffer = device.createFramebuffer({
      ...props,
      id: `framebuffer-for-${id}`,
      width,
      height,
      colorAttachments: [texture]
    });
    return framebuffer;
  }
  function getPixelArray(pixelArray, glType, glFormat, width, height, depth) {
    if (pixelArray) {
      return pixelArray;
    }
    glType ||= 5121;
    const shaderType = convertGLDataTypeToDataType(glType);
    const ArrayType = (0, import_core23.getTypedArrayConstructor)(shaderType);
    const components = glFormatToComponents(glFormat);
    return new ArrayType(width * height * components);
  }
  var import_core23;
  var init_webgl_texture_utils = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/helpers/webgl-texture-utils.js"() {
      import_core23 = __toESM(require_core2(), 1);
      init_webgl_shadertypes();
      init_format_utils();
      init_shader_formats();
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/adapter/webgl-device.js
  function setConstantFloatArray(device, location, array) {
    switch (array.length) {
      case 1:
        device.gl.vertexAttrib1fv(location, array);
        break;
      case 2:
        device.gl.vertexAttrib2fv(location, array);
        break;
      case 3:
        device.gl.vertexAttrib3fv(location, array);
        break;
      case 4:
        device.gl.vertexAttrib4fv(location, array);
        break;
      default:
    }
  }
  function setConstantIntArray(device, location, array) {
    device.gl.vertexAttribI4iv(location, array);
  }
  function setConstantUintArray(device, location, array) {
    device.gl.vertexAttribI4uiv(location, array);
  }
  function compareConstantArrayValues2(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }
  var import_core24, WebGLDevice;
  var init_webgl_device = __esm({
    "../../node_modules/@luma.gl/webgl/dist/adapter/webgl-device.js"() {
      import_core24 = __toESM(require_core2(), 1);
      init_webgl_state_tracker();
      init_create_browser_context();
      init_webgl_device_info();
      init_webgl_device_features();
      init_webgl_device_limits();
      init_webgl_canvas_context();
      init_spector();
      init_webgl_developer_tools();
      init_webgl_texture_table();
      init_uid();
      init_webgl_buffer();
      init_webgl_shader();
      init_webgl_sampler();
      init_webgl_texture();
      init_webgl_framebuffer();
      init_webgl_render_pipeline();
      init_webgl_command_encoder();
      init_webgl_vertex_array();
      init_webgl_transform_feedback();
      init_webgl_query_set();
      init_webgl_texture_utils();
      init_unified_parameter_api();
      init_with_parameters();
      init_webgl_extensions();
      WebGLDevice = class extends import_core24.Device {
        // Public `Device` API
        /** type of this device */
        type = "webgl";
        // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
        /** The underlying WebGL context */
        handle;
        features;
        limits;
        info;
        canvasContext;
        preferredColorFormat = "rgba8unorm";
        preferredDepthFormat = "depth24plus";
        commandEncoder;
        lost;
        _resolveContextLost;
        /** WebGL2 context. */
        gl;
        /** Store constants */
        // @ts-ignore TODO fix
        _constants;
        /** State used by luma.gl classes - TODO - not used? */
        _extensions = {};
        _polyfilled = false;
        /** Instance of Spector.js (if initialized) */
        spectorJS;
        //
        // Public API
        //
        get [Symbol.toStringTag]() {
          return "WebGLDevice";
        }
        toString() {
          return `${this[Symbol.toStringTag]}(${this.id})`;
        }
        isVertexFormatSupported(format) {
          switch (format) {
            case "unorm8x4-bgra":
              return false;
            default:
              return true;
          }
        }
        constructor(props) {
          super({ ...props, id: props.id || uid("webgl-device") });
          const canvasContextProps = import_core24.Device._getCanvasContextProps(props);
          if (!canvasContextProps) {
            throw new Error("WebGLDevice requires props.createCanvasContext to be set");
          }
          let device = canvasContextProps.canvas?.gl?.device;
          if (device) {
            throw new Error(`WebGL context already attached to device ${device.id}`);
          }
          this.canvasContext = new WebGLCanvasContext(this, canvasContextProps);
          this.lost = new Promise((resolve) => {
            this._resolveContextLost = resolve;
          });
          const webglContextAttributes = { ...props.webgl };
          if (canvasContextProps.alphaMode === "premultiplied") {
            webglContextAttributes.premultipliedAlpha = true;
          }
          if (props.powerPreference !== void 0) {
            webglContextAttributes.powerPreference = props.powerPreference;
          }
          const externalGLContext = this.props._handle;
          const gl = externalGLContext || createBrowserContext(this.canvasContext.canvas, {
            onContextLost: (event) => this._resolveContextLost?.({
              reason: "destroyed",
              message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
            }),
            // eslint-disable-next-line no-console
            onContextRestored: (event) => console.log("WebGL context restored")
          }, webglContextAttributes);
          if (!gl) {
            throw new Error("WebGL context creation failed");
          }
          device = gl.device;
          if (device) {
            if (props._reuseDevices) {
              import_core24.log.log(1, `Not creating a new Device, instead returning a reference to Device ${device.id} already attached to WebGL context`, device)();
              device._reused = true;
              return device;
            }
            throw new Error(`WebGL context already attached to device ${device.id}`);
          }
          this.handle = gl;
          this.gl = gl;
          this.spectorJS = initializeSpectorJS({ ...this.props, gl: this.handle });
          this.gl.device = this;
          this.gl._version = 2;
          this.info = getDeviceInfo(this.gl, this._extensions);
          this.limits = new WebGLDeviceLimits(this.gl);
          this.features = new WebGLDeviceFeatures(this.gl, this._extensions, this.props._disabledFeatures);
          if (this.props._initializeFeatures) {
            this.features.initializeFeatures();
          }
          const glState = new WebGLStateTracker(this.gl, {
            log: (...args) => import_core24.log.log(1, ...args)()
          });
          glState.trackState(this.gl, { copyState: false });
          const debugWebGL = props.debugWebGL || props.debug;
          const traceWebGL = props.debugWebGL;
          if (debugWebGL) {
            this.gl = makeDebugContext(this.gl, { debugWebGL, traceWebGL });
            import_core24.log.warn("WebGL debug mode activated. Performance reduced.")();
            if (props.debugWebGL) {
              import_core24.log.level = Math.max(import_core24.log.level, 1);
            }
          }
          this.commandEncoder = new WEBGLCommandEncoder(this, { id: `${this}-command-encoder` });
        }
        /**
         * Destroys the device
         *
         * @note "Detaches" from the WebGL context unless _reuseDevices is true.
         *
         * @note The underlying WebGL context is not immediately destroyed,
         * but may be destroyed later through normal JavaScript garbage collection.
         * This is a fundamental limitation since WebGL does not offer any
         * browser API for destroying WebGL contexts.
         */
        destroy() {
          if (!this.props._reuseDevices && !this._reused) {
            delete this.gl.device;
          }
        }
        get isLost() {
          return this.gl.isContextLost();
        }
        // IMPLEMENTATION OF ABSTRACT DEVICE
        getTextureByteAlignment() {
          return 4;
        }
        createCanvasContext(props) {
          throw new Error("WebGL only supports a single canvas");
        }
        createBuffer(props) {
          const newProps = this._normalizeBufferProps(props);
          return new WEBGLBuffer(this, newProps);
        }
        createTexture(props) {
          return new WEBGLTexture(this, props);
        }
        createExternalTexture(props) {
          throw new Error("createExternalTexture() not implemented");
        }
        createSampler(props) {
          return new WEBGLSampler(this, props);
        }
        createShader(props) {
          return new WEBGLShader(this, props);
        }
        createFramebuffer(props) {
          return new WEBGLFramebuffer(this, props);
        }
        createVertexArray(props) {
          return new WEBGLVertexArray(this, props);
        }
        createTransformFeedback(props) {
          return new WEBGLTransformFeedback(this, props);
        }
        createQuerySet(props) {
          return new WEBGLQuerySet(this, props);
        }
        createRenderPipeline(props) {
          return new WEBGLRenderPipeline(this, props);
        }
        createComputePipeline(props) {
          throw new Error("ComputePipeline not supported in WebGL");
        }
        createCommandEncoder(props = {}) {
          return new WEBGLCommandEncoder(this, props);
        }
        /**
         * Offscreen Canvas Support: Commit the frame
         * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
         * Chrome's offscreen canvas does not require gl.commit
         */
        submit(commandBuffer) {
          if (!commandBuffer) {
            commandBuffer = this.commandEncoder.finish();
            this.commandEncoder.destroy();
            this.commandEncoder = this.createCommandEncoder({ id: `${this.id}-default-encoder` });
          }
          commandBuffer._executeCommands();
        }
        //
        // TEMPORARY HACKS - will be removed in v9.1
        //
        /** @deprecated - should use command encoder */
        readPixelsToArrayWebGL(source, options) {
          return readPixelsToArray(source, options);
        }
        /** @deprecated - should use command encoder */
        readPixelsToBufferWebGL(source, options) {
          return readPixelsToBuffer(source, options);
        }
        setParametersWebGL(parameters) {
          setGLParameters(this.gl, parameters);
        }
        getParametersWebGL(parameters) {
          return getGLParameters(this.gl, parameters);
        }
        withParametersWebGL(parameters, func) {
          return withGLParameters(this.gl, parameters, func);
        }
        resetWebGL() {
          import_core24.log.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")();
          resetGLParameters(this.gl);
        }
        _getDeviceSpecificTextureFormatCapabilities(capabilities) {
          return getTextureFormatCapabilitiesWebGL(this.gl, capabilities, this._extensions);
        }
        //
        // WebGL-only API (not part of `Device` API)
        //
        /**
         * Triggers device (or WebGL context) loss.
         * @note primarily intended for testing how application reacts to device loss
         */
        loseDevice() {
          let deviceLossTriggered = false;
          const extensions = this.getExtension("WEBGL_lose_context");
          const ext = extensions.WEBGL_lose_context;
          if (ext) {
            deviceLossTriggered = true;
            ext.loseContext();
          }
          this._resolveContextLost?.({
            reason: "destroyed",
            message: "Application triggered context loss"
          });
          return deviceLossTriggered;
        }
        /** Save current WebGL context state onto an internal stack */
        pushState() {
          const webglState = WebGLStateTracker.get(this.gl);
          webglState.push();
        }
        /** Restores previously saved context state */
        popState() {
          const webglState = WebGLStateTracker.get(this.gl);
          webglState.pop();
        }
        /**
         * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
         * Be aware that there are some duplicates especially for constants that are 0,
         * so this isn't guaranteed to return the right key in all cases.
         */
        getGLKey(value, options) {
          const number = Number(value);
          for (const key in this.gl) {
            if (this.gl[key] === number) {
              return `GL.${key}`;
            }
          }
          return options?.emptyIfUnknown ? "" : String(value);
        }
        /**
         * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
         */
        getGLKeys(glParameters) {
          const opts = { emptyIfUnknown: true };
          return Object.entries(glParameters).reduce((keys, [key, value]) => {
            keys[`${key}:${this.getGLKey(key, opts)}`] = `${value}:${this.getGLKey(value, opts)}`;
            return keys;
          }, {});
        }
        /**
         * Set a constant value for a location. Disabled attributes at that location will read from this value
         * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
         * so they need to be updated before every render
         * @todo - remember/cache values to avoid setting them unnecessarily?
         */
        setConstantAttributeWebGL(location, constant) {
          const maxVertexAttributes = this.limits.maxVertexAttributes;
          this._constants = this._constants || new Array(maxVertexAttributes).fill(null);
          const currentConstant = this._constants[location];
          if (currentConstant && compareConstantArrayValues2(currentConstant, constant)) {
            import_core24.log.info(1, `setConstantAttributeWebGL(${location}) could have been skipped, value unchanged`)();
          }
          this._constants[location] = constant;
          switch (constant.constructor) {
            case Float32Array:
              setConstantFloatArray(this, location, constant);
              break;
            case Int32Array:
              setConstantIntArray(this, location, constant);
              break;
            case Uint32Array:
              setConstantUintArray(this, location, constant);
              break;
            default:
              throw new Error("constant");
          }
        }
        /** Ensure extensions are only requested once */
        getExtension(name) {
          getWebGLExtension(this.gl, name, this._extensions);
          return this._extensions;
        }
        // INTERNAL SUPPORT METHODS FOR WEBGL RESOURCES
        /**
         * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
         * luma.gl ids and props can be inspected
         */
        _setWebGLDebugMetadata(handle, resource, options) {
          handle.luma = resource;
          const spectorMetadata = { props: options.spector, id: options.spector["id"] };
          handle.__SPECTOR_Metadata = spectorMetadata;
        }
      };
    }
  });

  // ../../node_modules/@luma.gl/webgl/dist/index.js
  var init_dist3 = __esm({
    "../../node_modules/@luma.gl/webgl/dist/index.js"() {
      init_webgl_device();
      init_webgl_buffer();
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    GoogleMapsOverlay: () => GoogleMapsOverlay
  });

  // ../core/bundle/peer-dependency.ts
  var peer_dependency_exports = {};
  var import_core = __toESM(require_core(), 1);
  __reExport(peer_dependency_exports, __toESM(require_core(), 1));
  if (!import_core.Layer) {
    throw new Error("@deck.gl/core is not found");
  }

  // bundle.ts
  __reExport(bundle_exports, peer_dependency_exports);

  // src/google-maps-overlay.ts
  init_dist();
  init_dist3();

  // src/utils.ts
  var import_core25 = __toESM(require_core(), 1);

  // ../../node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
  var config = globalThis.mathgl.config;
  function formatValue(value, { precision = config.precision } = {}) {
    value = round(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray3(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function equals(a, b, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a === b) {
        return true;
      }
      if (isArray3(a) && isArray3(b)) {
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; ++i) {
          if (!equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (a && a.equals) {
        return a.equals(b);
      }
      if (b && b.equals) {
        return b.equals(a);
      }
      if (typeof a === "number" && typeof b === "number") {
        return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round(value) {
    return Math.round(value / config.EPSILON) * config.EPSILON;
  }

  // ../../node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray = class extends Array {
    // Common methods
    /**
     * Clone the current object
     * @returns a new copy of this object
     */
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        targetArray[offset + i] = this[i];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
        // @ts-ignore
        this.fromObject(arrayOrObject)
      );
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray3(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target2) {
      return target2 ? this.to(target2) : this;
    }
    /** @deprecated */
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    /** Formats string according to options */
    formatString(opts) {
      let string = "";
      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += (i > 0 ? ", " : "") + formatValue(this[i], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        if (!equals(this[i], array[i])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        if (this[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
    // Modifiers
    /** Negates all values in this object */
    negate() {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = -this[i];
      }
      return this.check();
    }
    lerp(a, b, t) {
      if (t === void 0) {
        return this.lerp(this, a, b);
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        const ai = a[i];
        const endValue = typeof b === "number" ? b : b[i];
        this[i] = ai + t * (endValue - ai);
      }
      return this.check();
    }
    /** Minimal */
    min(vector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(vector[i], this[i]);
      }
      return this.check();
    }
    /** Maximal */
    max(vector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.max(vector[i], this[i]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] += vector[i];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] -= vector[i];
        }
      }
      return this.check();
    }
    scale(scale2) {
      if (typeof scale2 === "number") {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= scale2;
        }
      } else {
        for (let i = 0; i < this.ELEMENTS && i < scale2.length; ++i) {
          this[i] *= scale2[i];
        }
      }
      return this.check();
    }
    /**
     * Multiplies all elements by `scale`
     * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
     */
    multiplyByScalar(scalar) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }
      return this.check();
    }
    // Debug checks
    /** Throws an error if array length is incorrect or contains illegal values */
    check() {
      if (config.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    /** Returns false if the array length is incorrect or contains illegal values */
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        valid = valid && Number.isFinite(this[i]);
      }
      return valid;
    }
    // three.js compatibility
    /** @deprecated */
    sub(a) {
      return this.subtract(a);
    }
    /** @deprecated */
    setScalar(a) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = a;
      }
      return this.check();
    }
    /** @deprecated */
    addScalar(a) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += a;
      }
      return this.check();
    }
    /** @deprecated */
    subScalar(a) {
      return this.addScalar(-a);
    }
    /** @deprecated */
    multiplyScalar(scalar) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }
      return this.check();
    }
    /** @deprecated */
    divideScalar(a) {
      return this.multiplyByScalar(1 / a);
    }
    /** @deprecated */
    clampScalar(min, max) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], min), max);
      }
      return this.check();
    }
    /** @deprecated */
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector(v, length) {
    if (v.length !== length) {
      return false;
    }
    for (let i = 0; i < v.length; ++i) {
      if (!Number.isFinite(v[i])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }
  function checkVector(v, length, callerName = "") {
    if (config.debug && !validateVector(v, length)) {
      throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
    }
    return v;
  }

  // ../../node_modules/@math.gl/core/dist/lib/assert.js
  function assert(condition, message2) {
    if (!condition) {
      throw new Error(`math.gl assertion ${message2}`);
    }
  }

  // ../../node_modules/@math.gl/core/dist/classes/base/vector.js
  var Vector = class extends MathArray {
    // ACCESSORS
    get x() {
      return this[0];
    }
    set x(value) {
      this[0] = checkNumber(value);
    }
    get y() {
      return this[1];
    }
    set y(value) {
      this[1] = checkNumber(value);
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     *
     * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
     * Instead we provide `len` and `magnitude`
     */
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    /**
     * Returns the length of the vector from the origin to the point described by this vector
     */
    magnitude() {
      return this.len();
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    lengthSquared() {
      let length = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        length += this[i] * this[i];
      }
      return length;
    }
    /**
     * Returns the squared length of the vector from the origin to the point described by this vector
     */
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        const dist = this[i] - mathArray[i];
        length += dist * dist;
      }
      return checkNumber(length);
    }
    dot(mathArray) {
      let product = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        product += this[i] * mathArray[i];
      }
      return checkNumber(product);
    }
    // MODIFIERS
    normalize() {
      const length = this.magnitude();
      if (length !== 0) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= length;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= vector[i];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= vector[i];
        }
      }
      return this.check();
    }
    // THREE.js compatibility
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i) {
      assert(i >= 0 && i < this.ELEMENTS, "index is out of range");
      return checkNumber(this[i]);
    }
    setComponent(i, value) {
      assert(i >= 0 && i < this.ELEMENTS, "index is out of range");
      this[i] = value;
      return this.check();
    }
    addVectors(a, b) {
      return this.copy(a).add(b);
    }
    subVectors(a, b) {
      return this.copy(a).subtract(b);
    }
    multiplyVectors(a, b) {
      return this.copy(a).multiply(b);
    }
    addScaledVector(a, b) {
      return this.add(new this.constructor(a).multiplyScalar(b));
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree = Math.PI / 180;

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create() {
    const out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat2(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
  }
  function transformMat2d(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
  }
  function transformMat3(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
  }
  function transformMat4(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  var forEach = function() {
    const vec = create();
    return function(a, stride, offset, count, fn, arg) {
      let i;
      let l;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }
      return a;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a, m) {
    const x = a[0];
    const y = a[1];
    const w = m[3] * x + m[7] * y || 1;
    out[0] = (m[0] * x + m[4] * y) / w;
    out[1] = (m[1] * x + m[5] * y) / w;
    return out;
  }
  function vec3_transformMat4AsVector(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const w = m[3] * x + m[7] * y + m[11] * z || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/classes/vector2.js
  var Vector2 = class extends Vector {
    // Creates a new, empty vec2
    constructor(x = 0, y = 0) {
      super(2);
      if (isArray3(x) && arguments.length === 1) {
        this.copy(x);
      } else {
        if (config.debug) {
          checkNumber(x);
          checkNumber(y);
        }
        this[0] = x;
        this[1] = y;
      }
    }
    set(x, y) {
      this[0] = x;
      this[1] = y;
      return this.check();
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      return this.check();
    }
    fromObject(object) {
      if (config.debug) {
        checkNumber(object.x);
        checkNumber(object.y);
      }
      this[0] = object.x;
      this[1] = object.y;
      return this.check();
    }
    toObject(object) {
      object.x = this[0];
      object.y = this[1];
      return object;
    }
    // Getters/setters
    get ELEMENTS() {
      return 2;
    }
    /**
     * Returns angle from x axis
     * @returns
     */
    horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
    /**
     * Returns angle from y axis
     * @returns
     */
    verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
    // Transforms
    /**
     * Transforms as point
     * @param matrix4
     * @returns
     */
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    /**
     * transforms as point (4th component is implicitly 1)
     * @param matrix4
     * @returns
     */
    transformAsPoint(matrix4) {
      transformMat4(this, this, matrix4);
      return this.check();
    }
    /**
     * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
     * @param matrix4
     * @returns
     */
    transformAsVector(matrix4) {
      vec2_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2x3(matrix2x3) {
      transformMat2d(this, this, matrix2x3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      transformMat2(this, this, matrix2);
      return this.check();
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  function create2() {
    const out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function transformMat42(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    let w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  var forEach2 = function() {
    const vec = create2();
    return function(a, stride, offset, count, fn, arg) {
      let i;
      let l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix = class extends MathArray {
    // fromObject(object) {
    //   const array = object.elements;
    //   return this.fromRowMajor(array);
    // }
    // toObject(object) {
    //   const array = object.elements;
    //   this.toRowMajor(array);
    //   return object;
    // }
    // TODO better override formatString?
    toString() {
      let string = "[";
      if (config.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += ` ${this[col * this.RANK + row]}`;
          }
        }
      } else {
        string += "column-major:";
        for (let i = 0; i < this.ELEMENTS; ++i) {
          string += ` ${this[i]}`;
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    // By default assumes row major indices
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    // By default assumes row major indices
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i = 0; i < this.RANK; ++i) {
        result[i] = this[firstIndex + i];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i = 0; i < this.RANK; ++i) {
        this[firstIndex + i] = columnVector[i];
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/mat4.js
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a12 = a[6];
      const a13 = a[7];
      const a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  function invert(out, a) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant(a) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  function multiply(out, a, b) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function scale(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function rotate(out, a, rad, axis) {
    let x = axis[0];
    let y = axis[1];
    let z = axis[2];
    let len = Math.sqrt(x * x + y * y + z * z);
    let c;
    let s;
    let t;
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    let b00;
    let b01;
    let b02;
    let b10;
    let b11;
    let b12;
    let b20;
    let b21;
    let b22;
    if (len < EPSILON) {
      return null;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  function rotateX(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function fromQuat(out, q) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const yx = y * x2;
    const yy = y * y2;
    const zx = z * x2;
    const zy = z * y2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    const f = 1 / Math.tan(fovy / 2);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function orthoNO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function lookAt(out, eye, center, up) {
    let len;
    let x0;
    let x1;
    let x2;
    let y0;
    let y1;
    let y2;
    let z0;
    let z1;
    let z2;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec4.js
  function create3() {
    const out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function transformMat43(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  var forEach3 = function() {
    const vec = create3();
    return function(a, stride, offset, count, fn, arg) {
      let i;
      let l;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }
      return a;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/matrix4.js
  var INDICES;
  (function(INDICES2) {
    INDICES2[INDICES2["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES2[INDICES2["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES2[INDICES2["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES2[INDICES2["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES2[INDICES2["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES2[INDICES2["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES2[INDICES2["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES2[INDICES2["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES2[INDICES2["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES2[INDICES2["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES2[INDICES2["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES2[INDICES2["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES2[INDICES2["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES2[INDICES2["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES2[INDICES2["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES2[INDICES2["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES || (INDICES = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    // accepts row major order, stores as column major
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    // Constructors
    /** Set to identity matrix */
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /**
     * Calculates a 4x4 matrix from the given quaternion
     * @param quaternion Quaternion to create matrix from
     * @returns self
     */
    fromQuaternion(quaternion) {
      fromQuat(this, quaternion);
      return this.check();
    }
    /**
     * Generates a frustum matrix with the given bounds
     * @param view.left - Left bound of the frustum
     * @param view.right - Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top - Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far - Far bound of the frustum. Can be set to Infinity.
     * @returns self
     */
    frustum(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        frustum(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    /**
     * Generates a look-at matrix with the given eye position, focal point,
     * and up axis
     * @param view.eye - (vector) Position of the viewer
     * @param view.center - (vector) Point the viewer is looking at
     * @param view.up - (vector) Up axis
     * @returns self
     */
    lookAt(view) {
      const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    /**
     * Generates a orthogonal projection matrix with the given bounds
     * from "traditional" view space parameters
     * @param view.left - Left bound of the frustum
     * @param view.right number  Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top number  Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far number  Far bound of the frustum
     * @returns self
     */
    ortho(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
    /**
     * Generates an orthogonal projection matrix with the same parameters
     * as a perspective matrix (plus focalDistance)
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. Typically viewport width / viewport height
     * @param view.focalDistance Distance in the view frustum used for extent calculations
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    orthographic(view) {
      const { fovy = DEFAULT_FOVY, aspect = DEFAULT_ASPECT, focalDistance = 1, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    /**
     * Generates a perspective projection matrix with the given bounds
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. typically viewport width/height
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    perspective(view) {
      const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant(this);
    }
    /**
     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
     * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
     * @param result
     * @returns self
     */
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    /**
     * Gets the translation portion, assuming the matrix is a affine transformation matrix.
     * @param result
     * @returns self
     */
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    /**
     * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale2 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale2[0];
      const inverseScale1 = 1 / scale2[1];
      const inverseScale2 = 1 / scale2[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    /**
     *
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale2 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale2[0];
      const inverseScale1 = 1 / scale2[1];
      const inverseScale2 = 1 / scale2[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    // Modifiers
    transpose() {
      transpose(this, this);
      return this.check();
    }
    invert() {
      invert(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a) {
      multiply(this, a, this);
      return this.check();
    }
    multiplyRight(a) {
      multiply(this, this, a);
      return this.check();
    }
    // Rotates a matrix by the given angle around the X axis
    rotateX(radians) {
      rotateX(this, this, radians);
      return this.check();
    }
    // Rotates a matrix by the given angle around the Y axis.
    rotateY(radians) {
      rotateY(this, this, radians);
      return this.check();
    }
    /**
     * Rotates a matrix by the given angle around the Z axis.
     * @param radians
     * @returns self
     */
    rotateZ(radians) {
      rotateZ(this, this, radians);
      return this.check();
    }
    /**
     *
     * @param param0
     * @returns self
     */
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    /**
     *
     * @param radians
     * @param axis
     * @returns self
     */
    rotateAxis(radians, axis) {
      rotate(this, this, radians, axis);
      return this.check();
    }
    /**
     *
     * @param factor
     * @returns self
     */
    scale(factor) {
      scale(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    /**
     *
     * @param vec
     * @returns self
     */
    translate(vector) {
      translate(this, this, vector);
      return this.check();
    }
    // Transforms
    /**
     * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
     * @param vector
     * @param result
     * @returns self
     */
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat43(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    /**
     * Transforms any 2 or 3 element array as point (w implicitly 1)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsPoint(vector, result) {
      const { length } = vector;
      let out;
      switch (length) {
        case 2:
          out = transformMat4(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat42(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    /**
     * Transforms any 2 or 3 element array as vector (w implicitly 0)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    // three.js math API compatibility
    makeRotationX(radians) {
      return this.identity().rotateX(radians);
    }
    makeTranslation(x, y, z) {
      return this.identity().translate([x, y, z]);
    }
  };
  var ZERO;
  var IDENTITY;
  function getZeroMatrix() {
    if (!ZERO) {
      ZERO = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  function getIdentityMatrix() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // src/utils.ts
  var MAX_LATITUDE = 85.05113;
  function createDeckInstance(map2, overlay, deck, props) {
    if (deck) {
      if (deck.userData._googleMap === map2) {
        return deck;
      }
      destroyDeckInstance(deck);
    }
    const eventListeners = {
      click: null,
      rightclick: null,
      dblclick: null,
      mousemove: null,
      mouseout: null
    };
    const newDeck = new import_core25.Deck({
      ...props,
      useDevicePixels: props.interleaved ? true : props.useDevicePixels,
      style: props.interleaved ? null : { pointerEvents: "none" },
      parent: getContainer(overlay, props.style),
      views: new import_core25.MapView({ repeat: true }),
      initialViewState: {
        longitude: 0,
        latitude: 0,
        zoom: 1
      },
      controller: false
    });
    for (const eventType in eventListeners) {
      eventListeners[eventType] = map2.addListener(
        eventType,
        (evt) => handleMouseEvent(newDeck, eventType, evt)
      );
    }
    newDeck.userData._googleMap = map2;
    newDeck.userData._eventListeners = eventListeners;
    return newDeck;
  }
  function getContainer(overlay, style) {
    const container = document.createElement("div");
    container.style.position = "absolute";
    Object.assign(container.style, style);
    if ("getPanes" in overlay) {
      overlay.getPanes()?.overlayLayer.appendChild(container);
    } else {
      overlay.getMap()?.getDiv().appendChild(container);
    }
    return container;
  }
  function destroyDeckInstance(deck) {
    const { _eventListeners: eventListeners } = deck.userData;
    for (const eventType in eventListeners) {
      if (eventListeners[eventType]) {
        eventListeners[eventType].remove();
      }
    }
    deck.finalize();
  }
  function getViewPropsFromOverlay(map2, overlay) {
    const { width, height } = getMapSize(map2);
    const projection = overlay.getProjection();
    const bounds = map2.getBounds();
    if (!bounds) {
      return { width, height, left: 0, top: 0 };
    }
    const ne = bounds.getNorthEast();
    const sw = bounds.getSouthWest();
    const topRight = projection.fromLatLngToDivPixel(ne);
    const bottomLeft = projection.fromLatLngToDivPixel(sw);
    const centerLngLat = pixelToLngLat(projection, width / 2, height / 2);
    const centerH = new google.maps.LatLng(0, centerLngLat[0]);
    const centerContainerPx = projection.fromLatLngToContainerPixel(centerH);
    const centerDivPx = projection.fromLatLngToDivPixel(centerH);
    if (!topRight || !bottomLeft || !centerDivPx || !centerContainerPx) {
      return { width, height, left: 0, top: 0 };
    }
    const leftOffset = Math.round(centerDivPx.x - centerContainerPx.x);
    let topOffset = centerDivPx.y - centerContainerPx.y;
    const topLngLat = pixelToLngLat(projection, width / 2, 0);
    const bottomLngLat = pixelToLngLat(projection, width / 2, height);
    let latitude = centerLngLat[1];
    const longitude = centerLngLat[0];
    if (Math.abs(latitude) > MAX_LATITUDE) {
      latitude = latitude > 0 ? MAX_LATITUDE : -MAX_LATITUDE;
      const center = new google.maps.LatLng(latitude, longitude);
      const centerPx = projection.fromLatLngToContainerPixel(center);
      topOffset += centerPx.y - height / 2;
    }
    topOffset = Math.round(topOffset);
    const delta = new Vector2(topLngLat).sub(bottomLngLat);
    let bearing = 180 * delta.verticalAngle() / Math.PI;
    if (bearing < 0)
      bearing += 360;
    const heading = map2.getHeading() || 0;
    let zoom = map2.getZoom() - 1;
    let scale2;
    if (bearing === 0) {
      scale2 = height ? (bottomLeft.y - topRight.y) / height : 1;
    } else if (bearing === heading) {
      const viewDiagonal = new Vector2([topRight.x, topRight.y]).sub([bottomLeft.x, bottomLeft.y]).len();
      const mapDiagonal = new Vector2([width, -height]).len();
      scale2 = mapDiagonal ? viewDiagonal / mapDiagonal : 1;
    }
    zoom += Math.log2(scale2 || 1);
    return {
      width,
      height,
      left: leftOffset,
      top: topOffset,
      zoom,
      bearing,
      pitch: map2.getTilt(),
      latitude,
      longitude
    };
  }
  function getViewPropsFromCoordinateTransformer(map2, transformer) {
    const { width, height } = getMapSize(map2);
    const { center, heading: bearing, tilt: pitch, zoom } = transformer.getCameraParams();
    const fovy = 25;
    const aspect = height ? width / height : 1;
    const near = 0.75;
    const far = 3e14;
    const projectionMatrix = new Matrix4().perspective({
      fovy: fovy * Math.PI / 180,
      aspect,
      near,
      far
    });
    const focalDistance = 0.5 * projectionMatrix[5];
    return {
      width,
      height,
      viewState: {
        altitude: focalDistance,
        bearing,
        latitude: center.lat(),
        longitude: center.lng(),
        pitch,
        projectionMatrix,
        repeat: true,
        zoom: zoom - 1
      }
    };
  }
  function getMapSize(map2) {
    const container = map2.getDiv().firstChild;
    return {
      // @ts-ignore (TS2531) Object is possibly 'null'
      width: container.offsetWidth,
      // @ts-ignore (TS2531) Object is possibly 'null'
      height: container.offsetHeight
    };
  }
  function pixelToLngLat(projection, x, y) {
    const point = new google.maps.Point(x, y);
    const latLng = projection.fromContainerPixelToLatLng(point);
    return [latLng.lng(), latLng.lat()];
  }
  function getEventPixel(event, deck) {
    if (event.pixel) {
      return event.pixel;
    }
    const point = deck.getViewports()[0].project([event.latLng.lng(), event.latLng.lat()]);
    return {
      x: point[0],
      y: point[1]
    };
  }
  function handleMouseEvent(deck, type, event) {
    if (!deck.isInitialized) {
      return;
    }
    const mockEvent = {
      type,
      offsetCenter: getEventPixel(event, deck),
      srcEvent: event
    };
    switch (type) {
      case "click":
      case "rightclick":
        mockEvent.type = "click";
        mockEvent.tapCount = 1;
        deck._onPointerDown(mockEvent);
        deck._onEvent(mockEvent);
        break;
      case "dblclick":
        mockEvent.type = "click";
        mockEvent.tapCount = 2;
        deck._onEvent(mockEvent);
        break;
      case "mousemove":
        mockEvent.type = "pointermove";
        deck._onPointerMove(mockEvent);
        break;
      case "mouseout":
        mockEvent.type = "pointerleave";
        deck._onPointerMove(mockEvent);
        break;
      default:
        return;
    }
  }

  // src/google-maps-overlay.ts
  var HIDE_ALL_LAYERS = () => false;
  var GL_STATE = {
    depthMask: true,
    depthTest: true,
    blend: true,
    blendFunc: [GLEnum.SRC_ALPHA, GLEnum.ONE_MINUS_SRC_ALPHA, GLEnum.ONE, GLEnum.ONE_MINUS_SRC_ALPHA],
    blendEquation: GLEnum.FUNC_ADD
  };
  function noop() {
  }
  var defaultProps = {
    interleaved: true
  };
  var GoogleMapsOverlay = class {
    constructor(props) {
      this.props = {};
      this._map = null;
      this._deck = null;
      this._overlay = null;
      this.setProps({ ...defaultProps, ...props });
    }
    /* Public API */
    /** Add/remove the overlay from a map. */
    setMap(map2) {
      if (map2 === this._map) {
        return;
      }
      const { VECTOR, UNINITIALIZED } = google.maps.RenderingType;
      if (this._map) {
        if (!map2 && this._map.getRenderingType() === VECTOR && this.props.interleaved) {
          this._overlay.requestRedraw();
        }
        this._overlay?.setMap(null);
        this._map = null;
      }
      if (map2) {
        this._map = map2;
        const renderingType = map2.getRenderingType();
        if (renderingType !== UNINITIALIZED) {
          this._createOverlay(map2);
        } else {
          map2.addListener("renderingtype_changed", () => {
            this._createOverlay(map2);
          });
        }
      }
    }
    /**
     * Update (partial) props.
     */
    setProps(props) {
      Object.assign(this.props, props);
      if (this._deck) {
        const canvas = this._deck.getCanvas();
        if (props.style && canvas?.parentElement) {
          const parentStyle = canvas.parentElement.style;
          Object.assign(parentStyle, props.style);
          props.style = null;
        }
        this._deck.setProps(props);
      }
    }
    /** Equivalent of `deck.pickObject`. */
    pickObject(params) {
      return this._deck && this._deck.pickObject(params);
    }
    /** Equivalent of `deck.pickObjects`.  */
    pickMultipleObjects(params) {
      return this._deck && this._deck.pickMultipleObjects(params);
    }
    /** Equivalent of `deck.pickMultipleObjects`. */
    pickObjects(params) {
      return this._deck && this._deck.pickObjects(params);
    }
    /** Remove the overlay and release all underlying resources. */
    finalize() {
      this.setMap(null);
      if (this._deck) {
        destroyDeckInstance(this._deck);
        this._deck = null;
      }
    }
    /* Private API */
    _createOverlay(map2) {
      const { interleaved } = this.props;
      const { VECTOR, UNINITIALIZED } = google.maps.RenderingType;
      const renderingType = map2.getRenderingType();
      if (renderingType === UNINITIALIZED) {
        return;
      }
      const isVectorMap = renderingType === VECTOR && google.maps.WebGLOverlayView;
      const OverlayView = isVectorMap ? google.maps.WebGLOverlayView : google.maps.OverlayView;
      const overlay = new OverlayView();
      if (overlay instanceof google.maps.WebGLOverlayView) {
        if (interleaved) {
          overlay.onAdd = noop;
          overlay.onContextRestored = this._onContextRestored.bind(this);
          overlay.onDraw = this._onDrawVectorInterleaved.bind(this);
        } else {
          overlay.onAdd = this._onAdd.bind(this);
          overlay.onContextRestored = noop;
          overlay.onDraw = this._onDrawVectorOverlay.bind(this);
        }
        overlay.onContextLost = this._onContextLost.bind(this);
      } else {
        overlay.onAdd = this._onAdd.bind(this);
        overlay.draw = this._onDrawRaster.bind(this);
      }
      overlay.onRemove = this._onRemove.bind(this);
      this._overlay = overlay;
      this._overlay.setMap(map2);
    }
    _onAdd() {
      this._deck = createDeckInstance(this._map, this._overlay, this._deck, this.props);
    }
    _onContextRestored({ gl }) {
      if (!this._map || !this._overlay) {
        return;
      }
      const _customRender = () => {
        if (this._overlay) {
          this._overlay.requestRedraw();
        }
      };
      const deck = createDeckInstance(this._map, this._overlay, this._deck, {
        gl,
        _customRender,
        ...this.props
      });
      this._deck = deck;
      const animationLoop = deck.animationLoop;
      animationLoop._renderFrame = () => {
        const ab = gl.getParameter(gl.ARRAY_BUFFER_BINDING);
        const device = deck.device;
        device.withParametersWebGL({}, () => {
          animationLoop.props.onRender(animationLoop.animationProps);
        });
        gl.bindBuffer(gl.ARRAY_BUFFER, ab);
      };
    }
    _onContextLost() {
      if (this._deck) {
        destroyDeckInstance(this._deck);
        this._deck = null;
      }
    }
    _onRemove() {
      this._deck?.setProps({ layerFilter: HIDE_ALL_LAYERS });
    }
    _onDrawRaster() {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      const { width, height, left, top, ...rest } = getViewPropsFromOverlay(
        this._map,
        this._overlay
      );
      const canvas = deck.getCanvas();
      const parent = canvas?.parentElement || deck.props.parent;
      if (parent) {
        const parentStyle = parent.style;
        parentStyle.left = `${left}px`;
        parentStyle.top = `${top}px`;
      }
      const altitude = 1e4;
      deck.setProps({
        width,
        height,
        // @ts-expect-error altitude is accepted by WebMercatorViewport but not exposed by type
        viewState: { altitude, ...rest }
      });
      deck.redraw();
    }
    // Vector code path
    _onDrawVectorInterleaved({ gl, transformer }) {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      deck.setProps({
        ...getViewPropsFromCoordinateTransformer(this._map, transformer),
        // Using external gl context - do not set css size
        width: null,
        height: null
      });
      if (deck.isInitialized) {
        const device = deck.device;
        if (device instanceof WebGLDevice) {
          const _framebuffer = device.getParametersWebGL(GLEnum.FRAMEBUFFER_BINDING);
          deck.setProps({ _framebuffer });
        }
        deck.needsRedraw({ clearRedrawFlags: true });
        if (device instanceof WebGLDevice) {
          device.setParametersWebGL({
            viewport: [0, 0, gl.canvas.width, gl.canvas.height],
            scissor: [0, 0, gl.canvas.width, gl.canvas.height],
            stencilFunc: [gl.ALWAYS, 0, 255, gl.ALWAYS, 0, 255]
          });
          device.withParametersWebGL(GL_STATE, () => {
            deck._drawLayers("google-vector", {
              clearCanvas: false
            });
          });
        }
      }
    }
    _onDrawVectorOverlay({ transformer }) {
      if (!this._deck || !this._map) {
        return;
      }
      const deck = this._deck;
      deck.setProps({
        ...getViewPropsFromCoordinateTransformer(this._map, transformer)
      });
      deck.redraw();
    }
  };
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
