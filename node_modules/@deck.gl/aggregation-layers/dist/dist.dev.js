(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";
var __exports__ = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // external-global-plugin:@deck.gl/layers
  var require_layers = __commonJS({
    "external-global-plugin:@deck.gl/layers"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // external-global-plugin:@deck.gl/core
  var require_core = __commonJS({
    "external-global-plugin:@deck.gl/core"(exports, module) {
      module.exports = globalThis.deck;
    }
  });

  // external-global-plugin:@luma.gl/engine
  var require_engine = __commonJS({
    "external-global-plugin:@luma.gl/engine"(exports, module) {
      module.exports = globalThis.luma;
    }
  });

  // bundle.ts
  var bundle_exports = {};
  __export(bundle_exports, {
    CPUAggregator: () => CPUAggregator,
    ContourLayer: () => GridLayer,
    GridLayer: () => GridLayer2,
    HeatmapLayer: () => HeatmapLayer,
    HexagonLayer: () => HexagonLayer,
    ScreenGridLayer: () => ScreenGridLayer,
    WebGLAggregator: () => WebGLAggregator,
    _AggregationLayer: () => AggregationLayer
  });

  // ../layers/bundle/peer-dependency.ts
  var peer_dependency_exports = {};
  var import_layers = __toESM(require_layers(), 1);
  __reExport(peer_dependency_exports, __toESM(require_layers(), 1));
  if (!import_layers.GeoJsonLayer) {
    throw new Error("@deck.gl/layers is not found");
  }

  // bundle.ts
  __reExport(bundle_exports, peer_dependency_exports);

  // src/screen-grid-layer/screen-grid-layer.ts
  var import_core5 = __toESM(require_core(), 1);

  // src/common/aggregator/cpu-aggregator/cpu-aggregator.ts
  var import_core = __toESM(require_core(), 1);

  // src/common/aggregator/cpu-aggregator/sort-bins.ts
  function sortBins({
    pointCount,
    getBinId
  }) {
    const binsById = /* @__PURE__ */ new Map();
    for (let i = 0; i < pointCount; i++) {
      const id = getBinId(i);
      if (id === null) {
        continue;
      }
      let bin = binsById.get(String(id));
      if (bin) {
        bin.points.push(i);
      } else {
        bin = {
          id,
          index: binsById.size,
          points: [i]
        };
        binsById.set(String(id), bin);
      }
    }
    return Array.from(binsById.values());
  }
  function packBinIds({
    bins,
    dimensions,
    target
  }) {
    const targetLength = bins.length * dimensions;
    if (!target || target.length < targetLength) {
      target = new Float32Array(targetLength);
    }
    for (let i = 0; i < bins.length; i++) {
      const { id } = bins[i];
      if (Array.isArray(id)) {
        target.set(id, i * dimensions);
      } else {
        target[i] = id;
      }
    }
    return target;
  }

  // src/common/aggregator/cpu-aggregator/aggregate.ts
  var count = (pointIndices) => {
    return pointIndices.length;
  };
  var sum = (pointIndices, getValue) => {
    let result = 0;
    for (const i of pointIndices) {
      result += getValue(i);
    }
    return result;
  };
  var mean = (pointIndices, getValue) => {
    if (pointIndices.length === 0) {
      return NaN;
    }
    return sum(pointIndices, getValue) / pointIndices.length;
  };
  var min = (pointIndices, getValue) => {
    let result = Infinity;
    for (const i of pointIndices) {
      const value = getValue(i);
      if (value < result) {
        result = value;
      }
    }
    return result;
  };
  var max = (pointIndices, getValue) => {
    let result = -Infinity;
    for (const i of pointIndices) {
      const value = getValue(i);
      if (value > result) {
        result = value;
      }
    }
    return result;
  };
  var BUILT_IN_OPERATIONS = {
    COUNT: count,
    SUM: sum,
    MEAN: mean,
    MIN: min,
    MAX: max
  };
  function aggregate({
    bins,
    getValue,
    operation,
    target
  }) {
    if (!target || target.length < bins.length) {
      target = new Float32Array(bins.length);
    }
    let min2 = Infinity;
    let max2 = -Infinity;
    for (let j = 0; j < bins.length; j++) {
      const { points } = bins[j];
      target[j] = operation(points, getValue);
      if (target[j] < min2)
        min2 = target[j];
      if (target[j] > max2)
        max2 = target[j];
    }
    return { value: target, domain: [min2, max2] };
  }

  // src/common/aggregator/cpu-aggregator/vertex-accessor.ts
  function evaluateVertexAccessor(accessor, attributes, options) {
    const vertexReaders = {};
    for (const id of accessor.sources || []) {
      const attribute = attributes[id];
      if (attribute) {
        vertexReaders[id] = getVertexReader(attribute);
      } else {
        throw new Error(`Cannot find attribute ${id}`);
      }
    }
    const data = {};
    return (vertexIndex) => {
      for (const id in vertexReaders) {
        data[id] = vertexReaders[id](vertexIndex);
      }
      return accessor.getValue(data, vertexIndex, options);
    };
  }
  function getVertexReader(attribute) {
    const value = attribute.value;
    const { offset = 0, stride, size } = attribute.getAccessor();
    const bytesPerElement = value.BYTES_PER_ELEMENT;
    const elementOffset = offset / bytesPerElement;
    const elementStride = stride ? stride / bytesPerElement : size;
    if (size === 1) {
      if (attribute.isConstant) {
        return () => value[0];
      }
      return (vertexIndex) => {
        const i = elementOffset + elementStride * vertexIndex;
        return value[i];
      };
    }
    let result;
    if (attribute.isConstant) {
      result = Array.from(value);
      return () => result;
    }
    result = new Array(size);
    return (vertexIndex) => {
      const i = elementOffset + elementStride * vertexIndex;
      for (let j = 0; j < size; j++) {
        result[j] = value[i + j];
      }
      return result;
    };
  }

  // src/common/aggregator/cpu-aggregator/cpu-aggregator.ts
  var CPUAggregator = class {
    constructor(props) {
      this.bins = [];
      this.binIds = null;
      this.results = [];
      this.dimensions = props.dimensions;
      this.channelCount = props.getValue.length;
      this.props = {
        ...props,
        binOptions: {},
        pointCount: 0,
        operations: [],
        customOperations: [],
        attributes: {}
      };
      this.needsUpdate = true;
      this.setProps(props);
    }
    destroy() {
    }
    get binCount() {
      return this.bins.length;
    }
    /** Update aggregation props */
    // eslint-disable-next-line complexity
    setProps(props) {
      const oldProps = this.props;
      if (props.binOptions) {
        if (!(0, import_core._deepEqual)(props.binOptions, oldProps.binOptions, 2)) {
          this.setNeedsUpdate();
        }
      }
      if (props.operations) {
        for (let channel = 0; channel < this.channelCount; channel++) {
          if (props.operations[channel] !== oldProps.operations[channel]) {
            this.setNeedsUpdate(channel);
          }
        }
      }
      if (props.customOperations) {
        for (let channel = 0; channel < this.channelCount; channel++) {
          if (Boolean(props.customOperations[channel]) !== Boolean(oldProps.customOperations[channel])) {
            this.setNeedsUpdate(channel);
          }
        }
      }
      if (props.pointCount !== void 0 && props.pointCount !== oldProps.pointCount) {
        this.setNeedsUpdate();
      }
      if (props.attributes) {
        props.attributes = { ...oldProps.attributes, ...props.attributes };
      }
      Object.assign(this.props, props);
    }
    /** Flags a channel to need update
     * This is called internally by setProps() if certain props change
     * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed
     * the underlying buffers could have been updated and require rerunning the aggregation
     * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.
     */
    setNeedsUpdate(channel) {
      if (channel === void 0) {
        this.needsUpdate = true;
      } else if (this.needsUpdate !== true) {
        this.needsUpdate = this.needsUpdate || [];
        this.needsUpdate[channel] = true;
      }
    }
    /** Run aggregation */
    update() {
      if (this.needsUpdate === true) {
        this.bins = sortBins({
          pointCount: this.props.pointCount,
          getBinId: evaluateVertexAccessor(
            this.props.getBin,
            this.props.attributes,
            this.props.binOptions
          )
        });
        const value = packBinIds({
          bins: this.bins,
          dimensions: this.dimensions,
          // Reuse allocated typed array
          target: this.binIds?.value
        });
        this.binIds = { value, type: "float32", size: this.dimensions };
      }
      for (let channel = 0; channel < this.channelCount; channel++) {
        if (this.needsUpdate === true || this.needsUpdate[channel]) {
          const operation = this.props.customOperations[channel] || BUILT_IN_OPERATIONS[this.props.operations[channel]];
          const { value, domain } = aggregate({
            bins: this.bins,
            getValue: evaluateVertexAccessor(
              this.props.getValue[channel],
              this.props.attributes,
              void 0
            ),
            operation,
            // Reuse allocated typed array
            target: this.results[channel]?.value
          });
          this.results[channel] = { value, domain, type: "float32", size: 1 };
          this.props.onUpdate?.({ channel });
        }
      }
      this.needsUpdate = false;
    }
    preDraw() {
    }
    /** Returns an accessor to the bins. */
    getBins() {
      return this.binIds;
    }
    /** Returns an accessor to the output for a given channel. */
    getResult(channel) {
      return this.results[channel];
    }
    /** Returns the [min, max] of aggregated values for a given channel. */
    getResultDomain(channel) {
      return this.results[channel]?.domain ?? [Infinity, -Infinity];
    }
    /** Returns the information for a given bin. */
    getBin(index) {
      const bin = this.bins[index];
      if (!bin) {
        return null;
      }
      const value = new Array(this.channelCount);
      for (let i = 0; i < value.length; i++) {
        const result = this.results[i];
        value[i] = result?.value[index];
      }
      return {
        id: bin.id,
        value,
        count: bin.points.length,
        pointIndices: bin.points
      };
    }
  };

  // src/common/aggregator/gpu-aggregator/webgl-bin-sorter.ts
  var import_engine = __toESM(require_engine(), 1);

  // src/common/aggregator/gpu-aggregator/utils.ts
  function createRenderTarget(device, width, height) {
    return device.createFramebuffer({
      width,
      height,
      colorAttachments: [
        device.createTexture({
          width,
          height,
          format: "rgba32float",
          sampler: {
            minFilter: "nearest",
            magFilter: "nearest"
          }
        })
      ]
    });
  }

  // src/common/aggregator/gpu-aggregator/bin-sorter-uniforms.ts
  var uniformBlock = (
    /* glsl */
    `uniform binSorterUniforms {
  ivec4 binIdRange;
  ivec2 targetSize;
} binSorter;
`
  );
  var binSorterUniforms = {
    name: "binSorter",
    vs: uniformBlock,
    uniformTypes: {
      binIdRange: "vec4<i32>",
      targetSize: "vec2<i32>"
    }
  };

  // src/common/aggregator/gpu-aggregator/webgl-bin-sorter.ts
  var COLOR_CHANNELS = [1, 2, 4, 8];
  var MAX_FLOAT32 = 3e38;
  var EMPTY_MASKS = { SUM: 0, MEAN: 0, MIN: 0, MAX: 0, COUNT: 0 };
  var TEXTURE_WIDTH = 1024;
  var WebGLBinSorter = class {
    constructor(device, props) {
      /**
       * A packed texture in which each pixel represents a bin.
       * The index of the pixel in the memory layout is the bin index.
       * Alpha value is the count of data points that fall into this bin
       * R,G,B values are the aggregated values of each channel:
       *   - Sum of all data points if operation is 'SUM', or 'MEAN'
       *   - Min of all data points if operation is 'MIN'
       *   - Max of all data points if operation is 'MAX'
       */
      this.binsFBO = null;
      this.device = device;
      this.model = createModel(device, props);
    }
    get texture() {
      return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;
    }
    destroy() {
      this.model.destroy();
      this.binsFBO?.colorAttachments[0].texture.destroy();
      this.binsFBO?.destroy();
    }
    getBinValues(index) {
      if (!this.binsFBO) {
        return null;
      }
      const x = index % TEXTURE_WIDTH;
      const y = Math.floor(index / TEXTURE_WIDTH);
      const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {
        sourceX: x,
        sourceY: y,
        sourceWidth: 1,
        sourceHeight: 1
      }).buffer;
      return new Float32Array(buffer);
    }
    setDimensions(binCount, binIdRange) {
      const width = TEXTURE_WIDTH;
      const height = Math.ceil(binCount / width);
      if (!this.binsFBO) {
        this.binsFBO = createRenderTarget(this.device, width, height);
      } else if (this.binsFBO.height < height) {
        this.binsFBO.resize({ width, height });
      }
      const binSorterProps = {
        binIdRange: [
          binIdRange[0][0],
          binIdRange[0][1],
          binIdRange[1]?.[0] || 0,
          binIdRange[1]?.[1] || 0
        ],
        targetSize: [this.binsFBO.width, this.binsFBO.height]
      };
      this.model.shaderInputs.setProps({ binSorter: binSorterProps });
    }
    setModelProps(props) {
      const model = this.model;
      if (props.attributes) {
        model.setAttributes(props.attributes);
      }
      if (props.constantAttributes) {
        model.setConstantAttributes(props.constantAttributes);
      }
      if (props.vertexCount !== void 0) {
        model.setVertexCount(props.vertexCount);
      }
      if (props.shaderModuleProps) {
        model.shaderInputs.setProps(props.shaderModuleProps);
      }
    }
    /** Update aggregation */
    update(operations) {
      if (!this.binsFBO) {
        return;
      }
      const masks = getMaskByOperation(operations);
      this._updateBins("SUM", masks.SUM + masks.MEAN);
      this._updateBins("MIN", masks.MIN);
      this._updateBins("MAX", masks.MAX);
    }
    /** Recalculate aggregation on the given channels using the given operation */
    _updateBins(operation, colorMask) {
      if (colorMask === 0) {
        return;
      }
      colorMask |= COLOR_CHANNELS[3];
      const model = this.model;
      const target = this.binsFBO;
      const initialValue = operation === "MAX" ? -MAX_FLOAT32 : operation === "MIN" ? MAX_FLOAT32 : 0;
      const renderPass = this.device.beginRenderPass({
        id: `gpu-aggregation-${operation}`,
        framebuffer: target,
        parameters: {
          viewport: [0, 0, target.width, target.height],
          colorMask
        },
        clearColor: [initialValue, initialValue, initialValue, 0],
        clearDepth: false,
        clearStencil: false
      });
      model.setParameters({
        blend: true,
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one",
        blendColorOperation: operation === "MAX" ? "max" : operation === "MIN" ? "min" : "add",
        blendAlphaOperation: "add"
      });
      model.draw(renderPass);
      renderPass.end();
    }
  };
  function getMaskByOperation(operations) {
    const result = { ...EMPTY_MASKS };
    for (let channel = 0; channel < operations.length; channel++) {
      const op = operations[channel];
      if (op) {
        result[op] += COLOR_CHANNELS[channel];
      }
    }
    return result;
  }
  function createModel(device, props) {
    let userVs = props.vs;
    if (props.dimensions === 2) {
      userVs += /* glsl */
      `
void getBin(out int binId) {
  ivec2 binId2;
  getBin(binId2);
  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {
    binId = -1;
  } else {
    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;
  }
}
`;
    }
    const vs = `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-vertex

${userVs}

out vec3 v_Value;

void main() {
  int binIndex;
  getBin(binIndex);
  binIndex = binIndex - binSorter.binIdRange.x;
  if (binIndex < 0) {
    gl_Position = vec4(0.);
    return;
  }
  int row = binIndex / binSorter.targetSize.x;
  int col = binIndex - row * binSorter.targetSize.x;
  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;
  gl_Position = vec4(position, 0.0, 1.0);
  gl_PointSize = 1.0;

#if NUM_CHANNELS == 3
  getValue(v_Value);
#elif NUM_CHANNELS == 2
  getValue(v_Value.xy);
#else
  getValue(v_Value.x);
#endif
}
`;
    const fs = (
      /* glsl */
      `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-fragment

precision highp float;

in vec3 v_Value;
out vec4 fragColor;

void main() {
  fragColor.xyz = v_Value;

  #ifdef MODULE_GEOMETRY
  geometry.uv = vec2(0.);
  DECKGL_FILTER_COLOR(fragColor, geometry);
  #endif

  fragColor.w = 1.0;
}
`
    );
    const model = new import_engine.Model(device, {
      bufferLayout: props.bufferLayout,
      modules: [...props.modules || [], binSorterUniforms],
      // @ts-expect-error TODO fix luma type
      defines: { ...props.defines, NON_INSTANCED_MODEL: 1, NUM_CHANNELS: props.channelCount },
      isInstanced: false,
      vs,
      fs,
      topology: "point-list",
      disableWarnings: true
    });
    return model;
  }

  // src/common/aggregator/gpu-aggregator/webgl-aggregation-transform.ts
  var import_engine2 = __toESM(require_engine(), 1);

  // src/common/aggregator/gpu-aggregator/aggregation-transform-uniforms.ts
  var uniformBlock2 = (
    /* glsl */
    `uniform aggregatorTransformUniforms {
  ivec4 binIdRange;
  bvec3 isCount;
  bvec3 isMean;
  float naN;
} aggregatorTransform;
`
  );
  var aggregatorTransformUniforms = {
    name: "aggregatorTransform",
    vs: uniformBlock2,
    uniformTypes: {
      binIdRange: "vec4<i32>",
      isCount: "vec3<f32>",
      isMean: "vec3<f32>"
    }
  };

  // src/common/aggregator/gpu-aggregator/webgl-aggregation-transform.ts
  var MAX_FLOAT322 = 3e38;
  var WebGLAggregationTransform = class {
    constructor(device, props) {
      /** Packed from bin ids */
      this.binBuffer = null;
      /** Packed values from each channel of each bin
       * Stride is number of channels * 4 bytes (float32)
       */
      this.valueBuffer = null;
      /** Aggregated [min, max] for each channel */
      this._domains = null;
      this.device = device;
      this.channelCount = props.channelCount;
      this.transform = createTransform(device, props);
      this.domainFBO = createRenderTarget(device, 2, 1);
    }
    destroy() {
      this.transform.destroy();
      this.binBuffer?.destroy();
      this.valueBuffer?.destroy();
      this.domainFBO.colorAttachments[0].texture.destroy();
      this.domainFBO.destroy();
    }
    get domains() {
      if (!this._domains) {
        const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;
        const domain = new Float32Array(buffer);
        this._domains = [
          [-domain[4], domain[0]],
          [-domain[5], domain[1]],
          [-domain[6], domain[2]]
        ].slice(0, this.channelCount);
      }
      return this._domains;
    }
    setDimensions(binCount, binIdRange) {
      const { model, transformFeedback } = this.transform;
      model.setVertexCount(binCount);
      const aggregatorTransformProps = {
        binIdRange: [
          binIdRange[0][0],
          binIdRange[0][1],
          binIdRange[1]?.[0] || 0,
          binIdRange[1]?.[1] || 0
        ]
      };
      model.shaderInputs.setProps({ aggregatorTransform: aggregatorTransformProps });
      const binBufferByteLength = binCount * binIdRange.length * 4;
      if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {
        this.binBuffer?.destroy();
        this.binBuffer = this.device.createBuffer({ byteLength: binBufferByteLength });
        transformFeedback.setBuffer("binIds", this.binBuffer);
      }
      const valueBufferByteLength = binCount * this.channelCount * 4;
      if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {
        this.valueBuffer?.destroy();
        this.valueBuffer = this.device.createBuffer({ byteLength: valueBufferByteLength });
        transformFeedback.setBuffer("values", this.valueBuffer);
      }
    }
    update(bins, operations) {
      if (!bins) {
        return;
      }
      const transform = this.transform;
      const target = this.domainFBO;
      const isCount = [0, 1, 2].map((i) => operations[i] === "COUNT" ? 1 : 0);
      const isMean = [0, 1, 2].map((i) => operations[i] === "MEAN" ? 1 : 0);
      const aggregatorTransformProps = {
        isCount,
        isMean,
        bins
      };
      transform.model.shaderInputs.setProps({ aggregatorTransform: aggregatorTransformProps });
      transform.run({
        id: "gpu-aggregation-domain",
        framebuffer: target,
        parameters: {
          viewport: [0, 0, 2, 1]
        },
        clearColor: [-MAX_FLOAT322, -MAX_FLOAT322, -MAX_FLOAT322, 0],
        clearDepth: false,
        clearStencil: false
      });
      this._domains = null;
    }
  };
  function createTransform(device, props) {
    const vs = (
      /* glsl */
      `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-vertex

uniform sampler2D bins;

#if NUM_DIMS == 1
out float binIds;
#else
out vec2 binIds;
#endif

#if NUM_CHANNELS == 1
flat out float values;
#elif NUM_CHANNELS == 2
flat out vec2 values;
#else
flat out vec3 values;
#endif

const float NAN = intBitsToFloat(-1);

void main() {
  int row = gl_VertexID / SAMPLER_WIDTH;
  int col = gl_VertexID - row * SAMPLER_WIDTH;
  vec4 weights = texelFetch(bins, ivec2(col, row), 0);
  vec3 value3 = mix(
    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),
    weights.rgb / max(weights.a, 1.0),
    aggregatorTransform.isMean
  );
  if (weights.a == 0.0) {
    value3 = vec3(NAN);
  }

#if NUM_DIMS == 1
  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);
#else
  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  binIds.y = float(y + aggregatorTransform.binIdRange.z);
  binIds.x = float(x + aggregatorTransform.binIdRange.x);
#endif

#if NUM_CHANNELS == 3
  values = value3;
#elif NUM_CHANNELS == 2
  values = value3.xy;
#else
  values = value3.x;
#endif

  gl_Position = vec4(0., 0., 0., 1.);
  // This model renders into a 2x1 texture to obtain min and max simultaneously.
  // See comments in fragment shader
  gl_PointSize = 2.0;
}
`
    );
    const fs = (
      /* glsl */
      `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-fragment

precision highp float;

#if NUM_CHANNELS == 1
flat in float values;
#elif NUM_CHANNELS == 2
flat in vec2 values;
#else
flat in vec3 values;
#endif

out vec4 fragColor;

void main() {
  vec3 value3;
#if NUM_CHANNELS == 3
  value3 = values;
#elif NUM_CHANNELS == 2
  value3.xy = values;
#else
  value3.x = values;
#endif
  if (isnan(value3.x)) discard;
  // This shader renders into a 2x1 texture with blending=max
  // The left pixel yields the max value of each channel
  // The right pixel yields the min value of each channel
  if (gl_FragCoord.x < 1.0) {
    fragColor = vec4(value3, 1.0);
  } else {
    fragColor = vec4(-value3, 1.0);
  }
}
`
    );
    return new import_engine2.BufferTransform(device, {
      vs,
      fs,
      topology: "point-list",
      modules: [aggregatorTransformUniforms],
      parameters: {
        blend: true,
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendColorOperation: "max",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one",
        blendAlphaOperation: "max"
      },
      defines: {
        // @ts-expect-error TODO fix luma type
        NUM_DIMS: props.dimensions,
        // @ts-expect-error TODO fix luma type
        NUM_CHANNELS: props.channelCount,
        // @ts-expect-error TODO fix luma type
        SAMPLER_WIDTH: TEXTURE_WIDTH
      },
      varyings: ["binIds", "values"],
      disableWarnings: true
    });
  }

  // src/common/aggregator/gpu-aggregator/webgl-aggregator.ts
  var import_core2 = __toESM(require_core(), 1);
  var WebGLAggregator = class {
    constructor(device, props) {
      this.binCount = 0;
      /** Cached outputs */
      this.binIds = null;
      this.results = [];
      this.device = device;
      this.dimensions = props.dimensions;
      this.channelCount = props.channelCount;
      this.props = {
        ...props,
        pointCount: 0,
        binIdRange: [[0, 0]],
        operations: [],
        attributes: {},
        binOptions: {}
      };
      this.needsUpdate = new Array(this.channelCount).fill(true);
      this.binSorter = new WebGLBinSorter(device, props);
      this.aggregationTransform = new WebGLAggregationTransform(device, props);
      this.setProps(props);
    }
    /** Checks if the current device supports GPU aggregation */
    static isSupported(device) {
      return device.features.has("float32-renderable-webgl") && device.features.has("texture-blend-float-webgl");
    }
    getBins() {
      const buffer = this.aggregationTransform.binBuffer;
      if (!buffer) {
        return null;
      }
      if (this.binIds?.buffer !== buffer) {
        this.binIds = { buffer, type: "float32", size: this.dimensions };
      }
      return this.binIds;
    }
    /** Returns an accessor to the output for a given channel. */
    getResult(channel) {
      const buffer = this.aggregationTransform.valueBuffer;
      if (!buffer || channel >= this.channelCount) {
        return null;
      }
      if (this.results[channel]?.buffer !== buffer) {
        this.results[channel] = {
          buffer,
          type: "float32",
          size: 1,
          stride: this.channelCount * 4,
          offset: channel * 4
        };
      }
      return this.results[channel];
    }
    /** Returns the [min, max] of aggregated values for a given channel. */
    getResultDomain(channel) {
      return this.aggregationTransform.domains[channel];
    }
    /** Returns the information for a given bin. */
    getBin(index) {
      if (index < 0 || index >= this.binCount) {
        return null;
      }
      const { binIdRange } = this.props;
      let id;
      if (this.dimensions === 1) {
        id = [index + binIdRange[0][0]];
      } else {
        const [[x0, x1], [y0]] = binIdRange;
        const width = x1 - x0;
        id = [index % width + x0, Math.floor(index / width) + y0];
      }
      const pixel = this.binSorter.getBinValues(index);
      if (!pixel) {
        return null;
      }
      const count2 = pixel[3];
      const value = [];
      for (let channel = 0; channel < this.channelCount; channel++) {
        const operation = this.props.operations[channel];
        if (operation === "COUNT") {
          value[channel] = count2;
        } else if (count2 === 0) {
          value[channel] = NaN;
        } else {
          value[channel] = operation === "MEAN" ? pixel[channel] / count2 : pixel[channel];
        }
      }
      return { id, value, count: count2 };
    }
    /** Release GPU resources */
    destroy() {
      this.binSorter.destroy();
      this.aggregationTransform.destroy();
    }
    /** Update aggregation props. Normalize prop values and set change flags. */
    // eslint-disable-next-line complexity, max-statements
    setProps(props) {
      const oldProps = this.props;
      if ("binIdRange" in props && !(0, import_core2._deepEqual)(props.binIdRange, oldProps.binIdRange, 2)) {
        const binIdRange = props.binIdRange;
        import_core2.log.assert(binIdRange.length === this.dimensions);
        if (this.dimensions === 1) {
          const [[x0, x1]] = binIdRange;
          this.binCount = x1 - x0;
        } else {
          const [[x0, x1], [y0, y1]] = binIdRange;
          this.binCount = (x1 - x0) * (y1 - y0);
        }
        this.binSorter.setDimensions(this.binCount, binIdRange);
        this.aggregationTransform.setDimensions(this.binCount, binIdRange);
        this.setNeedsUpdate();
      }
      if (props.operations) {
        for (let channel = 0; channel < this.channelCount; channel++) {
          if (props.operations[channel] !== oldProps.operations[channel]) {
            this.setNeedsUpdate(channel);
          }
        }
      }
      if (props.pointCount !== void 0 && props.pointCount !== oldProps.pointCount) {
        this.binSorter.setModelProps({ vertexCount: props.pointCount });
        this.setNeedsUpdate();
      }
      if (props.binOptions) {
        if (!(0, import_core2._deepEqual)(props.binOptions, oldProps.binOptions, 2)) {
          this.setNeedsUpdate();
        }
        this.binSorter.model.shaderInputs.setProps({ binOptions: props.binOptions });
      }
      if (props.attributes) {
        const attributeBuffers = {};
        const constantAttributes = {};
        for (const attribute of Object.values(props.attributes)) {
          for (const [attributeName, value] of Object.entries(attribute.getValue())) {
            if (ArrayBuffer.isView(value)) {
              constantAttributes[attributeName] = value;
            } else if (value) {
              attributeBuffers[attributeName] = value;
            }
          }
        }
        this.binSorter.setModelProps({ attributes: attributeBuffers, constantAttributes });
      }
      if (props.shaderModuleProps) {
        this.binSorter.setModelProps({ shaderModuleProps: props.shaderModuleProps });
      }
      Object.assign(this.props, props);
    }
    /** Flags a channel to need update.
     * This is called internally by setProps() if certain props change
     * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed
     * the underlying buffers could have been updated and require rerunning the aggregation
     * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.
     */
    setNeedsUpdate(channel) {
      if (channel === void 0) {
        this.needsUpdate.fill(true);
      } else {
        this.needsUpdate[channel] = true;
      }
    }
    update() {
    }
    /** Run aggregation */
    preDraw() {
      if (!this.needsUpdate.some(Boolean)) {
        return;
      }
      const { operations } = this.props;
      const operationsToUpdate = this.needsUpdate.map(
        (needsUpdate, i) => needsUpdate ? operations[i] : null
      );
      this.binSorter.update(operationsToUpdate);
      this.aggregationTransform.update(this.binSorter.texture, operations);
      for (let i = 0; i < this.channelCount; i++) {
        if (this.needsUpdate[i]) {
          this.needsUpdate[i] = false;
          this.props.onUpdate?.({ channel: i });
        }
      }
    }
  };

  // src/common/aggregation-layer.ts
  var import_core3 = __toESM(require_core(), 1);
  var AggregationLayer = class extends import_core3.CompositeLayer {
    /** Allow this layer to participates in the draw cycle */
    get isDrawable() {
      return true;
    }
    initializeState() {
      this.getAttributeManager().remove(["instancePickingColors"]);
    }
    // Extend Layer.updateState to update the Aggregator instance
    // returns true if aggregator is changed
    updateState(params) {
      super.updateState(params);
      const aggregatorType = this.getAggregatorType();
      if (params.changeFlags.extensionsChanged || this.state.aggregatorType !== aggregatorType) {
        this.state.aggregator?.destroy();
        const aggregator = this.createAggregator(aggregatorType);
        aggregator.setProps({
          attributes: this.getAttributeManager()?.attributes
        });
        this.setState({ aggregator, aggregatorType });
        return true;
      }
      return false;
    }
    // Override Layer.finalizeState to dispose the Aggregator instance
    finalizeState(context) {
      super.finalizeState(context);
      this.state.aggregator.destroy();
    }
    // Override Layer.updateAttributes to update the aggregator
    updateAttributes(changedAttributes) {
      const { aggregator } = this.state;
      aggregator.setProps({
        attributes: changedAttributes
      });
      for (const id in changedAttributes) {
        this.onAttributeChange(id);
      }
      aggregator.update();
    }
    draw({ shaderModuleProps }) {
      const { aggregator } = this.state;
      aggregator.setProps({ shaderModuleProps });
      aggregator.preDraw();
    }
    // override CompositeLayer._getAttributeManager to create AttributeManager instance
    _getAttributeManager() {
      return new import_core3.AttributeManager(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  };
  AggregationLayer.layerName = "AggregationLayer";

  // src/screen-grid-layer/screen-grid-cell-layer.ts
  var import_engine3 = __toESM(require_engine(), 1);
  var import_core4 = __toESM(require_core(), 1);

  // src/common/utils/color-utils.ts
  var defaultColorRange = [
    [255, 255, 178],
    [254, 217, 118],
    [254, 178, 76],
    [253, 141, 60],
    [240, 59, 32],
    [189, 0, 38]
  ];
  function colorRangeToFlatArray(colorRange, normalize = false, ArrayType = Float32Array) {
    let flatArray;
    if (Number.isFinite(colorRange[0])) {
      flatArray = new ArrayType(colorRange);
    } else {
      flatArray = new ArrayType(colorRange.length * 4);
      let index = 0;
      for (let i = 0; i < colorRange.length; i++) {
        const color = colorRange[i];
        flatArray[index++] = color[0];
        flatArray[index++] = color[1];
        flatArray[index++] = color[2];
        flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;
      }
    }
    if (normalize) {
      for (let i = 0; i < flatArray.length; i++) {
        flatArray[i] /= 255;
      }
    }
    return flatArray;
  }
  var COLOR_RANGE_FILTER = {
    linear: "linear",
    quantile: "nearest",
    quantize: "nearest",
    ordinal: "nearest"
  };
  function updateColorRangeTexture(texture, type) {
    texture.setSampler({
      minFilter: COLOR_RANGE_FILTER[type],
      magFilter: COLOR_RANGE_FILTER[type]
    });
  }
  function createColorRangeTexture(device, colorRange, type = "linear") {
    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);
    return device.createTexture({
      format: "rgba8unorm",
      sampler: {
        minFilter: COLOR_RANGE_FILTER[type],
        magFilter: COLOR_RANGE_FILTER[type],
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      },
      data: colors,
      width: colors.length / 4,
      height: 1
    });
  }

  // src/screen-grid-layer/screen-grid-layer-vertex.glsl.ts
  var screen_grid_layer_vertex_glsl_default = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME screen-grid-layer-vertex-shader
#define RANGE_COUNT 6

in vec2 positions;
in vec2 instancePositions;
in float instanceWeights;
in vec3 instancePickingColors;

uniform sampler2D colorRange;

out vec4 vColor;

vec4 interp(float value, vec2 domain, sampler2D range) {
  float r = (value - domain.x) / (domain.y - domain.x);
  return texture(range, vec2(r, 0.5));
}

void main(void) {
  if (isnan(instanceWeights)) {
    gl_Position = vec4(0.);
    return;
  }

  vec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;
  pos.x = pos.x - 1.0;
  pos.y = 1.0 - pos.y;

  gl_Position = vec4(pos, 0., 1.);

  vColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);
  vColor.a *= layer.opacity;

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);
}
`
  );

  // src/screen-grid-layer/screen-grid-layer-fragment.glsl.ts
  var screen_grid_layer_fragment_glsl_default = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME screen-grid-layer-fragment-shader

precision highp float;

in vec4 vColor;

out vec4 fragColor;

void main(void) {
  fragColor = vColor;

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`
  );

  // src/screen-grid-layer/screen-grid-layer-uniforms.ts
  var uniformBlock3 = (
    /* glsl */
    `uniform screenGridUniforms {
  vec2 cellSizeClipspace;
  vec2 gridSizeClipspace;
  vec2 colorDomain;
} screenGrid;
`
  );
  var screenGridUniforms = {
    name: "screenGrid",
    vs: uniformBlock3,
    uniformTypes: {
      cellSizeClipspace: "vec2<f32>",
      gridSizeClipspace: "vec2<f32>",
      colorDomain: "vec2<f32>"
    }
  };

  // src/screen-grid-layer/screen-grid-cell-layer.ts
  var ScreenGridCellLayer = class extends import_core4.Layer {
    getShaders() {
      return super.getShaders({ vs: screen_grid_layer_vertex_glsl_default, fs: screen_grid_layer_fragment_glsl_default, modules: [import_core4.picking, screenGridUniforms] });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 2,
          type: "float32",
          accessor: "getBin"
        },
        instanceWeights: {
          size: 1,
          type: "float32",
          accessor: "getWeight"
        }
      });
      this.state.model = this._getModel();
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const model = this.state.model;
      if (oldProps.colorRange !== props.colorRange) {
        this.state.colorTexture?.destroy();
        this.state.colorTexture = createColorRangeTexture(
          this.context.device,
          props.colorRange,
          props.colorScaleType
        );
        const screenGridProps = { colorRange: this.state.colorTexture };
        model.shaderInputs.setProps({ screenGrid: screenGridProps });
      } else if (oldProps.colorScaleType !== props.colorScaleType) {
        updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);
      }
      if (oldProps.cellMarginPixels !== props.cellMarginPixels || oldProps.cellSizePixels !== props.cellSizePixels || changeFlags.viewportChanged) {
        const { width, height } = this.context.viewport;
        const { cellSizePixels: gridSize, cellMarginPixels } = this.props;
        const cellSize = Math.max(gridSize - cellMarginPixels, 0);
        const screenGridProps = {
          gridSizeClipspace: [gridSize / width * 2, gridSize / height * 2],
          cellSizeClipspace: [cellSize / width * 2, cellSize / height * 2]
        };
        model.shaderInputs.setProps({ screenGrid: screenGridProps });
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.colorTexture?.destroy();
    }
    draw({ uniforms }) {
      const colorDomain = this.props.colorDomain();
      const model = this.state.model;
      const screenGridProps = { colorDomain };
      model.shaderInputs.setProps({ screenGrid: screenGridProps });
      model.draw(this.context.renderPass);
    }
    // Private Methods
    _getModel() {
      return new import_engine3.Model(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new import_engine3.Geometry({
          topology: "triangle-strip",
          attributes: {
            positions: {
              value: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),
              size: 2
            }
          }
        }),
        isInstanced: true
      });
    }
  };
  ScreenGridCellLayer.layerName = "ScreenGridCellLayer";

  // src/screen-grid-layer/bin-options-uniforms.ts
  var uniformBlock4 = (
    /* glsl */
    `uniform binOptionsUniforms {
  float cellSizePixels;
} binOptions;
`
  );
  var binOptionsUniforms = {
    name: "binOptions",
    vs: uniformBlock4,
    uniformTypes: {
      cellSizePixels: "f32"
    }
  };

  // src/screen-grid-layer/screen-grid-layer.ts
  var defaultProps = {
    cellSizePixels: { type: "number", value: 100, min: 1 },
    cellMarginPixels: { type: "number", value: 2, min: 0 },
    colorRange: defaultColorRange,
    colorScaleType: "linear",
    getPosition: { type: "accessor", value: (d) => d.position },
    getWeight: { type: "accessor", value: 1 },
    gpuAggregation: true,
    aggregation: "SUM"
  };
  var ScreenGridLayer = class extends AggregationLayer {
    getAggregatorType() {
      return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device) ? "gpu" : "cpu";
    }
    createAggregator(type) {
      if (type === "cpu" || !WebGLAggregator.isSupported(this.context.device)) {
        return new CPUAggregator({
          dimensions: 2,
          getBin: {
            sources: ["positions"],
            getValue: ({ positions }, index, opts) => {
              const viewport = this.context.viewport;
              const p = viewport.project(positions);
              const cellSizePixels = opts.cellSizePixels;
              if (p[0] < 0 || p[0] >= viewport.width || p[1] < 0 || p[1] >= viewport.height) {
                return null;
              }
              return [Math.floor(p[0] / cellSizePixels), Math.floor(p[1] / cellSizePixels)];
            }
          },
          getValue: [{ sources: ["counts"], getValue: ({ counts }) => counts }]
        });
      }
      return new WebGLAggregator(this.context.device, {
        dimensions: 2,
        channelCount: 1,
        bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),
        ...super.getShaders({
          modules: [import_core5.project32, binOptionsUniforms],
          vs: `
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;
  
  void getBin(out ivec2 binId) {
    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));
    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;
    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);
    binId = ivec2(gridCoords);
  }
  void getValue(out float weight) {
    weight = counts;
  }
  `
        })
      });
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        // this attribute is used in gpu aggregation path only
        counts: { size: 1, accessor: "getWeight" }
      });
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    updateState(params) {
      const aggregatorChanged = super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const { cellSizePixels, aggregation } = props;
      if (aggregatorChanged || changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.viewportChanged || aggregation !== oldProps.aggregation || cellSizePixels !== oldProps.cellSizePixels) {
        const { width, height } = this.context.viewport;
        const { aggregator } = this.state;
        if (aggregator instanceof WebGLAggregator) {
          aggregator.setProps({
            binIdRange: [
              [0, Math.ceil(width / cellSizePixels)],
              [0, Math.ceil(height / cellSizePixels)]
            ]
          });
        }
        aggregator.setProps({
          pointCount: this.getNumInstances(),
          operations: [aggregation],
          binOptions: {
            cellSizePixels
          }
        });
      }
      if (changeFlags.viewportChanged) {
        this.state.aggregator.setNeedsUpdate();
      }
      return aggregatorChanged;
    }
    onAttributeChange(id) {
      const { aggregator } = this.state;
      switch (id) {
        case "positions":
          aggregator.setNeedsUpdate();
          break;
        case "counts":
          aggregator.setNeedsUpdate(0);
          break;
        default:
      }
    }
    renderLayers() {
      const { aggregator } = this.state;
      const CellLayerClass = this.getSubLayerClass("cells", ScreenGridCellLayer);
      const binAttribute = aggregator.getBins();
      const weightAttribute = aggregator.getResult(0);
      return new CellLayerClass(
        this.props,
        this.getSubLayerProps({
          id: "cell-layer"
        }),
        {
          data: {
            length: aggregator.binCount,
            attributes: {
              getBin: binAttribute,
              getWeight: weightAttribute
            }
          },
          // Data has changed shallowly, but we likely don't need to update the attributes
          dataComparator: (data, oldData) => data.length === oldData.length,
          updateTriggers: {
            getBin: [binAttribute],
            getWeight: [weightAttribute]
          },
          parameters: {
            depthWriteEnabled: false,
            ...this.props.parameters
          },
          // Evaluate domain at draw() time
          colorDomain: () => this.props.colorDomain || aggregator.getResultDomain(0),
          // Extensions are already handled by the GPUAggregator, do not pass it down
          extensions: []
        }
      );
    }
    getPickingInfo(params) {
      const info = params.info;
      const { index } = info;
      if (index >= 0) {
        const bin = this.state.aggregator.getBin(index);
        let object;
        if (bin) {
          object = {
            col: bin.id[0],
            row: bin.id[1],
            value: bin.value[0],
            count: bin.count
          };
          if (bin.pointIndices) {
            object.pointIndices = bin.pointIndices;
            object.points = Array.isArray(this.props.data) ? bin.pointIndices.map((i) => this.props.data[i]) : [];
          }
        }
        info.object = object;
      }
      return info;
    }
  };
  ScreenGridLayer.layerName = "ScreenGridLayer";
  ScreenGridLayer.defaultProps = defaultProps;

  // src/hexagon-layer/hexagon-layer.ts
  var import_core6 = __toESM(require_core(), 1);

  // src/common/utils/scale-utils.ts
  var AttributeWithScale = class {
    constructor(input, inputLength) {
      this.props = {
        scaleType: "linear",
        lowerPercentile: 0,
        upperPercentile: 100
      };
      /** [min, max] of attribute values, or null if unknown */
      this.domain = null;
      /** Valid domain if lower/upper percentile are defined */
      this.cutoff = null;
      this.input = input;
      this.inputLength = inputLength;
      this.attribute = input;
    }
    getScalePercentile() {
      if (!this._percentile) {
        const value = getAttributeValue(this.input, this.inputLength);
        this._percentile = applyScaleQuantile(value);
      }
      return this._percentile;
    }
    getScaleOrdinal() {
      if (!this._ordinal) {
        const value = getAttributeValue(this.input, this.inputLength);
        this._ordinal = applyScaleOrdinal(value);
      }
      return this._ordinal;
    }
    /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */
    getCutoff({
      scaleType,
      lowerPercentile,
      upperPercentile
    }) {
      if (scaleType === "quantile") {
        return [lowerPercentile, upperPercentile - 1];
      }
      if (lowerPercentile > 0 || upperPercentile < 100) {
        const { domain: thresholds } = this.getScalePercentile();
        let lowValue = thresholds[Math.floor(lowerPercentile) - 1] ?? -Infinity;
        let highValue = thresholds[Math.floor(upperPercentile) - 1] ?? Infinity;
        if (scaleType === "ordinal") {
          const { domain: sortedUniqueValues } = this.getScaleOrdinal();
          lowValue = sortedUniqueValues.findIndex((x) => x >= lowValue);
          highValue = sortedUniqueValues.findIndex((x) => x > highValue) - 1;
          if (highValue === -2) {
            highValue = sortedUniqueValues.length - 1;
          }
        }
        return [lowValue, highValue];
      }
      return null;
    }
    update(props) {
      const oldProps = this.props;
      if (props.scaleType !== oldProps.scaleType) {
        switch (props.scaleType) {
          case "quantile": {
            const { attribute } = this.getScalePercentile();
            this.attribute = attribute;
            this.domain = [0, 99];
            break;
          }
          case "ordinal": {
            const { attribute, domain } = this.getScaleOrdinal();
            this.attribute = attribute;
            this.domain = [0, domain.length - 1];
            break;
          }
          default:
            this.attribute = this.input;
            this.domain = null;
        }
      }
      if (props.scaleType !== oldProps.scaleType || props.lowerPercentile !== oldProps.lowerPercentile || props.upperPercentile !== oldProps.upperPercentile) {
        this.cutoff = this.getCutoff(props);
      }
      this.props = props;
      return this;
    }
  };
  function applyScaleOrdinal(values) {
    const uniqueValues = /* @__PURE__ */ new Set();
    for (const x of values) {
      if (Number.isFinite(x)) {
        uniqueValues.add(x);
      }
    }
    const sortedUniqueValues = Array.from(uniqueValues).sort();
    const domainMap = /* @__PURE__ */ new Map();
    for (let i = 0; i < sortedUniqueValues.length; i++) {
      domainMap.set(sortedUniqueValues[i], i);
    }
    return {
      attribute: {
        value: values.map((x) => Number.isFinite(x) ? domainMap.get(x) : NaN),
        type: "float32",
        size: 1
      },
      domain: sortedUniqueValues
    };
  }
  function applyScaleQuantile(values, rangeLength = 100) {
    const sortedValues = Array.from(values).filter(Number.isFinite).sort(ascending);
    let i = 0;
    const n = Math.max(1, rangeLength);
    const thresholds = new Array(n - 1);
    while (++i < n) {
      thresholds[i - 1] = threshold(sortedValues, i / n);
    }
    return {
      attribute: {
        value: values.map((x) => Number.isFinite(x) ? bisectRight(thresholds, x) : NaN),
        type: "float32",
        size: 1
      },
      domain: thresholds
    };
  }
  function getAttributeValue(attribute, length) {
    const elementStride = (attribute.stride ?? 4) / 4;
    const elementOffset = (attribute.offset ?? 0) / 4;
    let value = attribute.value;
    if (!value) {
      const bytes = attribute.buffer?.readSyncWebGL(0, elementStride * 4 * length);
      if (bytes) {
        value = new Float32Array(bytes.buffer);
        attribute.value = value;
      }
    }
    if (elementStride === 1) {
      return value.subarray(0, length);
    }
    const result = new Float32Array(length);
    for (let i = 0; i < length; i++) {
      result[i] = value[i * elementStride + elementOffset];
    }
    return result;
  }
  function ascending(a, b) {
    return a - b;
  }
  function threshold(domain, fraction) {
    const domainLength = domain.length;
    if (fraction <= 0 || domainLength < 2) {
      return domain[0];
    }
    if (fraction >= 1) {
      return domain[domainLength - 1];
    }
    const domainFraction = (domainLength - 1) * fraction;
    const lowIndex = Math.floor(domainFraction);
    const low = domain[lowIndex];
    const high = domain[lowIndex + 1];
    return low + (high - low) * (domainFraction - lowIndex);
  }
  function bisectRight(a, x) {
    let lo = 0;
    let hi = a.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (a[mid] > x) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    return lo;
  }

  // src/common/utils/bounds-utils.ts
  function getBinIdRange({
    dataBounds,
    getBinId,
    padding = 0
  }) {
    const corners = [
      dataBounds[0],
      dataBounds[1],
      [dataBounds[0][0], dataBounds[1][1]],
      [dataBounds[1][0], dataBounds[0][1]]
    ].map((p) => getBinId(p));
    const minX = Math.min(...corners.map((p) => p[0])) - padding;
    const minY = Math.min(...corners.map((p) => p[1])) - padding;
    const maxX = Math.max(...corners.map((p) => p[0])) + padding + 1;
    const maxY = Math.max(...corners.map((p) => p[1])) + padding + 1;
    return [
      [minX, maxX],
      [minY, maxY]
    ];
  }

  // src/hexagon-layer/hexagon-cell-layer.ts
  var import_layers2 = __toESM(require_layers(), 1);

  // src/hexagon-layer/hexbin.ts
  var THIRD_PI = Math.PI / 3;
  var DIST_X = 2 * Math.sin(THIRD_PI);
  var DIST_Y = 1.5;
  var HexbinVertices = Array.from({ length: 6 }, (_, i) => {
    const angle = i * THIRD_PI;
    return [Math.sin(angle), -Math.cos(angle)];
  });
  function pointToHexbin([px, py], radius) {
    let pj = Math.round(py = py / radius / DIST_Y);
    let pi = Math.round(px = px / radius / DIST_X - (pj & 1) / 2);
    const py1 = py - pj;
    if (Math.abs(py1) * 3 > 1) {
      const px1 = px - pi;
      const pi2 = pi + (px < pi ? -1 : 1) / 2;
      const pj2 = pj + (py < pj ? -1 : 1);
      const px2 = px - pi2;
      const py2 = py - pj2;
      if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) {
        pi = pi2 + (pj & 1 ? 1 : -1) / 2;
        pj = pj2;
      }
    }
    return [pi, pj];
  }
  var pointToHexbinGLSL = (
    /* glsl */
    `
const vec2 DIST = vec2(${DIST_X}, ${DIST_Y});

ivec2 pointToHexbin(vec2 p, float radius) {
  p /= radius * DIST;
  float pj = round(p.y);
  float pjm2 = mod(pj, 2.0);
  p.x -= pjm2 * 0.5;
  float pi = round(p.x);
  vec2 d1 = p - vec2(pi, pj);

  if (abs(d1.y) * 3. > 1.) {
    vec2 v2 = step(0.0, d1) - 0.5;
    v2.y *= 2.0;
    vec2 d2 = d1 - v2;
    if (dot(d1, d1) > dot(d2, d2)) {
      pi += v2.x + pjm2 - 0.5;
      pj += v2.y;
    }
  }
  return ivec2(pi, pj);
}
`
  );
  function getHexbinCentroid([i, j], radius) {
    return [(i + (j & 1) / 2) * radius * DIST_X, j * radius * DIST_Y];
  }
  var getHexbinCentroidGLSL = `
const vec2 DIST = vec2(${DIST_X}, ${DIST_Y});

vec2 hexbinCentroid(vec2 binId, float radius) {
  binId.x += fract(binId.y * 0.5);
  return binId * DIST * radius;
}
`;

  // src/hexagon-layer/hexagon-cell-layer-vertex.glsl.ts
  var hexagon_cell_layer_vertex_glsl_default = (
    /* glsl */
    `#version 300 es
#define SHADER_NAME hexagon-cell-layer-vertex-shader

in vec3 positions;
in vec3 normals;

in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;

uniform sampler2D colorRange;

// Result
out vec4 vColor;

${getHexbinCentroidGLSL}

float interp(float value, vec2 domain, vec2 range) {
  float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
  return mix(range.x, range.y, r);
}

vec4 interp(float value, vec2 domain, sampler2D range) {
  float r = (value - domain.x) / (domain.y - domain.x);
  return texture(range, vec2(r, 0.5));
}

void main(void) {
  geometry.pickingColor = instancePickingColors;

  if (isnan(instanceColorValues) ||
    instanceColorValues < hexagon.colorDomain.z ||
    instanceColorValues > hexagon.colorDomain.w ||
    instanceElevationValues < hexagon.elevationDomain.z ||
    instanceElevationValues > hexagon.elevationDomain.w
  ) {
    gl_Position = vec4(0.);
    return;
  }
  
  vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);
  commonPosition += positions.xy * column.radius * column.coverage;
  geometry.position = vec4(commonPosition, 0.0, 1.0);
  geometry.normal = project_normal(normals);

  // calculate z, if 3d not enabled set to 0
  float elevation = 0.0;
  if (column.extruded) {
    elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);
    elevation = project_size(elevation);
    // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1
    geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
  }

  gl_Position = project_common_position_to_clipspace(geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);
  vColor.a *= layer.opacity;
  if (column.extruded) {
    vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`
  );

  // src/hexagon-layer/hexagon-layer-uniforms.ts
  var uniformBlock5 = (
    /* glsl */
    `uniform hexagonUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
} hexagon;
`
  );
  var hexagonUniforms = {
    name: "hexagon",
    vs: uniformBlock5,
    uniformTypes: {
      colorDomain: "vec4<f32>",
      elevationDomain: "vec4<f32>",
      elevationRange: "vec2<f32>",
      originCommon: "vec2<f32>"
    }
  };

  // src/hexagon-layer/hexagon-cell-layer.ts
  var HexagonCellLayer = class extends import_layers2.ColumnLayer {
    getShaders() {
      const shaders = super.getShaders();
      shaders.modules.push(hexagonUniforms);
      return { ...shaders, vs: hexagon_cell_layer_vertex_glsl_default };
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.remove([
        "instanceElevations",
        "instanceFillColors",
        "instanceLineColors",
        "instanceStrokeWidths"
      ]);
      attributeManager.addInstanced({
        instancePositions: {
          size: 2,
          type: "float32",
          accessor: "getBin"
        },
        instanceColorValues: {
          size: 1,
          type: "float32",
          accessor: "getColorValue"
        },
        instanceElevationValues: {
          size: 1,
          type: "float32",
          accessor: "getElevationValue"
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      const model = this.state.fillModel;
      if (oldProps.colorRange !== props.colorRange) {
        this.state.colorTexture?.destroy();
        this.state.colorTexture = createColorRangeTexture(
          this.context.device,
          props.colorRange,
          props.colorScaleType
        );
        const hexagonProps = { colorRange: this.state.colorTexture };
        model.shaderInputs.setProps({ hexagon: hexagonProps });
      } else if (oldProps.colorScaleType !== props.colorScaleType) {
        updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.colorTexture?.destroy();
    }
    draw({ uniforms }) {
      const {
        radius,
        hexOriginCommon,
        elevationRange,
        elevationScale,
        extruded,
        coverage,
        colorDomain,
        elevationDomain
      } = this.props;
      const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];
      const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];
      const fillModel = this.state.fillModel;
      if (fillModel.vertexArray.indexBuffer) {
        fillModel.setIndexBuffer(null);
      }
      fillModel.setVertexCount(this.state.fillVertexCount);
      const hexagonProps = {
        colorDomain: [
          Math.max(colorDomain[0], colorCutoff[0]),
          // instanceColorValue that maps to colorRange[0]
          Math.min(colorDomain[1], colorCutoff[1]),
          // instanceColorValue that maps to colorRange[colorRange.length - 1]
          Math.max(colorDomain[0] - 1, colorCutoff[0]),
          // hide cell if instanceColorValue is less than this
          Math.min(colorDomain[1] + 1, colorCutoff[1])
          // hide cell if instanceColorValue is greater than this
        ],
        elevationDomain: [
          Math.max(elevationDomain[0], elevationCutoff[0]),
          // instanceElevationValue that maps to elevationRange[0]
          Math.min(elevationDomain[1], elevationCutoff[1]),
          // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]
          Math.max(elevationDomain[0] - 1, elevationCutoff[0]),
          // hide cell if instanceElevationValue is less than this
          Math.min(elevationDomain[1] + 1, elevationCutoff[1])
          // hide cell if instanceElevationValue is greater than this
        ],
        elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],
        originCommon: hexOriginCommon
      };
      fillModel.shaderInputs.setProps({
        column: { extruded, coverage, radius },
        hexagon: hexagonProps
      });
      fillModel.draw(this.context.renderPass);
    }
  };
  HexagonCellLayer.layerName = "HexagonCellLayer";

  // src/hexagon-layer/bin-options-uniforms.ts
  var uniformBlock6 = (
    /* glsl */
    `uniform binOptionsUniforms {
  vec2 hexOriginCommon;
  float radiusCommon;
} binOptions;
`
  );
  var binOptionsUniforms2 = {
    name: "binOptions",
    vs: uniformBlock6,
    uniformTypes: {
      hexOriginCommon: "vec2<f32>",
      radiusCommon: "f32"
    }
  };

  // src/hexagon-layer/hexagon-layer.ts
  function noop() {
  }
  var defaultProps2 = {
    gpuAggregation: true,
    // color
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorValue: { type: "accessor", value: null },
    // default value is calculated from `getColorWeight` and `colorAggregation`
    getColorWeight: { type: "accessor", value: 1 },
    colorAggregation: "SUM",
    lowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    upperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    colorScaleType: "quantize",
    onSetColorDomain: noop,
    // elevation
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationValue: { type: "accessor", value: null },
    // default value is calculated from `getElevationWeight` and `elevationAggregation`
    getElevationWeight: { type: "accessor", value: 1 },
    elevationAggregation: "SUM",
    elevationScale: { type: "number", min: 0, value: 1 },
    elevationLowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    elevationUpperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    elevationScaleType: "linear",
    onSetElevationDomain: noop,
    // hexbin
    radius: { type: "number", min: 1, value: 1e3 },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    getPosition: { type: "accessor", value: (x) => x.position },
    hexagonAggregator: { type: "function", optional: true, value: null },
    extruded: false,
    // Optional material for 'lighting' shader module
    material: true
  };
  var HexagonLayer = class extends AggregationLayer {
    getAggregatorType() {
      const { gpuAggregation, hexagonAggregator, getColorValue, getElevationValue } = this.props;
      if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {
        import_core6.log.warn("Features not supported by GPU aggregation, falling back to CPU")();
        return "cpu";
      }
      if (
        // GPU aggregation is requested
        gpuAggregation && // GPU aggregation is supported by the device
        WebGLAggregator.isSupported(this.context.device)
      ) {
        return "gpu";
      }
      return "cpu";
    }
    createAggregator(type) {
      if (type === "cpu") {
        const { hexagonAggregator, radius } = this.props;
        return new CPUAggregator({
          dimensions: 2,
          getBin: {
            sources: ["positions"],
            getValue: ({ positions }, index, opts) => {
              if (hexagonAggregator) {
                return hexagonAggregator(positions, radius);
              }
              const viewport = this.state.aggregatorViewport;
              const p = viewport.projectPosition(positions);
              const { radiusCommon, hexOriginCommon } = opts;
              return pointToHexbin(
                [p[0] - hexOriginCommon[0], p[1] - hexOriginCommon[1]],
                radiusCommon
              );
            }
          },
          getValue: [
            { sources: ["colorWeights"], getValue: ({ colorWeights }) => colorWeights },
            { sources: ["elevationWeights"], getValue: ({ elevationWeights }) => elevationWeights }
          ]
        });
      }
      return new WebGLAggregator(this.context.device, {
        dimensions: 2,
        channelCount: 2,
        bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),
        ...super.getShaders({
          modules: [import_core6.project32, binOptionsUniforms2],
          vs: (
            /* glsl */
            `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;
  
  ${pointToHexbinGLSL}

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
          )
        })
      });
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        colorWeights: { size: 1, accessor: "getColorWeight" },
        elevationWeights: { size: 1, accessor: "getElevationWeight" }
      });
    }
    // eslint-disable-next-line complexity
    updateState(params) {
      const aggregatorChanged = super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const { aggregator } = this.state;
      if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {
        this.state.dataAsArray = Array.from((0, import_core6.createIterable)(props.data).iterable);
      }
      if (aggregatorChanged || changeFlags.dataChanged || props.radius !== oldProps.radius || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {
        this._updateBinOptions();
        const { radiusCommon, hexOriginCommon, binIdRange, dataAsArray } = this.state;
        aggregator.setProps({
          // @ts-expect-error only used by GPUAggregator
          binIdRange,
          pointCount: this.getNumInstances(),
          operations: [props.colorAggregation, props.elevationAggregation],
          binOptions: {
            radiusCommon,
            hexOriginCommon
          },
          onUpdate: this._onAggregationUpdate.bind(this)
        });
        if (dataAsArray) {
          const { getColorValue, getElevationValue } = this.props;
          aggregator.setProps({
            // @ts-expect-error only used by CPUAggregator
            customOperations: [
              getColorValue && ((indices) => getColorValue(
                indices.map((i) => dataAsArray[i]),
                { indices, data: props.data }
              )),
              getElevationValue && ((indices) => getElevationValue(
                indices.map((i) => dataAsArray[i]),
                { indices, data: props.data }
              ))
            ]
          });
        }
      }
      if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {
        aggregator.setNeedsUpdate(0);
      }
      if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {
        aggregator.setNeedsUpdate(1);
      }
      return aggregatorChanged;
    }
    _updateBinOptions() {
      const bounds = this.getBounds();
      let radiusCommon = 1;
      let hexOriginCommon = [0, 0];
      let binIdRange = [
        [0, 1],
        [0, 1]
      ];
      let viewport = this.context.viewport;
      if (bounds && Number.isFinite(bounds[0][0])) {
        let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
        const { radius } = this.props;
        const { unitsPerMeter } = viewport.getDistanceScales(centroid);
        radiusCommon = unitsPerMeter[0] * radius;
        const centerHex = pointToHexbin(viewport.projectFlat(centroid), radiusCommon);
        centroid = viewport.unprojectFlat(getHexbinCentroid(centerHex, radiusCommon));
        const ViewportType = viewport.constructor;
        viewport = viewport.isGeospatial ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 }) : new import_core6.Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });
        hexOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];
        binIdRange = getBinIdRange({
          dataBounds: bounds,
          getBinId: (p) => {
            const positionCommon = viewport.projectFlat(p);
            positionCommon[0] -= hexOriginCommon[0];
            positionCommon[1] -= hexOriginCommon[1];
            return pointToHexbin(positionCommon, radiusCommon);
          },
          padding: 1
        });
      }
      this.setState({ radiusCommon, hexOriginCommon, binIdRange, aggregatorViewport: viewport });
    }
    draw(opts) {
      if (opts.shaderModuleProps.project) {
        opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;
      }
      super.draw(opts);
    }
    _onAggregationUpdate({ channel }) {
      const props = this.getCurrentLayer().props;
      const { aggregator } = this.state;
      if (channel === 0) {
        const result = aggregator.getResult(0);
        this.setState({
          colors: new AttributeWithScale(result, aggregator.binCount)
        });
        props.onSetColorDomain(aggregator.getResultDomain(0));
      } else if (channel === 1) {
        const result = aggregator.getResult(1);
        this.setState({
          elevations: new AttributeWithScale(result, aggregator.binCount)
        });
        props.onSetElevationDomain(aggregator.getResultDomain(1));
      }
    }
    onAttributeChange(id) {
      const { aggregator } = this.state;
      switch (id) {
        case "positions":
          aggregator.setNeedsUpdate();
          this._updateBinOptions();
          const { radiusCommon, hexOriginCommon, binIdRange } = this.state;
          aggregator.setProps({
            // @ts-expect-error only used by GPUAggregator
            binIdRange,
            binOptions: {
              radiusCommon,
              hexOriginCommon
            }
          });
          break;
        case "colorWeights":
          aggregator.setNeedsUpdate(0);
          break;
        case "elevationWeights":
          aggregator.setNeedsUpdate(1);
          break;
        default:
      }
    }
    renderLayers() {
      const { aggregator, radiusCommon, hexOriginCommon } = this.state;
      const {
        elevationScale,
        colorRange,
        elevationRange,
        extruded,
        coverage,
        material,
        transitions,
        colorScaleType,
        lowerPercentile,
        upperPercentile,
        colorDomain,
        elevationScaleType,
        elevationLowerPercentile,
        elevationUpperPercentile,
        elevationDomain
      } = this.props;
      const CellLayerClass = this.getSubLayerClass("cells", HexagonCellLayer);
      const binAttribute = aggregator.getBins();
      const colors = this.state.colors?.update({
        scaleType: colorScaleType,
        lowerPercentile,
        upperPercentile
      });
      const elevations = this.state.elevations?.update({
        scaleType: elevationScaleType,
        lowerPercentile: elevationLowerPercentile,
        upperPercentile: elevationUpperPercentile
      });
      if (!colors || !elevations) {
        return null;
      }
      return new CellLayerClass(
        this.getSubLayerProps({
          id: "cells"
        }),
        {
          data: {
            length: aggregator.binCount,
            attributes: {
              getBin: binAttribute,
              getColorValue: colors.attribute,
              getElevationValue: elevations.attribute
            }
          },
          // Data has changed shallowly, but we likely don't need to update the attributes
          dataComparator: (data, oldData) => data.length === oldData.length,
          updateTriggers: {
            getBin: [binAttribute],
            getColorValue: [colors.attribute],
            getElevationValue: [elevations.attribute]
          },
          diskResolution: 6,
          vertices: HexbinVertices,
          radius: radiusCommon,
          hexOriginCommon,
          elevationScale,
          colorRange,
          colorScaleType,
          elevationRange,
          extruded,
          coverage,
          material,
          colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),
          elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),
          colorCutoff: colors.cutoff,
          elevationCutoff: elevations.cutoff,
          transitions: transitions && {
            getFillColor: transitions.getColorValue || transitions.getColorWeight,
            getElevation: transitions.getElevationValue || transitions.getElevationWeight
          },
          // Extensions are already handled by the GPUAggregator, do not pass it down
          extensions: []
        }
      );
    }
    getPickingInfo(params) {
      const info = params.info;
      const { index } = info;
      if (index >= 0) {
        const bin = this.state.aggregator.getBin(index);
        let object;
        if (bin) {
          const centroidCommon = getHexbinCentroid(
            bin.id,
            this.state.radiusCommon
          );
          const centroid = this.context.viewport.unprojectFlat(centroidCommon);
          object = {
            col: bin.id[0],
            row: bin.id[1],
            position: centroid,
            colorValue: bin.value[0],
            elevationValue: bin.value[1],
            count: bin.count
          };
          if (bin.pointIndices) {
            object.pointIndices = bin.pointIndices;
            object.points = Array.isArray(this.props.data) ? bin.pointIndices.map((i) => this.props.data[i]) : [];
          }
        }
        info.object = object;
      }
      return info;
    }
  };
  HexagonLayer.layerName = "HexagonLayer";
  HexagonLayer.defaultProps = defaultProps2;

  // src/contour-layer/contour-layer.ts
  var import_core7 = __toESM(require_core(), 1);
  var import_layers3 = __toESM(require_layers(), 1);

  // src/contour-layer/marching-squares-codes.ts
  var HALF = 0.5;
  var ONE6TH = 1 / 6;
  var OFFSET = {
    N: [0, HALF],
    // NORTH
    E: [HALF, 0],
    // EAST
    S: [0, -HALF],
    // SOUTH
    W: [-HALF, 0],
    // WEST
    // CORNERS
    NE: [HALF, HALF],
    NW: [-HALF, HALF],
    SE: [HALF, -HALF],
    SW: [-HALF, -HALF]
  };
  var SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];
  var SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];
  var NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];
  var NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];
  var SW_TRAPEZOID = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF]
  ];
  var SE_TRAPEZOID = [
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [HALF, -ONE6TH],
    [HALF, ONE6TH]
  ];
  var NE_TRAPEZOID = [
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var NW_TRAPEZOID = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];
  var E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];
  var W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];
  var EW_RECTANGEL = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [HALF, -ONE6TH],
    [HALF, ONE6TH]
  ];
  var SN_RECTANGEL = [
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];
  var SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];
  var SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];
  var NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];
  var NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
  var NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];
  var SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];
  var SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];
  var NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];
  var SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];
  var S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];
  var E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];
  var N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];
  var W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];
  var SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];
  var NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];
  var NE_HEPTAGON = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    OFFSET.E,
    OFFSET.NE,
    OFFSET.N
  ];
  var SW_HEPTAGON = [
    OFFSET.W,
    OFFSET.SW,
    OFFSET.S,
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var NW_HEPTAGON = [
    OFFSET.NW,
    OFFSET.W,
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    OFFSET.N
  ];
  var SE_HEPTAGON = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    OFFSET.S,
    OFFSET.SE,
    OFFSET.E,
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var OCTAGON = [
    [-HALF, ONE6TH],
    [-HALF, -ONE6TH],
    [-ONE6TH, -HALF],
    [ONE6TH, -HALF],
    [HALF, -ONE6TH],
    [HALF, ONE6TH],
    [ONE6TH, HALF],
    [-ONE6TH, HALF]
  ];
  var ISOLINES_CODE_OFFSET_MAP = {
    // key is equal to the code of 4 vertices (invert the code specified in wiki)
    // value can be an array or an Object
    // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]
    // Object : to handle saddle cases, whos output depends on mean value of all 4 corners
    //  key: code of mean value (0 or 1)
    //  value: Array , as above defines one or two line segments
    0: [],
    1: [[OFFSET.W, OFFSET.S]],
    2: [[OFFSET.S, OFFSET.E]],
    3: [[OFFSET.W, OFFSET.E]],
    4: [[OFFSET.N, OFFSET.E]],
    5: {
      0: [
        [OFFSET.W, OFFSET.S],
        [OFFSET.N, OFFSET.E]
      ],
      1: [
        [OFFSET.W, OFFSET.N],
        [OFFSET.S, OFFSET.E]
      ]
    },
    6: [[OFFSET.N, OFFSET.S]],
    7: [[OFFSET.W, OFFSET.N]],
    8: [[OFFSET.W, OFFSET.N]],
    9: [[OFFSET.N, OFFSET.S]],
    10: {
      0: [
        [OFFSET.W, OFFSET.N],
        [OFFSET.S, OFFSET.E]
      ],
      1: [
        [OFFSET.W, OFFSET.S],
        [OFFSET.N, OFFSET.E]
      ]
    },
    11: [[OFFSET.N, OFFSET.E]],
    12: [[OFFSET.W, OFFSET.E]],
    13: [[OFFSET.S, OFFSET.E]],
    14: [[OFFSET.W, OFFSET.S]],
    15: []
  };
  function ternaryToIndex(ternary) {
    return parseInt(ternary, 4);
  }
  var ISOBANDS_CODE_OFFSET_MAP = {
    // Below list of cases, follow the same order as in above mentioned wiki page.
    // Each case has its code on first commented line // T,TR,R,C
    // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2
    // final code is binary representation of above code , where takes 2 digits
    // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169
    // no contours
    [ternaryToIndex("0000")]: [],
    [ternaryToIndex("2222")]: [],
    // single triangle
    [ternaryToIndex("2221")]: [SW_TRIANGLE],
    [ternaryToIndex("2212")]: [SE_TRIANGLE],
    [ternaryToIndex("2122")]: [NE_TRIANGLE],
    [ternaryToIndex("1222")]: [NW_TRIANGLE],
    [ternaryToIndex("0001")]: [SW_TRIANGLE],
    [ternaryToIndex("0010")]: [SE_TRIANGLE],
    [ternaryToIndex("0100")]: [NE_TRIANGLE],
    [ternaryToIndex("1000")]: [NW_TRIANGLE],
    // single trapezoid
    [ternaryToIndex("2220")]: [SW_TRAPEZOID],
    [ternaryToIndex("2202")]: [SE_TRAPEZOID],
    [ternaryToIndex("2022")]: [NE_TRAPEZOID],
    [ternaryToIndex("0222")]: [NW_TRAPEZOID],
    [ternaryToIndex("0002")]: [SW_TRAPEZOID],
    [ternaryToIndex("0020")]: [SE_TRAPEZOID],
    [ternaryToIndex("0200")]: [NE_TRAPEZOID],
    [ternaryToIndex("2000")]: [NW_TRAPEZOID],
    // single rectangle
    [ternaryToIndex("0011")]: [S_RECTANGLE],
    [ternaryToIndex("0110")]: [E_RECTANGLE],
    [ternaryToIndex("1100")]: [N_RECTANGLE],
    [ternaryToIndex("1001")]: [W_RECTANGLE],
    [ternaryToIndex("2211")]: [S_RECTANGLE],
    [ternaryToIndex("2112")]: [E_RECTANGLE],
    [ternaryToIndex("1122")]: [N_RECTANGLE],
    [ternaryToIndex("1221")]: [W_RECTANGLE],
    [ternaryToIndex("2200")]: [EW_RECTANGEL],
    [ternaryToIndex("2002")]: [SN_RECTANGEL],
    [ternaryToIndex("0022")]: [EW_RECTANGEL],
    [ternaryToIndex("0220")]: [SN_RECTANGEL],
    // single square
    // 1111
    [ternaryToIndex("1111")]: [SQUARE],
    // single pentagon
    [ternaryToIndex("1211")]: [SW_PENTAGON],
    [ternaryToIndex("2111")]: [SE_PENTAGON],
    [ternaryToIndex("1112")]: [NE_PENTAGON],
    [ternaryToIndex("1121")]: [NW_PENTAGON],
    [ternaryToIndex("1011")]: [SW_PENTAGON],
    [ternaryToIndex("0111")]: [SE_PENTAGON],
    [ternaryToIndex("1110")]: [NE_PENTAGON],
    [ternaryToIndex("1101")]: [NW_PENTAGON],
    [ternaryToIndex("1200")]: [NW_N_PENTAGON],
    [ternaryToIndex("0120")]: [NE_E_PENTAGON],
    [ternaryToIndex("0012")]: [SE_S_PENTAGON],
    [ternaryToIndex("2001")]: [SW_W_PENTAGON],
    [ternaryToIndex("1022")]: [NW_N_PENTAGON],
    [ternaryToIndex("2102")]: [NE_E_PENTAGON],
    [ternaryToIndex("2210")]: [SE_S_PENTAGON],
    [ternaryToIndex("0221")]: [SW_W_PENTAGON],
    [ternaryToIndex("1002")]: [NW_W_PENTAGON],
    [ternaryToIndex("2100")]: [NE_N_PENTAGON],
    [ternaryToIndex("0210")]: [SE_E_PENTAGON],
    [ternaryToIndex("0021")]: [SW_S_PENTAGON],
    [ternaryToIndex("1220")]: [NW_W_PENTAGON],
    [ternaryToIndex("0122")]: [NE_N_PENTAGON],
    [ternaryToIndex("2012")]: [SE_E_PENTAGON],
    [ternaryToIndex("2201")]: [SW_S_PENTAGON],
    // single hexagon
    [ternaryToIndex("0211")]: [S_HEXAGON],
    [ternaryToIndex("2110")]: [E_HEXAGON],
    [ternaryToIndex("1102")]: [N_HEXAGON],
    [ternaryToIndex("1021")]: [W_HEXAGON],
    [ternaryToIndex("2011")]: [S_HEXAGON],
    [ternaryToIndex("0112")]: [E_HEXAGON],
    [ternaryToIndex("1120")]: [N_HEXAGON],
    [ternaryToIndex("1201")]: [W_HEXAGON],
    [ternaryToIndex("2101")]: [SW_NE_HEXAGON],
    [ternaryToIndex("0121")]: [SW_NE_HEXAGON],
    [ternaryToIndex("1012")]: [NW_SE_HEXAGON],
    [ternaryToIndex("1210")]: [NW_SE_HEXAGON],
    // 6-sided polygons based on mean weight
    // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)
    [ternaryToIndex("0101")]: {
      0: [SW_TRIANGLE, NE_TRIANGLE],
      1: [SW_NE_HEXAGON],
      2: [SW_NE_HEXAGON]
    },
    [ternaryToIndex("1010")]: {
      0: [NW_TRIANGLE, SE_TRIANGLE],
      1: [NW_SE_HEXAGON],
      2: [NW_SE_HEXAGON]
    },
    [ternaryToIndex("2121")]: {
      0: [SW_NE_HEXAGON],
      1: [SW_NE_HEXAGON],
      2: [SW_TRIANGLE, NE_TRIANGLE]
    },
    [ternaryToIndex("1212")]: {
      0: [NW_SE_HEXAGON],
      1: [NW_SE_HEXAGON],
      2: [NW_TRIANGLE, SE_TRIANGLE]
    },
    // 7-sided polygons based on mean weight
    [ternaryToIndex("2120")]: {
      0: [NE_HEPTAGON],
      1: [NE_HEPTAGON],
      2: [SW_TRAPEZOID, NE_TRIANGLE]
    },
    [ternaryToIndex("2021")]: {
      0: [SW_HEPTAGON],
      1: [SW_HEPTAGON],
      2: [SW_TRIANGLE, NE_TRAPEZOID]
    },
    [ternaryToIndex("1202")]: {
      0: [NW_HEPTAGON],
      1: [NW_HEPTAGON],
      2: [NW_TRIANGLE, SE_TRAPEZOID]
    },
    [ternaryToIndex("0212")]: {
      0: [SE_HEPTAGON],
      1: [SE_HEPTAGON],
      2: [SE_TRIANGLE, NW_TRAPEZOID]
    },
    [ternaryToIndex("0102")]: {
      0: [SW_TRAPEZOID, NE_TRIANGLE],
      1: [NE_HEPTAGON],
      2: [NE_HEPTAGON]
    },
    [ternaryToIndex("0201")]: {
      0: [SW_TRIANGLE, NE_TRAPEZOID],
      1: [SW_HEPTAGON],
      2: [SW_HEPTAGON]
    },
    [ternaryToIndex("1020")]: {
      0: [NW_TRIANGLE, SE_TRAPEZOID],
      1: [NW_HEPTAGON],
      2: [NW_HEPTAGON]
    },
    [ternaryToIndex("2010")]: {
      0: [SE_TRIANGLE, NW_TRAPEZOID],
      1: [SE_HEPTAGON],
      2: [SE_HEPTAGON]
    },
    // 8-sided polygons based on mean weight
    [ternaryToIndex("2020")]: {
      0: [NW_TRAPEZOID, SE_TRAPEZOID],
      1: [OCTAGON],
      2: [SW_TRAPEZOID, NE_TRAPEZOID]
    },
    [ternaryToIndex("0202")]: {
      0: [NE_TRAPEZOID, SW_TRAPEZOID],
      1: [OCTAGON],
      2: [NW_TRAPEZOID, SE_TRAPEZOID]
    }
  };

  // src/contour-layer/marching-squares.ts
  function getVertexCode(weight, threshold2) {
    if (Number.isNaN(weight)) {
      return 0;
    }
    if (Array.isArray(threshold2)) {
      if (weight < threshold2[0]) {
        return 0;
      }
      return weight < threshold2[1] ? 1 : 2;
    }
    return weight >= threshold2 ? 1 : 0;
  }
  function getCode(opts) {
    const { x, y, xRange, yRange, getValue, threshold: threshold2 } = opts;
    const isLeftBoundary = x < xRange[0];
    const isRightBoundary = x >= xRange[1] - 1;
    const isBottomBoundary = y < yRange[0];
    const isTopBoundary = y >= yRange[1] - 1;
    const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;
    let weights = 0;
    let current;
    let right;
    let top;
    let topRight;
    if (isLeftBoundary || isTopBoundary) {
      top = 0;
    } else {
      const w = getValue(x, y + 1);
      top = getVertexCode(w, threshold2);
      weights += w;
    }
    if (isRightBoundary || isTopBoundary) {
      topRight = 0;
    } else {
      const w = getValue(x + 1, y + 1);
      topRight = getVertexCode(w, threshold2);
      weights += w;
    }
    if (isRightBoundary || isBottomBoundary) {
      right = 0;
    } else {
      const w = getValue(x + 1, y);
      right = getVertexCode(w, threshold2);
      weights += w;
    }
    if (isLeftBoundary || isBottomBoundary) {
      current = 0;
    } else {
      const w = getValue(x, y);
      current = getVertexCode(w, threshold2);
      weights += w;
    }
    let code = -1;
    if (Number.isFinite(threshold2)) {
      code = top << 3 | topRight << 2 | right << 1 | current;
    }
    if (Array.isArray(threshold2)) {
      code = top << 6 | topRight << 4 | right << 2 | current;
    }
    let meanCode = 0;
    if (!isBoundary) {
      meanCode = getVertexCode(weights / 4, threshold2);
    }
    return { code, meanCode };
  }
  function getPolygons(opts) {
    const { x, y, z, code, meanCode } = opts;
    let offsets = ISOBANDS_CODE_OFFSET_MAP[code];
    if (!Array.isArray(offsets)) {
      offsets = offsets[meanCode];
    }
    const rX = x + 1;
    const rY = y + 1;
    const polygons = [];
    offsets.forEach((polygonOffsets) => {
      const polygon = [];
      polygonOffsets.forEach((xyOffset) => {
        const vX = rX + xyOffset[0];
        const vY = rY + xyOffset[1];
        polygon.push([vX, vY, z]);
      });
      polygons.push(polygon);
    });
    return polygons;
  }
  function getLines(opts) {
    const { x, y, z, code, meanCode } = opts;
    let offsets = ISOLINES_CODE_OFFSET_MAP[code];
    if (!Array.isArray(offsets)) {
      offsets = offsets[meanCode];
    }
    const rX = x + 1;
    const rY = y + 1;
    const lines = [];
    offsets.forEach((xyOffsets) => {
      xyOffsets.forEach((offset) => {
        const vX = rX + offset[0];
        const vY = rY + offset[1];
        lines.push([vX, vY, z]);
      });
    });
    return lines;
  }

  // src/contour-layer/contour-utils.ts
  function generateContours({
    contours,
    getValue,
    xRange,
    yRange
  }) {
    const contourLines = [];
    const contourPolygons = [];
    let segmentIndex = 0;
    let polygonIndex = 0;
    for (let i = 0; i < contours.length; i++) {
      const contour = contours[i];
      const z = contour.zIndex ?? i;
      const { threshold: threshold2 } = contour;
      for (let x = xRange[0] - 1; x < xRange[1]; x++) {
        for (let y = yRange[0] - 1; y < yRange[1]; y++) {
          const { code, meanCode } = getCode({
            getValue,
            threshold: threshold2,
            x,
            y,
            xRange,
            yRange
          });
          const opts = {
            x,
            y,
            z,
            code,
            meanCode
          };
          if (Array.isArray(threshold2)) {
            const polygons = getPolygons(opts);
            for (const polygon of polygons) {
              contourPolygons[polygonIndex++] = {
                vertices: polygon,
                contour
              };
            }
          } else {
            const path = getLines(opts);
            if (path.length > 0) {
              contourLines[segmentIndex++] = {
                vertices: path,
                contour
              };
            }
          }
        }
      }
    }
    return { lines: contourLines, polygons: contourPolygons };
  }

  // src/contour-layer/value-reader.ts
  function getAggregatorValueReader(opts) {
    const { aggregator, binIdRange, channel } = opts;
    if (aggregator instanceof WebGLAggregator) {
      const buffer = aggregator.getResult(channel)?.buffer;
      if (buffer) {
        const values = new Float32Array(buffer.readSyncWebGL().buffer);
        return getWebGLAggregatorValueReader(values, binIdRange);
      }
    }
    if (aggregator instanceof CPUAggregator) {
      const values = aggregator.getResult(channel)?.value;
      const ids = aggregator.getBins()?.value;
      if (ids && values) {
        return getCPUAggregatorValueReader(values, ids, aggregator.binCount);
      }
    }
    return null;
  }
  function getWebGLAggregatorValueReader(values, binIdRange) {
    const [[minX, maxX], [minY, maxY]] = binIdRange;
    const width = maxX - minX;
    const height = maxY - minY;
    return (x, y) => {
      x -= minX;
      y -= minY;
      if (x < 0 || x >= width || y < 0 || y >= height) {
        return NaN;
      }
      return values[y * width + x];
    };
  }
  function getCPUAggregatorValueReader(values, ids, count2) {
    const idMap = {};
    for (let i = 0; i < count2; i++) {
      const x = ids[i * 2];
      const y = ids[i * 2 + 1];
      idMap[x] = idMap[x] || {};
      idMap[x][y] = values[i];
    }
    return (x, y) => idMap[x]?.[y] ?? NaN;
  }

  // ../../node_modules/@math.gl/core/dist/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var DEFAULT_CONFIG = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || { config: { ...DEFAULT_CONFIG } };
  var config = globalThis.mathgl.config;
  function formatValue(value, { precision = config.precision } = {}) {
    value = round(value);
    return `${parseFloat(value.toPrecision(precision))}`;
  }
  function isArray(value) {
    return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
  }
  function equals(a, b, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a === b) {
        return true;
      }
      if (isArray(a) && isArray(b)) {
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; ++i) {
          if (!equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (a && a.equals) {
        return a.equals(b);
      }
      if (b && b.equals) {
        return b.equals(a);
      }
      if (typeof a === "number" && typeof b === "number") {
        return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round(value) {
    return Math.round(value / config.EPSILON) * config.EPSILON;
  }

  // ../../node_modules/@math.gl/core/dist/classes/base/math-array.js
  var MathArray = class extends Array {
    // Common methods
    /**
     * Clone the current object
     * @returns a new copy of this object
     */
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array, offset = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        targetArray[offset + i] = this[i];
      }
      return targetArray;
    }
    toObject(targetObject) {
      return targetObject;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : (
        // @ts-ignore
        this.fromObject(arrayOrObject)
      );
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target) {
      return target ? this.to(target) : this;
    }
    /** @deprecated */
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    /** Formats string according to options */
    formatString(opts) {
      let string = "";
      for (let i = 0; i < this.ELEMENTS; ++i) {
        string += (i > 0 ? ", " : "") + formatValue(this[i], opts);
      }
      return `${opts.printTypes ? this.constructor.name : ""}[${string}]`;
    }
    equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        if (!equals(this[i], array[i])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        if (this[i] !== array[i]) {
          return false;
        }
      }
      return true;
    }
    // Modifiers
    /** Negates all values in this object */
    negate() {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = -this[i];
      }
      return this.check();
    }
    lerp(a, b, t) {
      if (t === void 0) {
        return this.lerp(this, a, b);
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        const ai = a[i];
        const endValue = typeof b === "number" ? b : b[i];
        this[i] = ai + t * (endValue - ai);
      }
      return this.check();
    }
    /** Minimal */
    min(vector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(vector[i], this[i]);
      }
      return this.check();
    }
    /** Maximal */
    max(vector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.max(vector[i], this[i]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] += vector[i];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] -= vector[i];
        }
      }
      return this.check();
    }
    scale(scale2) {
      if (typeof scale2 === "number") {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= scale2;
        }
      } else {
        for (let i = 0; i < this.ELEMENTS && i < scale2.length; ++i) {
          this[i] *= scale2[i];
        }
      }
      return this.check();
    }
    /**
     * Multiplies all elements by `scale`
     * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
     */
    multiplyByScalar(scalar) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }
      return this.check();
    }
    // Debug checks
    /** Throws an error if array length is incorrect or contains illegal values */
    check() {
      if (config.debug && !this.validate()) {
        throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      }
      return this;
    }
    /** Returns false if the array length is incorrect or contains illegal values */
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        valid = valid && Number.isFinite(this[i]);
      }
      return valid;
    }
    // three.js compatibility
    /** @deprecated */
    sub(a) {
      return this.subtract(a);
    }
    /** @deprecated */
    setScalar(a) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = a;
      }
      return this.check();
    }
    /** @deprecated */
    addScalar(a) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += a;
      }
      return this.check();
    }
    /** @deprecated */
    subScalar(a) {
      return this.addScalar(-a);
    }
    /** @deprecated */
    multiplyScalar(scalar) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }
      return this.check();
    }
    /** @deprecated */
    divideScalar(a) {
      return this.multiplyByScalar(1 / a);
    }
    /** @deprecated */
    clampScalar(min2, max2) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], min2), max2);
      }
      return this.check();
    }
    /** @deprecated */
    get elements() {
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/lib/validators.js
  function validateVector(v, length) {
    if (v.length !== length) {
      return false;
    }
    for (let i = 0; i < v.length; ++i) {
      if (!Number.isFinite(v[i])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value) {
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid number ${JSON.stringify(value)}`);
    }
    return value;
  }
  function checkVector(v, length, callerName = "") {
    if (config.debug && !validateVector(v, length)) {
      throw new Error(`math.gl: ${callerName} some fields set to invalid numbers'`);
    }
    return v;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree = Math.PI / 180;

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec2.js
  function create() {
    const out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function transformMat4(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  var forEach = function() {
    const vec = create();
    return function(a, stride, offset, count2, fn, arg) {
      let i;
      let l;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l = Math.min(count2 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }
      return a;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a, m) {
    const x = a[0];
    const y = a[1];
    const w = m[3] * x + m[7] * y || 1;
    out[0] = (m[0] * x + m[4] * y) / w;
    out[1] = (m[1] * x + m[5] * y) / w;
    return out;
  }
  function vec3_transformMat4AsVector(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const w = m[3] * x + m[7] * y + m[11] * z || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec3.js
  function create2() {
    const out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function transformMat42(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    let w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  var forEach2 = function() {
    const vec = create2();
    return function(a, stride, offset, count2, fn, arg) {
      let i;
      let l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l = Math.min(count2 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/base/matrix.js
  var Matrix = class extends MathArray {
    // fromObject(object) {
    //   const array = object.elements;
    //   return this.fromRowMajor(array);
    // }
    // toObject(object) {
    //   const array = object.elements;
    //   this.toRowMajor(array);
    //   return object;
    // }
    // TODO better override formatString?
    toString() {
      let string = "[";
      if (config.printRowMajor) {
        string += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string += ` ${this[col * this.RANK + row]}`;
          }
        }
      } else {
        string += "column-major:";
        for (let i = 0; i < this.ELEMENTS; ++i) {
          string += ` ${this[i]}`;
        }
      }
      string += "]";
      return string;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    // By default assumes row major indices
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    // By default assumes row major indices
    setElement(row, col, value) {
      this[col * this.RANK + row] = checkNumber(value);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i = 0; i < this.RANK; ++i) {
        result[i] = this[firstIndex + i];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i = 0; i < this.RANK; ++i) {
        this[firstIndex + i] = columnVector[i];
      }
      return this;
    }
  };

  // ../../node_modules/@math.gl/core/dist/gl-matrix/mat4.js
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a12 = a[6];
      const a13 = a[7];
      const a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  function invert(out, a) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant(a) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  function multiply(out, a, b) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function scale(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function rotate(out, a, rad, axis) {
    let x = axis[0];
    let y = axis[1];
    let z = axis[2];
    let len = Math.sqrt(x * x + y * y + z * z);
    let c;
    let s;
    let t;
    let a00;
    let a01;
    let a02;
    let a03;
    let a10;
    let a11;
    let a12;
    let a13;
    let a20;
    let a21;
    let a22;
    let a23;
    let b00;
    let b01;
    let b02;
    let b10;
    let b11;
    let b12;
    let b20;
    let b21;
    let b22;
    if (len < EPSILON) {
      return null;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  function rotateX(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ(out, a, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function fromQuat(out, q) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const yx = y * x2;
    const yy = y * y2;
    const zx = z * x2;
    const zy = z * y2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    const f = 1 / Math.tan(fovy / 2);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function orthoNO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function lookAt(out, eye, center, up) {
    let len;
    let x0;
    let x1;
    let x2;
    let y0;
    let y1;
    let y2;
    let z0;
    let z1;
    let z2;
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }

  // ../../node_modules/@math.gl/core/dist/gl-matrix/vec4.js
  function create3() {
    const out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function transformMat43(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  var forEach3 = function() {
    const vec = create3();
    return function(a, stride, offset, count2, fn, arg) {
      let i;
      let l;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l = Math.min(count2 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }
      return a;
    };
  }();

  // ../../node_modules/@math.gl/core/dist/classes/matrix4.js
  var INDICES;
  (function(INDICES2) {
    INDICES2[INDICES2["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES2[INDICES2["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES2[INDICES2["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES2[INDICES2["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES2[INDICES2["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES2[INDICES2["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES2[INDICES2["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES2[INDICES2["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES2[INDICES2["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES2[INDICES2["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES2[INDICES2["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES2[INDICES2["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES2[INDICES2["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES2[INDICES2["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES2[INDICES2["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES2[INDICES2["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES || (INDICES = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array)) {
        this.copy(array);
      } else {
        this.identity();
      }
    }
    copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
    // eslint-disable-next-line max-params
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    // accepts row major order, stores as column major
    // eslint-disable-next-line max-params
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    // Constructors
    /** Set to identity matrix */
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    /**
     *
     * @param object
     * @returns self
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fromObject(object) {
      return this.check();
    }
    /**
     * Calculates a 4x4 matrix from the given quaternion
     * @param quaternion Quaternion to create matrix from
     * @returns self
     */
    fromQuaternion(quaternion) {
      fromQuat(this, quaternion);
      return this.check();
    }
    /**
     * Generates a frustum matrix with the given bounds
     * @param view.left - Left bound of the frustum
     * @param view.right - Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top - Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far - Far bound of the frustum. Can be set to Infinity.
     * @returns self
     */
    frustum(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        frustum(this, left, right, bottom, top, near, far);
      }
      return this.check();
    }
    /**
     * Generates a look-at matrix with the given eye position, focal point,
     * and up axis
     * @param view.eye - (vector) Position of the viewer
     * @param view.center - (vector) Point the viewer is looking at
     * @param view.up - (vector) Up axis
     * @returns self
     */
    lookAt(view) {
      const { eye, center = [0, 0, 0], up = [0, 1, 0] } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    /**
     * Generates a orthogonal projection matrix with the given bounds
     * from "traditional" view space parameters
     * @param view.left - Left bound of the frustum
     * @param view.right number  Right bound of the frustum
     * @param view.bottom - Bottom bound of the frustum
     * @param view.top number  Top bound of the frustum
     * @param view.near - Near bound of the frustum
     * @param view.far number  Far bound of the frustum
     * @returns self
     */
    ortho(view) {
      const { left, right, bottom, top, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      ortho(this, left, right, bottom, top, near, far);
      return this.check();
    }
    /**
     * Generates an orthogonal projection matrix with the same parameters
     * as a perspective matrix (plus focalDistance)
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. Typically viewport width / viewport height
     * @param view.focalDistance Distance in the view frustum used for extent calculations
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    orthographic(view) {
      const { fovy = DEFAULT_FOVY, aspect = DEFAULT_ASPECT, focalDistance = 1, near = DEFAULT_NEAR, far = DEFAULT_FAR } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top = focalDistance * Math.tan(halfY);
      const right = top * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top,
        top,
        near,
        far
      });
    }
    /**
     * Generates a perspective projection matrix with the given bounds
     * @param view.fovy Vertical field of view in radians
     * @param view.aspect Aspect ratio. typically viewport width/height
     * @param view.near Near bound of the frustum
     * @param view.far Far bound of the frustum
     * @returns self
     */
    perspective(view) {
      const { fovy = 45 * Math.PI / 180, aspect = 1, near = 0.1, far = 500 } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    // Accessors
    determinant() {
      return determinant(this);
    }
    /**
     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
     * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
     * @param result
     * @returns self
     */
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    /**
     * Gets the translation portion, assuming the matrix is a affine transformation matrix.
     * @param result
     * @returns self
     */
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    /**
     * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale2 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale2[0];
      const inverseScale1 = 1 / scale2[1];
      const inverseScale2 = 1 / scale2[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    /**
     *
     * @param result
     * @param scaleResult
     * @returns self
     */
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale2 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale2[0];
      const inverseScale1 = 1 / scale2[1];
      const inverseScale2 = 1 / scale2[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    // Modifiers
    transpose() {
      transpose(this, this);
      return this.check();
    }
    invert() {
      invert(this, this);
      return this.check();
    }
    // Operations
    multiplyLeft(a) {
      multiply(this, a, this);
      return this.check();
    }
    multiplyRight(a) {
      multiply(this, this, a);
      return this.check();
    }
    // Rotates a matrix by the given angle around the X axis
    rotateX(radians) {
      rotateX(this, this, radians);
      return this.check();
    }
    // Rotates a matrix by the given angle around the Y axis.
    rotateY(radians) {
      rotateY(this, this, radians);
      return this.check();
    }
    /**
     * Rotates a matrix by the given angle around the Z axis.
     * @param radians
     * @returns self
     */
    rotateZ(radians) {
      rotateZ(this, this, radians);
      return this.check();
    }
    /**
     *
     * @param param0
     * @returns self
     */
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    /**
     *
     * @param radians
     * @param axis
     * @returns self
     */
    rotateAxis(radians, axis) {
      rotate(this, this, radians, axis);
      return this.check();
    }
    /**
     *
     * @param factor
     * @returns self
     */
    scale(factor) {
      scale(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    /**
     *
     * @param vec
     * @returns self
     */
    translate(vector) {
      translate(this, this, vector);
      return this.check();
    }
    // Transforms
    /**
     * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
     * @param vector
     * @param result
     * @returns self
     */
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat43(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    /**
     * Transforms any 2 or 3 element array as point (w implicitly 1)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsPoint(vector, result) {
      const { length } = vector;
      let out;
      switch (length) {
        case 2:
          out = transformMat4(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat42(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    /**
     * Transforms any 2 or 3 element array as vector (w implicitly 0)
     * @param vector
     * @param result
     * @returns self
     */
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    /** @deprecated */
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    /** @deprecated */
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    // three.js math API compatibility
    makeRotationX(radians) {
      return this.identity().rotateX(radians);
    }
    makeTranslation(x, y, z) {
      return this.identity().translate([x, y, z]);
    }
  };
  var ZERO;
  var IDENTITY;
  function getZeroMatrix() {
    if (!ZERO) {
      ZERO = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO);
    }
    return ZERO;
  }
  function getIdentityMatrix() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
    const column0Row0 = 2 * near / (right - left);
    const column1Row1 = 2 * near / (top - bottom);
    const column2Row0 = (right + left) / (right - left);
    const column2Row1 = (top + bottom) / (top - bottom);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // src/contour-layer/bin-options-uniforms.ts
  var uniformBlock7 = (
    /* glsl */
    `uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`
  );
  var binOptionsUniforms3 = {
    name: "binOptions",
    vs: uniformBlock7,
    uniformTypes: {
      cellOriginCommon: "vec2<f32>",
      cellSizeCommon: "vec2<f32>"
    }
  };

  // src/contour-layer/contour-layer.ts
  var DEFAULT_COLOR = [255, 255, 255, 255];
  var DEFAULT_STROKE_WIDTH = 1;
  var defaultProps3 = {
    // grid aggregation
    cellSize: { type: "number", min: 1, value: 1e3 },
    gridOrigin: { type: "array", compare: true, value: [0, 0] },
    getPosition: { type: "accessor", value: (x) => x.position },
    getWeight: { type: "accessor", value: 1 },
    gpuAggregation: true,
    aggregation: "SUM",
    // contour lines
    contours: {
      type: "object",
      value: [{ threshold: 1 }],
      optional: true,
      compare: 3
    },
    zOffset: 5e-3
  };
  var GridLayer = class extends AggregationLayer {
    getAggregatorType() {
      return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device) ? "gpu" : "cpu";
    }
    createAggregator(type) {
      if (type === "cpu") {
        return new CPUAggregator({
          dimensions: 2,
          getBin: {
            sources: ["positions"],
            getValue: ({ positions }, index, opts) => {
              const viewport = this.state.aggregatorViewport;
              const p = viewport.projectPosition(positions);
              const { cellSizeCommon, cellOriginCommon } = opts;
              return [
                Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
                Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])
              ];
            }
          },
          getValue: [{ sources: ["counts"], getValue: ({ counts }) => counts }],
          onUpdate: this._onAggregationUpdate.bind(this)
        });
      }
      return new WebGLAggregator(this.context.device, {
        dimensions: 2,
        channelCount: 1,
        bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),
        ...super.getShaders({
          modules: [import_core7.project32, binOptionsUniforms3],
          vs: (
            /* glsl */
            `
  in vec3 positions;
  in vec3 positions64Low;
  in float counts;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out float value) {
    value = counts;
  }
  `
          )
        }),
        onUpdate: this._onAggregationUpdate.bind(this)
      });
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        counts: { size: 1, accessor: "getWeight" }
      });
    }
    updateState(params) {
      const aggregatorChanged = super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const { aggregator } = this.state;
      if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || !(0, import_core7._deepEqual)(props.gridOrigin, oldProps.gridOrigin, 1) || props.aggregation !== oldProps.aggregation) {
        this._updateBinOptions();
        const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;
        aggregator.setProps({
          // @ts-expect-error only used by GPUAggregator
          binIdRange,
          pointCount: this.getNumInstances(),
          operations: [props.aggregation],
          binOptions: {
            cellSizeCommon,
            cellOriginCommon
          }
        });
      }
      if (!(0, import_core7._deepEqual)(oldProps.contours, props.contours, 2)) {
        this.setState({ contourData: null });
      }
      return aggregatorChanged;
    }
    _updateBinOptions() {
      const bounds = this.getBounds();
      const cellSizeCommon = [1, 1];
      let cellOriginCommon = [0, 0];
      let binIdRange = [
        [0, 1],
        [0, 1]
      ];
      let viewport = this.context.viewport;
      if (bounds && Number.isFinite(bounds[0][0])) {
        let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
        const { cellSize, gridOrigin } = this.props;
        const { unitsPerMeter } = viewport.getDistanceScales(centroid);
        cellSizeCommon[0] = unitsPerMeter[0] * cellSize;
        cellSizeCommon[1] = unitsPerMeter[1] * cellSize;
        const centroidCommon = viewport.projectFlat(centroid);
        cellOriginCommon = [
          Math.floor((centroidCommon[0] - gridOrigin[0]) / cellSizeCommon[0]) * cellSizeCommon[0] + gridOrigin[0],
          Math.floor((centroidCommon[1] - gridOrigin[1]) / cellSizeCommon[1]) * cellSizeCommon[1] + gridOrigin[1]
        ];
        centroid = viewport.unprojectFlat(cellOriginCommon);
        const ViewportType = viewport.constructor;
        viewport = viewport.isGeospatial ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 }) : new import_core7.Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });
        cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];
        binIdRange = getBinIdRange({
          dataBounds: bounds,
          getBinId: (p) => {
            const positionCommon = viewport.projectFlat(p);
            return [
              Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
              Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])
            ];
          }
        });
      }
      this.setState({ cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport });
    }
    draw(opts) {
      if (opts.shaderModuleProps.project) {
        opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;
      }
      super.draw(opts);
    }
    _onAggregationUpdate() {
      const { aggregator, binIdRange } = this.state;
      this.setState({
        aggregatedValueReader: getAggregatorValueReader({ aggregator, binIdRange, channel: 0 }),
        contourData: null
      });
    }
    _getContours() {
      const { aggregatedValueReader } = this.state;
      if (!aggregatedValueReader) {
        return null;
      }
      if (!this.state.contourData) {
        const { binIdRange } = this.state;
        const { contours } = this.props;
        const contourData = generateContours({
          contours,
          getValue: aggregatedValueReader,
          xRange: binIdRange[0],
          yRange: binIdRange[1]
        });
        this.state.contourData = contourData;
      }
      return this.state.contourData;
    }
    onAttributeChange(id) {
      const { aggregator } = this.state;
      switch (id) {
        case "positions":
          aggregator.setNeedsUpdate();
          this._updateBinOptions();
          const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;
          aggregator.setProps({
            // @ts-expect-error only used by GPUAggregator
            binIdRange,
            binOptions: {
              cellSizeCommon,
              cellOriginCommon
            }
          });
          break;
        case "counts":
          aggregator.setNeedsUpdate(0);
          break;
        default:
      }
    }
    renderLayers() {
      const contourData = this._getContours();
      if (!contourData) {
        return null;
      }
      const { lines, polygons } = contourData;
      const { zOffset } = this.props;
      const { cellOriginCommon, cellSizeCommon } = this.state;
      const LinesSubLayerClass = this.getSubLayerClass("lines", import_layers3.PathLayer);
      const BandsSubLayerClass = this.getSubLayerClass("bands", import_layers3.SolidPolygonLayer);
      const modelMatrix = new Matrix4().translate([cellOriginCommon[0], cellOriginCommon[1], 0]).scale([cellSizeCommon[0], cellSizeCommon[1], zOffset]);
      const lineLayer = lines && lines.length > 0 && new LinesSubLayerClass(
        this.getSubLayerProps({
          id: "lines"
        }),
        {
          data: lines,
          coordinateSystem: import_core7.COORDINATE_SYSTEM.CARTESIAN,
          modelMatrix,
          getPath: (d) => d.vertices,
          getColor: (d) => d.contour.color ?? DEFAULT_COLOR,
          getWidth: (d) => d.contour.strokeWidth ?? DEFAULT_STROKE_WIDTH,
          widthUnits: "pixels"
        }
      );
      const bandsLayer = polygons && polygons.length > 0 && new BandsSubLayerClass(
        this.getSubLayerProps({
          id: "bands"
        }),
        {
          data: polygons,
          coordinateSystem: import_core7.COORDINATE_SYSTEM.CARTESIAN,
          modelMatrix,
          getPolygon: (d) => d.vertices,
          getFillColor: (d) => d.contour.color ?? DEFAULT_COLOR
        }
      );
      return [lineLayer, bandsLayer];
    }
    getPickingInfo(params) {
      const info = params.info;
      const { object } = info;
      if (object) {
        info.object = {
          contour: object.contour
        };
      }
      return info;
    }
  };
  GridLayer.layerName = "ContourLayer";
  GridLayer.defaultProps = defaultProps3;

  // src/grid-layer/grid-layer.ts
  var import_core9 = __toESM(require_core(), 1);

  // src/grid-layer/grid-cell-layer.ts
  var import_layers4 = __toESM(require_layers(), 1);
  var import_engine4 = __toESM(require_engine(), 1);

  // src/grid-layer/grid-cell-layer-vertex.glsl.ts
  var grid_cell_layer_vertex_glsl_default = (
    /* glsl */
    `#version 300 es

#define SHADER_NAME grid-cell-layer-vertex-shader

in vec3 positions;
in vec3 normals;

in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;

uniform sampler2D colorRange;

// Result
out vec4 vColor;

float interp(float value, vec2 domain, vec2 range) {
  float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
  return mix(range.x, range.y, r);
}

vec4 interp(float value, vec2 domain, sampler2D range) {
  float r = (value - domain.x) / (domain.y - domain.x);
  return texture(range, vec2(r, 0.5));
}

void main(void) {
  geometry.pickingColor = instancePickingColors;

  if (isnan(instanceColorValues) ||
    instanceColorValues < grid.colorDomain.z ||
    instanceColorValues > grid.colorDomain.w ||
    instanceElevationValues < grid.elevationDomain.z ||
    instanceElevationValues > grid.elevationDomain.w
  ) {
    gl_Position = vec4(0.);
    return;
  }
  
  vec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;
  geometry.position = vec4(commonPosition, 0.0, 1.0);
  geometry.normal = project_normal(normals);

  // calculate z, if 3d not enabled set to 0
  float elevation = 0.0;
  if (column.extruded) {
    elevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);
    elevation = project_size(elevation);
    // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1
    geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
  }

  gl_Position = project_common_position_to_clipspace(geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  vColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);
  vColor.a *= layer.opacity;
  if (column.extruded) {
    vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
  }
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`
  );

  // src/grid-layer/grid-layer-uniforms.ts
  var uniformBlock8 = (
    /* glsl */
    `uniform gridUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
  vec2 sizeCommon;
} grid;
`
  );
  var gridUniforms = {
    name: "grid",
    vs: uniformBlock8,
    uniformTypes: {
      colorDomain: "vec4<f32>",
      elevationDomain: "vec4<f32>",
      elevationRange: "vec2<f32>",
      originCommon: "vec2<f32>",
      sizeCommon: "vec2<f32>"
    }
  };

  // src/grid-layer/grid-cell-layer.ts
  var GridCellLayer = class extends import_layers4.ColumnLayer {
    getShaders() {
      const shaders = super.getShaders();
      shaders.modules.push(gridUniforms);
      return { ...shaders, vs: grid_cell_layer_vertex_glsl_default };
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.remove([
        "instanceElevations",
        "instanceFillColors",
        "instanceLineColors",
        "instanceStrokeWidths"
      ]);
      attributeManager.addInstanced({
        instancePositions: {
          size: 2,
          type: "float32",
          accessor: "getBin"
        },
        instanceColorValues: {
          size: 1,
          type: "float32",
          accessor: "getColorValue"
        },
        instanceElevationValues: {
          size: 1,
          type: "float32",
          accessor: "getElevationValue"
        }
      });
    }
    updateState(params) {
      super.updateState(params);
      const { props, oldProps } = params;
      const model = this.state.fillModel;
      if (oldProps.colorRange !== props.colorRange) {
        this.state.colorTexture?.destroy();
        this.state.colorTexture = createColorRangeTexture(
          this.context.device,
          props.colorRange,
          props.colorScaleType
        );
        const gridProps = { colorRange: this.state.colorTexture };
        model.shaderInputs.setProps({ grid: gridProps });
      } else if (oldProps.colorScaleType !== props.colorScaleType) {
        updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);
      }
    }
    finalizeState(context) {
      super.finalizeState(context);
      this.state.colorTexture?.destroy();
    }
    _updateGeometry() {
      const geometry = new import_engine4.CubeGeometry();
      this.state.fillModel.setGeometry(geometry);
    }
    draw({ uniforms }) {
      const {
        cellOriginCommon,
        cellSizeCommon,
        elevationRange,
        elevationScale,
        extruded,
        coverage,
        colorDomain,
        elevationDomain
      } = this.props;
      const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];
      const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];
      const fillModel = this.state.fillModel;
      const gridProps = {
        colorDomain: [
          Math.max(colorDomain[0], colorCutoff[0]),
          // instanceColorValue that maps to colorRange[0]
          Math.min(colorDomain[1], colorCutoff[1]),
          // instanceColorValue that maps to colorRange[colorRange.length - 1]
          Math.max(colorDomain[0] - 1, colorCutoff[0]),
          // hide cell if instanceColorValue is less than this
          Math.min(colorDomain[1] + 1, colorCutoff[1])
          // hide cell if instanceColorValue is greater than this
        ],
        elevationDomain: [
          Math.max(elevationDomain[0], elevationCutoff[0]),
          // instanceElevationValue that maps to elevationRange[0]
          Math.min(elevationDomain[1], elevationCutoff[1]),
          // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]
          Math.max(elevationDomain[0] - 1, elevationCutoff[0]),
          // hide cell if instanceElevationValue is less than this
          Math.min(elevationDomain[1] + 1, elevationCutoff[1])
          // hide cell if instanceElevationValue is greater than this
        ],
        elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],
        originCommon: cellOriginCommon,
        sizeCommon: cellSizeCommon
      };
      fillModel.shaderInputs.setProps({
        column: { extruded, coverage },
        grid: gridProps
      });
      fillModel.draw(this.context.renderPass);
    }
  };
  GridCellLayer.layerName = "GridCellLayer";

  // src/grid-layer/bin-options-uniforms.ts
  var uniformBlock9 = (
    /* glsl */
    `uniform binOptionsUniforms {
  vec2 cellOriginCommon;
  vec2 cellSizeCommon;
} binOptions;
`
  );
  var binOptionsUniforms4 = {
    name: "binOptions",
    vs: uniformBlock9,
    uniformTypes: {
      cellOriginCommon: "vec2<f32>",
      cellSizeCommon: "vec2<f32>"
    }
  };

  // src/grid-layer/grid-layer.ts
  function noop2() {
  }
  var defaultProps4 = {
    gpuAggregation: true,
    // color
    colorDomain: null,
    colorRange: defaultColorRange,
    getColorValue: { type: "accessor", value: null },
    // default value is calculated from `getColorWeight` and `colorAggregation`
    getColorWeight: { type: "accessor", value: 1 },
    colorAggregation: "SUM",
    lowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    upperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    colorScaleType: "quantize",
    onSetColorDomain: noop2,
    // elevation
    elevationDomain: null,
    elevationRange: [0, 1e3],
    getElevationValue: { type: "accessor", value: null },
    // default value is calculated from `getElevationWeight` and `elevationAggregation`
    getElevationWeight: { type: "accessor", value: 1 },
    elevationAggregation: "SUM",
    elevationScale: { type: "number", min: 0, value: 1 },
    elevationLowerPercentile: { type: "number", min: 0, max: 100, value: 0 },
    elevationUpperPercentile: { type: "number", min: 0, max: 100, value: 100 },
    elevationScaleType: "linear",
    onSetElevationDomain: noop2,
    // grid
    cellSize: { type: "number", min: 0, value: 1e3 },
    coverage: { type: "number", min: 0, max: 1, value: 1 },
    getPosition: { type: "accessor", value: (x) => x.position },
    gridAggregator: { type: "function", optional: true, value: null },
    extruded: false,
    // Optional material for 'lighting' shader module
    material: true
  };
  var GridLayer2 = class extends AggregationLayer {
    getAggregatorType() {
      const { gpuAggregation, gridAggregator, getColorValue, getElevationValue } = this.props;
      if (gpuAggregation && (gridAggregator || getColorValue || getElevationValue)) {
        import_core9.log.warn("Features not supported by GPU aggregation, falling back to CPU")();
        return "cpu";
      }
      if (
        // GPU aggregation is requested
        gpuAggregation && // GPU aggregation is supported by the device
        WebGLAggregator.isSupported(this.context.device)
      ) {
        return "gpu";
      }
      return "cpu";
    }
    createAggregator(type) {
      if (type === "cpu") {
        const { gridAggregator, cellSize } = this.props;
        return new CPUAggregator({
          dimensions: 2,
          getBin: {
            sources: ["positions"],
            getValue: ({ positions }, index, opts) => {
              if (gridAggregator) {
                return gridAggregator(positions, cellSize);
              }
              const viewport = this.state.aggregatorViewport;
              const p = viewport.projectPosition(positions);
              const { cellSizeCommon, cellOriginCommon } = opts;
              return [
                Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
                Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])
              ];
            }
          },
          getValue: [
            { sources: ["colorWeights"], getValue: ({ colorWeights }) => colorWeights },
            { sources: ["elevationWeights"], getValue: ({ elevationWeights }) => elevationWeights }
          ]
        });
      }
      return new WebGLAggregator(this.context.device, {
        dimensions: 2,
        channelCount: 2,
        bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),
        ...super.getShaders({
          modules: [import_core9.project32, binOptionsUniforms4],
          vs: (
            /* glsl */
            `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);
    binId = ivec2(gridCoords);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
          )
        })
      });
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        colorWeights: { size: 1, accessor: "getColorWeight" },
        elevationWeights: { size: 1, accessor: "getElevationWeight" }
      });
    }
    // eslint-disable-next-line complexity
    updateState(params) {
      const aggregatorChanged = super.updateState(params);
      const { props, oldProps, changeFlags } = params;
      const { aggregator } = this.state;
      if ((changeFlags.dataChanged || !this.state.dataAsArray) && (props.getColorValue || props.getElevationValue)) {
        this.state.dataAsArray = Array.from((0, import_core9.createIterable)(props.data).iterable);
      }
      if (aggregatorChanged || changeFlags.dataChanged || props.cellSize !== oldProps.cellSize || props.getColorValue !== oldProps.getColorValue || props.getElevationValue !== oldProps.getElevationValue || props.colorAggregation !== oldProps.colorAggregation || props.elevationAggregation !== oldProps.elevationAggregation) {
        this._updateBinOptions();
        const { cellSizeCommon, cellOriginCommon, binIdRange, dataAsArray } = this.state;
        aggregator.setProps({
          // @ts-expect-error only used by GPUAggregator
          binIdRange,
          pointCount: this.getNumInstances(),
          operations: [props.colorAggregation, props.elevationAggregation],
          binOptions: {
            cellSizeCommon,
            cellOriginCommon
          },
          onUpdate: this._onAggregationUpdate.bind(this)
        });
        if (dataAsArray) {
          const { getColorValue, getElevationValue } = this.props;
          aggregator.setProps({
            // @ts-expect-error only used by CPUAggregator
            customOperations: [
              getColorValue && ((indices) => getColorValue(
                indices.map((i) => dataAsArray[i]),
                { indices, data: props.data }
              )),
              getElevationValue && ((indices) => getElevationValue(
                indices.map((i) => dataAsArray[i]),
                { indices, data: props.data }
              ))
            ]
          });
        }
      }
      if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {
        aggregator.setNeedsUpdate(0);
      }
      if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {
        aggregator.setNeedsUpdate(1);
      }
      return aggregatorChanged;
    }
    _updateBinOptions() {
      const bounds = this.getBounds();
      const cellSizeCommon = [1, 1];
      let cellOriginCommon = [0, 0];
      let binIdRange = [
        [0, 1],
        [0, 1]
      ];
      let viewport = this.context.viewport;
      if (bounds && Number.isFinite(bounds[0][0])) {
        let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];
        const { cellSize } = this.props;
        const { unitsPerMeter } = viewport.getDistanceScales(centroid);
        cellSizeCommon[0] = unitsPerMeter[0] * cellSize;
        cellSizeCommon[1] = unitsPerMeter[1] * cellSize;
        const centroidCommon = viewport.projectFlat(centroid);
        cellOriginCommon = [
          Math.floor(centroidCommon[0] / cellSizeCommon[0]) * cellSizeCommon[0],
          Math.floor(centroidCommon[1] / cellSizeCommon[1]) * cellSizeCommon[1]
        ];
        centroid = viewport.unprojectFlat(cellOriginCommon);
        const ViewportType = viewport.constructor;
        viewport = viewport.isGeospatial ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 }) : new import_core9.Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });
        cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];
        binIdRange = getBinIdRange({
          dataBounds: bounds,
          getBinId: (p) => {
            const positionCommon = viewport.projectFlat(p);
            return [
              Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),
              Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])
            ];
          }
        });
      }
      this.setState({ cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport });
    }
    draw(opts) {
      if (opts.shaderModuleProps.project) {
        opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;
      }
      super.draw(opts);
    }
    _onAggregationUpdate({ channel }) {
      const props = this.getCurrentLayer().props;
      const { aggregator } = this.state;
      if (channel === 0) {
        const result = aggregator.getResult(0);
        this.setState({
          colors: new AttributeWithScale(result, aggregator.binCount)
        });
        props.onSetColorDomain(aggregator.getResultDomain(0));
      } else if (channel === 1) {
        const result = aggregator.getResult(1);
        this.setState({
          elevations: new AttributeWithScale(result, aggregator.binCount)
        });
        props.onSetElevationDomain(aggregator.getResultDomain(1));
      }
    }
    onAttributeChange(id) {
      const { aggregator } = this.state;
      switch (id) {
        case "positions":
          aggregator.setNeedsUpdate();
          this._updateBinOptions();
          const { cellSizeCommon, cellOriginCommon, binIdRange } = this.state;
          aggregator.setProps({
            // @ts-expect-error only used by GPUAggregator
            binIdRange,
            binOptions: {
              cellSizeCommon,
              cellOriginCommon
            }
          });
          break;
        case "colorWeights":
          aggregator.setNeedsUpdate(0);
          break;
        case "elevationWeights":
          aggregator.setNeedsUpdate(1);
          break;
        default:
      }
    }
    renderLayers() {
      const { aggregator, cellOriginCommon, cellSizeCommon } = this.state;
      const {
        elevationScale,
        colorRange,
        elevationRange,
        extruded,
        coverage,
        material,
        transitions,
        colorScaleType,
        lowerPercentile,
        upperPercentile,
        colorDomain,
        elevationScaleType,
        elevationLowerPercentile,
        elevationUpperPercentile,
        elevationDomain
      } = this.props;
      const CellLayerClass = this.getSubLayerClass("cells", GridCellLayer);
      const binAttribute = aggregator.getBins();
      const colors = this.state.colors?.update({
        scaleType: colorScaleType,
        lowerPercentile,
        upperPercentile
      });
      const elevations = this.state.elevations?.update({
        scaleType: elevationScaleType,
        lowerPercentile: elevationLowerPercentile,
        upperPercentile: elevationUpperPercentile
      });
      if (!colors || !elevations) {
        return null;
      }
      return new CellLayerClass(
        this.getSubLayerProps({
          id: "cells"
        }),
        {
          data: {
            length: aggregator.binCount,
            attributes: {
              getBin: binAttribute,
              getColorValue: colors.attribute,
              getElevationValue: elevations.attribute
            }
          },
          // Data has changed shallowly, but we likely don't need to update the attributes
          dataComparator: (data, oldData) => data.length === oldData.length,
          updateTriggers: {
            getBin: [binAttribute],
            getColorValue: [colors.attribute],
            getElevationValue: [elevations.attribute]
          },
          cellOriginCommon,
          cellSizeCommon,
          elevationScale,
          colorRange,
          colorScaleType,
          elevationRange,
          extruded,
          coverage,
          material,
          colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),
          elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),
          colorCutoff: colors.cutoff,
          elevationCutoff: elevations.cutoff,
          transitions: transitions && {
            getFillColor: transitions.getColorValue || transitions.getColorWeight,
            getElevation: transitions.getElevationValue || transitions.getElevationWeight
          },
          // Extensions are already handled by the GPUAggregator, do not pass it down
          extensions: []
        }
      );
    }
    getPickingInfo(params) {
      const info = params.info;
      const { index } = info;
      if (index >= 0) {
        const bin = this.state.aggregator.getBin(index);
        let object;
        if (bin) {
          object = {
            col: bin.id[0],
            row: bin.id[1],
            colorValue: bin.value[0],
            elevationValue: bin.value[1],
            count: bin.count
          };
          if (bin.pointIndices) {
            object.pointIndices = bin.pointIndices;
            object.points = Array.isArray(this.props.data) ? bin.pointIndices.map((i) => this.props.data[i]) : [];
          }
        }
        info.object = object;
      }
      return info;
    }
  };
  GridLayer2.layerName = "GridLayer";
  GridLayer2.defaultProps = defaultProps4;

  // src/heatmap-layer/heatmap-layer-utils.ts
  function getBounds(points) {
    const x = points.map((p) => p[0]);
    const y = points.map((p) => p[1]);
    const xMin = Math.min.apply(null, x);
    const xMax = Math.max.apply(null, x);
    const yMin = Math.min.apply(null, y);
    const yMax = Math.max.apply(null, y);
    return [xMin, yMin, xMax, yMax];
  }
  function boundsContain(currentBounds, targetBounds) {
    if (targetBounds[0] >= currentBounds[0] && targetBounds[2] <= currentBounds[2] && targetBounds[1] >= currentBounds[1] && targetBounds[3] <= currentBounds[3]) {
      return true;
    }
    return false;
  }
  var scratchArray = new Float32Array(12);
  function packVertices(points, dimensions = 2) {
    let index = 0;
    for (const point of points) {
      for (let i = 0; i < dimensions; i++) {
        scratchArray[index++] = point[i] || 0;
      }
    }
    return scratchArray;
  }
  function scaleToAspectRatio(boundingBox, width, height) {
    const [xMin, yMin, xMax, yMax] = boundingBox;
    const currentWidth = xMax - xMin;
    const currentHeight = yMax - yMin;
    let newWidth = currentWidth;
    let newHeight = currentHeight;
    if (currentWidth / currentHeight < width / height) {
      newWidth = width / height * currentHeight;
    } else {
      newHeight = height / width * currentWidth;
    }
    if (newWidth < width) {
      newWidth = width;
      newHeight = height;
    }
    const xCenter = (xMax + xMin) / 2;
    const yCenter = (yMax + yMin) / 2;
    return [
      xCenter - newWidth / 2,
      yCenter - newHeight / 2,
      xCenter + newWidth / 2,
      yCenter + newHeight / 2
    ];
  }
  function getTextureCoordinates(point, bounds) {
    const [xMin, yMin, xMax, yMax] = bounds;
    return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];
  }

  // src/heatmap-layer/heatmap-layer.ts
  var import_engine6 = __toESM(require_engine(), 1);
  var import_core12 = __toESM(require_core(), 1);

  // src/heatmap-layer/triangle-layer.ts
  var import_engine5 = __toESM(require_engine(), 1);
  var import_core10 = __toESM(require_core(), 1);

  // src/heatmap-layer/triangle-layer-vertex.glsl.ts
  var triangle_layer_vertex_glsl_default = `#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader

uniform sampler2D maxTexture;

in vec3 positions;
in vec2 texCoords;

out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;

void main(void) {
  gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
  vTexCoords = texCoords;
  vec4 maxTexture = texture(maxTexture, vec2(0.5));
  float maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
  float minValue = maxValue * triangle.threshold;
  if (triangle.colorDomain[1] > 0.) {
    // if user specified custom domain use it.
    maxValue = triangle.colorDomain[1];
    minValue = triangle.colorDomain[0];
  }
  vIntensityMax = triangle.intensity / maxValue;
  vIntensityMin = triangle.intensity / minValue;
}
`;

  // src/heatmap-layer/triangle-layer-fragment.glsl.ts
  var triangle_layer_fragment_glsl_default = `#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader

precision highp float;

uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;

in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;

out vec4 fragColor;

vec4 getLinearColor(float value) {
  float factor = clamp(value * vIntensityMax, 0., 1.);
  vec4 color = texture(colorTexture, vec2(factor, 0.5));
  color.a *= min(value * vIntensityMin, 1.0);
  return color;
}

void main(void) {
  vec4 weights = texture(weightsTexture, vTexCoords);
  float weight = weights.r;

  if (triangle.aggregationMode > 0.5) {
    weight /= max(1.0, weights.a);
  }

  // discard pixels with 0 weight.
  if (weight <= 0.) {
     discard;
  }

  vec4 linearColor = getLinearColor(weight);
  linearColor.a *= layer.opacity;
  fragColor = linearColor;
}
`;

  // src/heatmap-layer/triangle-layer-uniforms.ts
  var uniformBlock10 = `uniform triangleUniforms {
  float aggregationMode;
  vec2 colorDomain;
  float intensity;
  float threshold;
} triangle;
`;
  var triangleUniforms = {
    name: "triangle",
    vs: uniformBlock10,
    fs: uniformBlock10,
    uniformTypes: {
      aggregationMode: "f32",
      colorDomain: "vec2<f32>",
      intensity: "f32",
      threshold: "f32"
    }
  };

  // src/heatmap-layer/triangle-layer.ts
  var TriangleLayer = class extends import_core10.Layer {
    getShaders() {
      return super.getShaders({ vs: triangle_layer_vertex_glsl_default, fs: triangle_layer_fragment_glsl_default, modules: [import_core10.project32, triangleUniforms] });
    }
    initializeState({ device }) {
      this.setState({ model: this._getModel(device) });
    }
    _getModel(device) {
      const { vertexCount, data } = this.props;
      return new import_engine5.Model(device, {
        ...this.getShaders(),
        id: this.props.id,
        attributes: data.attributes,
        bufferLayout: [
          { name: "positions", format: "float32x3" },
          { name: "texCoords", format: "float32x2" }
        ],
        topology: "triangle-strip",
        vertexCount
      });
    }
    draw() {
      const { model } = this.state;
      const {
        aggregationMode,
        colorDomain,
        intensity,
        threshold: threshold2,
        colorTexture,
        maxTexture,
        weightsTexture
      } = this.props;
      const triangleProps = {
        aggregationMode,
        colorDomain,
        intensity,
        threshold: threshold2,
        colorTexture,
        maxTexture,
        weightsTexture
      };
      model.shaderInputs.setProps({ triangle: triangleProps });
      model.draw(this.context.renderPass);
    }
  };
  TriangleLayer.layerName = "TriangleLayer";

  // src/heatmap-layer/aggregation-layer.ts
  var import_core11 = __toESM(require_core(), 1);

  // src/common/utils/prop-utils.ts
  function filterProps(props, filterKeys) {
    const filteredProps = {};
    for (const key in props) {
      if (!filterKeys.includes(key)) {
        filteredProps[key] = props[key];
      }
    }
    return filteredProps;
  }

  // src/heatmap-layer/aggregation-layer.ts
  var AggregationLayer2 = class extends import_core11.CompositeLayer {
    initializeAggregationLayer(dimensions) {
      super.initializeState(this.context);
      this.setState({
        // Layer props , when changed doesn't require updating aggregation
        ignoreProps: filterProps(this.constructor._propTypes, dimensions.data.props),
        dimensions
      });
    }
    updateState(opts) {
      super.updateState(opts);
      const { changeFlags } = opts;
      if (changeFlags.extensionsChanged) {
        const shaders = this.getShaders({});
        if (shaders && shaders.defines) {
          shaders.defines.NON_INSTANCED_MODEL = 1;
        }
        this.updateShaders(shaders);
      }
      this._updateAttributes();
    }
    updateAttributes(changedAttributes) {
      this.setState({ changedAttributes });
    }
    getAttributes() {
      return this.getAttributeManager().getAttributes();
    }
    getModuleSettings() {
      const { viewport, mousePosition, device } = this.context;
      const moduleSettings = Object.assign(Object.create(this.props), {
        viewport,
        mousePosition,
        picking: {
          isActive: 0
        },
        // @ts-expect-error TODO - assuming WebGL context
        devicePixelRatio: device.canvasContext.cssToDeviceRatio()
      });
      return moduleSettings;
    }
    updateShaders(shaders) {
    }
    /**
     * Checks if aggregation is dirty
     * @param {Object} updateOpts - object {props, oldProps, changeFlags}
     * @param {Object} params - object {dimension, compareAll}
     * @param {Object} params.dimension - {props, accessors} array of props and/or accessors
     * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision
     * @returns {Boolean} - returns true if dimensions' prop or accessor is changed
     **/
    isAggregationDirty(updateOpts, params = {}) {
      const { props, oldProps, changeFlags } = updateOpts;
      const { compareAll = false, dimension } = params;
      const { ignoreProps } = this.state;
      const { props: dataProps, accessors = [] } = dimension;
      const { updateTriggersChanged } = changeFlags;
      if (changeFlags.dataChanged) {
        return true;
      }
      if (updateTriggersChanged) {
        if (updateTriggersChanged.all) {
          return true;
        }
        for (const accessor of accessors) {
          if (updateTriggersChanged[accessor]) {
            return true;
          }
        }
      }
      if (compareAll) {
        if (changeFlags.extensionsChanged) {
          return true;
        }
        return (0, import_core11._compareProps)({
          oldProps,
          newProps: props,
          ignoreProps,
          propTypes: this.constructor._propTypes
        });
      }
      for (const name of dataProps) {
        if (props[name] !== oldProps[name]) {
          return true;
        }
      }
      return false;
    }
    /**
     * Checks if an attribute is changed
     * @param {String} name - name of the attribute
     * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,
     *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise
     **/
    isAttributeChanged(name) {
      const { changedAttributes } = this.state;
      if (!name) {
        return !isObjectEmpty(changedAttributes);
      }
      return changedAttributes && changedAttributes[name] !== void 0;
    }
    // Private
    // override Composite layer private method to create AttributeManager instance
    _getAttributeManager() {
      return new import_core11.AttributeManager(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  };
  AggregationLayer2.layerName = "AggregationLayer";
  function isObjectEmpty(obj) {
    let isEmpty = true;
    for (const key in obj) {
      isEmpty = false;
      break;
    }
    return isEmpty;
  }

  // src/heatmap-layer/weights-vs.glsl.ts
  var weights_vs_glsl_default = `#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;

void main()
{
  weightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);

  float radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);
  gl_PointSize = radiusTexels * 2.;

  vec3 commonPosition = project_position(positions, positions64Low);

  // // map xy from commonBounds to [-1, 1]
  gl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;
  gl_Position.xy = (gl_Position.xy * 2.) - (1.);
  gl_Position.w = 1.0;
}
`;

  // src/heatmap-layer/weights-fs.glsl.ts
  var weights_fs_glsl_default = `#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
// Epanechnikov function, keeping for reference
// float epanechnikovKDE(float u) {
//   return 0.75 * (1.0 - u * u);
// }
float gaussianKDE(float u){
  return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
  float dist = length(gl_PointCoord - vec2(0.5, 0.5));
  if (dist > 0.5) {
    discard;
  }
  fragColor = weightsTexture * gaussianKDE(2. * dist);
  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;

  // src/heatmap-layer/max-vs.glsl.ts
  var max_vs_glsl_default = `#version 300 es
uniform sampler2D inTexture;
out vec4 outTexture;

void main()
{
  // Sample every pixel in texture
  int yIndex = gl_VertexID / int(maxWeight.textureSize);
  int xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));
  vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;
  outTexture = texture(inTexture, uv);

  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)
  gl_PointSize = 1.0;
}
`;

  // src/heatmap-layer/max-fs.glsl.ts
  var max_fs_glsl_default = `#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
  fragColor = outTexture;
  fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`;

  // src/heatmap-layer/heatmap-layer-uniforms.ts
  var uniformBlock11 = `uniform weightUniforms {
  vec4 commonBounds;
  float radiusPixels;
  float textureWidth;
  float weightsScale;
} weight;
`;
  var weightUniforms = {
    name: "weight",
    vs: uniformBlock11,
    uniformTypes: {
      commonBounds: "vec4<f32>",
      radiusPixels: "f32",
      textureWidth: "f32",
      weightsScale: "f32"
    }
  };
  var maxWeightUniforms = {
    name: "maxWeight",
    vs: `uniform maxWeightUniforms {
  float textureSize;
} maxWeight;
`,
    uniformTypes: {
      textureSize: "f32"
    }
  };

  // src/heatmap-layer/heatmap-layer.ts
  var RESOLUTION = 2;
  var TEXTURE_PROPS = {
    format: "rgba8unorm",
    dimension: "2d",
    width: 1,
    height: 1,
    sampler: {
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  };
  var DEFAULT_COLOR_DOMAIN = [0, 0];
  var AGGREGATION_MODE = {
    SUM: 0,
    MEAN: 1
  };
  var defaultProps5 = {
    getPosition: { type: "accessor", value: (x) => x.position },
    getWeight: { type: "accessor", value: 1 },
    intensity: { type: "number", min: 0, value: 1 },
    radiusPixels: { type: "number", min: 1, max: 100, value: 50 },
    colorRange: defaultColorRange,
    threshold: { type: "number", min: 0, max: 1, value: 0.05 },
    colorDomain: { type: "array", value: null, optional: true },
    // 'SUM' or 'MEAN'
    aggregation: "SUM",
    weightsTextureSize: { type: "number", min: 128, max: 2048, value: 2048 },
    debounceTimeout: { type: "number", min: 0, max: 1e3, value: 500 }
  };
  var FLOAT_TARGET_FEATURES = [
    "float32-renderable-webgl",
    // ability to render to float texture
    "texture-blend-float-webgl"
    // ability to blend when rendering to float texture
  ];
  var DIMENSIONS = {
    data: {
      props: ["radiusPixels"]
    }
  };
  var HeatmapLayer = class extends AggregationLayer2 {
    getShaders(shaders) {
      let modules = [import_core12.project32];
      if (shaders.modules) {
        modules = [...modules, ...shaders.modules];
      }
      return super.getShaders({ ...shaders, modules });
    }
    initializeState() {
      super.initializeAggregationLayer(DIMENSIONS);
      this.setState({ colorDomain: DEFAULT_COLOR_DOMAIN });
      this._setupTextureParams();
      this._setupAttributes();
      this._setupResources();
    }
    shouldUpdateState({ changeFlags }) {
      return changeFlags.somethingChanged;
    }
    /* eslint-disable max-statements,complexity */
    updateState(opts) {
      super.updateState(opts);
      this._updateHeatmapState(opts);
    }
    _updateHeatmapState(opts) {
      const { props, oldProps } = opts;
      const changeFlags = this._getChangeFlags(opts);
      if (changeFlags.dataChanged || changeFlags.viewportChanged) {
        changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);
        this._updateTextureRenderingBounds();
      }
      if (changeFlags.dataChanged || changeFlags.boundsChanged) {
        clearTimeout(this.state.updateTimer);
        this.setState({ isWeightMapDirty: true });
        if (changeFlags.dataChanged) {
          const weightsTransformShaders = this.getShaders({ vs: weights_vs_glsl_default, fs: weights_fs_glsl_default });
          this._createWeightsTransform(weightsTransformShaders);
        }
      } else if (changeFlags.viewportZoomChanged) {
        this._debouncedUpdateWeightmap();
      }
      if (props.colorRange !== oldProps.colorRange) {
        this._updateColorTexture(opts);
      }
      if (this.state.isWeightMapDirty) {
        this._updateWeightmap();
      }
      this.setState({ zoom: opts.context.viewport.zoom });
    }
    renderLayers() {
      const {
        weightsTexture,
        triPositionBuffer,
        triTexCoordBuffer,
        maxWeightsTexture,
        colorTexture,
        colorDomain
      } = this.state;
      const { updateTriggers, intensity, threshold: threshold2, aggregation } = this.props;
      const TriangleLayerClass = this.getSubLayerClass("triangle", TriangleLayer);
      return new TriangleLayerClass(
        this.getSubLayerProps({
          id: "triangle-layer",
          updateTriggers
        }),
        {
          // position buffer is filled with world coordinates generated from viewport.unproject
          // i.e. LNGLAT if geospatial, CARTESIAN otherwise
          coordinateSystem: import_core12.COORDINATE_SYSTEM.DEFAULT,
          data: {
            attributes: {
              positions: triPositionBuffer,
              texCoords: triTexCoordBuffer
            }
          },
          vertexCount: 4,
          maxTexture: maxWeightsTexture,
          colorTexture,
          aggregationMode: AGGREGATION_MODE[aggregation] || 0,
          weightsTexture,
          intensity,
          threshold: threshold2,
          colorDomain
        }
      );
    }
    finalizeState(context) {
      super.finalizeState(context);
      const {
        weightsTransform,
        weightsTexture,
        maxWeightTransform,
        maxWeightsTexture,
        triPositionBuffer,
        triTexCoordBuffer,
        colorTexture,
        updateTimer
      } = this.state;
      weightsTransform?.destroy();
      weightsTexture?.destroy();
      maxWeightTransform?.destroy();
      maxWeightsTexture?.destroy();
      triPositionBuffer?.destroy();
      triTexCoordBuffer?.destroy();
      colorTexture?.destroy();
      if (updateTimer) {
        clearTimeout(updateTimer);
      }
    }
    // PRIVATE
    // override Composite layer private method to create AttributeManager instance
    _getAttributeManager() {
      return new import_core12.AttributeManager(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
    _getChangeFlags(opts) {
      const changeFlags = {};
      const { dimensions } = this.state;
      changeFlags.dataChanged = this.isAttributeChanged() && "attribute changed" || // if any attribute is changed
      this.isAggregationDirty(opts, {
        compareAll: true,
        dimension: dimensions.data
      }) && "aggregation is dirty";
      changeFlags.viewportChanged = opts.changeFlags.viewportChanged;
      const { zoom } = this.state;
      if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {
        changeFlags.viewportZoomChanged = true;
      }
      return changeFlags;
    }
    _createTextures() {
      const { textureSize, format } = this.state;
      this.setState({
        weightsTexture: this.context.device.createTexture({
          ...TEXTURE_PROPS,
          width: textureSize,
          height: textureSize,
          format
        }),
        maxWeightsTexture: this.context.device.createTexture({
          ...TEXTURE_PROPS,
          width: 1,
          height: 1,
          format
        })
      });
    }
    _setupAttributes() {
      const attributeManager = this.getAttributeManager();
      attributeManager.add({
        positions: { size: 3, type: "float64", accessor: "getPosition" },
        weights: { size: 1, accessor: "getWeight" }
      });
      this.setState({ positionAttributeName: "positions" });
    }
    _setupTextureParams() {
      const { device } = this.context;
      const { weightsTextureSize } = this.props;
      const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);
      const floatTargetSupport = FLOAT_TARGET_FEATURES.every((feature) => device.features.has(feature));
      const format = floatTargetSupport ? "rgba32float" : "rgba8unorm";
      const weightsScale = floatTargetSupport ? 1 : 1 / 255;
      this.setState({ textureSize, format, weightsScale });
      if (!floatTargetSupport) {
        import_core12.log.warn(
          `HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`
        )();
      }
    }
    _createWeightsTransform(shaders) {
      let { weightsTransform } = this.state;
      const { weightsTexture } = this.state;
      const attributeManager = this.getAttributeManager();
      weightsTransform?.destroy();
      weightsTransform = new import_engine6.TextureTransform(this.context.device, {
        id: `${this.id}-weights-transform`,
        bufferLayout: attributeManager.getBufferLayouts(),
        vertexCount: 1,
        targetTexture: weightsTexture,
        parameters: {
          depthWriteEnabled: false,
          blendColorOperation: "add",
          blendColorSrcFactor: "one",
          blendColorDstFactor: "one",
          blendAlphaSrcFactor: "one",
          blendAlphaDstFactor: "one"
        },
        topology: "point-list",
        ...shaders,
        modules: [...shaders.modules, weightUniforms]
      });
      this.setState({ weightsTransform });
    }
    _setupResources() {
      this._createTextures();
      const { device } = this.context;
      const { textureSize, weightsTexture, maxWeightsTexture } = this.state;
      const weightsTransformShaders = this.getShaders({
        vs: weights_vs_glsl_default,
        fs: weights_fs_glsl_default
      });
      this._createWeightsTransform(weightsTransformShaders);
      const maxWeightsTransformShaders = this.getShaders({
        vs: max_vs_glsl_default,
        fs: max_fs_glsl_default,
        modules: [maxWeightUniforms]
      });
      const maxWeightTransform = new import_engine6.TextureTransform(device, {
        id: `${this.id}-max-weights-transform`,
        targetTexture: maxWeightsTexture,
        ...maxWeightsTransformShaders,
        vertexCount: textureSize * textureSize,
        topology: "point-list",
        parameters: {
          depthWriteEnabled: false,
          blendColorOperation: "max",
          blendAlphaOperation: "max",
          blendColorSrcFactor: "one",
          blendColorDstFactor: "one",
          blendAlphaSrcFactor: "one",
          blendAlphaDstFactor: "one"
        }
      });
      const maxWeightProps = { inTexture: weightsTexture, textureSize };
      maxWeightTransform.model.shaderInputs.setProps({
        maxWeight: maxWeightProps
      });
      this.setState({
        weightsTexture,
        maxWeightsTexture,
        maxWeightTransform,
        zoom: null,
        triPositionBuffer: device.createBuffer({ byteLength: 48 }),
        triTexCoordBuffer: device.createBuffer({ byteLength: 48 })
      });
    }
    // overwrite super class method to update transform model
    updateShaders(shaderOptions) {
      this._createWeightsTransform({
        vs: weights_vs_glsl_default,
        fs: weights_fs_glsl_default,
        ...shaderOptions
      });
    }
    _updateMaxWeightValue() {
      const { maxWeightTransform } = this.state;
      maxWeightTransform.run({
        parameters: { viewport: [0, 0, 1, 1] },
        clearColor: [0, 0, 0, 0]
      });
    }
    // Computes world bounds area that needs to be processed for generate heatmap
    _updateBounds(forceUpdate = false) {
      const { viewport } = this.context;
      const viewportCorners = [
        viewport.unproject([0, 0]),
        viewport.unproject([viewport.width, 0]),
        viewport.unproject([0, viewport.height]),
        viewport.unproject([viewport.width, viewport.height])
      ].map((p) => p.map(Math.fround));
      const visibleWorldBounds = getBounds(viewportCorners);
      const newState = { visibleWorldBounds, viewportCorners };
      let boundsChanged = false;
      if (forceUpdate || !this.state.worldBounds || !boundsContain(this.state.worldBounds, visibleWorldBounds)) {
        const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);
        const worldBounds = this._commonToWorldBounds(scaledCommonBounds);
        if (this.props.coordinateSystem === import_core12.COORDINATE_SYSTEM.LNGLAT) {
          worldBounds[1] = Math.max(worldBounds[1], -85.051129);
          worldBounds[3] = Math.min(worldBounds[3], 85.051129);
          worldBounds[0] = Math.max(worldBounds[0], -360);
          worldBounds[2] = Math.min(worldBounds[2], 360);
        }
        const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);
        newState.worldBounds = worldBounds;
        newState.normalizedCommonBounds = normalizedCommonBounds;
        boundsChanged = true;
      }
      this.setState(newState);
      return boundsChanged;
    }
    _updateTextureRenderingBounds() {
      const { triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners } = this.state;
      const { viewport } = this.context;
      triPositionBuffer.write(packVertices(viewportCorners, 3));
      const textureBounds = viewportCorners.map(
        (p) => getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds)
      );
      triTexCoordBuffer.write(packVertices(textureBounds, 2));
    }
    _updateColorTexture(opts) {
      const { colorRange } = opts.props;
      let { colorTexture } = this.state;
      const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);
      colorTexture?.destroy();
      colorTexture = this.context.device.createTexture({
        ...TEXTURE_PROPS,
        data: colors,
        width: colorRange.length,
        height: 1
      });
      this.setState({ colorTexture });
    }
    _updateWeightmap() {
      const { radiusPixels, colorDomain, aggregation } = this.props;
      const { worldBounds, textureSize, weightsScale, weightsTexture } = this.state;
      const weightsTransform = this.state.weightsTransform;
      this.state.isWeightMapDirty = false;
      const commonBounds = this._worldToCommonBounds(worldBounds, {
        useLayerCoordinateSystem: true
      });
      if (colorDomain && aggregation === "SUM") {
        const { viewport: viewport2 } = this.context;
        const metersPerPixel = viewport2.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0]) / textureSize;
        this.state.colorDomain = colorDomain.map((x) => x * metersPerPixel * weightsScale);
      } else {
        this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;
      }
      const attributeManager = this.getAttributeManager();
      const attributes = attributeManager.getAttributes();
      const moduleSettings = this.getModuleSettings();
      this._setModelAttributes(weightsTransform.model, attributes);
      weightsTransform.model.setVertexCount(this.getNumInstances());
      const weightProps = {
        radiusPixels,
        commonBounds,
        textureWidth: textureSize,
        weightsScale,
        weightsTexture
      };
      const { viewport, devicePixelRatio, coordinateSystem, coordinateOrigin } = moduleSettings;
      const { modelMatrix } = this.props;
      weightsTransform.model.shaderInputs.setProps({
        project: { viewport, devicePixelRatio, modelMatrix, coordinateSystem, coordinateOrigin },
        weight: weightProps
      });
      weightsTransform.run({
        parameters: { viewport: [0, 0, textureSize, textureSize] },
        clearColor: [0, 0, 0, 0]
      });
      this._updateMaxWeightValue();
    }
    _debouncedUpdateWeightmap(fromTimer = false) {
      let { updateTimer } = this.state;
      const { debounceTimeout } = this.props;
      if (fromTimer) {
        updateTimer = null;
        this._updateBounds(true);
        this._updateTextureRenderingBounds();
        this.setState({ isWeightMapDirty: true });
      } else {
        this.setState({ isWeightMapDirty: false });
        clearTimeout(updateTimer);
        updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);
      }
      this.setState({ updateTimer });
    }
    // input: worldBounds: [minLong, minLat, maxLong, maxLat]
    // input: opts.useLayerCoordinateSystem : layers coordiante system is used
    // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture
    _worldToCommonBounds(worldBounds, opts = {}) {
      const { useLayerCoordinateSystem = false } = opts;
      const [minLong, minLat, maxLong, maxLat] = worldBounds;
      const { viewport } = this.context;
      const { textureSize } = this.state;
      const { coordinateSystem } = this.props;
      const offsetMode = useLayerCoordinateSystem && (coordinateSystem === import_core12.COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === import_core12.COORDINATE_SYSTEM.METER_OFFSETS);
      const offsetOriginCommon = offsetMode ? viewport.projectPosition(this.props.coordinateOrigin) : [0, 0];
      const size = textureSize * RESOLUTION / viewport.scale;
      let bottomLeftCommon;
      let topRightCommon;
      if (useLayerCoordinateSystem && !offsetMode) {
        bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);
        topRightCommon = this.projectPosition([maxLong, maxLat, 0]);
      } else {
        bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);
        topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);
      }
      return scaleToAspectRatio(
        [
          bottomLeftCommon[0] - offsetOriginCommon[0],
          bottomLeftCommon[1] - offsetOriginCommon[1],
          topRightCommon[0] - offsetOriginCommon[0],
          topRightCommon[1] - offsetOriginCommon[1]
        ],
        size,
        size
      );
    }
    // input commonBounds: [xMin, yMin, xMax, yMax]
    // output worldBounds: [minLong, minLat, maxLong, maxLat]
    _commonToWorldBounds(commonBounds) {
      const [xMin, yMin, xMax, yMax] = commonBounds;
      const { viewport } = this.context;
      const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);
      const topRightWorld = viewport.unprojectPosition([xMax, yMax]);
      return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));
    }
  };
  HeatmapLayer.layerName = "HeatmapLayer";
  HeatmapLayer.defaultProps = defaultProps5;
  return __toCommonJS(bundle_exports);
})();
      return __exports__;
      });
