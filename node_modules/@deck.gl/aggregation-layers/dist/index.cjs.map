{
  "version": 3,
  "sources": ["../src/index.ts", "../src/screen-grid-layer/screen-grid-layer.ts", "../src/common/aggregator/cpu-aggregator/cpu-aggregator.ts", "../src/common/aggregator/cpu-aggregator/sort-bins.ts", "../src/common/aggregator/cpu-aggregator/aggregate.ts", "../src/common/aggregator/cpu-aggregator/vertex-accessor.ts", "../src/common/aggregator/gpu-aggregator/webgl-bin-sorter.ts", "../src/common/aggregator/gpu-aggregator/utils.ts", "../src/common/aggregator/gpu-aggregator/bin-sorter-uniforms.ts", "../src/common/aggregator/gpu-aggregator/webgl-aggregation-transform.ts", "../src/common/aggregator/gpu-aggregator/aggregation-transform-uniforms.ts", "../src/common/aggregator/gpu-aggregator/webgl-aggregator.ts", "../src/common/aggregation-layer.ts", "../src/screen-grid-layer/screen-grid-cell-layer.ts", "../src/common/utils/color-utils.ts", "../src/screen-grid-layer/screen-grid-layer-vertex.glsl.ts", "../src/screen-grid-layer/screen-grid-layer-fragment.glsl.ts", "../src/screen-grid-layer/screen-grid-layer-uniforms.ts", "../src/screen-grid-layer/bin-options-uniforms.ts", "../src/hexagon-layer/hexagon-layer.ts", "../src/common/utils/scale-utils.ts", "../src/common/utils/bounds-utils.ts", "../src/hexagon-layer/hexagon-cell-layer.ts", "../src/hexagon-layer/hexbin.ts", "../src/hexagon-layer/hexagon-cell-layer-vertex.glsl.ts", "../src/hexagon-layer/hexagon-layer-uniforms.ts", "../src/hexagon-layer/bin-options-uniforms.ts", "../src/contour-layer/contour-layer.ts", "../src/contour-layer/marching-squares-codes.ts", "../src/contour-layer/marching-squares.ts", "../src/contour-layer/contour-utils.ts", "../src/contour-layer/value-reader.ts", "../src/contour-layer/bin-options-uniforms.ts", "../src/grid-layer/grid-layer.ts", "../src/grid-layer/grid-cell-layer.ts", "../src/grid-layer/grid-cell-layer-vertex.glsl.ts", "../src/grid-layer/grid-layer-uniforms.ts", "../src/grid-layer/bin-options-uniforms.ts", "../src/heatmap-layer/heatmap-layer-utils.ts", "../src/heatmap-layer/heatmap-layer.ts", "../src/heatmap-layer/triangle-layer.ts", "../src/heatmap-layer/triangle-layer-vertex.glsl.ts", "../src/heatmap-layer/triangle-layer-fragment.glsl.ts", "../src/heatmap-layer/triangle-layer-uniforms.ts", "../src/heatmap-layer/aggregation-layer.ts", "../src/common/utils/prop-utils.ts", "../src/heatmap-layer/weights-vs.glsl.ts", "../src/heatmap-layer/weights-fs.glsl.ts", "../src/heatmap-layer/max-vs.glsl.ts", "../src/heatmap-layer/max-fs.glsl.ts", "../src/heatmap-layer/heatmap-layer-uniforms.ts"],
  "sourcesContent": ["// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport {default as ScreenGridLayer} from './screen-grid-layer/screen-grid-layer';\nexport {default as HexagonLayer} from './hexagon-layer/hexagon-layer';\nexport {default as ContourLayer} from './contour-layer/contour-layer';\nexport {default as GridLayer} from './grid-layer/grid-layer';\nexport {default as HeatmapLayer} from './heatmap-layer/heatmap-layer';\n\nexport {default as _AggregationLayer} from './common/aggregation-layer';\nexport {WebGLAggregator, CPUAggregator} from './common/aggregator/index';\n\n// types\nexport type {ContourLayerProps, ContourLayerPickingInfo} from './contour-layer/contour-layer';\nexport type {HeatmapLayerProps} from './heatmap-layer/heatmap-layer';\nexport type {HexagonLayerProps, HexagonLayerPickingInfo} from './hexagon-layer/hexagon-layer';\nexport type {GridLayerProps, GridLayerPickingInfo} from './grid-layer/grid-layer';\nexport type {\n  ScreenGridLayerProps,\n  ScreenGridLayerPickingInfo\n} from './screen-grid-layer/screen-grid-layer';\n\nexport type {\n  Aggregator,\n  AggregationOperation,\n  AggregationProps,\n  WebGLAggregatorProps,\n  CPUAggregatorProps\n} from './common/aggregator/index';\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Accessor,\n  Color,\n  GetPickingInfoParams,\n  CompositeLayerProps,\n  Layer,\n  project32,\n  LayersList,\n  PickingInfo,\n  Position,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\nimport AggregationLayer from '../common/aggregation-layer';\nimport ScreenGridCellLayer from './screen-grid-cell-layer';\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\nimport {defaultColorRange} from '../common/utils/color-utils';\n\nconst defaultProps: DefaultProps<ScreenGridLayerProps> = {\n  cellSizePixels: {type: 'number', value: 100, min: 1},\n  cellMarginPixels: {type: 'number', value: 2, min: 0},\n  colorRange: defaultColorRange,\n  colorScaleType: 'linear',\n  getPosition: {type: 'accessor', value: (d: any) => d.position},\n  getWeight: {type: 'accessor', value: 1},\n\n  gpuAggregation: true,\n  aggregation: 'SUM'\n};\n\n/** All properties supported by ScreenGridLayer. */\nexport type ScreenGridLayerProps<DataT = unknown> = _ScreenGridLayerProps<DataT> &\n  CompositeLayerProps;\n\n/** Properties added by ScreenGridLayer. */\nexport type _ScreenGridLayerProps<DataT> = {\n  /**\n   * Unit width/height of the bins.\n   * @default 100\n   */\n  cellSizePixels?: number;\n\n  /**\n   * Cell margin size in pixels.\n   * @default 2\n   */\n  cellMarginPixels?: number;\n\n  /**\n   * Color scale input domain. The color scale maps continues numeric domain into discrete color range.\n   * @default [1, max(weight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   *\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Scaling function used to determine the color of the grid cell.\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'linear' | 'quantize';\n\n  /**\n   * Method called to retrieve the position of each object.\n   *\n   * @default d => d.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n\n  /**\n   * Perform aggregation is performed on GPU.\n   *\n   * @default true\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  aggregation?: AggregationOperation;\n};\n\nexport type ScreenGridLayerPickingInfo<DataT> = PickingInfo<{\n  /** Column index of the picked cell, starting from 0 at the left of the viewport */\n  col: number;\n  /** Row index of the picked cell, starting from 0 at the top of the viewport */\n  row: number;\n  /** Aggregated value */\n  value: number;\n  /** Number of data points in the picked cell */\n  count: number;\n  /** Indices of the data objects in the picked cell. Only available if using CPU aggregation. */\n  pointIndices?: number[];\n  /** The data objects in the picked cell. Only available if using CPU aggregation and layer data is an array. */\n  points?: DataT[];\n}>;\n\n/** Aggregates data into histogram bins and renders them as a grid. */\nexport default class ScreenGridLayer<\n  DataT = any,\n  ExtraProps extends {} = {}\n> extends AggregationLayer<DataT, ExtraProps & Required<_ScreenGridLayerProps<DataT>>> {\n  static layerName = 'ScreenGridLayer';\n  static defaultProps = defaultProps;\n\n  getAggregatorType(): string {\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device)\n      ? 'gpu'\n      : 'cpu';\n  }\n\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\n    if (type === 'cpu' || !WebGLAggregator.isSupported(this.context.device)) {\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\n            const viewport = this.context.viewport;\n            const p = viewport.project(positions);\n            const cellSizePixels: number = opts.cellSizePixels;\n            if (p[0] < 0 || p[0] >= viewport.width || p[1] < 0 || p[1] >= viewport.height) {\n              // Not on screen\n              return null;\n            }\n            return [Math.floor(p[0] / cellSizePixels), Math.floor(p[1] / cellSizePixels)];\n          }\n        },\n        getValue: [{sources: ['counts'], getValue: ({counts}) => counts}]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 1,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n  \n  void getBin(out ivec2 binId) {\n    vec4 pos = project_position_to_clipspace(positions, positions64Low, vec3(0.0));\n    vec2 screenCoords = vec2(pos.x / pos.w + 1.0, 1.0 - pos.y / pos.w) / 2.0 * project.viewportSize / project.devicePixelRatio;\n    vec2 gridCoords = floor(screenCoords / binOptions.cellSizePixels);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float weight) {\n    weight = counts;\n  }\n  `\n      })\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      // this attribute is used in gpu aggregation path only\n      counts: {size: 1, accessor: 'getWeight'}\n    });\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    const aggregatorChanged = super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const {cellSizePixels, aggregation} = props;\n    if (\n      aggregatorChanged ||\n      changeFlags.dataChanged ||\n      changeFlags.updateTriggersChanged ||\n      changeFlags.viewportChanged ||\n      aggregation !== oldProps.aggregation ||\n      cellSizePixels !== oldProps.cellSizePixels\n    ) {\n      const {width, height} = this.context.viewport;\n      const {aggregator} = this.state;\n\n      if (aggregator instanceof WebGLAggregator) {\n        aggregator.setProps({\n          binIdRange: [\n            [0, Math.ceil(width / cellSizePixels)],\n            [0, Math.ceil(height / cellSizePixels)]\n          ]\n        });\n      }\n\n      aggregator.setProps({\n        pointCount: this.getNumInstances(),\n        operations: [aggregation],\n        binOptions: {\n          cellSizePixels\n        }\n      });\n    }\n\n    if (changeFlags.viewportChanged) {\n      // Rerun aggregation on viewport change\n      this.state.aggregator.setNeedsUpdate();\n    }\n    return aggregatorChanged;\n  }\n\n  onAttributeChange(id: string) {\n    const {aggregator} = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n        break;\n\n      case 'counts':\n        aggregator.setNeedsUpdate(0);\n        break;\n\n      default:\n      // This should not happen\n    }\n  }\n\n  renderLayers(): LayersList | Layer | null {\n    const {aggregator} = this.state;\n    const CellLayerClass = this.getSubLayerClass('cells', ScreenGridCellLayer);\n    const binAttribute = aggregator.getBins();\n    const weightAttribute = aggregator.getResult(0);\n\n    return new CellLayerClass(\n      this.props,\n      this.getSubLayerProps({\n        id: 'cell-layer'\n      }),\n      {\n        data: {\n          length: aggregator.binCount,\n          attributes: {\n            getBin: binAttribute,\n            getWeight: weightAttribute\n          }\n        },\n        // Data has changed shallowly, but we likely don't need to update the attributes\n        dataComparator: (data, oldData) => data.length === oldData.length,\n        updateTriggers: {\n          getBin: [binAttribute],\n          getWeight: [weightAttribute]\n        },\n        parameters: {\n          depthWriteEnabled: false,\n          ...this.props.parameters\n        },\n        // Evaluate domain at draw() time\n        colorDomain: () => this.props.colorDomain || aggregator.getResultDomain(0),\n        // Extensions are already handled by the GPUAggregator, do not pass it down\n        extensions: []\n      }\n    );\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): ScreenGridLayerPickingInfo<DataT> {\n    const info: ScreenGridLayerPickingInfo<DataT> = params.info;\n    const {index} = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object: ScreenGridLayerPickingInfo<DataT>['object'];\n      if (bin) {\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          value: bin.value[0],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data)\n            ? bin.pointIndices.map(i => (this.props.data as DataT[])[i])\n            : [];\n        }\n      }\n      info.object = object;\n    }\n\n    return info;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Aggregator, AggregationProps, AggregatedBin} from '../aggregator';\nimport {_deepEqual as deepEqual, BinaryAttribute} from '@deck.gl/core';\nimport {sortBins, packBinIds} from './sort-bins';\nimport {aggregate, AggregationFunc, BUILT_IN_OPERATIONS} from './aggregate';\nimport {VertexAccessor, evaluateVertexAccessor} from './vertex-accessor';\n\n/** Options used to construct a new CPUAggregator */\nexport type CPUAggregatorProps = {\n  /** Size of bin IDs */\n  dimensions: number;\n  /** Accessor to map each data point to a bin ID.\n   * Bin ID should be an array with [dimensions] elements; or null if the data point should be skipped\n   */\n  getBin: VertexAccessor<number[] | null, any>;\n  /** Accessor to map each data point to a weight value, defined per channel */\n  getValue: VertexAccessor<number>[];\n} & Partial<CPUAggregationProps>;\n\n/** Props used to run CPU aggregation, can be changed at any time */\ntype CPUAggregationProps = AggregationProps & {\n  /** Custom callback to aggregate points, overrides the built-in operations */\n  customOperations: (AggregationFunc | null | undefined)[];\n};\n\nexport type Bin = {\n  id: number[];\n  index: number;\n  /** list of data point indices */\n  points: number[];\n};\n\n/** An Aggregator implementation that calculates aggregation on the CPU */\nexport class CPUAggregator implements Aggregator {\n  readonly dimensions: number;\n  readonly channelCount: number;\n\n  props: CPUAggregatorProps & CPUAggregationProps;\n\n  /** Dirty flag\n   * If true, redo sorting\n   * If array, redo aggregation on the specified channel\n   */\n  protected needsUpdate: boolean[] | boolean;\n\n  protected bins: Bin[] = [];\n  protected binIds: (BinaryAttribute & {value: Float32Array}) | null = null;\n  protected results: (BinaryAttribute & {\n    value: Float32Array;\n    domain: [min: number, max: number];\n  })[] = [];\n\n  constructor(props: CPUAggregatorProps) {\n    this.dimensions = props.dimensions;\n    this.channelCount = props.getValue.length;\n    this.props = {\n      ...props,\n      binOptions: {},\n      pointCount: 0,\n      operations: [],\n      customOperations: [],\n      attributes: {}\n    };\n    this.needsUpdate = true;\n    this.setProps(props);\n  }\n\n  destroy() {}\n\n  get binCount() {\n    return this.bins.length;\n  }\n\n  /** Update aggregation props */\n  // eslint-disable-next-line complexity\n  setProps(props: Partial<CPUAggregationProps>) {\n    const oldProps = this.props;\n\n    if (props.binOptions) {\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n        this.setNeedsUpdate();\n      }\n    }\n    if (props.operations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (props.operations[channel] !== oldProps.operations[channel]) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.customOperations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (\n          Boolean(props.customOperations[channel]) !== Boolean(oldProps.customOperations[channel])\n        ) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n      this.setNeedsUpdate();\n    }\n    if (props.attributes) {\n      props.attributes = {...oldProps.attributes, ...props.attributes};\n    }\n    Object.assign(this.props, props);\n  }\n\n  /** Flags a channel to need update\n   * This is called internally by setProps() if certain props change\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n   * the underlying buffers could have been updated and require rerunning the aggregation\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n   */\n  setNeedsUpdate(channel?: number): void {\n    if (channel === undefined) {\n      this.needsUpdate = true;\n    } else if (this.needsUpdate !== true) {\n      this.needsUpdate = this.needsUpdate || [];\n      this.needsUpdate[channel] = true;\n    }\n  }\n\n  /** Run aggregation */\n  update() {\n    if (this.needsUpdate === true) {\n      this.bins = sortBins({\n        pointCount: this.props.pointCount,\n        getBinId: evaluateVertexAccessor(\n          this.props.getBin,\n          this.props.attributes,\n          this.props.binOptions\n        )\n      });\n      const value = packBinIds({\n        bins: this.bins,\n        dimensions: this.dimensions,\n        // Reuse allocated typed array\n        target: this.binIds?.value\n      });\n      this.binIds = {value, type: 'float32', size: this.dimensions};\n    }\n    for (let channel = 0; channel < this.channelCount; channel++) {\n      if (this.needsUpdate === true || this.needsUpdate[channel]) {\n        const operation =\n          this.props.customOperations[channel] ||\n          BUILT_IN_OPERATIONS[this.props.operations[channel]];\n        const {value, domain} = aggregate({\n          bins: this.bins,\n          getValue: evaluateVertexAccessor(\n            this.props.getValue[channel],\n            this.props.attributes,\n            undefined\n          ),\n          operation,\n          // Reuse allocated typed array\n          target: this.results[channel]?.value\n        });\n        this.results[channel] = {value, domain, type: 'float32', size: 1};\n        this.props.onUpdate?.({channel});\n      }\n    }\n    this.needsUpdate = false;\n  }\n\n  preDraw() {}\n\n  /** Returns an accessor to the bins. */\n  getBins(): BinaryAttribute | null {\n    return this.binIds;\n  }\n\n  /** Returns an accessor to the output for a given channel. */\n  getResult(channel: number): BinaryAttribute | null {\n    return this.results[channel];\n  }\n\n  /** Returns the [min, max] of aggregated values for a given channel. */\n  getResultDomain(channel: number): [min: number, max: number] {\n    return this.results[channel]?.domain ?? [Infinity, -Infinity];\n  }\n\n  /** Returns the information for a given bin. */\n  getBin(index: number): AggregatedBin | null {\n    const bin = this.bins[index];\n    if (!bin) {\n      return null;\n    }\n    const value = new Array(this.channelCount);\n    for (let i = 0; i < value.length; i++) {\n      const result = this.results[i];\n      value[i] = result?.value[index];\n    }\n    return {\n      id: bin.id,\n      value,\n      count: bin.points.length,\n      pointIndices: bin.points\n    };\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Bin} from './cpu-aggregator';\n\n/** Group data points into bins */\nexport function sortBins({\n  pointCount,\n  getBinId\n}: {\n  pointCount: number;\n  getBinId: (index: number) => number[] | null;\n}): Bin[] {\n  const binsById: Map<string, Bin> = new Map();\n\n  for (let i = 0; i < pointCount; i++) {\n    const id = getBinId(i);\n    if (id === null) {\n      continue;\n    }\n    let bin = binsById.get(String(id));\n    if (bin) {\n      bin.points.push(i);\n    } else {\n      bin = {\n        id,\n        index: binsById.size,\n        points: [i]\n      };\n      binsById.set(String(id), bin);\n    }\n  }\n  return Array.from(binsById.values());\n}\n\n/** Pack bin ids into a typed array */\nexport function packBinIds({\n  bins,\n  dimensions,\n  target\n}: {\n  bins: Bin[];\n  /** Size of bin IDs */\n  dimensions: number;\n  /** Array to write output into */\n  target?: Float32Array | null;\n}): Float32Array {\n  const targetLength = bins.length * dimensions;\n  if (!target || target.length < targetLength) {\n    target = new Float32Array(targetLength);\n  }\n\n  for (let i = 0; i < bins.length; i++) {\n    const {id} = bins[i];\n    if (Array.isArray(id)) {\n      target.set(id, i * dimensions);\n    } else {\n      target[i] = id;\n    }\n  }\n  return target;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Bin} from './cpu-aggregator';\nimport type {AggregationOperation} from '../aggregator';\n\n/** A reducer function that takes a list of data points and outputs one measurement */\nexport type AggregationFunc = (\n  /** Indices of the points */\n  pointIndices: number[],\n  /** Accessor to the value for each point */\n  getValue: (index: number) => number\n) => number;\n\nconst count: AggregationFunc = pointIndices => {\n  return pointIndices.length;\n};\n\nconst sum: AggregationFunc = (pointIndices, getValue) => {\n  let result = 0;\n  for (const i of pointIndices) {\n    result += getValue(i);\n  }\n  return result;\n};\n\nconst mean: AggregationFunc = (pointIndices, getValue) => {\n  if (pointIndices.length === 0) {\n    return NaN;\n  }\n  return sum(pointIndices, getValue) / pointIndices.length;\n};\n\nconst min: AggregationFunc = (pointIndices, getValue) => {\n  let result = Infinity;\n  for (const i of pointIndices) {\n    const value = getValue(i);\n    if (value < result) {\n      result = value;\n    }\n  }\n  return result;\n};\n\nconst max: AggregationFunc = (pointIndices, getValue) => {\n  let result = -Infinity;\n  for (const i of pointIndices) {\n    const value = getValue(i);\n    if (value > result) {\n      result = value;\n    }\n  }\n  return result;\n};\n\nexport const BUILT_IN_OPERATIONS: Record<AggregationOperation, AggregationFunc> = {\n  COUNT: count,\n  SUM: sum,\n  MEAN: mean,\n  MIN: min,\n  MAX: max\n} as const;\n\n/**\n * Performs the aggregation step. See interface Aggregator comments.\n * @returns Floa32Array of aggregated values, one for each bin, and the [min,max] of the values\n */\nexport function aggregate({\n  bins,\n  getValue,\n  operation,\n  target\n}: {\n  /** Data points sorted by bins */\n  bins: Bin[];\n  /** Given the index of a data point, returns its value */\n  getValue: (index: number) => number;\n  /** Method used to reduce a list of values to one number */\n  operation: AggregationFunc;\n  /** Array to write the output into */\n  target?: Float32Array | null;\n}): {\n  value: Float32Array;\n  domain: [min: number, max: number];\n} {\n  if (!target || target.length < bins.length) {\n    target = new Float32Array(bins.length);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  let min = Infinity;\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  let max = -Infinity;\n\n  for (let j = 0; j < bins.length; j++) {\n    const {points} = bins[j];\n    target[j] = operation(points, getValue);\n    if (target[j] < min) min = target[j];\n    if (target[j] > max) max = target[j];\n  }\n\n  return {value: target, domain: [min, max]};\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Attribute} from '@deck.gl/core';\nimport type {TypedArray} from '@luma.gl/core';\n\n/** This is designed to mirror a vertex shader function\n * For each vertex, calculates a value from attribtes, vertex index and options (uniforms)\n */\nexport type VertexAccessor<ValueT, OptionsT = undefined> = {\n  /** Attribute ids that provide input to getValue, used to index into the attributes map.\n   * For example `['position', 'size']`\n   */\n  sources?: string[];\n  /** Called for each data point to retrieve a value during update. */\n  getValue: (\n    /** Attributes at the vertex index */\n    data: any,\n    /** Vertex index */\n    index: number,\n    /** Shared options across all vertices */\n    options: OptionsT\n  ) => ValueT;\n};\n\n/** Evaluate a VertexAccessor with a set of attributes */\nexport function evaluateVertexAccessor<ValueT, OptionsT>(\n  accessor: VertexAccessor<ValueT, OptionsT>,\n  attributes: Record<string, Attribute>,\n  options: OptionsT\n): (vertexIndex: number) => ValueT {\n  const vertexReaders: {[id: string]: (i: number) => number | number[]} = {};\n  for (const id of accessor.sources || []) {\n    const attribute = attributes[id];\n    if (attribute) {\n      vertexReaders[id] = getVertexReader(attribute);\n    } else {\n      throw new Error(`Cannot find attribute ${id}`);\n    }\n  }\n  const data: {[id: string]: number | number[]} = {};\n\n  return (vertexIndex: number) => {\n    for (const id in vertexReaders) {\n      data[id] = vertexReaders[id](vertexIndex);\n    }\n    return accessor.getValue(data, vertexIndex, options);\n  };\n}\n\n/** Read value out of a deck.gl Attribute by vertex */\nfunction getVertexReader(attribute: Attribute): (vertexIndex: number) => number | number[] {\n  const value = attribute.value as TypedArray;\n  const {offset = 0, stride, size} = attribute.getAccessor();\n  const bytesPerElement = value.BYTES_PER_ELEMENT;\n  const elementOffset = offset / bytesPerElement;\n  const elementStride = stride ? stride / bytesPerElement : size;\n\n  if (size === 1) {\n    // Size 1, returns (i: number) => number\n    if (attribute.isConstant) {\n      return () => value[0];\n    }\n    return (vertexIndex: number) => {\n      const i = elementOffset + elementStride * vertexIndex;\n      return value[i];\n    };\n  }\n\n  // Size >1, returns (i: number) => number[]\n  let result: number[];\n  if (attribute.isConstant) {\n    result = Array.from(value);\n    return () => result;\n  }\n\n  result = new Array(size);\n  return (vertexIndex: number) => {\n    const i = elementOffset + elementStride * vertexIndex;\n    for (let j = 0; j < size; j++) {\n      result[j] = value[i + j];\n    }\n    return result;\n  };\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Model, ModelProps} from '@luma.gl/engine';\nimport {createRenderTarget} from './utils';\n\nimport type {Device, Framebuffer, Texture} from '@luma.gl/core';\nimport type {WebGLAggregatorProps} from './webgl-aggregator';\nimport type {AggregationOperation} from '../aggregator';\nimport {BinSorterProps, binSorterUniforms} from './bin-sorter-uniforms';\n\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPU color mask RED, GREEN, BLUE, ALPHA\nconst MAX_FLOAT32 = 3e38;\nconst EMPTY_MASKS = {SUM: 0, MEAN: 0, MIN: 0, MAX: 0, COUNT: 0};\n\nexport const TEXTURE_WIDTH = 1024;\n\n/**\n * This class manages the resources for performing the first step of aggregation\n * Sort a list of data points into a number of bins\n */\nexport class WebGLBinSorter {\n  device: Device;\n  model: Model;\n\n  /**\n   * A packed texture in which each pixel represents a bin.\n   * The index of the pixel in the memory layout is the bin index.\n   * Alpha value is the count of data points that fall into this bin\n   * R,G,B values are the aggregated values of each channel:\n   *   - Sum of all data points if operation is 'SUM', or 'MEAN'\n   *   - Min of all data points if operation is 'MIN'\n   *   - Max of all data points if operation is 'MAX'\n   */\n  private binsFBO: Framebuffer | null = null;\n\n  constructor(device: Device, props: WebGLAggregatorProps) {\n    this.device = device;\n    this.model = createModel(device, props);\n  }\n\n  get texture(): Texture | null {\n    return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;\n  }\n\n  destroy() {\n    this.model.destroy();\n    this.binsFBO?.colorAttachments[0].texture.destroy();\n    this.binsFBO?.destroy();\n  }\n\n  getBinValues(index: number): Float32Array | null {\n    if (!this.binsFBO) {\n      return null;\n    }\n    const x = index % TEXTURE_WIDTH;\n    const y = Math.floor(index / TEXTURE_WIDTH);\n    const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {\n      sourceX: x,\n      sourceY: y,\n      sourceWidth: 1,\n      sourceHeight: 1\n    }).buffer;\n    return new Float32Array(buffer);\n  }\n\n  setDimensions(binCount: number, binIdRange: [number, number][]) {\n    const width = TEXTURE_WIDTH;\n    const height = Math.ceil(binCount / width);\n\n    // Only destroy existing texture if it is not large enough\n    if (!this.binsFBO) {\n      this.binsFBO = createRenderTarget(this.device, width, height);\n    } else if (this.binsFBO.height < height) {\n      this.binsFBO.resize({width, height});\n    }\n\n    const binSorterProps: BinSorterProps = {\n      binIdRange: [\n        binIdRange[0][0],\n        binIdRange[0][1],\n        binIdRange[1]?.[0] || 0,\n        binIdRange[1]?.[1] || 0\n      ],\n      targetSize: [this.binsFBO.width, this.binsFBO.height]\n    };\n    this.model.shaderInputs.setProps({binSorter: binSorterProps});\n  }\n\n  setModelProps(\n    props: Pick<ModelProps, 'vertexCount' | 'uniforms' | 'attributes' | 'constantAttributes'> & {\n      shaderModuleProps?: Record<string, any>;\n    }\n  ) {\n    const model = this.model;\n    if (props.attributes) {\n      model.setAttributes(props.attributes);\n    }\n    if (props.constantAttributes) {\n      model.setConstantAttributes(props.constantAttributes);\n    }\n    if (props.vertexCount !== undefined) {\n      model.setVertexCount(props.vertexCount);\n    }\n    if (props.shaderModuleProps) {\n      model.shaderInputs.setProps(props.shaderModuleProps);\n    }\n  }\n\n  /** Update aggregation */\n  update(\n    /** The aggregation operation for each channel. Use null to skip update. */\n    operations: (AggregationOperation | null)[]\n  ) {\n    if (!this.binsFBO) {\n      return;\n    }\n    const masks = getMaskByOperation(operations);\n    this._updateBins('SUM', masks.SUM + masks.MEAN);\n    this._updateBins('MIN', masks.MIN);\n    this._updateBins('MAX', masks.MAX);\n  }\n\n  /** Recalculate aggregation on the given channels using the given operation */\n  private _updateBins(\n    operation: AggregationOperation,\n    /** GPU bit mask of one or more channels that should be updated */\n    colorMask: number\n  ) {\n    if (colorMask === 0) {\n      return;\n    }\n    colorMask |= COLOR_CHANNELS[3]; // Also renders to the alpha channel (point count)\n\n    const model = this.model;\n    const target = this.binsFBO!;\n\n    const initialValue = operation === 'MAX' ? -MAX_FLOAT32 : operation === 'MIN' ? MAX_FLOAT32 : 0;\n    const renderPass = this.device.beginRenderPass({\n      id: `gpu-aggregation-${operation}`,\n      framebuffer: target,\n      parameters: {\n        viewport: [0, 0, target.width, target.height],\n        colorMask\n      },\n      clearColor: [initialValue, initialValue, initialValue, 0],\n      clearDepth: false,\n      clearStencil: false\n    });\n    model.setParameters({\n      blend: true,\n      blendColorSrcFactor: 'one',\n      blendColorDstFactor: 'one',\n      blendAlphaSrcFactor: 'one',\n      blendAlphaDstFactor: 'one',\n      blendColorOperation: operation === 'MAX' ? 'max' : operation === 'MIN' ? 'min' : 'add',\n      blendAlphaOperation: 'add'\n    });\n    model.draw(renderPass);\n    renderPass.end();\n  }\n}\n\n/** Convert a [channel -> operation] map to a [operation -> GPU color mask] map */\nfunction getMaskByOperation(\n  operations: (AggregationOperation | null)[]\n): Record<AggregationOperation, number> {\n  const result: Record<AggregationOperation, number> = {...EMPTY_MASKS};\n  for (let channel = 0; channel < operations.length; channel++) {\n    const op = operations[channel];\n    if (op) {\n      result[op] += COLOR_CHANNELS[channel];\n    }\n  }\n  return result;\n}\n\nfunction createModel(device: Device, props: WebGLAggregatorProps): Model {\n  let userVs = props.vs;\n\n  if (props.dimensions === 2) {\n    // If user provides 2d bin IDs, convert them to 1d indices for data packing\n    userVs += /* glsl */ `\nvoid getBin(out int binId) {\n  ivec2 binId2;\n  getBin(binId2);\n  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {\n    binId = -1;\n  } else {\n    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;\n  }\n}\n`;\n  }\n\n  const vs = `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-vertex\n\n${userVs}\n\nout vec3 v_Value;\n\nvoid main() {\n  int binIndex;\n  getBin(binIndex);\n  binIndex = binIndex - binSorter.binIdRange.x;\n  if (binIndex < 0) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  int row = binIndex / binSorter.targetSize.x;\n  int col = binIndex - row * binSorter.targetSize.x;\n  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;\n  gl_Position = vec4(position, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n#if NUM_CHANNELS == 3\n  getValue(v_Value);\n#elif NUM_CHANNELS == 2\n  getValue(v_Value.xy);\n#else\n  getValue(v_Value.x);\n#endif\n}\n`;\n  const fs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-fragment\n\nprecision highp float;\n\nin vec3 v_Value;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor.xyz = v_Value;\n\n  #ifdef MODULE_GEOMETRY\n  geometry.uv = vec2(0.);\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n  #endif\n\n  fragColor.w = 1.0;\n}\n`;\n  const model = new Model(device, {\n    bufferLayout: props.bufferLayout,\n    modules: [...(props.modules || []), binSorterUniforms],\n    // @ts-expect-error TODO fix luma type\n    defines: {...props.defines, NON_INSTANCED_MODEL: 1, NUM_CHANNELS: props.channelCount},\n    isInstanced: false,\n    vs,\n    fs,\n    topology: 'point-list',\n    disableWarnings: true\n  });\n  return model;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Device, Framebuffer} from '@luma.gl/core';\n\n/**\n * Create a float texture to store aggregation result\n */\nexport function createRenderTarget(device: Device, width: number, height: number): Framebuffer {\n  return device.createFramebuffer({\n    width,\n    height,\n    colorAttachments: [\n      device.createTexture({\n        width,\n        height,\n        format: 'rgba32float',\n        sampler: {\n          minFilter: 'nearest',\n          magFilter: 'nearest'\n        }\n      })\n    ]\n  });\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {NumberArray2, NumberArray4} from '@math.gl/core';\nimport {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = /* glsl */ `\\\nuniform binSorterUniforms {\n  ivec4 binIdRange;\n  ivec2 targetSize;\n} binSorter;\n`;\n\nexport type BinSorterProps = {\n  binIdRange: NumberArray4;\n  targetSize: NumberArray2;\n};\n\nexport const binSorterUniforms = {\n  name: 'binSorter',\n  vs: uniformBlock,\n  uniformTypes: {\n    binIdRange: 'vec4<i32>',\n    targetSize: 'vec2<i32>'\n  }\n} as const satisfies ShaderModule<BinSorterProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {BufferTransform} from '@luma.gl/engine';\nimport {createRenderTarget} from './utils';\n\nimport type {Device, Framebuffer, Buffer, Texture} from '@luma.gl/core';\nimport type {WebGLAggregatorProps} from './webgl-aggregator';\nimport type {AggregationOperation} from '../aggregator';\n\nimport {TEXTURE_WIDTH} from './webgl-bin-sorter';\nimport {\n  AggregatorTransformProps,\n  aggregatorTransformUniforms\n} from './aggregation-transform-uniforms';\nimport {NumberArray3} from '@math.gl/core';\n\nconst MAX_FLOAT32 = 3e38;\n\nexport class WebGLAggregationTransform {\n  device: Device;\n  channelCount: number;\n\n  /** Packed from bin ids */\n  binBuffer: Buffer | null = null;\n  /** Packed values from each channel of each bin\n   * Stride is number of channels * 4 bytes (float32)\n   */\n  valueBuffer: Buffer | null = null;\n\n  private transform: BufferTransform;\n  /** Render target for calculating domain */\n  private domainFBO: Framebuffer;\n  /** Aggregated [min, max] for each channel */\n  private _domains: [min: number, max: number][] | null = null;\n\n  constructor(device: Device, props: WebGLAggregatorProps) {\n    this.device = device;\n    this.channelCount = props.channelCount;\n    this.transform = createTransform(device, props);\n    this.domainFBO = createRenderTarget(device, 2, 1);\n  }\n\n  destroy() {\n    this.transform.destroy();\n    this.binBuffer?.destroy();\n    this.valueBuffer?.destroy();\n    this.domainFBO.colorAttachments[0].texture.destroy();\n    this.domainFBO.destroy();\n  }\n\n  get domains(): [min: number, max: number][] {\n    if (!this._domains) {\n      // Domain model has run, but result has not been read to CPU\n      const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;\n      const domain = new Float32Array(buffer);\n      this._domains = [\n        [-domain[4], domain[0]],\n        [-domain[5], domain[1]],\n        [-domain[6], domain[2]]\n      ].slice(0, this.channelCount) as [number, number][];\n    }\n    return this._domains;\n  }\n\n  setDimensions(binCount: number, binIdRange: [number, number][]) {\n    const {model, transformFeedback} = this.transform;\n    model.setVertexCount(binCount);\n    const aggregatorTransformProps: Partial<AggregatorTransformProps> = {\n      binIdRange: [\n        binIdRange[0][0],\n        binIdRange[0][1],\n        binIdRange[1]?.[0] || 0,\n        binIdRange[1]?.[1] || 0\n      ]\n    };\n    model.shaderInputs.setProps({aggregatorTransform: aggregatorTransformProps});\n\n    // Only destroy existing buffer if it is not large enough\n    const binBufferByteLength = binCount * binIdRange.length * 4;\n    if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {\n      this.binBuffer?.destroy();\n      this.binBuffer = this.device.createBuffer({byteLength: binBufferByteLength});\n      transformFeedback.setBuffer('binIds', this.binBuffer);\n    }\n\n    const valueBufferByteLength = binCount * this.channelCount * 4;\n    if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {\n      this.valueBuffer?.destroy();\n      this.valueBuffer = this.device.createBuffer({byteLength: valueBufferByteLength});\n      transformFeedback.setBuffer('values', this.valueBuffer);\n    }\n  }\n\n  update(bins: Texture | null, operations: AggregationOperation[]) {\n    if (!bins) {\n      return;\n    }\n    const transform = this.transform;\n    const target = this.domainFBO;\n\n    const isCount = [0, 1, 2].map(i => (operations[i] === 'COUNT' ? 1 : 0));\n    const isMean = [0, 1, 2].map(i => (operations[i] === 'MEAN' ? 1 : 0));\n    const aggregatorTransformProps: Partial<AggregatorTransformProps> = {\n      isCount: isCount as NumberArray3,\n      isMean: isMean as NumberArray3,\n      bins\n    };\n    transform.model.shaderInputs.setProps({aggregatorTransform: aggregatorTransformProps});\n\n    transform.run({\n      id: 'gpu-aggregation-domain',\n      framebuffer: target,\n      parameters: {\n        viewport: [0, 0, 2, 1]\n      },\n      clearColor: [-MAX_FLOAT32, -MAX_FLOAT32, -MAX_FLOAT32, 0],\n      clearDepth: false,\n      clearStencil: false\n    });\n\n    // Clear the last read results. This will be lazy-populated if used.\n    this._domains = null;\n  }\n}\n\nfunction createTransform(device: Device, props: WebGLAggregatorProps): BufferTransform {\n  const vs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-vertex\n\nuniform sampler2D bins;\n\n#if NUM_DIMS == 1\nout float binIds;\n#else\nout vec2 binIds;\n#endif\n\n#if NUM_CHANNELS == 1\nflat out float values;\n#elif NUM_CHANNELS == 2\nflat out vec2 values;\n#else\nflat out vec3 values;\n#endif\n\nconst float NAN = intBitsToFloat(-1);\n\nvoid main() {\n  int row = gl_VertexID / SAMPLER_WIDTH;\n  int col = gl_VertexID - row * SAMPLER_WIDTH;\n  vec4 weights = texelFetch(bins, ivec2(col, row), 0);\n  vec3 value3 = mix(\n    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),\n    weights.rgb / max(weights.a, 1.0),\n    aggregatorTransform.isMean\n  );\n  if (weights.a == 0.0) {\n    value3 = vec3(NAN);\n  }\n\n#if NUM_DIMS == 1\n  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);\n#else\n  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  binIds.y = float(y + aggregatorTransform.binIdRange.z);\n  binIds.x = float(x + aggregatorTransform.binIdRange.x);\n#endif\n\n#if NUM_CHANNELS == 3\n  values = value3;\n#elif NUM_CHANNELS == 2\n  values = value3.xy;\n#else\n  values = value3.x;\n#endif\n\n  gl_Position = vec4(0., 0., 0., 1.);\n  // This model renders into a 2x1 texture to obtain min and max simultaneously.\n  // See comments in fragment shader\n  gl_PointSize = 2.0;\n}\n`;\n\n  const fs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-fragment\n\nprecision highp float;\n\n#if NUM_CHANNELS == 1\nflat in float values;\n#elif NUM_CHANNELS == 2\nflat in vec2 values;\n#else\nflat in vec3 values;\n#endif\n\nout vec4 fragColor;\n\nvoid main() {\n  vec3 value3;\n#if NUM_CHANNELS == 3\n  value3 = values;\n#elif NUM_CHANNELS == 2\n  value3.xy = values;\n#else\n  value3.x = values;\n#endif\n  if (isnan(value3.x)) discard;\n  // This shader renders into a 2x1 texture with blending=max\n  // The left pixel yields the max value of each channel\n  // The right pixel yields the min value of each channel\n  if (gl_FragCoord.x < 1.0) {\n    fragColor = vec4(value3, 1.0);\n  } else {\n    fragColor = vec4(-value3, 1.0);\n  }\n}\n`;\n\n  return new BufferTransform(device, {\n    vs,\n    fs,\n    topology: 'point-list',\n    modules: [aggregatorTransformUniforms],\n    parameters: {\n      blend: true,\n      blendColorSrcFactor: 'one',\n      blendColorDstFactor: 'one',\n      blendColorOperation: 'max',\n      blendAlphaSrcFactor: 'one',\n      blendAlphaDstFactor: 'one',\n      blendAlphaOperation: 'max'\n    },\n    defines: {\n      // @ts-expect-error TODO fix luma type\n      NUM_DIMS: props.dimensions,\n      // @ts-expect-error TODO fix luma type\n      NUM_CHANNELS: props.channelCount,\n      // @ts-expect-error TODO fix luma type\n      SAMPLER_WIDTH: TEXTURE_WIDTH\n    },\n    varyings: ['binIds', 'values'],\n    disableWarnings: true\n  });\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {NumberArray3, NumberArray4} from '@math.gl/core';\nimport {ShaderModule} from '@luma.gl/shadertools';\nimport {Texture} from '@luma.gl/core';\n\nconst uniformBlock = /* glsl */ `\\\nuniform aggregatorTransformUniforms {\n  ivec4 binIdRange;\n  bvec3 isCount;\n  bvec3 isMean;\n  float naN;\n} aggregatorTransform;\n`;\n\nexport type AggregatorTransformProps = {\n  binIdRange: NumberArray4;\n  isCount: NumberArray3;\n  isMean: NumberArray3;\n  bins: Texture;\n};\n\nexport const aggregatorTransformUniforms = {\n  name: 'aggregatorTransform',\n  vs: uniformBlock,\n  uniformTypes: {\n    binIdRange: 'vec4<i32>',\n    isCount: 'vec3<f32>',\n    isMean: 'vec3<f32>'\n  }\n} as const satisfies ShaderModule<AggregatorTransformProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {WebGLBinSorter} from './webgl-bin-sorter';\nimport {WebGLAggregationTransform} from './webgl-aggregation-transform';\nimport {_deepEqual as deepEqual, log, BinaryAttribute} from '@deck.gl/core';\n\nimport type {Aggregator, AggregationProps, AggregatedBin} from '../aggregator';\nimport type {Device, Buffer, BufferLayout, TypedArray} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\n/** Options used to construct a new WebGLAggregator */\nexport type WebGLAggregatorProps = {\n  /** Size of bin IDs */\n  dimensions: 1 | 2;\n  /** How many properties to perform aggregation on */\n  channelCount: 1 | 2 | 3;\n  /** Buffer layout for input attributes */\n  bufferLayout?: BufferLayout[];\n  /** Define a shader function with one of the signatures\n   *  `void getBin(out int binId)`: if dimensions=1\n   *  `void getBin(out ivec2 binId)`: if dimensions=2\n   * And a shader function with one of the signatures\n   *  `void getValue(out float value)`: if channelCount=1\n   *  `void getValue(out vec2 value)`: if channelCount=2\n   *  `void getValue(out vec3 value)`: if channelCount=3\n   */\n  vs: string;\n  /** Shader modules\n   * Required to support certain layer extensions (e.g. data filter)\n   */\n  modules?: ShaderModule[];\n  /** Shadertool module defines */\n  defines?: Record<string, string | number | boolean>;\n} & Partial<WebGLAggregationProps>;\n\n/** Props used to run GPU aggregation, can be changed at any time */\ntype WebGLAggregationProps = AggregationProps & {\n  /** Limits of binId defined for each dimension. Ids outside of the [start, end) are ignored.\n   */\n  binIdRange: [start: number, end: number][];\n  /** Context props passed to the shader modules */\n  shaderModuleProps?: Record<string, any>;\n};\n\n/** An Aggregator implementation that calculates aggregation on the GPU */\nexport class WebGLAggregator implements Aggregator {\n  /** Checks if the current device supports GPU aggregation */\n  static isSupported(device: Device): boolean {\n    return (\n      device.features.has('float32-renderable-webgl') &&\n      device.features.has('texture-blend-float-webgl')\n    );\n  }\n\n  readonly dimensions: 1 | 2;\n  readonly channelCount: 1 | 2 | 3;\n  binCount: number = 0;\n\n  readonly device: Device;\n  props: WebGLAggregatorProps & WebGLAggregationProps;\n\n  /** Dirty flag per channel */\n  protected needsUpdate: boolean[];\n  /** Step 1. sort data points into bins, blended using an aggregation opera\u2020ion */\n  protected binSorter: WebGLBinSorter;\n  /** Step 2. (optional) calculate the min/max across all bins */\n  protected aggregationTransform: WebGLAggregationTransform;\n\n  /** Cached outputs */\n  protected binIds: BinaryAttribute | null = null;\n  protected results: BinaryAttribute[] = [];\n\n  constructor(device: Device, props: WebGLAggregatorProps) {\n    this.device = device;\n    this.dimensions = props.dimensions;\n    this.channelCount = props.channelCount;\n    this.props = {\n      ...props,\n      pointCount: 0,\n      binIdRange: [[0, 0]],\n      operations: [],\n      attributes: {},\n      binOptions: {}\n    };\n    this.needsUpdate = new Array(this.channelCount).fill(true);\n    this.binSorter = new WebGLBinSorter(device, props);\n    this.aggregationTransform = new WebGLAggregationTransform(device, props);\n    this.setProps(props);\n  }\n\n  getBins(): BinaryAttribute | null {\n    const buffer = this.aggregationTransform.binBuffer;\n    if (!buffer) {\n      return null;\n    }\n    if (this.binIds?.buffer !== buffer) {\n      // deck.gl Attribute.setBinaryValue uses shallow comparison to determine if attribute value has changed\n      // For performance, only create a new binary attribute descriptor when Buffer changes\n      this.binIds = {buffer, type: 'float32', size: this.dimensions};\n    }\n    return this.binIds;\n  }\n\n  /** Returns an accessor to the output for a given channel. */\n  getResult(channel: 0 | 1 | 2): BinaryAttribute | null {\n    const buffer = this.aggregationTransform.valueBuffer;\n    if (!buffer || channel >= this.channelCount) {\n      return null;\n    }\n    if (this.results[channel]?.buffer !== buffer) {\n      this.results[channel] = {\n        buffer,\n        type: 'float32',\n        size: 1,\n        stride: this.channelCount * 4,\n        offset: channel * 4\n      };\n    }\n    return this.results[channel];\n  }\n\n  /** Returns the [min, max] of aggregated values for a given channel. */\n  getResultDomain(channel: 0 | 1 | 2): [min: number, max: number] {\n    return this.aggregationTransform.domains[channel];\n  }\n\n  /** Returns the information for a given bin. */\n  getBin(index: number): AggregatedBin | null {\n    if (index < 0 || index >= this.binCount) {\n      return null;\n    }\n    const {binIdRange} = this.props;\n    let id: number[];\n\n    if (this.dimensions === 1) {\n      id = [index + binIdRange[0][0]];\n    } else {\n      const [[x0, x1], [y0]] = binIdRange;\n      const width = x1 - x0;\n      id = [(index % width) + x0, Math.floor(index / width) + y0];\n    }\n\n    const pixel = this.binSorter.getBinValues(index);\n    if (!pixel) {\n      return null;\n    }\n    const count = pixel[3];\n    const value: number[] = [];\n    for (let channel = 0; channel < this.channelCount; channel++) {\n      const operation = this.props.operations[channel];\n      if (operation === 'COUNT') {\n        value[channel] = count;\n      } else if (count === 0) {\n        value[channel] = NaN;\n      } else {\n        value[channel] = operation === 'MEAN' ? pixel[channel] / count : pixel[channel];\n      }\n    }\n    return {id, value, count};\n  }\n\n  /** Release GPU resources */\n  destroy() {\n    this.binSorter.destroy();\n    this.aggregationTransform.destroy();\n  }\n\n  /** Update aggregation props. Normalize prop values and set change flags. */\n  // eslint-disable-next-line complexity, max-statements\n  setProps(props: Partial<WebGLAggregationProps>) {\n    const oldProps = this.props;\n\n    // Update local settings. These will set the flag this._needsUpdate\n    if ('binIdRange' in props && !deepEqual(props.binIdRange, oldProps.binIdRange, 2)) {\n      const binIdRange = props.binIdRange!;\n      log.assert(binIdRange.length === this.dimensions);\n\n      if (this.dimensions === 1) {\n        const [[x0, x1]] = binIdRange;\n        this.binCount = x1 - x0;\n      } else {\n        const [[x0, x1], [y0, y1]] = binIdRange;\n        this.binCount = (x1 - x0) * (y1 - y0);\n      }\n\n      this.binSorter.setDimensions(this.binCount, binIdRange);\n      this.aggregationTransform.setDimensions(this.binCount, binIdRange);\n      this.setNeedsUpdate();\n    }\n    if (props.operations) {\n      for (let channel = 0; channel < this.channelCount; channel++) {\n        if (props.operations[channel] !== oldProps.operations[channel]) {\n          this.setNeedsUpdate(channel);\n        }\n      }\n    }\n    if (props.pointCount !== undefined && props.pointCount !== oldProps.pointCount) {\n      this.binSorter.setModelProps({vertexCount: props.pointCount});\n      this.setNeedsUpdate();\n    }\n    if (props.binOptions) {\n      if (!deepEqual(props.binOptions, oldProps.binOptions, 2)) {\n        this.setNeedsUpdate();\n      }\n      this.binSorter.model.shaderInputs.setProps({binOptions: props.binOptions});\n    }\n    if (props.attributes) {\n      const attributeBuffers: Record<string, Buffer> = {};\n      const constantAttributes: Record<string, TypedArray> = {};\n\n      for (const attribute of Object.values(props.attributes)) {\n        for (const [attributeName, value] of Object.entries(attribute.getValue())) {\n          if (ArrayBuffer.isView(value)) {\n            constantAttributes[attributeName] = value;\n          } else if (value) {\n            attributeBuffers[attributeName] = value;\n          }\n        }\n      }\n      this.binSorter.setModelProps({attributes: attributeBuffers, constantAttributes});\n    }\n    if (props.shaderModuleProps) {\n      this.binSorter.setModelProps({shaderModuleProps: props.shaderModuleProps});\n    }\n\n    Object.assign(this.props, props);\n  }\n\n  /** Flags a channel to need update.\n   * This is called internally by setProps() if certain props change\n   * Users of this class still need to manually set the dirty flag sometimes, because even if no props changed\n   * the underlying buffers could have been updated and require rerunning the aggregation\n   * @param {number} channel - mark the given channel as dirty. If not provided, all channels will be updated.\n   */\n  setNeedsUpdate(channel?: number) {\n    if (channel === undefined) {\n      this.needsUpdate.fill(true);\n    } else {\n      this.needsUpdate[channel] = true;\n    }\n  }\n\n  update() {}\n\n  /** Run aggregation */\n  preDraw() {\n    if (!this.needsUpdate.some(Boolean)) {\n      return;\n    }\n\n    const {operations} = this.props;\n    const operationsToUpdate = this.needsUpdate.map((needsUpdate, i) =>\n      needsUpdate ? operations[i] : null\n    );\n    // Render data to bins\n    this.binSorter.update(operationsToUpdate);\n    // Read to buffer and calculate domain\n    this.aggregationTransform.update(this.binSorter.texture, operations);\n\n    for (let i = 0; i < this.channelCount; i++) {\n      if (this.needsUpdate[i]) {\n        this.needsUpdate[i] = false;\n        this.props.onUpdate?.({channel: i});\n      }\n    }\n\n    // Uncomment to debug\n    // console.log('binsFBO', new Float32Array(this.device.readPixelsToArrayWebGL(this.binSorter.texture!).buffer));\n    // console.log('binsBuffer', new Float32Array(this.aggregationTransform.binBuffer?.readSyncWebGL().buffer!));\n    // console.log('resultBuffer', new Float32Array(this.aggregationTransform.valueBuffer?.readSyncWebGL().buffer!));\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  CompositeLayer,\n  LayerDataSource,\n  LayerContext,\n  UpdateParameters,\n  CompositeLayerProps,\n  Attribute,\n  AttributeManager\n} from '@deck.gl/core';\nimport {Aggregator} from './aggregator/aggregator';\n\nexport type AggregationLayerProps<DataT> = CompositeLayerProps & {\n  data: LayerDataSource<DataT>;\n};\n\nexport default abstract class AggregationLayer<\n  DataT,\n  ExtraPropsT extends {} = {}\n> extends CompositeLayer<Required<AggregationLayer<DataT>> & ExtraPropsT> {\n  static layerName = 'AggregationLayer';\n\n  state!: {\n    aggregatorType: string;\n    aggregator: Aggregator;\n  };\n\n  /** Allow this layer to participates in the draw cycle */\n  get isDrawable() {\n    return true;\n  }\n\n  abstract getAggregatorType(): string;\n  /** Called to create an Aggregator instance */\n  abstract createAggregator(type: string): Aggregator;\n  /** Called when some attributes change, a chance to mark Aggregator as dirty */\n  abstract onAttributeChange(id: string): void;\n\n  initializeState(): void {\n    this.getAttributeManager()!.remove(['instancePickingColors']);\n  }\n\n  // Extend Layer.updateState to update the Aggregator instance\n  // returns true if aggregator is changed\n  updateState(params: UpdateParameters<this>): boolean {\n    super.updateState(params);\n\n    const aggregatorType = this.getAggregatorType();\n    if (params.changeFlags.extensionsChanged || this.state.aggregatorType !== aggregatorType) {\n      this.state.aggregator?.destroy();\n      const aggregator = this.createAggregator(aggregatorType);\n      aggregator.setProps({\n        attributes: this.getAttributeManager()?.attributes\n      });\n      this.setState({aggregator, aggregatorType});\n      return true;\n    }\n    return false;\n  }\n\n  // Override Layer.finalizeState to dispose the Aggregator instance\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    this.state.aggregator.destroy();\n  }\n\n  // Override Layer.updateAttributes to update the aggregator\n  protected updateAttributes(changedAttributes: {[id: string]: Attribute}) {\n    const {aggregator} = this.state;\n    aggregator.setProps({\n      attributes: changedAttributes\n    });\n\n    for (const id in changedAttributes) {\n      this.onAttributeChange(id);\n    }\n\n    // In aggregator.update() the aggregator allocates the buffers to store its output\n    // These buffers will be exposed by aggregator.getResults() and passed to the sublayers\n    // Therefore update() must be called before renderLayers()\n    // CPUAggregator's output is populated right here in update()\n    // GPUAggregator's output is pre-allocated and populated in preDraw(), see comments below\n    aggregator.update();\n  }\n\n  draw({shaderModuleProps}) {\n    // GPU aggregation needs `shaderModuleProps` for projection/filter uniforms which are only accessible at draw time\n    // GPUAggregator's Buffers are pre-allocated during `update()` and passed down to the sublayer attributes in renderLayers()\n    // Although the Buffers have been bound to the sublayer's Model, their content are not populated yet\n    // GPUAggregator.preDraw() is called in the draw cycle here right before Buffers are used by sublayer.draw()\n    const {aggregator} = this.state;\n    // @ts-expect-error only used by GPU aggregators\n    aggregator.setProps({shaderModuleProps});\n    aggregator.preDraw();\n  }\n\n  // override CompositeLayer._getAttributeManager to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.device, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport {Model, Geometry} from '@luma.gl/engine';\nimport {Layer, picking, UpdateParameters, Color} from '@deck.gl/core';\nimport {createColorRangeTexture, updateColorRangeTexture} from '../common/utils/color-utils';\nimport vs from './screen-grid-layer-vertex.glsl';\nimport fs from './screen-grid-layer-fragment.glsl';\nimport {ScreenGridProps, screenGridUniforms} from './screen-grid-layer-uniforms';\nimport {ShaderModule} from '@luma.gl/shadertools';\nimport type {ScaleType} from '../common/types';\n\n/** Proprties added by ScreenGridCellLayer. */\nexport type _ScreenGridCellLayerProps = {\n  cellSizePixels: number;\n  cellMarginPixels: number;\n  colorScaleType: ScaleType;\n  colorDomain: () => [number, number];\n  colorRange?: Color[];\n};\n\nexport default class ScreenGridCellLayer<ExtraPropsT extends {} = {}> extends Layer<\n  ExtraPropsT & Required<_ScreenGridCellLayerProps>\n> {\n  static layerName = 'ScreenGridCellLayer';\n\n  state!: {\n    model?: Model;\n    colorTexture: Texture;\n  };\n\n  getShaders(): {vs: string; fs: string; modules: ShaderModule[]} {\n    return super.getShaders({vs, fs, modules: [picking, screenGridUniforms]});\n  }\n\n  initializeState() {\n    this.getAttributeManager()!.addInstanced({\n      instancePositions: {\n        size: 2,\n        type: 'float32',\n        accessor: 'getBin'\n      },\n      instanceWeights: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getWeight'\n      }\n    });\n\n    this.state.model = this._getModel();\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const model = this.state.model!;\n\n    if (oldProps.colorRange !== props.colorRange) {\n      this.state.colorTexture?.destroy();\n      this.state.colorTexture = createColorRangeTexture(\n        this.context.device,\n        props.colorRange,\n        props.colorScaleType\n      );\n      const screenGridProps: Partial<ScreenGridProps> = {colorRange: this.state.colorTexture};\n      model.shaderInputs.setProps({screenGrid: screenGridProps});\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n    }\n\n    if (\n      oldProps.cellMarginPixels !== props.cellMarginPixels ||\n      oldProps.cellSizePixels !== props.cellSizePixels ||\n      changeFlags.viewportChanged\n    ) {\n      const {width, height} = this.context.viewport;\n      const {cellSizePixels: gridSize, cellMarginPixels} = this.props;\n      const cellSize = Math.max(gridSize - cellMarginPixels, 0);\n\n      const screenGridProps: Partial<ScreenGridProps> = {\n        gridSizeClipspace: [(gridSize / width) * 2, (gridSize / height) * 2],\n        cellSizeClipspace: [(cellSize / width) * 2, (cellSize / height) * 2]\n      };\n      model.shaderInputs.setProps({screenGrid: screenGridProps});\n    }\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n\n    this.state.colorTexture?.destroy();\n  }\n\n  draw({uniforms}) {\n    const colorDomain = this.props.colorDomain();\n    const model = this.state.model!;\n\n    const screenGridProps: Partial<ScreenGridProps> = {colorDomain};\n    model.shaderInputs.setProps({screenGrid: screenGridProps});\n    model.draw(this.context.renderPass);\n  }\n\n  // Private Methods\n\n  _getModel(): Model {\n    return new Model(this.context.device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts(),\n      geometry: new Geometry({\n        topology: 'triangle-strip',\n        attributes: {\n          positions: {\n            value: new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]),\n            size: 2\n          }\n        }\n      }),\n      isInstanced: true\n    });\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Color} from '@deck.gl/core';\nimport type {Device, Texture} from '@luma.gl/core';\nimport type {NumericArray, TypedArray, TypedArrayConstructor} from '@math.gl/types';\nimport type {ScaleType} from '../types';\n\nexport const defaultColorRange: Color[] = [\n  [255, 255, 178],\n  [254, 217, 118],\n  [254, 178, 76],\n  [253, 141, 60],\n  [240, 59, 32],\n  [189, 0, 38]\n];\n\n// Converts a colorRange array to a flat array with 4 components per color\nexport function colorRangeToFlatArray(\n  colorRange: Color[] | NumericArray,\n  normalize = false,\n  ArrayType: TypedArrayConstructor = Float32Array\n): TypedArray {\n  let flatArray: TypedArray;\n\n  if (Number.isFinite(colorRange[0])) {\n    // its already a flat array.\n    flatArray = new ArrayType(colorRange as NumericArray);\n  } else {\n    // flatten it\n    flatArray = new ArrayType(colorRange.length * 4);\n    let index = 0;\n\n    for (let i = 0; i < colorRange.length; i++) {\n      const color = colorRange[i];\n      flatArray[index++] = color[0];\n      flatArray[index++] = color[1];\n      flatArray[index++] = color[2];\n      flatArray[index++] = Number.isFinite(color[3]) ? color[3] : 255;\n    }\n  }\n\n  if (normalize) {\n    for (let i = 0; i < flatArray.length; i++) {\n      flatArray[i] /= 255;\n    }\n  }\n  return flatArray;\n}\n\nexport const COLOR_RANGE_FILTER: Record<ScaleType, 'linear' | 'nearest'> = {\n  linear: 'linear',\n  quantile: 'nearest',\n  quantize: 'nearest',\n  ordinal: 'nearest'\n} as const;\n\nexport function updateColorRangeTexture(texture: Texture, type: ScaleType) {\n  texture.setSampler({\n    minFilter: COLOR_RANGE_FILTER[type],\n    magFilter: COLOR_RANGE_FILTER[type]\n  });\n}\n\nexport function createColorRangeTexture(\n  device: Device,\n  colorRange: Color[] | NumericArray,\n  type: ScaleType = 'linear'\n): Texture {\n  const colors = colorRangeToFlatArray(colorRange, false, Uint8Array);\n\n  return device.createTexture({\n    format: 'rgba8unorm',\n    sampler: {\n      minFilter: COLOR_RANGE_FILTER[type],\n      magFilter: COLOR_RANGE_FILTER[type],\n      addressModeU: 'clamp-to-edge',\n      addressModeV: 'clamp-to-edge'\n    },\n    data: colors,\n    width: colors.length / 4,\n    height: 1\n  });\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME screen-grid-layer-vertex-shader\n#define RANGE_COUNT 6\n\nin vec2 positions;\nin vec2 instancePositions;\nin float instanceWeights;\nin vec3 instancePickingColors;\n\nuniform sampler2D colorRange;\n\nout vec4 vColor;\n\nvec4 interp(float value, vec2 domain, sampler2D range) {\n  float r = (value - domain.x) / (domain.y - domain.x);\n  return texture(range, vec2(r, 0.5));\n}\n\nvoid main(void) {\n  if (isnan(instanceWeights)) {\n    gl_Position = vec4(0.);\n    return;\n  }\n\n  vec2 pos = instancePositions * screenGrid.gridSizeClipspace + positions * screenGrid.cellSizeClipspace;\n  pos.x = pos.x - 1.0;\n  pos.y = 1.0 - pos.y;\n\n  gl_Position = vec4(pos, 0., 1.);\n\n  vColor = interp(instanceWeights, screenGrid.colorDomain, colorRange);\n  vColor.a *= layer.opacity;\n\n  // Set color to be rendered to picking fbo (also used to check for selection highlight).\n  picking_setPickingColor(instancePickingColors);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* fragment shader for the grid-layer */\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME screen-grid-layer-fragment-shader\n\nprecision highp float;\n\nin vec4 vColor;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  fragColor = vColor;\n\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = /* glsl */ `\\\nuniform screenGridUniforms {\n  vec2 cellSizeClipspace;\n  vec2 gridSizeClipspace;\n  vec2 colorDomain;\n} screenGrid;\n`;\n\nexport type ScreenGridProps = {\n  cellSizeClipspace: [number, number];\n  gridSizeClipspace: [number, number];\n  colorDomain: [number, number];\n  colorRange: Texture;\n};\n\nexport const screenGridUniforms = {\n  name: 'screenGrid',\n  vs: uniformBlock,\n  uniformTypes: {\n    cellSizeClipspace: 'vec2<f32>',\n    gridSizeClipspace: 'vec2<f32>',\n    colorDomain: 'vec2<f32>'\n  }\n} as const satisfies ShaderModule<ScreenGridProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = /* glsl */ `\\\nuniform binOptionsUniforms {\n  float cellSizePixels;\n} binOptions;\n`;\n\nexport type BinOptions = {\n  cellSizePixels: number;\n};\n\nexport const binOptionsUniforms = {\n  name: 'binOptions',\n  vs: uniformBlock,\n  uniformTypes: {\n    cellSizePixels: 'f32'\n  }\n} as const satisfies ShaderModule<BinOptions>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  log,\n  Accessor,\n  Color,\n  GetPickingInfoParams,\n  CompositeLayerProps,\n  createIterable,\n  Layer,\n  Material,\n  project32,\n  LayersList,\n  PickingInfo,\n  Position,\n  Viewport,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\nimport AggregationLayer from '../common/aggregation-layer';\nimport {AggregateAccessor} from '../common/types';\nimport {defaultColorRange} from '../common/utils/color-utils';\nimport {AttributeWithScale} from '../common/utils/scale-utils';\nimport {getBinIdRange} from '../common/utils/bounds-utils';\n\nimport HexagonCellLayer from './hexagon-cell-layer';\nimport {pointToHexbin, HexbinVertices, getHexbinCentroid, pointToHexbinGLSL} from './hexbin';\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n\nconst defaultProps: DefaultProps<HexagonLayerProps> = {\n  gpuAggregation: true,\n\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  upperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: noop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationLowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  elevationUpperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: noop,\n\n  // hexbin\n  radius: {type: 'number', min: 1, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  hexagonAggregator: {type: 'function', optional: true, value: null},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n/** All properties supported by HexagonLayer. */\nexport type HexagonLayerProps<DataT = unknown> = _HexagonLayerProps<DataT> & CompositeLayerProps;\n\n/** Properties added by HexagonLayer. */\ntype _HexagonLayerProps<DataT> = {\n  /**\n   * Radius of hexagon bin in meters. The hexagons are pointy-topped (rather than flat-topped).\n   * @default 1000\n   */\n  radius?: number;\n\n  /**\n   * Custom accessor to retrieve a hexagonal bin index from each data object.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  hexagonAggregator?: ((position: number[], radius: number) => [number, number]) | null;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Filter cells and re-calculate color by `upperPercentile`.\n   * Cells with value larger than the upperPercentile will be hidden.\n   * @default 100\n   */\n  upperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate color by `lowerPercentile`.\n   * Cells with value smaller than the lowerPercentile will be hidden.\n   * @default 0\n   */\n  lowerPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationUpperPercentile`.\n   * Cells with elevation value larger than the `elevationUpperPercentile` will be hidden.\n   * @default 100\n   */\n  elevationUpperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationLowerPercentile`.\n   * Cells with elevation value larger than the `elevationLowerPercentile` will be hidden.\n   * @default 0\n   */\n  elevationLowerPercentile?: number;\n\n  /**\n   * Scaling function used to determine the color of the grid cell, default value is 'quantize'.\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'quantize' | 'linear' | 'quantile' | 'ordinal';\n\n  /**\n   * Scaling function used to determine the elevation of the grid cell, only supports 'linear'.\n   * Supported Values are 'linear' and 'quantile'.\n   * @default 'linear'\n   */\n  elevationScaleType?: 'linear';\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  colorAggregation?: AggregationOperation;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  elevationAggregation?: AggregationOperation;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  getColorValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  getElevationValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * This callback will be called when bin color domain has been calculated.\n   * @default () => {}\n   */\n  onSetColorDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * This callback will be called when bin elevation domain has been calculated.\n   * @default () => {}\n   */\n  onSetElevationDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default true\n   */\n  gpuAggregation?: boolean;\n};\n\nexport type HexagonLayerPickingInfo<DataT> = PickingInfo<{\n  /** Column index of the picked cell */\n  col: number;\n  /** Row index of the picked cell */\n  row: number;\n  /** Aggregated color value, as determined by `getColorWeight` and `colorAggregation` */\n  colorValue: number;\n  /** Aggregated elevation value, as determined by `getElevationWeight` and `elevationAggregation` */\n  elevationValue: number;\n  /** Number of data points in the picked cell */\n  count: number;\n  /** Centroid of the hexagon */\n  position: [number, number];\n  /** Indices of the data objects in the picked cell. Only available if using CPU aggregation. */\n  pointIndices?: number[];\n  /** The data objects in the picked cell. Only available if using CPU aggregation and layer data is an array. */\n  points?: DataT[];\n}>;\n\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nexport default class HexagonLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_HexagonLayerProps<DataT>>> {\n  static layerName = 'HexagonLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] &\n    BinOptions & {\n      // Needed if getColorValue, getElevationValue are used\n      dataAsArray?: DataT[];\n\n      colors?: AttributeWithScale;\n      elevations?: AttributeWithScale;\n\n      binIdRange: [number, number][];\n      aggregatorViewport: Viewport;\n    };\n\n  getAggregatorType(): string {\n    const {gpuAggregation, hexagonAggregator, getColorValue, getElevationValue} = this.props;\n    if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n      return 'cpu';\n    }\n\n    if (\n      // GPU aggregation is requested\n      gpuAggregation &&\n      // GPU aggregation is supported by the device\n      WebGLAggregator.isSupported(this.context.device)\n    ) {\n      return 'gpu';\n    }\n    return 'cpu';\n  }\n\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\n    if (type === 'cpu') {\n      const {hexagonAggregator, radius} = this.props;\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\n            if (hexagonAggregator) {\n              return hexagonAggregator(positions, radius);\n            }\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {radiusCommon, hexOriginCommon} = opts;\n            return pointToHexbin(\n              [p[0] - hexOriginCommon[0], p[1] - hexOriginCommon[1]],\n              radiusCommon\n            );\n          }\n        },\n        getValue: [\n          {sources: ['colorWeights'], getValue: ({colorWeights}) => colorWeights},\n          {sources: ['elevationWeights'], getValue: ({elevationWeights}) => elevationWeights}\n        ]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 2,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n  \n  ${pointToHexbinGLSL}\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n      })\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      colorWeights: {size: 1, accessor: 'getColorWeight'},\n      elevationWeights: {size: 1, accessor: 'getElevationWeight'}\n    });\n  }\n\n  // eslint-disable-next-line complexity\n  updateState(params: UpdateParameters<this>) {\n    const aggregatorChanged = super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const {aggregator} = this.state;\n    if (\n      (changeFlags.dataChanged || !this.state.dataAsArray) &&\n      (props.getColorValue || props.getElevationValue)\n    ) {\n      // Convert data to array\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n    }\n    if (\n      aggregatorChanged ||\n      changeFlags.dataChanged ||\n      props.radius !== oldProps.radius ||\n      props.getColorValue !== oldProps.getColorValue ||\n      props.getElevationValue !== oldProps.getElevationValue ||\n      props.colorAggregation !== oldProps.colorAggregation ||\n      props.elevationAggregation !== oldProps.elevationAggregation\n    ) {\n      this._updateBinOptions();\n      const {radiusCommon, hexOriginCommon, binIdRange, dataAsArray} = this.state;\n\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.colorAggregation, props.elevationAggregation],\n        binOptions: {\n          radiusCommon,\n          hexOriginCommon\n        },\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n\n      if (dataAsArray) {\n        const {getColorValue, getElevationValue} = this.props;\n        aggregator.setProps({\n          // @ts-expect-error only used by CPUAggregator\n          customOperations: [\n            getColorValue &&\n              ((indices: number[]) =>\n                getColorValue(\n                  indices.map(i => dataAsArray[i]),\n                  {indices, data: props.data}\n                )),\n            getElevationValue &&\n              ((indices: number[]) =>\n                getElevationValue(\n                  indices.map(i => dataAsArray[i]),\n                  {indices, data: props.data}\n                ))\n          ]\n        });\n      }\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n      aggregator.setNeedsUpdate(0);\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n      aggregator.setNeedsUpdate(1);\n    }\n\n    return aggregatorChanged;\n  }\n\n  private _updateBinOptions() {\n    const bounds = this.getBounds();\n    let radiusCommon = 1;\n    let hexOriginCommon: [number, number] = [0, 0];\n    let binIdRange: [number, number][] = [\n      [0, 1],\n      [0, 1]\n    ];\n    let viewport = this.context.viewport;\n\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {radius} = this.props;\n      const {unitsPerMeter} = viewport.getDistanceScales(centroid);\n      radiusCommon = unitsPerMeter[0] * radius;\n\n      // Use the centroid of the hex at the center of the data\n      // This offsets the common space without changing the bins\n      const centerHex = pointToHexbin(viewport.projectFlat(centroid), radiusCommon);\n      centroid = viewport.unprojectFlat(getHexbinCentroid(centerHex, radiusCommon));\n\n      const ViewportType = viewport.constructor as any;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial\n        ? new ViewportType({longitude: centroid[0], latitude: centroid[1], zoom: 12})\n        : new Viewport({position: [centroid[0], centroid[1], 0], zoom: 12});\n\n      hexOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: (p: number[]) => {\n          const positionCommon = viewport.projectFlat(p);\n          positionCommon[0] -= hexOriginCommon[0];\n          positionCommon[1] -= hexOriginCommon[1];\n          return pointToHexbin(positionCommon, radiusCommon);\n        },\n        padding: 1\n      });\n    }\n\n    this.setState({radiusCommon, hexOriginCommon, binIdRange, aggregatorViewport: viewport});\n  }\n\n  override draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n\n  private _onAggregationUpdate({channel}: {channel: number}) {\n    const props = this.getCurrentLayer()!.props;\n    const {aggregator} = this.state;\n    if (channel === 0) {\n      const result = aggregator.getResult(0)!;\n      this.setState({\n        colors: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetColorDomain(aggregator.getResultDomain(0));\n    } else if (channel === 1) {\n      const result = aggregator.getResult(1)!;\n      this.setState({\n        elevations: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\n    }\n  }\n\n  onAttributeChange(id: string) {\n    const {aggregator} = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n\n        this._updateBinOptions();\n        const {radiusCommon, hexOriginCommon, binIdRange} = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            radiusCommon,\n            hexOriginCommon\n          }\n        });\n        break;\n\n      case 'colorWeights':\n        aggregator.setNeedsUpdate(0);\n        break;\n\n      case 'elevationWeights':\n        aggregator.setNeedsUpdate(1);\n        break;\n\n      default:\n      // This should not happen\n    }\n  }\n\n  renderLayers(): LayersList | Layer | null {\n    const {aggregator, radiusCommon, hexOriginCommon} = this.state;\n    const {\n      elevationScale,\n      colorRange,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      transitions,\n      colorScaleType,\n      lowerPercentile,\n      upperPercentile,\n      colorDomain,\n      elevationScaleType,\n      elevationLowerPercentile,\n      elevationUpperPercentile,\n      elevationDomain\n    } = this.props;\n    const CellLayerClass = this.getSubLayerClass('cells', HexagonCellLayer);\n    const binAttribute = aggregator.getBins();\n\n    const colors = this.state.colors?.update({\n      scaleType: colorScaleType,\n      lowerPercentile,\n      upperPercentile\n    });\n    const elevations = this.state.elevations?.update({\n      scaleType: elevationScaleType,\n      lowerPercentile: elevationLowerPercentile,\n      upperPercentile: elevationUpperPercentile\n    });\n\n    if (!colors || !elevations) {\n      return null;\n    }\n\n    return new CellLayerClass(\n      this.getSubLayerProps({\n        id: 'cells'\n      }),\n      {\n        data: {\n          length: aggregator.binCount,\n          attributes: {\n            getBin: binAttribute,\n            getColorValue: colors.attribute,\n            getElevationValue: elevations.attribute\n          }\n        },\n        // Data has changed shallowly, but we likely don't need to update the attributes\n        dataComparator: (data, oldData) => data.length === oldData.length,\n        updateTriggers: {\n          getBin: [binAttribute],\n          getColorValue: [colors.attribute],\n          getElevationValue: [elevations.attribute]\n        },\n        diskResolution: 6,\n        vertices: HexbinVertices,\n        radius: radiusCommon,\n        hexOriginCommon,\n        elevationScale,\n        colorRange,\n        colorScaleType,\n        elevationRange,\n        extruded,\n        coverage,\n        material,\n        colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n        elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n        colorCutoff: colors.cutoff,\n        elevationCutoff: elevations.cutoff,\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        },\n        // Extensions are already handled by the GPUAggregator, do not pass it down\n        extensions: []\n      }\n    );\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): HexagonLayerPickingInfo<DataT> {\n    const info: HexagonLayerPickingInfo<DataT> = params.info;\n    const {index} = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object: HexagonLayerPickingInfo<DataT>['object'];\n      if (bin) {\n        const centroidCommon = getHexbinCentroid(\n          bin.id as [number, number],\n          this.state.radiusCommon\n        );\n        const centroid = this.context.viewport.unprojectFlat(centroidCommon);\n\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          position: centroid,\n          colorValue: bin.value[0],\n          elevationValue: bin.value[1],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data)\n            ? bin.pointIndices.map(i => (this.props.data as DataT[])[i])\n            : [];\n        }\n      }\n      info.object = object;\n    }\n\n    return info;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {BinaryAttribute} from '@deck.gl/core';\nimport type {ScaleType} from '../types';\n\ntype ScaleProps = {\n  scaleType: ScaleType;\n  /** Trim the lower end of the domain by this percentile. Set to `0` to disable. */\n  lowerPercentile: number;\n  /** Trim the upper end of the domain by this percentile. Set to `100` to disable. */\n  upperPercentile: number;\n};\n\n/** Applies a scale to BinaryAttribute */\nexport class AttributeWithScale {\n  /** Input values accessor. Has either a `value` (CPU aggregation) or a `buffer` (GPU aggregation) */\n  private readonly input: BinaryAttribute;\n  private readonly inputLength: number;\n\n  private props: ScaleProps = {\n    scaleType: 'linear',\n    lowerPercentile: 0,\n    upperPercentile: 100\n  };\n\n  // cached calculations\n  private _percentile?: {attribute: BinaryAttribute; domain: number[]};\n  private _ordinal?: {attribute: BinaryAttribute; domain: number[]};\n\n  /** Output values accessor */\n  attribute: BinaryAttribute;\n  /** [min, max] of attribute values, or null if unknown */\n  domain: [number, number] | null = null;\n  /** Valid domain if lower/upper percentile are defined */\n  cutoff: [number, number] | null = null;\n\n  constructor(input: BinaryAttribute, inputLength: number) {\n    this.input = input;\n    this.inputLength = inputLength;\n    // No processing is needed with the default scale\n    this.attribute = input;\n  }\n\n  private getScalePercentile() {\n    if (!this._percentile) {\n      const value = getAttributeValue(this.input, this.inputLength);\n      this._percentile = applyScaleQuantile(value);\n    }\n    return this._percentile;\n  }\n\n  private getScaleOrdinal() {\n    if (!this._ordinal) {\n      const value = getAttributeValue(this.input, this.inputLength);\n      this._ordinal = applyScaleOrdinal(value);\n    }\n    return this._ordinal;\n  }\n\n  /** Returns the [lowerCutoff, upperCutoff] of scaled values, or null if not applicable */\n  private getCutoff({\n    scaleType,\n    lowerPercentile,\n    upperPercentile\n  }: ScaleProps): [number, number] | null {\n    if (scaleType === 'quantile') {\n      return [lowerPercentile, upperPercentile - 1];\n    }\n\n    if (lowerPercentile > 0 || upperPercentile < 100) {\n      const {domain: thresholds} = this.getScalePercentile();\n      let lowValue = thresholds[Math.floor(lowerPercentile) - 1] ?? -Infinity;\n      let highValue = thresholds[Math.floor(upperPercentile) - 1] ?? Infinity;\n\n      if (scaleType === 'ordinal') {\n        const {domain: sortedUniqueValues} = this.getScaleOrdinal();\n        lowValue = sortedUniqueValues.findIndex(x => x >= lowValue);\n        highValue = sortedUniqueValues.findIndex(x => x > highValue) - 1;\n        if (highValue === -2) {\n          highValue = sortedUniqueValues.length - 1;\n        }\n      }\n      return [lowValue, highValue];\n    }\n\n    return null;\n  }\n\n  update(props: ScaleProps) {\n    const oldProps = this.props;\n\n    if (props.scaleType !== oldProps.scaleType) {\n      switch (props.scaleType) {\n        case 'quantile': {\n          const {attribute} = this.getScalePercentile();\n          this.attribute = attribute;\n          this.domain = [0, 99];\n          break;\n        }\n        case 'ordinal': {\n          const {attribute, domain} = this.getScaleOrdinal();\n          this.attribute = attribute;\n          this.domain = [0, domain.length - 1];\n          break;\n        }\n\n        default:\n          this.attribute = this.input;\n          this.domain = null;\n      }\n    }\n    if (\n      props.scaleType !== oldProps.scaleType ||\n      props.lowerPercentile !== oldProps.lowerPercentile ||\n      props.upperPercentile !== oldProps.upperPercentile\n    ) {\n      this.cutoff = this.getCutoff(props);\n    }\n    this.props = props;\n    return this;\n  }\n}\n\n/**\n * Transform an array of values to ordinal indices\n */\nexport function applyScaleOrdinal(values: Float32Array): {\n  attribute: BinaryAttribute;\n  domain: number[];\n} {\n  const uniqueValues = new Set<number>();\n  for (const x of values) {\n    if (Number.isFinite(x)) {\n      uniqueValues.add(x);\n    }\n  }\n  const sortedUniqueValues = Array.from(uniqueValues).sort();\n  const domainMap = new Map();\n  for (let i = 0; i < sortedUniqueValues.length; i++) {\n    domainMap.set(sortedUniqueValues[i], i);\n  }\n\n  return {\n    attribute: {\n      value: values.map(x => (Number.isFinite(x) ? domainMap.get(x) : NaN)),\n      type: 'float32',\n      size: 1\n    },\n    domain: sortedUniqueValues\n  };\n}\n\n/**\n * Transform an array of values to percentiles\n */\nexport function applyScaleQuantile(\n  values: Float32Array,\n  rangeLength = 100\n): {\n  attribute: BinaryAttribute;\n  domain: number[];\n} {\n  const sortedValues = Array.from(values).filter(Number.isFinite).sort(ascending);\n  let i = 0;\n  const n = Math.max(1, rangeLength);\n  const thresholds: number[] = new Array(n - 1);\n  while (++i < n) {\n    thresholds[i - 1] = threshold(sortedValues, i / n);\n  }\n  return {\n    attribute: {\n      value: values.map(x => (Number.isFinite(x) ? bisectRight(thresholds, x) : NaN)),\n      type: 'float32',\n      size: 1\n    },\n    domain: thresholds\n  };\n}\n\nfunction getAttributeValue(attribute: BinaryAttribute, length: number): Float32Array {\n  const elementStride = (attribute.stride ?? 4) / 4;\n  const elementOffset = (attribute.offset ?? 0) / 4;\n  let value = attribute.value as Float32Array;\n  if (!value) {\n    const bytes = attribute.buffer?.readSyncWebGL(0, elementStride * 4 * length);\n    if (bytes) {\n      value = new Float32Array(bytes.buffer);\n      attribute.value = value;\n    }\n  }\n\n  if (elementStride === 1) {\n    return value.subarray(0, length);\n  }\n  const result = new Float32Array(length);\n  for (let i = 0; i < length; i++) {\n    result[i] = value[i * elementStride + elementOffset];\n  }\n  return result;\n}\n\nfunction ascending(a: number, b: number): number {\n  return a - b;\n}\n\nfunction threshold(domain: number[], fraction: number): number {\n  const domainLength = domain.length;\n  if (fraction <= 0 || domainLength < 2) {\n    return domain[0];\n  }\n  if (fraction >= 1) {\n    return domain[domainLength - 1];\n  }\n\n  const domainFraction = (domainLength - 1) * fraction;\n  const lowIndex = Math.floor(domainFraction);\n  const low = domain[lowIndex];\n  const high = domain[lowIndex + 1];\n  return low + (high - low) * (domainFraction - lowIndex);\n}\n\nfunction bisectRight(a: number[], x: number): number {\n  let lo = 0;\n  let hi = a.length;\n  while (lo < hi) {\n    const mid = (lo + hi) >>> 1;\n    if (a[mid] > x) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  return lo;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/** Utility to estimate binIdRange as expected by AggregatorProps */\nexport function getBinIdRange({\n  dataBounds,\n  getBinId,\n  padding = 0\n}: {\n  /** Bounds of the input data */\n  dataBounds: [min: number[], max: number[]];\n  /** Given a data point, returns the bin id that it belongs to */\n  getBinId: (p: number[]) => number[];\n  /** Add a border around the result to avoid clipping */\n  padding?: number;\n}): [number, number][] {\n  const corners = [\n    dataBounds[0],\n    dataBounds[1],\n    [dataBounds[0][0], dataBounds[1][1]],\n    [dataBounds[1][0], dataBounds[0][1]]\n  ].map(p => getBinId(p));\n\n  const minX = Math.min(...corners.map(p => p[0])) - padding;\n  const minY = Math.min(...corners.map(p => p[1])) - padding;\n  const maxX = Math.max(...corners.map(p => p[0])) + padding + 1;\n  const maxY = Math.max(...corners.map(p => p[1])) + padding + 1;\n\n  return [\n    [minX, maxX],\n    [minY, maxY]\n  ];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport {UpdateParameters, Color} from '@deck.gl/core';\nimport {ColumnLayer} from '@deck.gl/layers';\nimport {createColorRangeTexture, updateColorRangeTexture} from '../common/utils/color-utils';\nimport vs from './hexagon-cell-layer-vertex.glsl';\nimport {HexagonProps, hexagonUniforms} from './hexagon-layer-uniforms';\nimport type {ScaleType} from '../common/types';\n\n/** Proprties added by HexagonCellLayer. */\nexport type _HexagonCellLayerProps = {\n  hexOriginCommon: [number, number];\n  colorDomain: [number, number];\n  colorCutoff: [number, number] | null;\n  colorRange: Color[];\n  colorScaleType: ScaleType;\n  elevationDomain: [number, number];\n  elevationCutoff: [number, number] | null;\n  elevationRange: [number, number];\n};\n\nexport default class HexagonCellLayer<ExtraPropsT extends {} = {}> extends ColumnLayer<\n  null,\n  ExtraPropsT & Required<_HexagonCellLayerProps>\n> {\n  static layerName = 'HexagonCellLayer';\n\n  state!: ColumnLayer['state'] & {\n    colorTexture: Texture;\n  };\n\n  getShaders() {\n    const shaders = super.getShaders();\n    shaders.modules.push(hexagonUniforms);\n    return {...shaders, vs};\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.remove([\n      'instanceElevations',\n      'instanceFillColors',\n      'instanceLineColors',\n      'instanceStrokeWidths'\n    ]);\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 2,\n        type: 'float32',\n        accessor: 'getBin'\n      },\n      instanceColorValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getColorValue'\n      },\n      instanceElevationValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getElevationValue'\n      }\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps} = params;\n    const model = this.state.fillModel!;\n\n    if (oldProps.colorRange !== props.colorRange) {\n      this.state.colorTexture?.destroy();\n      this.state.colorTexture = createColorRangeTexture(\n        this.context.device,\n        props.colorRange,\n        props.colorScaleType\n      );\n      const hexagonProps: Partial<HexagonProps> = {colorRange: this.state.colorTexture};\n      model.shaderInputs.setProps({hexagon: hexagonProps});\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n    }\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n\n    this.state.colorTexture?.destroy();\n  }\n\n  draw({uniforms}) {\n    const {\n      radius,\n      hexOriginCommon,\n      elevationRange,\n      elevationScale,\n      extruded,\n      coverage,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\n    const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\n    const fillModel = this.state.fillModel!;\n\n    if (fillModel.vertexArray.indexBuffer) {\n      // indices are for drawing wireframe, disable them\n      // TODO - this should be handled in ColumnLayer?\n      fillModel.setIndexBuffer(null);\n    }\n    fillModel.setVertexCount(this.state.fillVertexCount);\n\n    const hexagonProps: Omit<HexagonProps, 'colorRange'> = {\n      colorDomain: [\n        Math.max(colorDomain[0], colorCutoff[0]), // instanceColorValue that maps to colorRange[0]\n        Math.min(colorDomain[1], colorCutoff[1]), // instanceColorValue that maps to colorRange[colorRange.length - 1]\n        Math.max(colorDomain[0] - 1, colorCutoff[0]), // hide cell if instanceColorValue is less than this\n        Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\n      ],\n      elevationDomain: [\n        Math.max(elevationDomain[0], elevationCutoff[0]), // instanceElevationValue that maps to elevationRange[0]\n        Math.min(elevationDomain[1], elevationCutoff[1]), // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\n        Math.max(elevationDomain[0] - 1, elevationCutoff[0]), // hide cell if instanceElevationValue is less than this\n        Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\n      ],\n      elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\n      originCommon: hexOriginCommon\n    };\n\n    fillModel.shaderInputs.setProps({\n      column: {extruded, coverage, radius},\n      hexagon: hexagonProps\n    });\n    fillModel.draw(this.context.renderPass);\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nconst THIRD_PI = Math.PI / 3;\nconst DIST_X = 2 * Math.sin(THIRD_PI);\nconst DIST_Y = 1.5;\n\ntype HexBin = [i: number, j: number];\ntype Point = [x: number, y: number];\n\nexport const HexbinVertices = Array.from({length: 6}, (_, i) => {\n  const angle = i * THIRD_PI;\n  return [Math.sin(angle), -Math.cos(angle)];\n});\n\n/**\n * Adapted from d3-hexbin\n * Copyright Mike Bostock, 2012-2016\n   All rights reserved.\n * https://github.com/d3/d3-hexbin/blob/master/src/hexbin.js\n *\n * Returns the hexbin that a point (x,y) falls into\n */\nexport function pointToHexbin([px, py]: Point, radius: number): HexBin {\n  let pj = Math.round((py = py / radius / DIST_Y));\n  let pi = Math.round((px = px / radius / DIST_X - (pj & 1) / 2));\n  const py1 = py - pj;\n\n  if (Math.abs(py1) * 3 > 1) {\n    const px1 = px - pi;\n    const pi2 = pi + (px < pi ? -1 : 1) / 2;\n    const pj2 = pj + (py < pj ? -1 : 1);\n    const px2 = px - pi2;\n    const py2 = py - pj2;\n    if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) {\n      pi = pi2 + (pj & 1 ? 1 : -1) / 2;\n      pj = pj2;\n    }\n  }\n  return [pi, pj];\n}\n\nexport const pointToHexbinGLSL = /* glsl */ `\nconst vec2 DIST = vec2(${DIST_X}, ${DIST_Y});\n\nivec2 pointToHexbin(vec2 p, float radius) {\n  p /= radius * DIST;\n  float pj = round(p.y);\n  float pjm2 = mod(pj, 2.0);\n  p.x -= pjm2 * 0.5;\n  float pi = round(p.x);\n  vec2 d1 = p - vec2(pi, pj);\n\n  if (abs(d1.y) * 3. > 1.) {\n    vec2 v2 = step(0.0, d1) - 0.5;\n    v2.y *= 2.0;\n    vec2 d2 = d1 - v2;\n    if (dot(d1, d1) > dot(d2, d2)) {\n      pi += v2.x + pjm2 - 0.5;\n      pj += v2.y;\n    }\n  }\n  return ivec2(pi, pj);\n}\n`;\n\nexport function getHexbinCentroid([i, j]: HexBin, radius: number): Point {\n  return [(i + (j & 1) / 2) * radius * DIST_X, j * radius * DIST_Y];\n}\n\nexport const getHexbinCentroidGLSL = `\nconst vec2 DIST = vec2(${DIST_X}, ${DIST_Y});\n\nvec2 hexbinCentroid(vec2 binId, float radius) {\n  binId.x += fract(binId.y * 0.5);\n  return binId * DIST * radius;\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {getHexbinCentroidGLSL} from './hexbin';\n\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME hexagon-cell-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\n\nuniform sampler2D colorRange;\n\n// Result\nout vec4 vColor;\n\n${getHexbinCentroidGLSL}\n\nfloat interp(float value, vec2 domain, vec2 range) {\n  float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\n  return mix(range.x, range.y, r);\n}\n\nvec4 interp(float value, vec2 domain, sampler2D range) {\n  float r = (value - domain.x) / (domain.y - domain.x);\n  return texture(range, vec2(r, 0.5));\n}\n\nvoid main(void) {\n  geometry.pickingColor = instancePickingColors;\n\n  if (isnan(instanceColorValues) ||\n    instanceColorValues < hexagon.colorDomain.z ||\n    instanceColorValues > hexagon.colorDomain.w ||\n    instanceElevationValues < hexagon.elevationDomain.z ||\n    instanceElevationValues > hexagon.elevationDomain.w\n  ) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  \n  vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);\n  commonPosition += positions.xy * column.radius * column.coverage;\n  geometry.position = vec4(commonPosition, 0.0, 1.0);\n  geometry.normal = project_normal(normals);\n\n  // calculate z, if 3d not enabled set to 0\n  float elevation = 0.0;\n  if (column.extruded) {\n    elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);\n    elevation = project_size(elevation);\n    // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1\n    geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n  }\n\n  gl_Position = project_common_position_to_clipspace(geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);\n  vColor.a *= layer.opacity;\n  if (column.extruded) {\n    vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = /* glsl */ `\\\nuniform hexagonUniforms {\n  vec4 colorDomain;\n  vec4 elevationDomain;\n  vec2 elevationRange;\n  vec2 originCommon;\n} hexagon;\n`;\n\nexport type HexagonProps = {\n  colorDomain: [number, number, number, number];\n  colorRange: Texture;\n  elevationDomain: [number, number, number, number];\n  elevationRange: [number, number];\n  originCommon: [number, number];\n};\n\nexport const hexagonUniforms = {\n  name: 'hexagon',\n  vs: uniformBlock,\n  uniformTypes: {\n    colorDomain: 'vec4<f32>',\n    elevationDomain: 'vec4<f32>',\n    elevationRange: 'vec2<f32>',\n    originCommon: 'vec2<f32>'\n  }\n} as const satisfies ShaderModule<HexagonProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\nimport {NumberArray2} from '@math.gl/core';\n\nconst uniformBlock = /* glsl */ `\\\nuniform binOptionsUniforms {\n  vec2 hexOriginCommon;\n  float radiusCommon;\n} binOptions;\n`;\n\nexport type BinOptions = {\n  hexOriginCommon: NumberArray2;\n  radiusCommon: number;\n};\n\nexport const binOptionsUniforms = {\n  name: 'binOptions',\n  vs: uniformBlock,\n  uniformTypes: {\n    hexOriginCommon: 'vec2<f32>',\n    radiusCommon: 'f32'\n  }\n} as const satisfies ShaderModule<BinOptions>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  Accessor,\n  COORDINATE_SYSTEM,\n  GetPickingInfoParams,\n  project32,\n  LayersList,\n  PickingInfo,\n  Position,\n  Viewport,\n  _deepEqual,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {PathLayer, SolidPolygonLayer} from '@deck.gl/layers';\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\nimport AggregationLayer from '../common/aggregation-layer';\nimport {AggregationLayerProps} from '../common/aggregation-layer';\nimport {generateContours, Contour, ContourLine, ContourPolygon} from './contour-utils';\nimport {getAggregatorValueReader} from './value-reader';\nimport {getBinIdRange} from '../common/utils/bounds-utils';\nimport {Matrix4} from '@math.gl/core';\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\n\nconst DEFAULT_COLOR = [255, 255, 255, 255];\nconst DEFAULT_STROKE_WIDTH = 1;\n\nconst defaultProps: DefaultProps<ContourLayerProps> = {\n  // grid aggregation\n  cellSize: {type: 'number', min: 1, value: 1000},\n  gridOrigin: {type: 'array', compare: true, value: [0, 0]},\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  gpuAggregation: true,\n  aggregation: 'SUM',\n\n  // contour lines\n  contours: {\n    type: 'object',\n    value: [{threshold: 1}],\n    optional: true,\n    compare: 3\n  },\n\n  zOffset: 0.005\n};\n\n/** All properties supported by GridLayer. */\nexport type ContourLayerProps<DataT = unknown> = _ContourLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\n/** Properties added by GridLayer. */\ntype _ContourLayerProps<DataT> = {\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * The grid origin\n   * @default [0, 0]\n   */\n  gridOrigin?: [number, number];\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default false\n   */\n  gpuAggregation?: boolean;\n\n  /**\n   * Defines the type of aggregation operation, valid values are 'SUM', 'MEAN', 'MIN' and 'MAX'.\n   * @default 'SUM'\n   */\n  aggregation?: AggregationOperation;\n\n  /**\n   * Definition of contours to be drawn.\n   * @default [{threshold: 1}]\n   */\n  contours?: Contour[];\n\n  /**\n   * A very small z offset that is added for each vertex of a contour (Isoline or Isoband).\n   * @default 0.005\n   */\n  zOffset?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\nexport type ContourLayerPickingInfo = PickingInfo<{\n  contour: Contour;\n}>;\n\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nexport default class GridLayer<DataT = any, ExtraPropsT extends {} = {}> extends AggregationLayer<\n  DataT,\n  ExtraPropsT & Required<_ContourLayerProps<DataT>>\n> {\n  static layerName = 'ContourLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] &\n    BinOptions & {\n      // Aggregator result\n      aggregatedValueReader?: (x: number, y: number) => number;\n      contourData?: {\n        lines: ContourLine[];\n        polygons: ContourPolygon[];\n      };\n\n      binIdRange: [number, number][];\n      aggregatorViewport: Viewport;\n    };\n\n  getAggregatorType(): string {\n    return this.props.gpuAggregation && WebGLAggregator.isSupported(this.context.device)\n      ? 'gpu'\n      : 'cpu';\n  }\n\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\n    if (type === 'cpu') {\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {cellSizeCommon, cellOriginCommon} = opts;\n            return [\n              Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n              Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n            ];\n          }\n        },\n        getValue: [{sources: ['counts'], getValue: ({counts}) => counts}],\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 1,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float counts;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out float value) {\n    value = counts;\n  }\n  `\n      }),\n      onUpdate: this._onAggregationUpdate.bind(this)\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      counts: {size: 1, accessor: 'getWeight'}\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    const aggregatorChanged = super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const {aggregator} = this.state;\n    if (\n      aggregatorChanged ||\n      changeFlags.dataChanged ||\n      props.cellSize !== oldProps.cellSize ||\n      !_deepEqual(props.gridOrigin, oldProps.gridOrigin, 1) ||\n      props.aggregation !== oldProps.aggregation\n    ) {\n      this._updateBinOptions();\n      const {cellSizeCommon, cellOriginCommon, binIdRange} = this.state;\n\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.aggregation],\n        binOptions: {\n          cellSizeCommon,\n          cellOriginCommon\n        }\n      });\n    }\n\n    if (!_deepEqual(oldProps.contours, props.contours, 2)) {\n      // Recalculate contours\n      this.setState({contourData: null});\n    }\n\n    return aggregatorChanged;\n  }\n\n  private _updateBinOptions() {\n    const bounds = this.getBounds();\n    const cellSizeCommon: [number, number] = [1, 1];\n    let cellOriginCommon: [number, number] = [0, 0];\n    let binIdRange: [number, number][] = [\n      [0, 1],\n      [0, 1]\n    ];\n    let viewport = this.context.viewport;\n\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {cellSize, gridOrigin} = this.props;\n      const {unitsPerMeter} = viewport.getDistanceScales(centroid);\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n\n      // Offset common space to center at the origin of the grid cell where the data center is in\n      // This improves precision without affecting the cell positions\n      const centroidCommon = viewport.projectFlat(centroid);\n      cellOriginCommon = [\n        Math.floor((centroidCommon[0] - gridOrigin[0]) / cellSizeCommon[0]) * cellSizeCommon[0] +\n          gridOrigin[0],\n        Math.floor((centroidCommon[1] - gridOrigin[1]) / cellSizeCommon[1]) * cellSizeCommon[1] +\n          gridOrigin[1]\n      ];\n      centroid = viewport.unprojectFlat(cellOriginCommon);\n\n      const ViewportType = viewport.constructor as any;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial\n        ? new ViewportType({longitude: centroid[0], latitude: centroid[1], zoom: 12})\n        : new Viewport({position: [centroid[0], centroid[1], 0], zoom: 12});\n\n      // Round to the nearest 32-bit float to match CPU and GPU results\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: (p: number[]) => {\n          const positionCommon = viewport.projectFlat(p);\n          return [\n            Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n            Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n          ];\n        }\n      });\n    }\n\n    this.setState({cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport});\n  }\n\n  override draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n\n  private _onAggregationUpdate() {\n    const {aggregator, binIdRange} = this.state;\n    this.setState({\n      aggregatedValueReader: getAggregatorValueReader({aggregator, binIdRange, channel: 0}),\n      contourData: null\n    });\n  }\n\n  private _getContours(): {\n    lines: ContourLine[];\n    polygons: ContourPolygon[];\n  } | null {\n    const {aggregatedValueReader} = this.state;\n    if (!aggregatedValueReader) {\n      return null;\n    }\n\n    if (!this.state.contourData) {\n      const {binIdRange} = this.state;\n      const {contours} = this.props;\n      const contourData = generateContours({\n        contours,\n        getValue: aggregatedValueReader,\n        xRange: binIdRange[0],\n        yRange: binIdRange[1]\n      });\n\n      this.state.contourData = contourData;\n    }\n    return this.state.contourData;\n  }\n\n  onAttributeChange(id: string) {\n    const {aggregator} = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n\n        this._updateBinOptions();\n        const {cellSizeCommon, cellOriginCommon, binIdRange} = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            cellSizeCommon,\n            cellOriginCommon\n          }\n        });\n        break;\n\n      case 'counts':\n        aggregator.setNeedsUpdate(0);\n        break;\n\n      default:\n      // This should not happen\n    }\n  }\n\n  renderLayers(): LayersList | null {\n    const contourData = this._getContours();\n    if (!contourData) {\n      return null;\n    }\n    const {lines, polygons} = contourData;\n    const {zOffset} = this.props;\n    const {cellOriginCommon, cellSizeCommon} = this.state;\n\n    const LinesSubLayerClass = this.getSubLayerClass('lines', PathLayer);\n    const BandsSubLayerClass = this.getSubLayerClass('bands', SolidPolygonLayer);\n    const modelMatrix = new Matrix4()\n      .translate([cellOriginCommon[0], cellOriginCommon[1], 0])\n      .scale([cellSizeCommon[0], cellSizeCommon[1], zOffset]);\n\n    // Contour lines layer\n    const lineLayer =\n      lines &&\n      lines.length > 0 &&\n      new LinesSubLayerClass(\n        this.getSubLayerProps({\n          id: 'lines'\n        }),\n        {\n          data: lines,\n          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n          modelMatrix,\n          getPath: d => d.vertices,\n          getColor: d => d.contour.color ?? DEFAULT_COLOR,\n          getWidth: d => d.contour.strokeWidth ?? DEFAULT_STROKE_WIDTH,\n          widthUnits: 'pixels'\n        }\n      );\n\n    // Contour bands layer\n    const bandsLayer =\n      polygons &&\n      polygons.length > 0 &&\n      new BandsSubLayerClass(\n        this.getSubLayerProps({\n          id: 'bands'\n        }),\n        {\n          data: polygons,\n          coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,\n          modelMatrix,\n          getPolygon: d => d.vertices,\n          getFillColor: d => d.contour.color ?? DEFAULT_COLOR\n        }\n      );\n\n    return [lineLayer, bandsLayer];\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): ContourLayerPickingInfo {\n    const info: ContourLayerPickingInfo = params.info;\n    const {object} = info;\n    if (object) {\n      info.object = {\n        contour: (object as ContourLine | ContourPolygon).contour\n      };\n    }\n\n    return info;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Code to Offsets Map needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\n// Table to map code to the intersection offsets\n// All offsets are relative to the center of marching cell (which is top right corner of grid-cell, and center of marching-square)\nconst HALF = 0.5;\nconst ONE6TH = 1 / 6;\nconst OFFSET = {\n  N: [0, HALF], // NORTH\n  E: [HALF, 0], // EAST\n  S: [0, -HALF], // SOUTH\n  W: [-HALF, 0], // WEST\n\n  // CORNERS\n  NE: [HALF, HALF],\n  NW: [-HALF, HALF],\n  SE: [HALF, -HALF],\n  SW: [-HALF, -HALF]\n};\n\n// NOTE: vertices are ordered in CCW direction, starting from NW corner\n\n// Triangles\nconst SW_TRIANGLE = [OFFSET.W, OFFSET.SW, OFFSET.S];\nconst SE_TRIANGLE = [OFFSET.S, OFFSET.SE, OFFSET.E];\nconst NE_TRIANGLE = [OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_TRIANGLE = [OFFSET.NW, OFFSET.W, OFFSET.N];\n\n// Trapezoids\nconst SW_TRAPEZOID = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF]\n];\nconst SE_TRAPEZOID = [\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH]\n];\nconst NE_TRAPEZOID = [\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\nconst NW_TRAPEZOID = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Rectangles\nconst S_RECTANGLE = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E];\nconst E_RECTANGLE = [OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_RECTANGLE = [OFFSET.NW, OFFSET.W, OFFSET.E, OFFSET.NE];\nconst W_RECTANGLE = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.N];\nconst EW_RECTANGEL = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH]\n];\nconst SN_RECTANGEL = [\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Square\nconst SQUARE = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.NE];\n\n// Pentagons\nconst SW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.SE, OFFSET.E, OFFSET.N];\nconst SE_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst NE_PENTAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.NE];\nconst NW_PENTAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE];\n\nconst NW_N_PENTAGON = [OFFSET.NW, OFFSET.W, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst NE_E_PENTAGON = [[-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_S_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.E];\nconst SW_W_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [ONE6TH, HALF], [-ONE6TH, HALF]];\n\nconst NW_W_PENTAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.N];\nconst NE_N_PENTAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.E, OFFSET.NE, OFFSET.N];\nconst SE_E_PENTAGON = [OFFSET.S, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst SW_S_PENTAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH]];\n\n// Hexagon\nconst S_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.SE, OFFSET.E, [ONE6TH, HALF], [-ONE6TH, HALF]];\nconst E_HEXAGON = [[-HALF, ONE6TH], [-HALF, -ONE6TH], OFFSET.S, OFFSET.SE, OFFSET.NE, OFFSET.N];\nconst N_HEXAGON = [OFFSET.NW, OFFSET.W, [-ONE6TH, -HALF], [ONE6TH, -HALF], OFFSET.E, OFFSET.NE];\nconst W_HEXAGON = [OFFSET.NW, OFFSET.SW, OFFSET.S, [HALF, -ONE6TH], [HALF, ONE6TH], OFFSET.N];\nconst SW_NE_HEXAGON = [OFFSET.W, OFFSET.SW, OFFSET.S, OFFSET.E, OFFSET.NE, OFFSET.N];\nconst NW_SE_HEXAGON = [OFFSET.NW, OFFSET.W, OFFSET.S, OFFSET.SE, OFFSET.E, OFFSET.N];\n\n// Heptagon (7-sided)\nconst NE_HEPTAGON = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  OFFSET.E,\n  OFFSET.NE,\n  OFFSET.N\n];\nconst SW_HEPTAGON = [\n  OFFSET.W,\n  OFFSET.SW,\n  OFFSET.S,\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\nconst NW_HEPTAGON = [\n  OFFSET.NW,\n  OFFSET.W,\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  OFFSET.N\n];\nconst SE_HEPTAGON = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  OFFSET.S,\n  OFFSET.SE,\n  OFFSET.E,\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Octagon\nconst OCTAGON = [\n  [-HALF, ONE6TH],\n  [-HALF, -ONE6TH],\n  [-ONE6TH, -HALF],\n  [ONE6TH, -HALF],\n  [HALF, -ONE6TH],\n  [HALF, ONE6TH],\n  [ONE6TH, HALF],\n  [-ONE6TH, HALF]\n];\n\n// Note: above wiki page invertes white/black dots for generating the code, we don't\nexport const ISOLINES_CODE_OFFSET_MAP = {\n  // key is equal to the code of 4 vertices (invert the code specified in wiki)\n  // value can be an array or an Object\n  // Array : [line] or [line, line], where each line is [start-point, end-point], and each point is [x, y]\n  // Object : to handle saddle cases, whos output depends on mean value of all 4 corners\n  //  key: code of mean value (0 or 1)\n  //  value: Array , as above defines one or two line segments\n  0: [],\n  1: [[OFFSET.W, OFFSET.S]],\n  2: [[OFFSET.S, OFFSET.E]],\n  3: [[OFFSET.W, OFFSET.E]],\n  4: [[OFFSET.N, OFFSET.E]],\n  5: {\n    0: [\n      [OFFSET.W, OFFSET.S],\n      [OFFSET.N, OFFSET.E]\n    ],\n    1: [\n      [OFFSET.W, OFFSET.N],\n      [OFFSET.S, OFFSET.E]\n    ]\n  },\n  6: [[OFFSET.N, OFFSET.S]],\n  7: [[OFFSET.W, OFFSET.N]],\n  8: [[OFFSET.W, OFFSET.N]],\n  9: [[OFFSET.N, OFFSET.S]],\n  10: {\n    0: [\n      [OFFSET.W, OFFSET.N],\n      [OFFSET.S, OFFSET.E]\n    ],\n    1: [\n      [OFFSET.W, OFFSET.S],\n      [OFFSET.N, OFFSET.E]\n    ]\n  },\n  11: [[OFFSET.N, OFFSET.E]],\n  12: [[OFFSET.W, OFFSET.E]],\n  13: [[OFFSET.S, OFFSET.E]],\n  14: [[OFFSET.W, OFFSET.S]],\n  15: []\n};\n\nfunction ternaryToIndex(ternary) {\n  return parseInt(ternary, 4);\n}\n\nexport const ISOBANDS_CODE_OFFSET_MAP = {\n  // Below list of cases, follow the same order as in above mentioned wiki page.\n  // Each case has its code on first commented line // T,TR,R,C\n  // where T: Top, TR: Top-right, R: Right and C: current, each will be either 0, 1 or 2\n  // final code is binary representation of above code , where takes 2 digits\n  // for example:  code 2-2-2-1 => 10-10-10-01 => 10101001 => 169\n\n  // no contours\n  [ternaryToIndex('0000')]: [],\n  [ternaryToIndex('2222')]: [],\n\n  // single triangle\n  [ternaryToIndex('2221')]: [SW_TRIANGLE],\n  [ternaryToIndex('2212')]: [SE_TRIANGLE],\n  [ternaryToIndex('2122')]: [NE_TRIANGLE],\n  [ternaryToIndex('1222')]: [NW_TRIANGLE],\n  [ternaryToIndex('0001')]: [SW_TRIANGLE],\n  [ternaryToIndex('0010')]: [SE_TRIANGLE],\n  [ternaryToIndex('0100')]: [NE_TRIANGLE],\n  [ternaryToIndex('1000')]: [NW_TRIANGLE],\n\n  // single trapezoid\n  [ternaryToIndex('2220')]: [SW_TRAPEZOID],\n  [ternaryToIndex('2202')]: [SE_TRAPEZOID],\n  [ternaryToIndex('2022')]: [NE_TRAPEZOID],\n  [ternaryToIndex('0222')]: [NW_TRAPEZOID],\n  [ternaryToIndex('0002')]: [SW_TRAPEZOID],\n  [ternaryToIndex('0020')]: [SE_TRAPEZOID],\n  [ternaryToIndex('0200')]: [NE_TRAPEZOID],\n  [ternaryToIndex('2000')]: [NW_TRAPEZOID],\n\n  // single rectangle\n  [ternaryToIndex('0011')]: [S_RECTANGLE],\n  [ternaryToIndex('0110')]: [E_RECTANGLE],\n  [ternaryToIndex('1100')]: [N_RECTANGLE],\n  [ternaryToIndex('1001')]: [W_RECTANGLE],\n  [ternaryToIndex('2211')]: [S_RECTANGLE],\n  [ternaryToIndex('2112')]: [E_RECTANGLE],\n  [ternaryToIndex('1122')]: [N_RECTANGLE],\n  [ternaryToIndex('1221')]: [W_RECTANGLE],\n  [ternaryToIndex('2200')]: [EW_RECTANGEL],\n  [ternaryToIndex('2002')]: [SN_RECTANGEL],\n  [ternaryToIndex('0022')]: [EW_RECTANGEL],\n  [ternaryToIndex('0220')]: [SN_RECTANGEL],\n\n  // single square\n  // 1111\n  [ternaryToIndex('1111')]: [SQUARE],\n\n  // single pentagon\n  [ternaryToIndex('1211')]: [SW_PENTAGON],\n  [ternaryToIndex('2111')]: [SE_PENTAGON],\n  [ternaryToIndex('1112')]: [NE_PENTAGON],\n  [ternaryToIndex('1121')]: [NW_PENTAGON],\n  [ternaryToIndex('1011')]: [SW_PENTAGON],\n  [ternaryToIndex('0111')]: [SE_PENTAGON],\n  [ternaryToIndex('1110')]: [NE_PENTAGON],\n  [ternaryToIndex('1101')]: [NW_PENTAGON],\n  [ternaryToIndex('1200')]: [NW_N_PENTAGON],\n  [ternaryToIndex('0120')]: [NE_E_PENTAGON],\n  [ternaryToIndex('0012')]: [SE_S_PENTAGON],\n  [ternaryToIndex('2001')]: [SW_W_PENTAGON],\n  [ternaryToIndex('1022')]: [NW_N_PENTAGON],\n  [ternaryToIndex('2102')]: [NE_E_PENTAGON],\n  [ternaryToIndex('2210')]: [SE_S_PENTAGON],\n  [ternaryToIndex('0221')]: [SW_W_PENTAGON],\n  [ternaryToIndex('1002')]: [NW_W_PENTAGON],\n  [ternaryToIndex('2100')]: [NE_N_PENTAGON],\n  [ternaryToIndex('0210')]: [SE_E_PENTAGON],\n  [ternaryToIndex('0021')]: [SW_S_PENTAGON],\n  [ternaryToIndex('1220')]: [NW_W_PENTAGON],\n  [ternaryToIndex('0122')]: [NE_N_PENTAGON],\n  [ternaryToIndex('2012')]: [SE_E_PENTAGON],\n  [ternaryToIndex('2201')]: [SW_S_PENTAGON],\n\n  // single hexagon\n  [ternaryToIndex('0211')]: [S_HEXAGON],\n  [ternaryToIndex('2110')]: [E_HEXAGON],\n  [ternaryToIndex('1102')]: [N_HEXAGON],\n  [ternaryToIndex('1021')]: [W_HEXAGON],\n  [ternaryToIndex('2011')]: [S_HEXAGON],\n  [ternaryToIndex('0112')]: [E_HEXAGON],\n  [ternaryToIndex('1120')]: [N_HEXAGON],\n  [ternaryToIndex('1201')]: [W_HEXAGON],\n  [ternaryToIndex('2101')]: [SW_NE_HEXAGON],\n  [ternaryToIndex('0121')]: [SW_NE_HEXAGON],\n  [ternaryToIndex('1012')]: [NW_SE_HEXAGON],\n  [ternaryToIndex('1210')]: [NW_SE_HEXAGON],\n\n  // 6-sided polygons based on mean weight\n  // NOTE: merges mean value codes for extreme changes (as per above Wiki doc)\n  [ternaryToIndex('0101')]: {\n    0: [SW_TRIANGLE, NE_TRIANGLE],\n    1: [SW_NE_HEXAGON],\n    2: [SW_NE_HEXAGON]\n  },\n  [ternaryToIndex('1010')]: {\n    0: [NW_TRIANGLE, SE_TRIANGLE],\n    1: [NW_SE_HEXAGON],\n    2: [NW_SE_HEXAGON]\n  },\n  [ternaryToIndex('2121')]: {\n    0: [SW_NE_HEXAGON],\n    1: [SW_NE_HEXAGON],\n    2: [SW_TRIANGLE, NE_TRIANGLE]\n  },\n  [ternaryToIndex('1212')]: {\n    0: [NW_SE_HEXAGON],\n    1: [NW_SE_HEXAGON],\n    2: [NW_TRIANGLE, SE_TRIANGLE]\n  },\n\n  // 7-sided polygons based on mean weight\n  [ternaryToIndex('2120')]: {\n    0: [NE_HEPTAGON],\n    1: [NE_HEPTAGON],\n    2: [SW_TRAPEZOID, NE_TRIANGLE]\n  },\n  [ternaryToIndex('2021')]: {\n    0: [SW_HEPTAGON],\n    1: [SW_HEPTAGON],\n    2: [SW_TRIANGLE, NE_TRAPEZOID]\n  },\n  [ternaryToIndex('1202')]: {\n    0: [NW_HEPTAGON],\n    1: [NW_HEPTAGON],\n    2: [NW_TRIANGLE, SE_TRAPEZOID]\n  },\n  [ternaryToIndex('0212')]: {\n    0: [SE_HEPTAGON],\n    1: [SE_HEPTAGON],\n    2: [SE_TRIANGLE, NW_TRAPEZOID]\n  },\n  [ternaryToIndex('0102')]: {\n    0: [SW_TRAPEZOID, NE_TRIANGLE],\n    1: [NE_HEPTAGON],\n    2: [NE_HEPTAGON]\n  },\n  [ternaryToIndex('0201')]: {\n    0: [SW_TRIANGLE, NE_TRAPEZOID],\n    1: [SW_HEPTAGON],\n    2: [SW_HEPTAGON]\n  },\n  [ternaryToIndex('1020')]: {\n    0: [NW_TRIANGLE, SE_TRAPEZOID],\n    1: [NW_HEPTAGON],\n    2: [NW_HEPTAGON]\n  },\n  [ternaryToIndex('2010')]: {\n    0: [SE_TRIANGLE, NW_TRAPEZOID],\n    1: [SE_HEPTAGON],\n    2: [SE_HEPTAGON]\n  },\n\n  // 8-sided polygons based on mean weight\n  [ternaryToIndex('2020')]: {\n    0: [NW_TRAPEZOID, SE_TRAPEZOID],\n    1: [OCTAGON],\n    2: [SW_TRAPEZOID, NE_TRAPEZOID]\n  },\n  [ternaryToIndex('0202')]: {\n    0: [NE_TRAPEZOID, SW_TRAPEZOID],\n    1: [OCTAGON],\n    2: [NW_TRAPEZOID, SE_TRAPEZOID]\n  }\n};\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// All utility methods needed to implement Marching Squares algorithm\n// Ref: https://en.wikipedia.org/wiki/Marching_squares\n\nimport {ISOLINES_CODE_OFFSET_MAP, ISOBANDS_CODE_OFFSET_MAP} from './marching-squares-codes';\n\n// Utility methods\n\nfunction getVertexCode(weight: number, threshold: number | number[]): number {\n  // threshold must be a single value or a range (array of size 2)\n  if (Number.isNaN(weight)) {\n    return 0;\n  }\n  // Iso-bands\n  if (Array.isArray(threshold)) {\n    if (weight < threshold[0]) {\n      return 0;\n    }\n    return weight < threshold[1] ? 1 : 2;\n  }\n  // Iso-lines\n  return weight >= threshold ? 1 : 0;\n}\n\n// Returns marching square code for given cell\n/* eslint-disable complexity, max-statements*/\nexport function getCode(opts: {\n  getValue: (x: number, y: number) => number;\n  threshold: number | number[];\n  x: number;\n  xRange: [number, number];\n  y: number;\n  yRange: [number, number];\n}): {\n  code: number;\n  meanCode: number;\n} {\n  // Assumptions\n  // Origin is on bottom-left , and X increase to right, Y to top\n  // When processing one cell, we process 4 cells, by extending row to top and on column to right\n  // to create a 2X2 cell grid\n  const {x, y, xRange, yRange, getValue, threshold} = opts;\n\n  const isLeftBoundary = x < xRange[0];\n  const isRightBoundary = x >= xRange[1] - 1;\n  const isBottomBoundary = y < yRange[0];\n  const isTopBoundary = y >= yRange[1] - 1;\n  const isBoundary = isLeftBoundary || isRightBoundary || isBottomBoundary || isTopBoundary;\n\n  let weights: number = 0;\n  let current: number;\n  let right: number;\n  let top: number;\n  let topRight: number;\n\n  // TOP\n  if (isLeftBoundary || isTopBoundary) {\n    top = 0;\n  } else {\n    const w = getValue(x, y + 1);\n    top = getVertexCode(w, threshold);\n    weights += w;\n  }\n\n  // TOP-RIGHT\n  if (isRightBoundary || isTopBoundary) {\n    topRight = 0;\n  } else {\n    const w = getValue(x + 1, y + 1);\n    topRight = getVertexCode(w, threshold);\n    weights += w;\n  }\n\n  // RIGHT\n  if (isRightBoundary || isBottomBoundary) {\n    right = 0;\n  } else {\n    const w = getValue(x + 1, y);\n    right = getVertexCode(w, threshold);\n    weights += w;\n  }\n\n  // CURRENT\n  if (isLeftBoundary || isBottomBoundary) {\n    current = 0;\n  } else {\n    const w = getValue(x, y);\n    current = getVertexCode(w, threshold);\n    weights += w;\n  }\n\n  let code = -1;\n  if (Number.isFinite(threshold)) {\n    code = (top << 3) | (topRight << 2) | (right << 1) | current;\n  }\n  if (Array.isArray(threshold)) {\n    code = (top << 6) | (topRight << 4) | (right << 2) | current;\n  }\n\n  let meanCode = 0;\n  // meanCode is only needed for saddle cases, and they should\n  // only occur when we are not processing a cell on boundary\n  // because when on a boundary either, bottom-row, top-row, left-column or right-column will have both 0 codes\n  if (!isBoundary) {\n    meanCode = getVertexCode(weights / 4, threshold);\n  }\n  return {code, meanCode};\n}\n/* eslint-enable complexity, max-statements*/\n\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getPolygons(opts: {\n  x: number;\n  y: number;\n  z: number;\n  code: number;\n  meanCode: number;\n}) {\n  const {x, y, z, code, meanCode} = opts;\n  let offsets: any = ISOBANDS_CODE_OFFSET_MAP[code];\n\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  // Reference vertex is at top-right move to top-right corner\n  const rX = x + 1;\n  const rY = y + 1;\n\n  // offsets format\n  // [[1A, 1B, 1C, ...], [2A, 2B, 2C, ...]],\n  // vertices format\n  // [\n  //   [[x1A, y1A], [x1B, y1B], [x1C, y1C] ... ],\n  //        ...\n  // ]\n\n  const polygons: number[][][] = [];\n  offsets.forEach(polygonOffsets => {\n    const polygon: number[][] = [];\n    polygonOffsets.forEach(xyOffset => {\n      const vX = rX + xyOffset[0];\n      const vY = rY + xyOffset[1];\n      polygon.push([vX, vY, z]);\n    });\n    polygons.push(polygon);\n  });\n  return polygons;\n}\n\n// Returns intersection vertices for given cellindex\n// [x, y] refers current marching cell, reference vertex is always top-right corner\nexport function getLines(opts: {x: number; y: number; z: number; code: number; meanCode: number}) {\n  const {x, y, z, code, meanCode} = opts;\n  let offsets = ISOLINES_CODE_OFFSET_MAP[code];\n\n  // handle saddle cases\n  if (!Array.isArray(offsets)) {\n    offsets = offsets[meanCode];\n  }\n\n  // Reference vertex is at top-right move to top-right corner\n  const rX = x + 1;\n  const rY = y + 1;\n\n  // offsets format\n  // [[1A, 1B], [2A, 2B]],\n  // vertices format\n  // [[x1A, y1A], [x1B, y1B], [x2A, x2B], ...],\n  const lines: number[][] = [];\n  offsets.forEach(xyOffsets => {\n    xyOffsets.forEach(offset => {\n      const vX = rX + offset[0];\n      const vY = rY + offset[1];\n      lines.push([vX, vY, z]);\n    });\n  });\n  return lines;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Color} from '@deck.gl/core';\nimport {getCode, getLines, getPolygons} from './marching-squares';\n\nexport type Contour = {\n  /**\n   * Isolines: `threshold` value must be a single `Number`, Isolines are generated based on this threshold value.\n   *\n   * Isobands: `threshold` value must be an Array of two `Number`s. Isobands are generated using `[threshold[0], threshold[1])` as threshold range, i.e area that has values `>= threshold[0]` and `< threshold[1]` are rendered with corresponding color. NOTE: `threshold[0]` is inclusive and `threshold[1]` is not inclusive.\n   */\n  threshold: number | number[];\n\n  /**\n   * RGBA color array to be used to render the contour.\n   * @default [255, 255, 255, 255]\n   */\n  color?: Color;\n\n  /**\n   * Applicable for `Isoline`s only, width of the Isoline in pixels.\n   * @default 1\n   */\n  strokeWidth?: number;\n\n  /** Defines z order of the contour. */\n  zIndex?: number;\n};\n\nexport type ContourLine = {\n  vertices: number[][];\n  contour: Contour;\n};\n\nexport type ContourPolygon = {\n  vertices: number[][];\n  contour: Contour;\n};\n\n// Given all the cell weights, generates contours for each threshold.\n/* eslint-disable max-depth */\nexport function generateContours({\n  contours,\n  getValue,\n  xRange,\n  yRange\n}: {\n  contours: Contour[];\n  getValue: (x: number, y: number) => number;\n  xRange: [number, number];\n  yRange: [number, number];\n}) {\n  const contourLines: ContourLine[] = [];\n  const contourPolygons: ContourPolygon[] = [];\n  let segmentIndex = 0;\n  let polygonIndex = 0;\n\n  for (let i = 0; i < contours.length; i++) {\n    const contour = contours[i];\n    const z = contour.zIndex ?? i;\n    const {threshold} = contour;\n    for (let x = xRange[0] - 1; x < xRange[1]; x++) {\n      for (let y = yRange[0] - 1; y < yRange[1]; y++) {\n        // Get the MarchingSquares code based on neighbor cell weights.\n        const {code, meanCode} = getCode({\n          getValue,\n          threshold,\n          x,\n          y,\n          xRange,\n          yRange\n        });\n        const opts = {\n          x,\n          y,\n          z,\n          code,\n          meanCode\n        };\n        if (Array.isArray(threshold)) {\n          // ISO bands\n          const polygons = getPolygons(opts);\n          for (const polygon of polygons) {\n            contourPolygons[polygonIndex++] = {\n              vertices: polygon,\n              contour\n            };\n          }\n        } else {\n          // ISO lines\n          const path = getLines(opts);\n          if (path.length > 0) {\n            contourLines[segmentIndex++] = {\n              vertices: path,\n              contour\n            };\n          }\n        }\n      }\n    }\n  }\n  return {lines: contourLines, polygons: contourPolygons};\n}\n/* eslint-enable max-depth */\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Aggregator, CPUAggregator, WebGLAggregator} from '../common/aggregator/index';\nimport type {TypedArray} from '@luma.gl/core';\n\ntype ValueReader = (x: number, y: number) => number;\n\n/** Returns an accessor to the aggregated values from bin id */\nexport function getAggregatorValueReader(opts: {\n  aggregator: Aggregator;\n  binIdRange: [number, number][];\n  channel: 0 | 1 | 2;\n}): ValueReader | null {\n  const {aggregator, binIdRange, channel} = opts;\n\n  if (aggregator instanceof WebGLAggregator) {\n    const buffer = aggregator.getResult(channel)?.buffer;\n    if (buffer) {\n      const values = new Float32Array(buffer.readSyncWebGL().buffer);\n      return getWebGLAggregatorValueReader(values, binIdRange);\n    }\n  }\n  if (aggregator instanceof CPUAggregator) {\n    const values = aggregator.getResult(channel)?.value;\n    const ids = aggregator.getBins()?.value;\n    if (ids && values) {\n      return getCPUAggregatorValueReader(values, ids, aggregator.binCount);\n    }\n  }\n  return null;\n}\n\nfunction getWebGLAggregatorValueReader(\n  values: Float32Array,\n  binIdRange: [number, number][]\n): ValueReader {\n  const [[minX, maxX], [minY, maxY]] = binIdRange;\n  const width = maxX - minX;\n  const height = maxY - minY;\n  return (x: number, y: number) => {\n    x -= minX;\n    y -= minY;\n    if (x < 0 || x >= width || y < 0 || y >= height) {\n      return NaN;\n    }\n    return values[y * width + x];\n  };\n}\n\nfunction getCPUAggregatorValueReader(\n  values: TypedArray,\n  ids: TypedArray,\n  count: number\n): ValueReader {\n  const idMap: Record<string, Record<string, number>> = {};\n  for (let i = 0; i < count; i++) {\n    const x = ids[i * 2];\n    const y = ids[i * 2 + 1];\n    idMap[x] = idMap[x] || {};\n    idMap[x][y] = values[i];\n  }\n  return (x: number, y: number) => idMap[x]?.[y] ?? NaN;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = /* glsl */ `\\\nuniform binOptionsUniforms {\n  vec2 cellOriginCommon;\n  vec2 cellSizeCommon;\n} binOptions;\n`;\n\nexport type BinOptions = {\n  cellOriginCommon: [number, number];\n  cellSizeCommon: [number, number];\n};\n\nexport const binOptionsUniforms = {\n  name: 'binOptions',\n  vs: uniformBlock,\n  uniformTypes: {\n    cellOriginCommon: 'vec2<f32>',\n    cellSizeCommon: 'vec2<f32>'\n  }\n} as const satisfies ShaderModule<BinOptions>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  log,\n  Accessor,\n  Color,\n  GetPickingInfoParams,\n  CompositeLayerProps,\n  createIterable,\n  Layer,\n  Material,\n  project32,\n  LayersList,\n  PickingInfo,\n  Position,\n  Viewport,\n  UpdateParameters,\n  DefaultProps\n} from '@deck.gl/core';\nimport {WebGLAggregator, CPUAggregator, AggregationOperation} from '../common/aggregator/index';\nimport AggregationLayer from '../common/aggregation-layer';\nimport {AggregateAccessor} from '../common/types';\nimport {defaultColorRange} from '../common/utils/color-utils';\nimport {AttributeWithScale} from '../common/utils/scale-utils';\nimport {getBinIdRange} from '../common/utils/bounds-utils';\n\nimport {GridCellLayer} from './grid-cell-layer';\nimport {BinOptions, binOptionsUniforms} from './bin-options-uniforms';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\n\nconst defaultProps: DefaultProps<GridLayerProps> = {\n  gpuAggregation: true,\n\n  // color\n  colorDomain: null,\n  colorRange: defaultColorRange,\n  getColorValue: {type: 'accessor', value: null}, // default value is calculated from `getColorWeight` and `colorAggregation`\n  getColorWeight: {type: 'accessor', value: 1},\n  colorAggregation: 'SUM',\n  lowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  upperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  colorScaleType: 'quantize',\n  onSetColorDomain: noop,\n\n  // elevation\n  elevationDomain: null,\n  elevationRange: [0, 1000],\n  getElevationValue: {type: 'accessor', value: null}, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n  getElevationWeight: {type: 'accessor', value: 1},\n  elevationAggregation: 'SUM',\n  elevationScale: {type: 'number', min: 0, value: 1},\n  elevationLowerPercentile: {type: 'number', min: 0, max: 100, value: 0},\n  elevationUpperPercentile: {type: 'number', min: 0, max: 100, value: 100},\n  elevationScaleType: 'linear',\n  onSetElevationDomain: noop,\n\n  // grid\n  cellSize: {type: 'number', min: 0, value: 1000},\n  coverage: {type: 'number', min: 0, max: 1, value: 1},\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  gridAggregator: {type: 'function', optional: true, value: null},\n  extruded: false,\n\n  // Optional material for 'lighting' shader module\n  material: true\n};\n\n/** All properties supported by GridLayer. */\nexport type GridLayerProps<DataT = unknown> = _GridLayerProps<DataT> & CompositeLayerProps;\n\n/** Properties added by GridLayer. */\ntype _GridLayerProps<DataT> = {\n  /**\n   * Custom accessor to retrieve a grid bin index from each data object.\n   * Not supported by GPU aggregation.\n   */\n  gridAggregator?: ((position: number[], cellSize: number) => [number, number]) | null;\n\n  /**\n   * Size of each cell in meters.\n   * @default 1000\n   */\n  cellSize?: number;\n\n  /**\n   * Color scale domain, default is set to the extent of aggregated weights in each cell.\n   * @default [min(colorWeight), max(colorWeight)]\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Default: [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6) `6-class YlOrRd`\n   */\n  colorRange?: Color[];\n\n  /**\n   * Cell size multiplier, clamped between 0 - 1.\n   * @default 1\n   */\n  coverage?: number;\n\n  /**\n   * Elevation scale input domain, default is set to between 0 and the max of aggregated weights in each cell.\n   * @default [0, max(elevationWeight)]\n   */\n  elevationDomain?: [number, number] | null;\n\n  /**\n   * Elevation scale output range.\n   * @default [0, 1000]\n   */\n  elevationRange?: [number, number];\n\n  /**\n   * Cell elevation multiplier.\n   * @default 1\n   */\n  elevationScale?: number;\n\n  /**\n   * Whether to enable cell elevation. If set to false, all cell will be flat.\n   * @default true\n   */\n  extruded?: boolean;\n\n  /**\n   * Filter cells and re-calculate color by `upperPercentile`.\n   * Cells with value larger than the upperPercentile will be hidden.\n   * @default 100\n   */\n  upperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate color by `lowerPercentile`.\n   * Cells with value smaller than the lowerPercentile will be hidden.\n   * @default 0\n   */\n  lowerPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationUpperPercentile`.\n   * Cells with elevation value larger than the `elevationUpperPercentile` will be hidden.\n   * @default 100\n   */\n  elevationUpperPercentile?: number;\n\n  /**\n   * Filter cells and re-calculate elevation by `elevationLowerPercentile`.\n   * Cells with elevation value larger than the `elevationLowerPercentile` will be hidden.\n   * @default 0\n   */\n  elevationLowerPercentile?: number;\n\n  /**\n   * Scaling function used to determine the color of the grid cell.\n   * Supported Values are 'quantize', 'linear', 'quantile' and 'ordinal'.\n   * @default 'quantize'\n   */\n  colorScaleType?: 'quantize' | 'linear' | 'quantile' | 'ordinal';\n\n  /**\n   * Scaling function used to determine the elevation of the grid cell.\n   * Supported Values are 'linear' and 'quantile'.\n   * @default 'linear'\n   */\n  elevationScaleType?: 'linear' | 'quantile';\n\n  /**\n   * Material settings for lighting effect. Applies if `extruded: true`.\n   *\n   * @default true\n   * @see https://deck.gl/docs/developer-guide/using-lighting\n   */\n  material?: Material;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's color value.\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  colorAggregation?: AggregationOperation;\n\n  /**\n   * Defines the operation used to aggregate all data object weights to calculate a cell's elevation value.\n   * Valid values are 'SUM', 'MEAN', 'MIN', 'MAX', 'COUNT'.\n   *\n   * @default 'SUM'\n   */\n  elevationAggregation?: AggregationOperation;\n\n  /**\n   * Method called to retrieve the position of each object.\n   * @default object => object.position\n   */\n  getPosition?: Accessor<DataT, Position>;\n\n  /**\n   * The weight of a data object used to calculate the color value for a cell.\n   * @default 1\n   */\n  getColorWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its color is based on.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  getColorValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * The weight of a data object used to calculate the elevation value for a cell.\n   * @default 1\n   */\n  getElevationWeight?: Accessor<DataT, number>;\n\n  /**\n   * After data objects are aggregated into cells, this accessor is called on each cell to get the value that its elevation is based on.\n   * Not supported by GPU aggregation.\n   * @default null\n   */\n  getElevationValue?: AggregateAccessor<DataT> | null;\n\n  /**\n   * This callback will be called when bin color domain has been calculated.\n   * @default () => {}\n   */\n  onSetColorDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * This callback will be called when bin elevation domain has been calculated.\n   * @default () => {}\n   */\n  onSetElevationDomain?: (minMax: [number, number]) => void;\n\n  /**\n   * When set to true, aggregation is performed on GPU, provided other conditions are met.\n   * @default true\n   */\n  gpuAggregation?: boolean;\n};\n\nexport type GridLayerPickingInfo<DataT> = PickingInfo<{\n  /** Column index of the picked cell */\n  col: number;\n  /** Row index of the picked cell */\n  row: number;\n  /** Aggregated color value, as determined by `getColorWeight` and `colorAggregation` */\n  colorValue: number;\n  /** Aggregated elevation value, as determined by `getElevationWeight` and `elevationAggregation` */\n  elevationValue: number;\n  /** Number of data points in the picked cell */\n  count: number;\n  /** Indices of the data objects in the picked cell. Only available if using CPU aggregation. */\n  pointIndices?: number[];\n  /** The data objects in the picked cell. Only available if using CPU aggregation and layer data is an array. */\n  points?: DataT[];\n}>;\n\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nexport default class GridLayer<DataT = any, ExtraPropsT extends {} = {}> extends AggregationLayer<\n  DataT,\n  ExtraPropsT & Required<_GridLayerProps<DataT>>\n> {\n  static layerName = 'GridLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] &\n    BinOptions & {\n      // Needed if getColorValue, getElevationValue are used\n      dataAsArray?: DataT[];\n\n      colors?: AttributeWithScale;\n      elevations?: AttributeWithScale;\n\n      binIdRange: [number, number][];\n      aggregatorViewport: Viewport;\n    };\n\n  getAggregatorType(): string {\n    const {gpuAggregation, gridAggregator, getColorValue, getElevationValue} = this.props;\n    if (gpuAggregation && (gridAggregator || getColorValue || getElevationValue)) {\n      // If these features are desired by the app, the user should explicitly use CPU aggregation\n      log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n      return 'cpu';\n    }\n\n    if (\n      // GPU aggregation is requested\n      gpuAggregation &&\n      // GPU aggregation is supported by the device\n      WebGLAggregator.isSupported(this.context.device)\n    ) {\n      return 'gpu';\n    }\n    return 'cpu';\n  }\n\n  createAggregator(type: string): WebGLAggregator | CPUAggregator {\n    if (type === 'cpu') {\n      const {gridAggregator, cellSize} = this.props;\n      return new CPUAggregator({\n        dimensions: 2,\n        getBin: {\n          sources: ['positions'],\n          getValue: ({positions}: {positions: number[]}, index: number, opts: BinOptions) => {\n            if (gridAggregator) {\n              return gridAggregator(positions, cellSize);\n            }\n            const viewport = this.state.aggregatorViewport;\n            // project to common space\n            const p = viewport.projectPosition(positions);\n            const {cellSizeCommon, cellOriginCommon} = opts;\n            return [\n              Math.floor((p[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n              Math.floor((p[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n            ];\n          }\n        },\n        getValue: [\n          {sources: ['colorWeights'], getValue: ({colorWeights}) => colorWeights},\n          {sources: ['elevationWeights'], getValue: ({elevationWeights}) => elevationWeights}\n        ]\n      });\n    }\n    return new WebGLAggregator(this.context.device, {\n      dimensions: 2,\n      channelCount: 2,\n      bufferLayout: this.getAttributeManager()!.getBufferLayouts({isInstanced: false}),\n      ...super.getShaders({\n        modules: [project32, binOptionsUniforms],\n        vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    vec2 gridCoords = floor(positionCommon.xy / binOptions.cellSizeCommon);\n    binId = ivec2(gridCoords);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n      })\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {\n        size: 3,\n        accessor: 'getPosition',\n        type: 'float64',\n        fp64: this.use64bitPositions()\n      },\n      colorWeights: {size: 1, accessor: 'getColorWeight'},\n      elevationWeights: {size: 1, accessor: 'getElevationWeight'}\n    });\n  }\n\n  // eslint-disable-next-line complexity\n  updateState(params: UpdateParameters<this>) {\n    const aggregatorChanged = super.updateState(params);\n\n    const {props, oldProps, changeFlags} = params;\n    const {aggregator} = this.state;\n    if (\n      (changeFlags.dataChanged || !this.state.dataAsArray) &&\n      (props.getColorValue || props.getElevationValue)\n    ) {\n      // Convert data to array\n      this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n    }\n    if (\n      aggregatorChanged ||\n      changeFlags.dataChanged ||\n      props.cellSize !== oldProps.cellSize ||\n      props.getColorValue !== oldProps.getColorValue ||\n      props.getElevationValue !== oldProps.getElevationValue ||\n      props.colorAggregation !== oldProps.colorAggregation ||\n      props.elevationAggregation !== oldProps.elevationAggregation\n    ) {\n      this._updateBinOptions();\n      const {cellSizeCommon, cellOriginCommon, binIdRange, dataAsArray} = this.state;\n\n      aggregator.setProps({\n        // @ts-expect-error only used by GPUAggregator\n        binIdRange,\n        pointCount: this.getNumInstances(),\n        operations: [props.colorAggregation, props.elevationAggregation],\n        binOptions: {\n          cellSizeCommon,\n          cellOriginCommon\n        },\n        onUpdate: this._onAggregationUpdate.bind(this)\n      });\n\n      if (dataAsArray) {\n        const {getColorValue, getElevationValue} = this.props;\n        aggregator.setProps({\n          // @ts-expect-error only used by CPUAggregator\n          customOperations: [\n            getColorValue &&\n              ((indices: number[]) =>\n                getColorValue(\n                  indices.map(i => dataAsArray[i]),\n                  {indices, data: props.data}\n                )),\n            getElevationValue &&\n              ((indices: number[]) =>\n                getElevationValue(\n                  indices.map(i => dataAsArray[i]),\n                  {indices, data: props.data}\n                ))\n          ]\n        });\n      }\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n      aggregator.setNeedsUpdate(0);\n    }\n    if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n      aggregator.setNeedsUpdate(1);\n    }\n\n    return aggregatorChanged;\n  }\n\n  private _updateBinOptions() {\n    const bounds = this.getBounds();\n    const cellSizeCommon: [number, number] = [1, 1];\n    let cellOriginCommon: [number, number] = [0, 0];\n    let binIdRange: [number, number][] = [\n      [0, 1],\n      [0, 1]\n    ];\n    let viewport = this.context.viewport;\n\n    if (bounds && Number.isFinite(bounds[0][0])) {\n      let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n      const {cellSize} = this.props;\n      const {unitsPerMeter} = viewport.getDistanceScales(centroid);\n      cellSizeCommon[0] = unitsPerMeter[0] * cellSize;\n      cellSizeCommon[1] = unitsPerMeter[1] * cellSize;\n\n      // Offset common space to center at the origin of the grid cell where the data center is in\n      // This improves precision without affecting the cell positions\n      const centroidCommon = viewport.projectFlat(centroid);\n      cellOriginCommon = [\n        Math.floor(centroidCommon[0] / cellSizeCommon[0]) * cellSizeCommon[0],\n        Math.floor(centroidCommon[1] / cellSizeCommon[1]) * cellSizeCommon[1]\n      ];\n      centroid = viewport.unprojectFlat(cellOriginCommon);\n\n      const ViewportType = viewport.constructor as any;\n      // We construct a viewport for the GPU aggregator's project module\n      // This viewport is determined by data\n      // removes arbitrary precision variance that depends on initial view state\n      viewport = viewport.isGeospatial\n        ? new ViewportType({longitude: centroid[0], latitude: centroid[1], zoom: 12})\n        : new Viewport({position: [centroid[0], centroid[1], 0], zoom: 12});\n\n      // Round to the nearest 32-bit float to match CPU and GPU results\n      cellOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n\n      binIdRange = getBinIdRange({\n        dataBounds: bounds,\n        getBinId: (p: number[]) => {\n          const positionCommon = viewport.projectFlat(p);\n          return [\n            Math.floor((positionCommon[0] - cellOriginCommon[0]) / cellSizeCommon[0]),\n            Math.floor((positionCommon[1] - cellOriginCommon[1]) / cellSizeCommon[1])\n          ];\n        }\n      });\n    }\n\n    this.setState({cellSizeCommon, cellOriginCommon, binIdRange, aggregatorViewport: viewport});\n  }\n\n  override draw(opts) {\n    // Replaces render time viewport with our own\n    if (opts.shaderModuleProps.project) {\n      opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n    }\n    super.draw(opts);\n  }\n\n  private _onAggregationUpdate({channel}: {channel: number}) {\n    const props = this.getCurrentLayer()!.props;\n    const {aggregator} = this.state;\n    if (channel === 0) {\n      const result = aggregator.getResult(0)!;\n      this.setState({\n        colors: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetColorDomain(aggregator.getResultDomain(0));\n    } else if (channel === 1) {\n      const result = aggregator.getResult(1)!;\n      this.setState({\n        elevations: new AttributeWithScale(result, aggregator.binCount)\n      });\n      props.onSetElevationDomain(aggregator.getResultDomain(1));\n    }\n  }\n\n  onAttributeChange(id: string) {\n    const {aggregator} = this.state;\n    switch (id) {\n      case 'positions':\n        aggregator.setNeedsUpdate();\n\n        this._updateBinOptions();\n        const {cellSizeCommon, cellOriginCommon, binIdRange} = this.state;\n        aggregator.setProps({\n          // @ts-expect-error only used by GPUAggregator\n          binIdRange,\n          binOptions: {\n            cellSizeCommon,\n            cellOriginCommon\n          }\n        });\n        break;\n\n      case 'colorWeights':\n        aggregator.setNeedsUpdate(0);\n        break;\n\n      case 'elevationWeights':\n        aggregator.setNeedsUpdate(1);\n        break;\n\n      default:\n      // This should not happen\n    }\n  }\n\n  renderLayers(): LayersList | Layer | null {\n    const {aggregator, cellOriginCommon, cellSizeCommon} = this.state;\n    const {\n      elevationScale,\n      colorRange,\n      elevationRange,\n      extruded,\n      coverage,\n      material,\n      transitions,\n      colorScaleType,\n      lowerPercentile,\n      upperPercentile,\n      colorDomain,\n      elevationScaleType,\n      elevationLowerPercentile,\n      elevationUpperPercentile,\n      elevationDomain\n    } = this.props;\n    const CellLayerClass = this.getSubLayerClass('cells', GridCellLayer);\n    const binAttribute = aggregator.getBins();\n\n    const colors = this.state.colors?.update({\n      scaleType: colorScaleType,\n      lowerPercentile,\n      upperPercentile\n    });\n    const elevations = this.state.elevations?.update({\n      scaleType: elevationScaleType,\n      lowerPercentile: elevationLowerPercentile,\n      upperPercentile: elevationUpperPercentile\n    });\n\n    if (!colors || !elevations) {\n      return null;\n    }\n\n    return new CellLayerClass(\n      this.getSubLayerProps({\n        id: 'cells'\n      }),\n      {\n        data: {\n          length: aggregator.binCount,\n          attributes: {\n            getBin: binAttribute,\n            getColorValue: colors.attribute,\n            getElevationValue: elevations.attribute\n          }\n        },\n        // Data has changed shallowly, but we likely don't need to update the attributes\n        dataComparator: (data, oldData) => data.length === oldData.length,\n        updateTriggers: {\n          getBin: [binAttribute],\n          getColorValue: [colors.attribute],\n          getElevationValue: [elevations.attribute]\n        },\n        cellOriginCommon,\n        cellSizeCommon,\n        elevationScale,\n        colorRange,\n        colorScaleType,\n        elevationRange,\n        extruded,\n        coverage,\n        material,\n        colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n        elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n        colorCutoff: colors.cutoff,\n        elevationCutoff: elevations.cutoff,\n        transitions: transitions && {\n          getFillColor: transitions.getColorValue || transitions.getColorWeight,\n          getElevation: transitions.getElevationValue || transitions.getElevationWeight\n        },\n        // Extensions are already handled by the GPUAggregator, do not pass it down\n        extensions: []\n      }\n    );\n  }\n\n  getPickingInfo(params: GetPickingInfoParams): GridLayerPickingInfo<DataT> {\n    const info: GridLayerPickingInfo<DataT> = params.info;\n    const {index} = info;\n    if (index >= 0) {\n      const bin = this.state.aggregator.getBin(index);\n      let object: GridLayerPickingInfo<DataT>['object'];\n      if (bin) {\n        object = {\n          col: bin.id[0],\n          row: bin.id[1],\n          colorValue: bin.value[0],\n          elevationValue: bin.value[1],\n          count: bin.count\n        };\n        if (bin.pointIndices) {\n          object.pointIndices = bin.pointIndices;\n          object.points = Array.isArray(this.props.data)\n            ? bin.pointIndices.map(i => (this.props.data as DataT[])[i])\n            : [];\n        }\n      }\n      info.object = object;\n    }\n\n    return info;\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport {UpdateParameters, Color} from '@deck.gl/core';\nimport {ColumnLayer} from '@deck.gl/layers';\nimport {CubeGeometry} from '@luma.gl/engine';\nimport {createColorRangeTexture, updateColorRangeTexture} from '../common/utils/color-utils';\nimport vs from './grid-cell-layer-vertex.glsl';\nimport {GridProps, gridUniforms} from './grid-layer-uniforms';\nimport type {ScaleType} from '../common/types';\n\n/** Proprties added by GridCellLayer. */\ntype GridCellLayerProps = {\n  cellSizeCommon: [number, number];\n  cellOriginCommon: [number, number];\n  colorDomain: [number, number];\n  colorCutoff: [number, number] | null;\n  colorRange: Color[];\n  colorScaleType: ScaleType;\n  elevationDomain: [number, number];\n  elevationCutoff: [number, number] | null;\n  elevationRange: [number, number];\n};\n\nexport class GridCellLayer<ExtraPropsT extends {} = {}> extends ColumnLayer<\n  null,\n  ExtraPropsT & Required<GridCellLayerProps>\n> {\n  static layerName = 'GridCellLayer';\n\n  state!: ColumnLayer['state'] & {\n    colorTexture: Texture;\n  };\n\n  getShaders() {\n    const shaders = super.getShaders();\n    shaders.modules.push(gridUniforms);\n    return {...shaders, vs};\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.remove([\n      'instanceElevations',\n      'instanceFillColors',\n      'instanceLineColors',\n      'instanceStrokeWidths'\n    ]);\n    attributeManager.addInstanced({\n      instancePositions: {\n        size: 2,\n        type: 'float32',\n        accessor: 'getBin'\n      },\n      instanceColorValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getColorValue'\n      },\n      instanceElevationValues: {\n        size: 1,\n        type: 'float32',\n        accessor: 'getElevationValue'\n      }\n    });\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps} = params;\n    const model = this.state.fillModel!;\n\n    if (oldProps.colorRange !== props.colorRange) {\n      this.state.colorTexture?.destroy();\n      this.state.colorTexture = createColorRangeTexture(\n        this.context.device,\n        props.colorRange,\n        props.colorScaleType\n      );\n      const gridProps: Partial<GridProps> = {colorRange: this.state.colorTexture};\n      model.shaderInputs.setProps({grid: gridProps});\n    } else if (oldProps.colorScaleType !== props.colorScaleType) {\n      updateColorRangeTexture(this.state.colorTexture, props.colorScaleType);\n    }\n  }\n\n  finalizeState(context) {\n    super.finalizeState(context);\n\n    this.state.colorTexture?.destroy();\n  }\n\n  protected _updateGeometry() {\n    const geometry = new CubeGeometry();\n    this.state.fillModel!.setGeometry(geometry);\n  }\n\n  draw({uniforms}) {\n    const {\n      cellOriginCommon,\n      cellSizeCommon,\n      elevationRange,\n      elevationScale,\n      extruded,\n      coverage,\n      colorDomain,\n      elevationDomain\n    } = this.props;\n    const colorCutoff = this.props.colorCutoff || [-Infinity, Infinity];\n    const elevationCutoff = this.props.elevationCutoff || [-Infinity, Infinity];\n    const fillModel = this.state.fillModel!;\n\n    const gridProps: Omit<GridProps, 'colorRange'> = {\n      colorDomain: [\n        Math.max(colorDomain[0], colorCutoff[0]), // instanceColorValue that maps to colorRange[0]\n        Math.min(colorDomain[1], colorCutoff[1]), // instanceColorValue that maps to colorRange[colorRange.length - 1]\n        Math.max(colorDomain[0] - 1, colorCutoff[0]), // hide cell if instanceColorValue is less than this\n        Math.min(colorDomain[1] + 1, colorCutoff[1]) // hide cell if instanceColorValue is greater than this\n      ],\n      elevationDomain: [\n        Math.max(elevationDomain[0], elevationCutoff[0]), // instanceElevationValue that maps to elevationRange[0]\n        Math.min(elevationDomain[1], elevationCutoff[1]), // instanceElevationValue that maps to elevationRange[elevationRange.length - 1]\n        Math.max(elevationDomain[0] - 1, elevationCutoff[0]), // hide cell if instanceElevationValue is less than this\n        Math.min(elevationDomain[1] + 1, elevationCutoff[1]) // hide cell if instanceElevationValue is greater than this\n      ],\n      elevationRange: [elevationRange[0] * elevationScale, elevationRange[1] * elevationScale],\n      originCommon: cellOriginCommon,\n      sizeCommon: cellSizeCommon\n    };\n    fillModel.shaderInputs.setProps({\n      column: {extruded, coverage},\n      grid: gridProps\n    });\n    fillModel.draw(this.context.renderPass);\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default /* glsl */ `#version 300 es\n\n#define SHADER_NAME grid-cell-layer-vertex-shader\n\nin vec3 positions;\nin vec3 normals;\n\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\n\nuniform sampler2D colorRange;\n\n// Result\nout vec4 vColor;\n\nfloat interp(float value, vec2 domain, vec2 range) {\n  float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\n  return mix(range.x, range.y, r);\n}\n\nvec4 interp(float value, vec2 domain, sampler2D range) {\n  float r = (value - domain.x) / (domain.y - domain.x);\n  return texture(range, vec2(r, 0.5));\n}\n\nvoid main(void) {\n  geometry.pickingColor = instancePickingColors;\n\n  if (isnan(instanceColorValues) ||\n    instanceColorValues < grid.colorDomain.z ||\n    instanceColorValues > grid.colorDomain.w ||\n    instanceElevationValues < grid.elevationDomain.z ||\n    instanceElevationValues > grid.elevationDomain.w\n  ) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  \n  vec2 commonPosition = (instancePositions + (positions.xy + 1.0) / 2.0 * column.coverage) * grid.sizeCommon + grid.originCommon - project.commonOrigin.xy;\n  geometry.position = vec4(commonPosition, 0.0, 1.0);\n  geometry.normal = project_normal(normals);\n\n  // calculate z, if 3d not enabled set to 0\n  float elevation = 0.0;\n  if (column.extruded) {\n    elevation = interp(instanceElevationValues, grid.elevationDomain.xy, grid.elevationRange);\n    elevation = project_size(elevation);\n    // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1\n    geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n  }\n\n  gl_Position = project_common_position_to_clipspace(geometry.position);\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n\n  vColor = interp(instanceColorValues, grid.colorDomain.xy, colorRange);\n  vColor.a *= layer.opacity;\n  if (column.extruded) {\n    vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = /* glsl */ `\\\nuniform gridUniforms {\n  vec4 colorDomain;\n  vec4 elevationDomain;\n  vec2 elevationRange;\n  vec2 originCommon;\n  vec2 sizeCommon;\n} grid;\n`;\n\nexport type GridProps = {\n  colorDomain: [number, number, number, number];\n  colorRange: Texture;\n  elevationDomain: [number, number, number, number];\n  elevationRange: [number, number];\n  originCommon: [number, number];\n  sizeCommon: [number, number];\n};\n\nexport const gridUniforms = {\n  name: 'grid',\n  vs: uniformBlock,\n  uniformTypes: {\n    colorDomain: 'vec4<f32>',\n    elevationDomain: 'vec4<f32>',\n    elevationRange: 'vec2<f32>',\n    originCommon: 'vec2<f32>',\n    sizeCommon: 'vec2<f32>'\n  }\n} as const satisfies ShaderModule<GridProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = /* glsl */ `\\\nuniform binOptionsUniforms {\n  vec2 cellOriginCommon;\n  vec2 cellSizeCommon;\n} binOptions;\n`;\n\nexport type BinOptions = {\n  cellOriginCommon: [number, number];\n  cellSizeCommon: [number, number];\n};\n\nexport const binOptionsUniforms = {\n  name: 'binOptions',\n  vs: uniformBlock,\n  uniformTypes: {\n    cellOriginCommon: 'vec2<f32>',\n    cellSizeCommon: 'vec2<f32>'\n  }\n} as const satisfies ShaderModule<BinOptions>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport function getBounds(points: number[][]): number[] {\n  // Now build bounding box in world space (aligned to world coordiante system)\n  const x = points.map(p => p[0]);\n  const y = points.map(p => p[1]);\n\n  const xMin = Math.min.apply(null, x);\n  const xMax = Math.max.apply(null, x);\n  const yMin = Math.min.apply(null, y);\n  const yMax = Math.max.apply(null, y);\n\n  return [xMin, yMin, xMax, yMax];\n}\n\n// true if currentBounds contains targetBounds, false otherwise\nexport function boundsContain(currentBounds: number[], targetBounds: number[]): boolean {\n  if (\n    targetBounds[0] >= currentBounds[0] &&\n    targetBounds[2] <= currentBounds[2] &&\n    targetBounds[1] >= currentBounds[1] &&\n    targetBounds[3] <= currentBounds[3]\n  ) {\n    return true;\n  }\n  return false;\n}\n\nconst scratchArray = new Float32Array(12);\n\n// For given rectangle bounds generates two triangles vertices that coverit completely\nexport function packVertices(points: number[][], dimensions: number = 2): Float32Array {\n  let index = 0;\n  for (const point of points) {\n    for (let i = 0; i < dimensions; i++) {\n      scratchArray[index++] = point[i] || 0;\n    }\n  }\n  return scratchArray;\n}\n\n// Expands boundingBox:[xMin, yMin, xMax, yMax] to match aspect ratio of given width and height\nexport function scaleToAspectRatio(\n  boundingBox: [number, number, number, number],\n  width: number,\n  height: number\n): [number, number, number, number] {\n  const [xMin, yMin, xMax, yMax] = boundingBox;\n\n  const currentWidth = xMax - xMin;\n  const currentHeight = yMax - yMin;\n\n  let newWidth = currentWidth;\n  let newHeight = currentHeight;\n  if (currentWidth / currentHeight < width / height) {\n    // expand bounding box width\n    newWidth = (width / height) * currentHeight;\n  } else {\n    newHeight = (height / width) * currentWidth;\n  }\n\n  if (newWidth < width) {\n    newWidth = width;\n    newHeight = height;\n  }\n\n  const xCenter = (xMax + xMin) / 2;\n  const yCenter = (yMax + yMin) / 2;\n\n  return [\n    xCenter - newWidth / 2,\n    yCenter - newHeight / 2,\n    xCenter + newWidth / 2,\n    yCenter + newHeight / 2\n  ];\n}\n\n// Get texture coordiante of point inside a bounding box\nexport function getTextureCoordinates(point: number[], bounds: number[]) {\n  const [xMin, yMin, xMax, yMax] = bounds;\n  return [(point[0] - xMin) / (xMax - xMin), (point[1] - yMin) / (yMax - yMin)];\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n/* global setTimeout clearTimeout */\nimport {\n  getBounds,\n  boundsContain,\n  packVertices,\n  scaleToAspectRatio,\n  getTextureCoordinates\n} from './heatmap-layer-utils';\nimport {Buffer, DeviceFeature, Texture, TextureProps, TextureFormat} from '@luma.gl/core';\nimport {TextureTransform, TextureTransformProps} from '@luma.gl/engine';\nimport {\n  Accessor,\n  AccessorFunction,\n  AttributeManager,\n  ChangeFlags,\n  Color,\n  COORDINATE_SYSTEM,\n  Layer,\n  LayerContext,\n  LayersList,\n  log,\n  Position,\n  UpdateParameters,\n  DefaultProps,\n  project32\n} from '@deck.gl/core';\nimport TriangleLayer from './triangle-layer';\nimport AggregationLayer, {AggregationLayerProps} from './aggregation-layer';\nimport {defaultColorRange, colorRangeToFlatArray} from '../common/utils/color-utils';\nimport weightsVs from './weights-vs.glsl';\nimport weightsFs from './weights-fs.glsl';\nimport maxVs from './max-vs.glsl';\nimport maxFs from './max-fs.glsl';\nimport {\n  MaxWeightProps,\n  maxWeightUniforms,\n  WeightProps,\n  weightUniforms\n} from './heatmap-layer-uniforms';\n\nconst RESOLUTION = 2; // (number of common space pixels) / (number texels)\nconst TEXTURE_PROPS: TextureProps = {\n  format: 'rgba8unorm',\n  dimension: '2d',\n  width: 1,\n  height: 1,\n  sampler: {\n    minFilter: 'linear',\n    magFilter: 'linear',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge'\n  }\n};\nconst DEFAULT_COLOR_DOMAIN = [0, 0];\nconst AGGREGATION_MODE = {\n  SUM: 0,\n  MEAN: 1\n};\n\nconst defaultProps: DefaultProps<HeatmapLayerProps> = {\n  getPosition: {type: 'accessor', value: (x: any) => x.position},\n  getWeight: {type: 'accessor', value: 1},\n  intensity: {type: 'number', min: 0, value: 1},\n  radiusPixels: {type: 'number', min: 1, max: 100, value: 50},\n  colorRange: defaultColorRange,\n  threshold: {type: 'number', min: 0, max: 1, value: 0.05},\n  colorDomain: {type: 'array', value: null, optional: true},\n  // 'SUM' or 'MEAN'\n  aggregation: 'SUM',\n  weightsTextureSize: {type: 'number', min: 128, max: 2048, value: 2048},\n  debounceTimeout: {type: 'number', min: 0, max: 1000, value: 500}\n};\n\nconst FLOAT_TARGET_FEATURES: DeviceFeature[] = [\n  'float32-renderable-webgl', // ability to render to float texture\n  'texture-blend-float-webgl' // ability to blend when rendering to float texture\n];\n\nconst DIMENSIONS = {\n  data: {\n    props: ['radiusPixels']\n  }\n};\n\nexport type HeatmapLayerProps<DataT = unknown> = _HeatmapLayerProps<DataT> &\n  AggregationLayerProps<DataT>;\n\ntype _HeatmapLayerProps<DataT> = {\n  /**\n   * Radius of the circle in pixels, to which the weight of an object is distributed.\n   *\n   * @default 30\n   */\n  radiusPixels?: number;\n\n  /**\n   * Specified as an array of colors [color1, color2, ...].\n   *\n   * @default `6-class YlOrRd` - [colorbrewer](http://colorbrewer2.org/#type=sequential&scheme=YlOrRd&n=6)\n   */\n  colorRange?: Color[];\n\n  /**\n   * Value that is multiplied with the total weight at a pixel to obtain the final weight.\n   *\n   * @default 1\n   */\n  intensity?: number;\n\n  /**\n   * Ratio of the fading weight to the max weight, between `0` and `1`.\n   *\n   * For example, `0.1` affects all pixels with weight under 10% of the max.\n   *\n   * Ignored when `colorDomain` is specified.\n   * @default 0.05\n   */\n  threshold?: number;\n\n  /**\n   * Controls how weight values are mapped to the `colorRange`, as an array of two numbers [`minValue`, `maxValue`].\n   *\n   * @default null\n   */\n  colorDomain?: [number, number] | null;\n\n  /**\n   * Defines the type of aggregation operation\n   *\n   * V valid values are 'SUM', 'MEAN'.\n   *\n   * @default 'SUM'\n   */\n  aggregation?: 'SUM' | 'MEAN';\n\n  /**\n   * Specifies the size of weight texture.\n   * @default 2048\n   */\n  weightsTextureSize?: number;\n\n  /**\n   * Interval in milliseconds during which changes to the viewport don't trigger aggregation.\n   *\n   * @default 500\n   */\n  debounceTimeout?: number;\n\n  /**\n   * Method called to retrieve the position of each object.\n   *\n   * @default d => d.position\n   */\n  getPosition?: AccessorFunction<DataT, Position>;\n\n  /**\n   * The weight of each object.\n   *\n   * @default 1\n   */\n  getWeight?: Accessor<DataT, number>;\n};\n\n/** Visualizes the spatial distribution of data. */\nexport default class HeatmapLayer<\n  DataT = any,\n  ExtraPropsT extends {} = {}\n> extends AggregationLayer<DataT, ExtraPropsT & Required<_HeatmapLayerProps<DataT>>> {\n  static layerName = 'HeatmapLayer';\n  static defaultProps = defaultProps;\n\n  state!: AggregationLayer<DataT>['state'] & {\n    colorDomain?: number[];\n    isWeightMapDirty?: boolean;\n    weightsTexture?: Texture;\n    maxWeightsTexture?: Texture;\n    colorTexture?: Texture;\n    zoom?: number;\n    worldBounds?: number[];\n    normalizedCommonBounds?: number[];\n    updateTimer?: any;\n    triPositionBuffer?: Buffer;\n    triTexCoordBuffer?: Buffer;\n    weightsTransform?: TextureTransform;\n    maxWeightTransform?: TextureTransform;\n    textureSize: number;\n    format: TextureFormat;\n    weightsScale: number;\n    visibleWorldBounds: number[];\n    viewportCorners: number[][];\n  };\n\n  getShaders(shaders: any) {\n    let modules = [project32];\n    if (shaders.modules) {\n      modules = [...modules, ...shaders.modules];\n    }\n\n    return super.getShaders({...shaders, modules});\n  }\n\n  initializeState() {\n    super.initializeAggregationLayer(DIMENSIONS);\n    this.setState({colorDomain: DEFAULT_COLOR_DOMAIN});\n    this._setupTextureParams();\n    this._setupAttributes();\n    this._setupResources();\n  }\n\n  shouldUpdateState({changeFlags}: UpdateParameters<this>) {\n    // Need to be updated when viewport changes\n    return changeFlags.somethingChanged;\n  }\n\n  /* eslint-disable max-statements,complexity */\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n    this._updateHeatmapState(opts);\n  }\n\n  _updateHeatmapState(opts: UpdateParameters<this>) {\n    const {props, oldProps} = opts;\n    const changeFlags = this._getChangeFlags(opts);\n\n    if (changeFlags.dataChanged || changeFlags.viewportChanged) {\n      // if data is changed, do not debounce and immediately update the weight map\n      changeFlags.boundsChanged = this._updateBounds(changeFlags.dataChanged);\n      this._updateTextureRenderingBounds();\n    }\n\n    if (changeFlags.dataChanged || changeFlags.boundsChanged) {\n      // Update weight map immediately\n      clearTimeout(this.state.updateTimer);\n      this.setState({isWeightMapDirty: true});\n\n      if (changeFlags.dataChanged) {\n        // Recreate weights transform if data changed, as buffer layout may have changed,\n        // happens when binary attibutes passed.\n        const weightsTransformShaders = this.getShaders({vs: weightsVs, fs: weightsFs});\n        this._createWeightsTransform(weightsTransformShaders);\n      }\n    } else if (changeFlags.viewportZoomChanged) {\n      // Update weight map when zoom stops\n      this._debouncedUpdateWeightmap();\n    }\n\n    if (props.colorRange !== oldProps.colorRange) {\n      this._updateColorTexture(opts);\n    }\n\n    if (this.state.isWeightMapDirty) {\n      this._updateWeightmap();\n    }\n\n    this.setState({zoom: opts.context.viewport.zoom});\n  }\n\n  renderLayers(): LayersList | Layer {\n    const {\n      weightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      maxWeightsTexture,\n      colorTexture,\n      colorDomain\n    } = this.state;\n    const {updateTriggers, intensity, threshold, aggregation} = this.props;\n\n    const TriangleLayerClass = this.getSubLayerClass('triangle', TriangleLayer);\n\n    return new TriangleLayerClass(\n      this.getSubLayerProps({\n        id: 'triangle-layer',\n        updateTriggers\n      }),\n      {\n        // position buffer is filled with world coordinates generated from viewport.unproject\n        // i.e. LNGLAT if geospatial, CARTESIAN otherwise\n        coordinateSystem: COORDINATE_SYSTEM.DEFAULT,\n        data: {\n          attributes: {\n            positions: triPositionBuffer,\n            texCoords: triTexCoordBuffer\n          }\n        },\n        vertexCount: 4,\n        maxTexture: maxWeightsTexture,\n        colorTexture,\n        aggregationMode: AGGREGATION_MODE[aggregation] || 0,\n        weightsTexture,\n        intensity,\n        threshold,\n        colorDomain\n      }\n    );\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    const {\n      weightsTransform,\n      weightsTexture,\n      maxWeightTransform,\n      maxWeightsTexture,\n      triPositionBuffer,\n      triTexCoordBuffer,\n      colorTexture,\n      updateTimer\n    } = this.state;\n    weightsTransform?.destroy();\n    weightsTexture?.destroy();\n    maxWeightTransform?.destroy();\n    maxWeightsTexture?.destroy();\n    triPositionBuffer?.destroy();\n    triTexCoordBuffer?.destroy();\n    colorTexture?.destroy();\n    if (updateTimer) {\n      clearTimeout(updateTimer);\n    }\n  }\n\n  // PRIVATE\n\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.device, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n\n  _getChangeFlags(opts: UpdateParameters<this>) {\n    const changeFlags: Partial<ChangeFlags> & {\n      boundsChanged?: boolean;\n      viewportZoomChanged?: boolean;\n    } = {};\n    const {dimensions} = this.state;\n    changeFlags.dataChanged =\n      (this.isAttributeChanged() && 'attribute changed') || // if any attribute is changed\n      (this.isAggregationDirty(opts, {\n        compareAll: true,\n        dimension: dimensions.data\n      }) &&\n        'aggregation is dirty');\n    changeFlags.viewportChanged = opts.changeFlags.viewportChanged;\n\n    const {zoom} = this.state;\n    if (!opts.context.viewport || opts.context.viewport.zoom !== zoom) {\n      changeFlags.viewportZoomChanged = true;\n    }\n\n    return changeFlags;\n  }\n\n  _createTextures() {\n    const {textureSize, format} = this.state;\n\n    this.setState({\n      weightsTexture: this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        width: textureSize,\n        height: textureSize,\n        format\n      }),\n      maxWeightsTexture: this.context.device.createTexture({\n        ...TEXTURE_PROPS,\n        width: 1,\n        height: 1,\n        format\n      })\n    });\n  }\n\n  _setupAttributes() {\n    const attributeManager = this.getAttributeManager()!;\n    attributeManager.add({\n      positions: {size: 3, type: 'float64', accessor: 'getPosition'},\n      weights: {size: 1, accessor: 'getWeight'}\n    });\n    this.setState({positionAttributeName: 'positions'});\n  }\n\n  _setupTextureParams() {\n    const {device} = this.context;\n    const {weightsTextureSize} = this.props;\n\n    const textureSize = Math.min(weightsTextureSize, device.limits.maxTextureDimension2D);\n    const floatTargetSupport = FLOAT_TARGET_FEATURES.every(feature => device.features.has(feature));\n    const format: TextureFormat = floatTargetSupport ? 'rgba32float' : 'rgba8unorm';\n    const weightsScale = floatTargetSupport ? 1 : 1 / 255;\n    this.setState({textureSize, format, weightsScale});\n    if (!floatTargetSupport) {\n      log.warn(\n        `HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`\n      )();\n    }\n  }\n\n  _createWeightsTransform(shaders: {vs: string; fs?: string; modules: any[]}) {\n    let {weightsTransform} = this.state;\n    const {weightsTexture} = this.state;\n    const attributeManager = this.getAttributeManager()!;\n\n    weightsTransform?.destroy();\n    weightsTransform = new TextureTransform(this.context.device, {\n      id: `${this.id}-weights-transform`,\n      bufferLayout: attributeManager.getBufferLayouts(),\n      vertexCount: 1,\n      targetTexture: weightsTexture!,\n      parameters: {\n        depthWriteEnabled: false,\n        blendColorOperation: 'add',\n        blendColorSrcFactor: 'one',\n        blendColorDstFactor: 'one',\n        blendAlphaSrcFactor: 'one',\n        blendAlphaDstFactor: 'one'\n      },\n      topology: 'point-list',\n      ...shaders,\n      modules: [...shaders.modules, weightUniforms]\n    } as TextureTransformProps);\n\n    this.setState({weightsTransform});\n  }\n\n  _setupResources() {\n    this._createTextures();\n    const {device} = this.context;\n    const {textureSize, weightsTexture, maxWeightsTexture} = this.state;\n\n    const weightsTransformShaders = this.getShaders({\n      vs: weightsVs,\n      fs: weightsFs\n    });\n    this._createWeightsTransform(weightsTransformShaders);\n\n    const maxWeightsTransformShaders = this.getShaders({\n      vs: maxVs,\n      fs: maxFs,\n      modules: [maxWeightUniforms]\n    });\n    const maxWeightTransform = new TextureTransform(device, {\n      id: `${this.id}-max-weights-transform`,\n      targetTexture: maxWeightsTexture!,\n      ...maxWeightsTransformShaders,\n      vertexCount: textureSize * textureSize,\n      topology: 'point-list',\n      parameters: {\n        depthWriteEnabled: false,\n        blendColorOperation: 'max',\n        blendAlphaOperation: 'max',\n        blendColorSrcFactor: 'one',\n        blendColorDstFactor: 'one',\n        blendAlphaSrcFactor: 'one',\n        blendAlphaDstFactor: 'one'\n      }\n    });\n\n    const maxWeightProps: MaxWeightProps = {inTexture: weightsTexture!, textureSize};\n    maxWeightTransform.model.shaderInputs.setProps({\n      maxWeight: maxWeightProps\n    });\n\n    this.setState({\n      weightsTexture,\n      maxWeightsTexture,\n      maxWeightTransform,\n      zoom: null,\n      triPositionBuffer: device.createBuffer({byteLength: 48}),\n      triTexCoordBuffer: device.createBuffer({byteLength: 48})\n    });\n  }\n\n  // overwrite super class method to update transform model\n  updateShaders(shaderOptions) {\n    // shader params (modules, injects) changed, update model object\n    this._createWeightsTransform({\n      vs: weightsVs,\n      fs: weightsFs,\n      ...shaderOptions\n    });\n  }\n\n  _updateMaxWeightValue() {\n    const {maxWeightTransform} = this.state;\n\n    maxWeightTransform!.run({\n      parameters: {viewport: [0, 0, 1, 1]},\n      clearColor: [0, 0, 0, 0]\n    });\n  }\n\n  // Computes world bounds area that needs to be processed for generate heatmap\n  _updateBounds(forceUpdate: any = false): boolean {\n    const {viewport} = this.context;\n\n    // Unproject all 4 corners of the current screen coordinates into world coordinates (lng/lat)\n    // Takes care of viewport has non zero bearing/pitch (i.e axis not aligned with world coordiante system)\n    const viewportCorners = [\n      viewport.unproject([0, 0]),\n      viewport.unproject([viewport.width, 0]),\n      viewport.unproject([0, viewport.height]),\n      viewport.unproject([viewport.width, viewport.height])\n    ].map(p => p.map(Math.fround));\n\n    // #1: get world bounds for current viewport extends\n    const visibleWorldBounds = getBounds(viewportCorners); // TODO: Change to visible bounds\n\n    const newState: Partial<HeatmapLayer['state']> = {visibleWorldBounds, viewportCorners};\n    let boundsChanged = false;\n\n    if (\n      forceUpdate ||\n      !this.state.worldBounds ||\n      !boundsContain(this.state.worldBounds, visibleWorldBounds)\n    ) {\n      // #2 : convert world bounds to common (Flat) bounds\n      // #3 : extend common bounds to match aspect ratio with viewport\n      const scaledCommonBounds = this._worldToCommonBounds(visibleWorldBounds);\n\n      // #4 :convert aligned common bounds to world bounds\n      const worldBounds = this._commonToWorldBounds(scaledCommonBounds);\n\n      // Clip webmercator projection limits\n      if (this.props.coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {\n        worldBounds[1] = Math.max(worldBounds[1], -85.051129);\n        worldBounds[3] = Math.min(worldBounds[3], 85.051129);\n        worldBounds[0] = Math.max(worldBounds[0], -360);\n        worldBounds[2] = Math.min(worldBounds[2], 360);\n      }\n\n      // #5: now convert world bounds to common using Layer's coordiante system and origin\n      const normalizedCommonBounds = this._worldToCommonBounds(worldBounds);\n\n      newState.worldBounds = worldBounds;\n      newState.normalizedCommonBounds = normalizedCommonBounds;\n\n      boundsChanged = true;\n    }\n    this.setState(newState);\n    return boundsChanged;\n  }\n\n  _updateTextureRenderingBounds() {\n    // Just render visible portion of the texture\n    const {triPositionBuffer, triTexCoordBuffer, normalizedCommonBounds, viewportCorners} =\n      this.state;\n\n    const {viewport} = this.context;\n\n    triPositionBuffer!.write(packVertices(viewportCorners, 3));\n\n    const textureBounds = viewportCorners.map(p =>\n      getTextureCoordinates(viewport.projectPosition(p), normalizedCommonBounds!)\n    );\n    triTexCoordBuffer!.write(packVertices(textureBounds, 2));\n  }\n\n  _updateColorTexture(opts) {\n    const {colorRange} = opts.props;\n    let {colorTexture} = this.state;\n    const colors = colorRangeToFlatArray(colorRange, false, Uint8Array as any);\n\n    colorTexture?.destroy();\n    colorTexture = this.context.device.createTexture({\n      ...TEXTURE_PROPS,\n      data: colors,\n      width: colorRange.length,\n      height: 1\n    });\n    this.setState({colorTexture});\n  }\n\n  _updateWeightmap() {\n    const {radiusPixels, colorDomain, aggregation} = this.props;\n    const {worldBounds, textureSize, weightsScale, weightsTexture} = this.state;\n    const weightsTransform = this.state.weightsTransform!;\n    this.state.isWeightMapDirty = false;\n\n    // convert world bounds to common using Layer's coordiante system and origin\n    const commonBounds = this._worldToCommonBounds(worldBounds, {\n      useLayerCoordinateSystem: true\n    });\n\n    if (colorDomain && aggregation === 'SUM') {\n      // scale color domain to weight per pixel\n      const {viewport} = this.context;\n      const metersPerPixel =\n        (viewport.distanceScales.metersPerUnit[2] * (commonBounds[2] - commonBounds[0])) /\n        textureSize;\n      this.state.colorDomain = colorDomain.map(x => x * metersPerPixel * weightsScale);\n    } else {\n      this.state.colorDomain = colorDomain || DEFAULT_COLOR_DOMAIN;\n    }\n\n    const attributeManager = this.getAttributeManager()!;\n    const attributes = attributeManager.getAttributes();\n    const moduleSettings = this.getModuleSettings();\n    this._setModelAttributes(weightsTransform.model, attributes);\n    weightsTransform.model.setVertexCount(this.getNumInstances());\n\n    const weightProps: WeightProps = {\n      radiusPixels,\n      commonBounds,\n      textureWidth: textureSize,\n      weightsScale,\n      weightsTexture: weightsTexture!\n    };\n    const {viewport, devicePixelRatio, coordinateSystem, coordinateOrigin} = moduleSettings;\n    const {modelMatrix} = this.props;\n    weightsTransform.model.shaderInputs.setProps({\n      project: {viewport, devicePixelRatio, modelMatrix, coordinateSystem, coordinateOrigin},\n      weight: weightProps\n    });\n    weightsTransform.run({\n      parameters: {viewport: [0, 0, textureSize, textureSize]},\n      clearColor: [0, 0, 0, 0]\n    });\n\n    this._updateMaxWeightValue();\n  }\n\n  _debouncedUpdateWeightmap(fromTimer = false) {\n    let {updateTimer} = this.state;\n    const {debounceTimeout} = this.props;\n\n    if (fromTimer) {\n      updateTimer = null;\n      // update\n      this._updateBounds(true);\n      this._updateTextureRenderingBounds();\n      this.setState({isWeightMapDirty: true});\n    } else {\n      this.setState({isWeightMapDirty: false});\n      clearTimeout(updateTimer);\n      updateTimer = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), debounceTimeout);\n    }\n\n    this.setState({updateTimer});\n  }\n\n  // input: worldBounds: [minLong, minLat, maxLong, maxLat]\n  // input: opts.useLayerCoordinateSystem : layers coordiante system is used\n  // optput: commonBounds: [minX, minY, maxX, maxY] scaled to fit the current texture\n  _worldToCommonBounds(\n    worldBounds,\n    opts: {useLayerCoordinateSystem?: boolean} = {}\n  ): [number, number, number, number] {\n    const {useLayerCoordinateSystem = false} = opts;\n    const [minLong, minLat, maxLong, maxLat] = worldBounds;\n    const {viewport} = this.context;\n    const {textureSize} = this.state;\n    const {coordinateSystem} = this.props;\n\n    const offsetMode =\n      useLayerCoordinateSystem &&\n      (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS ||\n        coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS);\n    const offsetOriginCommon = offsetMode\n      ? viewport.projectPosition(this.props.coordinateOrigin)\n      : [0, 0];\n    const size = (textureSize * RESOLUTION) / viewport.scale;\n\n    let bottomLeftCommon;\n    let topRightCommon;\n\n    // Y-axis is flipped between World and Common bounds\n    if (useLayerCoordinateSystem && !offsetMode) {\n      bottomLeftCommon = this.projectPosition([minLong, minLat, 0]);\n      topRightCommon = this.projectPosition([maxLong, maxLat, 0]);\n    } else {\n      bottomLeftCommon = viewport.projectPosition([minLong, minLat, 0]);\n      topRightCommon = viewport.projectPosition([maxLong, maxLat, 0]);\n    }\n    // Ignore z component\n    return scaleToAspectRatio(\n      [\n        bottomLeftCommon[0] - offsetOriginCommon[0],\n        bottomLeftCommon[1] - offsetOriginCommon[1],\n        topRightCommon[0] - offsetOriginCommon[0],\n        topRightCommon[1] - offsetOriginCommon[1]\n      ],\n      size,\n      size\n    );\n  }\n\n  // input commonBounds: [xMin, yMin, xMax, yMax]\n  // output worldBounds: [minLong, minLat, maxLong, maxLat]\n  _commonToWorldBounds(commonBounds) {\n    const [xMin, yMin, xMax, yMax] = commonBounds;\n    const {viewport} = this.context;\n    const bottomLeftWorld = viewport.unprojectPosition([xMin, yMin]);\n    const topRightWorld = viewport.unprojectPosition([xMax, yMax]);\n\n    return bottomLeftWorld.slice(0, 2).concat(topRightWorld.slice(0, 2));\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport type {Buffer, Device, Texture} from '@luma.gl/core';\nimport {Model} from '@luma.gl/engine';\nimport {Layer, LayerContext, project32} from '@deck.gl/core';\nimport vs from './triangle-layer-vertex.glsl';\nimport fs from './triangle-layer-fragment.glsl';\nimport {TriangleProps, triangleUniforms} from './triangle-layer-uniforms';\n\ntype _TriangleLayerProps = {\n  data: {attributes: {positions: Buffer; texCoords: Buffer}};\n  colorDomain: [number, number];\n  aggregationMode: number;\n  threshold: number;\n  intensity: number;\n  vertexCount: number;\n  colorTexture: Texture;\n  maxTexture: Texture;\n  weightsTexture: Texture;\n};\n\nexport default class TriangleLayer extends Layer<_TriangleLayerProps> {\n  static layerName = 'TriangleLayer';\n\n  state!: {\n    model: Model;\n    positions: Buffer;\n    texCoords: Buffer;\n  };\n\n  getShaders() {\n    return super.getShaders({vs, fs, modules: [project32, triangleUniforms]});\n  }\n\n  initializeState({device}: LayerContext): void {\n    this.setState({model: this._getModel(device)});\n  }\n\n  _getModel(device: Device): Model {\n    const {vertexCount, data} = this.props;\n\n    return new Model(device, {\n      ...this.getShaders(),\n      id: this.props.id,\n      attributes: data.attributes,\n      bufferLayout: [\n        {name: 'positions', format: 'float32x3'},\n        {name: 'texCoords', format: 'float32x2'}\n      ],\n      topology: 'triangle-strip',\n      vertexCount\n    });\n  }\n\n  draw(): void {\n    const {model} = this.state;\n    const {\n      aggregationMode,\n      colorDomain,\n      intensity,\n      threshold,\n      colorTexture,\n      maxTexture,\n      weightsTexture\n    } = this.props;\n    const triangleProps: TriangleProps = {\n      aggregationMode,\n      colorDomain,\n      intensity,\n      threshold,\n      colorTexture,\n      maxTexture,\n      weightsTexture\n    };\n    model.shaderInputs.setProps({triangle: triangleProps});\n    model.draw(this.context.renderPass);\n  }\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\n// Inspired by screen-grid-layer vertex shader in deck.gl\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME heatp-map-layer-vertex-shader\n\nuniform sampler2D maxTexture;\n\nin vec3 positions;\nin vec2 texCoords;\n\nout vec2 vTexCoords;\nout float vIntensityMin;\nout float vIntensityMax;\n\nvoid main(void) {\n  gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));\n  vTexCoords = texCoords;\n  vec4 maxTexture = texture(maxTexture, vec2(0.5));\n  float maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;\n  float minValue = maxValue * triangle.threshold;\n  if (triangle.colorDomain[1] > 0.) {\n    // if user specified custom domain use it.\n    maxValue = triangle.colorDomain[1];\n    minValue = triangle.colorDomain[0];\n  }\n  vIntensityMax = triangle.intensity / maxValue;\n  vIntensityMin = triangle.intensity / minValue;\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\n#define SHADER_NAME triangle-layer-fragment-shader\n\nprecision highp float;\n\nuniform sampler2D weightsTexture;\nuniform sampler2D colorTexture;\n\nin vec2 vTexCoords;\nin float vIntensityMin;\nin float vIntensityMax;\n\nout vec4 fragColor;\n\nvec4 getLinearColor(float value) {\n  float factor = clamp(value * vIntensityMax, 0., 1.);\n  vec4 color = texture(colorTexture, vec2(factor, 0.5));\n  color.a *= min(value * vIntensityMin, 1.0);\n  return color;\n}\n\nvoid main(void) {\n  vec4 weights = texture(weightsTexture, vTexCoords);\n  float weight = weights.r;\n\n  if (triangle.aggregationMode > 0.5) {\n    weight /= max(1.0, weights.a);\n  }\n\n  // discard pixels with 0 weight.\n  if (weight <= 0.) {\n     discard;\n  }\n\n  vec4 linearColor = getLinearColor(weight);\n  linearColor.a *= layer.opacity;\n  fragColor = linearColor;\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = `\\\nuniform triangleUniforms {\n  float aggregationMode;\n  vec2 colorDomain;\n  float intensity;\n  float threshold;\n} triangle;\n`;\n\nexport type TriangleProps = {\n  aggregationMode: number;\n  colorDomain: [number, number];\n  intensity: number;\n  threshold: number;\n  colorTexture: Texture;\n  maxTexture: Texture;\n  weightsTexture: Texture;\n};\n\nexport const triangleUniforms = {\n  name: 'triangle',\n  vs: uniformBlock,\n  fs: uniformBlock,\n  uniformTypes: {\n    aggregationMode: 'f32',\n    colorDomain: 'vec2<f32>',\n    intensity: 'f32',\n    threshold: 'f32'\n  }\n} as const satisfies ShaderModule<TriangleProps>;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {\n  CompositeLayer,\n  AttributeManager,\n  LayerDataSource,\n  _compareProps as compareProps,\n  UpdateParameters,\n  CompositeLayerProps,\n  Attribute\n} from '@deck.gl/core';\nimport {filterProps} from '../common/utils/prop-utils';\n\nexport type AggregationLayerProps<DataT> = CompositeLayerProps & {\n  data: LayerDataSource<DataT>;\n};\n\n/** Legacy AggregationLayer, to be removed in v9.1 */\nexport default abstract class AggregationLayer<\n  DataT,\n  ExtraPropsT extends {} = {}\n> extends CompositeLayer<Required<AggregationLayer<DataT>> & ExtraPropsT> {\n  static layerName = 'AggregationLayer';\n\n  state!: {\n    ignoreProps?: Record<string, any>;\n    dimensions?: any;\n    changedAttributes?: Record<string, any>;\n  };\n\n  initializeAggregationLayer(dimensions: any) {\n    super.initializeState(this.context);\n\n    this.setState({\n      // Layer props , when changed doesn't require updating aggregation\n      ignoreProps: filterProps((this.constructor as any)._propTypes, dimensions.data.props),\n      dimensions\n    });\n  }\n\n  updateState(opts: UpdateParameters<this>) {\n    super.updateState(opts);\n    const {changeFlags} = opts;\n    if (changeFlags.extensionsChanged) {\n      const shaders = this.getShaders({});\n      if (shaders && shaders.defines) {\n        shaders.defines.NON_INSTANCED_MODEL = 1;\n      }\n      this.updateShaders(shaders);\n    }\n\n    // Explictly call to update attributes as 'CompositeLayer' doesn't call this\n    this._updateAttributes();\n  }\n\n  updateAttributes(changedAttributes) {\n    // Super classes, can refer to state.changedAttributes to determine what\n    // attributes changed\n    this.setState({changedAttributes});\n  }\n\n  getAttributes(): {[id: string]: Attribute} {\n    return this.getAttributeManager()!.getAttributes();\n  }\n\n  getModuleSettings() {\n    // For regular layer draw this happens during draw cycle (_drawLayersInViewport) not during update cycle\n    // For aggregation layers this is called during updateState to update aggregation data\n    // NOTE: it is similar to LayerPass._getShaderModuleProps() but doesn't inlcude `effects` it is not needed for aggregation\n    const {viewport, mousePosition, device} = this.context;\n    const moduleSettings = Object.assign(Object.create(this.props), {\n      viewport,\n      mousePosition,\n      picking: {\n        isActive: 0\n      },\n      // @ts-expect-error TODO - assuming WebGL context\n      devicePixelRatio: device.canvasContext.cssToDeviceRatio()\n    });\n    return moduleSettings;\n  }\n\n  updateShaders(shaders) {\n    // Default implemention is empty, subclasses can update their Model objects if needed\n  }\n\n  /**\n   * Checks if aggregation is dirty\n   * @param {Object} updateOpts - object {props, oldProps, changeFlags}\n   * @param {Object} params - object {dimension, compareAll}\n   * @param {Object} params.dimension - {props, accessors} array of props and/or accessors\n   * @param {Boolean} params.compareAll - when `true` it will include non layer props for comparision\n   * @returns {Boolean} - returns true if dimensions' prop or accessor is changed\n   **/\n  isAggregationDirty(\n    updateOpts,\n    params: {compareAll?: boolean; dimension?: any} = {}\n  ): string | boolean {\n    const {props, oldProps, changeFlags} = updateOpts;\n    const {compareAll = false, dimension} = params;\n    const {ignoreProps} = this.state;\n    const {props: dataProps, accessors = []} = dimension;\n    const {updateTriggersChanged} = changeFlags;\n    if (changeFlags.dataChanged) {\n      return true;\n    }\n    if (updateTriggersChanged) {\n      if (updateTriggersChanged.all) {\n        return true;\n      }\n      for (const accessor of accessors) {\n        if (updateTriggersChanged[accessor]) {\n          return true;\n        }\n      }\n    }\n    if (compareAll) {\n      if (changeFlags.extensionsChanged) {\n        return true;\n      }\n      // Compare non layer props too (like extension props)\n      // ignoreprops refers to all Layer props other than aggregation props that need to be comapred\n      return compareProps({\n        oldProps,\n        newProps: props,\n        ignoreProps,\n        propTypes: (this.constructor as any)._propTypes\n      });\n    }\n    // Compare props of the dimension\n    for (const name of dataProps) {\n      if (props[name] !== oldProps[name]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks if an attribute is changed\n   * @param {String} name - name of the attribute\n   * @returns {Boolean} - `true` if attribute `name` is changed, `false` otherwise,\n   *                       If `name` is not passed or `undefiend`, `true` if any attribute is changed, `false` otherwise\n   **/\n  isAttributeChanged(name?: string) {\n    const {changedAttributes} = this.state;\n    if (!name) {\n      // if name not specified return true if any attribute is changed\n      return !isObjectEmpty(changedAttributes);\n    }\n    return changedAttributes && changedAttributes[name] !== undefined;\n  }\n\n  // Private\n\n  // override Composite layer private method to create AttributeManager instance\n  _getAttributeManager() {\n    return new AttributeManager(this.context.device, {\n      id: this.props.id,\n      stats: this.context.stats\n    });\n  }\n}\n\n// Helper methods\n\n// Returns true if given object is empty, false otherwise.\nfunction isObjectEmpty(obj) {\n  let isEmpty = true;\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for (const key in obj) {\n    isEmpty = false;\n    break;\n  }\n  return isEmpty;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport function filterProps(props, filterKeys) {\n  const filteredProps = {};\n  for (const key in props) {\n    if (!filterKeys.includes(key)) {\n      filteredProps[key] = props[key];\n    }\n  }\n  return filteredProps;\n}\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\nin vec3 positions;\nin vec3 positions64Low;\nin float weights;\nout vec4 weightsTexture;\n\nvoid main()\n{\n  weightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);\n\n  float radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);\n  gl_PointSize = radiusTexels * 2.;\n\n  vec3 commonPosition = project_position(positions, positions64Low);\n\n  // // map xy from commonBounds to [-1, 1]\n  gl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;\n  gl_Position.xy = (gl_Position.xy * 2.) - (1.);\n  gl_Position.w = 1.0;\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\nin vec4 weightsTexture;\nout vec4 fragColor;\n// Epanechnikov function, keeping for reference\n// float epanechnikovKDE(float u) {\n//   return 0.75 * (1.0 - u * u);\n// }\nfloat gaussianKDE(float u){\n  return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);\n}\nvoid main()\n{\n  float dist = length(gl_PointCoord - vec2(0.5, 0.5));\n  if (dist > 0.5) {\n    discard;\n  }\n  fragColor = weightsTexture * gaussianKDE(2. * dist);\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\nuniform sampler2D inTexture;\nout vec4 outTexture;\n\nvoid main()\n{\n  // Sample every pixel in texture\n  int yIndex = gl_VertexID / int(maxWeight.textureSize);\n  int xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));\n  vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;\n  outTexture = texture(inTexture, uv);\n\n  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\n  // Enforce default value for ANGLE issue (https://bugs.chromium.org/p/angleproject/issues/detail?id=3941)\n  gl_PointSize = 1.0;\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nexport default `\\\n#version 300 es\nin vec4 outTexture;\nout vec4 fragColor;\nvoid main() {\n  fragColor = outTexture;\n  fragColor.g = outTexture.r / max(1.0, outTexture.a);\n}\n`;\n", "// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n\nimport {Texture} from '@luma.gl/core';\nimport type {ShaderModule} from '@luma.gl/shadertools';\n\nconst uniformBlock = `\\\nuniform weightUniforms {\n  vec4 commonBounds;\n  float radiusPixels;\n  float textureWidth;\n  float weightsScale;\n} weight;\n`;\nexport type WeightProps = {\n  commonBounds: [number, number, number, number];\n  radiusPixels: number;\n  textureWidth: number;\n  weightsScale: number;\n  weightsTexture: Texture;\n};\n\nexport const weightUniforms = {\n  name: 'weight',\n  vs: uniformBlock,\n  uniformTypes: {\n    commonBounds: 'vec4<f32>',\n    radiusPixels: 'f32',\n    textureWidth: 'f32',\n    weightsScale: 'f32'\n  }\n} as const satisfies ShaderModule<WeightProps>;\n\nexport type MaxWeightProps = {\n  inTexture: Texture;\n  textureSize: number;\n};\n\nexport const maxWeightUniforms = {\n  name: 'maxWeight',\n  vs: `\\\nuniform maxWeightUniforms {\n  float textureSize;\n} maxWeight;\n`,\n  uniformTypes: {\n    textureSize: 'f32'\n  }\n} as const satisfies ShaderModule<MaxWeightProps>;\n"],
  "mappings": "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",
  "names": ["import_core", "min", "max", "deepEqual", "import_engine", "uniformBlock", "MAX_FLOAT32", "import_core", "count", "deepEqual", "import_core", "import_engine", "import_core", "uniformBlock", "uniformBlock", "import_core", "uniformBlock", "uniformBlock", "binOptionsUniforms", "defaultProps", "binOptionsUniforms", "import_core", "import_layers", "threshold", "threshold", "count", "import_core", "uniformBlock", "binOptionsUniforms", "defaultProps", "binOptionsUniforms", "import_core", "import_layers", "import_engine", "uniformBlock", "uniformBlock", "binOptionsUniforms", "noop", "defaultProps", "GridLayer", "binOptionsUniforms", "import_engine", "import_core", "import_engine", "import_core", "uniformBlock", "threshold", "import_core", "AggregationLayer", "compareProps", "uniformBlock", "defaultProps", "aggregation_layer_default", "threshold", "viewport"]
}
